<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-diy.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-diy.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-diy.png"><link rel="mask-icon" href="/images/logo-diy.svg" color="#222"><meta name="baidu-site-verification" content="y1cfESbTt9nd3LsA"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="/lib/pace/pace-theme-flash.min.css"><script src="/lib/pace/pace.min.js"></script><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"githubwyb.github.io",root:"/",scheme:"Pisces",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:null},back2top:{enable:!0,sidebar:!1,scrollpercent:!0},bookmark:{enable:!0,color:"#ff0000",save:"auto"},fancybox:!1,mediumzoom:!0,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="前言leetcode刷题记录在 LeetCode刷题思路总结 1. 二维数组查找题目在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 思路从右侧最上方开始，查到小于后，竖着找大于的，然后横着，直到数组溢出或者找到为止 2. 斐波那切数列输出题目大家都知道斐"><meta property="og:type" content="article"><meta property="og:title" content="编程题思路记录"><meta property="og:url" content="https://githubwyb.github.io/blogs/2019-10-21-programQuestion/index.html"><meta property="og:site_name" content="技术的路上奔跑"><meta property="og:description" content="前言leetcode刷题记录在 LeetCode刷题思路总结 1. 二维数组查找题目在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 思路从右侧最上方开始，查到小于后，竖着找大于的，然后横着，直到数组溢出或者找到为止 2. 斐波那切数列输出题目大家都知道斐"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2019-10-21T02:54:51.000Z"><meta property="article:modified_time" content="2023-10-15T02:28:27.657Z"><meta property="article:author" content="王钰博"><meta property="article:tag" content="wyb"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://githubwyb.github.io/blogs/2019-10-21-programQuestion/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>编程题思路记录 | 技术的路上奔跑</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">技术的路上奔跑</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">入门</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-fw fa-sitemap"></i>站点地图</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><div class="reading-progress-bar"></div><a role="button" class="book-mark-link book-mark-link-fixed"></a> <a href="https://github.com/Githubwyb" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://githubwyb.github.io/blogs/2019-10-21-programQuestion/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/12.jpg"><meta itemprop="name" content="王钰博"><meta itemprop="description" content="个人博客"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="技术的路上奔跑"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">编程题思路记录</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-10-21 10:54:51" itemprop="dateCreated datePublished" datetime="2019-10-21T10:54:51+08:00">2019-10-21</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-10-15 10:28:27" itemprop="dateModified" datetime="2023-10-15T10:28:27+08:00">2023-10-15</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Knowledge/" itemprop="url" rel="index"><span itemprop="name">Knowledge</span></a> </span>， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Knowledge/Study/" itemprop="url" rel="index"><span itemprop="name">Study</span></a> </span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span id="busuanzi_value_page_pv"></span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><span class="post-meta-item-text">Valine：</span> <a title="valine" href="/blogs/2019-10-21-programQuestion/#valine-comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/blogs/2019-10-21-programQuestion/" itemprop="commentCount"></span></a></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>27k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>24 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>leetcode刷题记录在 <a href="/bookPages/docs/leetcode/">LeetCode刷题思路总结</a></p><h1 id="1-二维数组查找"><a href="#1-二维数组查找" class="headerlink" title="1. 二维数组查找"></a>1. 二维数组查找</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>从右侧最上方开始，查到小于后，竖着找大于的，然后横着，直到数组溢出或者找到为止</p><h1 id="2-斐波那切数列输出"><a href="#2-斐波那切数列输出" class="headerlink" title="2. 斐波那切数列输出"></a><span id="H2">2. 斐波那切数列输出</span></h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。<br>n&lt;&#x3D;39</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><h3 id="硬解"><a href="#硬解" class="headerlink" title="硬解"></a>硬解</h3><p>保存前一次和前前一次，一步一步算</p><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><ul><li>每次计算中直接调用自己的<code>n - 1</code>和<code>n - 2</code>的值</li><li>防止递归过大，预留一个40的int数组，如果数组相应索引有值直接返回，没值递归算出保存返回</li></ul><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><ul><li>两个变量，g保存当前和前一次，f保存前一次和前两次</li><li>计算方法</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> f = <span class="number">0</span>, g = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">            g += f;     <span class="comment">//从前一次到当前</span></span><br><span class="line">            f = g - f;  <span class="comment">//从前两次算到前一次</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="3-青蛙跳台阶"><a href="#3-青蛙跳台阶" class="headerlink" title="3. 青蛙跳台阶"></a><span id="H4">3. 青蛙跳台阶</span></h1><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>青蛙跳n阶台阶，从第一跳来算:</p><ul><li>第一次跳1阶，剩下种类为$f(n - 1)$</li><li>第一次跳2阶，剩下种类为$f(n - 2)$</li></ul><p>则</p><p>$$f(n) &#x3D; f(n - 1) + f(n - 2)$$</p><p>其中</p><p>$$f(0) &#x3D; 0, f(1) &#x3D; 1，f(2) &#x3D; 2$$</p><p>分析可以看出和<a href="#H2">斐波那切数列输出</a>除了初始值基本一致</p><h1 id="4-两个栈实现队列"><a href="#4-两个栈实现队列" class="headerlink" title="4. 两个栈实现队列"></a>4. 两个栈实现队列</h1><h2 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h2><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><ul><li>stack1为入队列栈，stack2为出队列栈</li><li>stack2不为空时直接出栈，为空则从stack1取所有元素</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack1.<span class="built_in">push</span>(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//为空才从stack1拿数据</span></span><br><span class="line">        <span class="keyword">if</span> (stack2.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="comment">//stack1也是空的，就返回-1</span></span><br><span class="line">            <span class="keyword">if</span> (stack1.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (!stack1.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                stack2.<span class="built_in">push</span>(stack1.<span class="built_in">top</span>());</span><br><span class="line">                stack1.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> result = stack2.<span class="built_in">top</span>();</span><br><span class="line">        stack2.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stack1;  <span class="comment">//入队列</span></span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stack2;  <span class="comment">//出队列</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="旋转数组查找最小值"><a href="#旋转数组查找最小值" class="headerlink" title="旋转数组查找最小值"></a>旋转数组查找最小值</h1><h2 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h2><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。<br>输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。<br>例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。<br>NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p><h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><ul><li>数组旋转后，最小值为分界点的值，利用二分查找方式最快到达最小值输出。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt; rotateArray)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (rotateArray.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = rotateArray.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//另类的二分查找，比左边的大，左边等，比右边的小，右边等</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">int</span> tmp = (left + right) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (tmp == left) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (rotateArray[tmp] &gt;= rotateArray[left]) &#123;</span><br><span class="line">                left = tmp;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rotateArray[left] &lt; rotateArray[right]) &#123;</span><br><span class="line">            <span class="keyword">return</span> rotateArray[left];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rotateArray[right];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="变态跳台阶的问题"><a href="#变态跳台阶的问题" class="headerlink" title="变态跳台阶的问题"></a>变态跳台阶的问题</h1><h2 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p><h2 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h2><ul><li>数学统计题，$f(n) &#x3D; f(n - 1) + f(n - 2) + … + f(1) + 1 &#x3D; 2^{n - 1}$</li><li>使用<code>1 &lt;&lt; (number - 1)</code>计算2的<code>n - 1</code>次幂更快</li></ul><h1 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a>重建二叉树</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p><h2 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h2><ul><li>中序遍历的头结点左边为左子树，右边为右子树</li><li>前序遍历第一个为头结点</li><li>两个结合，找到头结点在中序遍历中的位置，左边递归出来为左子树，右边递归出来为右子树</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> TreeNode* <span class="title">reConstructBinaryTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt; pre,vector&lt;<span class="type">int</span>&gt; vin)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pre.<span class="built_in">size</span>() != vin.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reConstructBinaryTree</span>(pre.<span class="built_in">begin</span>().<span class="built_in">base</span>(), vin.<span class="built_in">begin</span>().<span class="built_in">base</span>(), pre.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> TreeNode* <span class="title">reConstructBinaryTree</span><span class="params">(<span class="type">const</span> <span class="type">int</span> *pre, <span class="type">const</span> <span class="type">int</span> *vin, <span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//头结点从pre第一个取</span></span><br><span class="line">        <span class="keyword">auto</span> head = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(pre[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">//找到和vin中和pre[0]相等的点，左边为左子树，右边为右子树</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vin[i] == pre[<span class="number">0</span>]) &#123;</span><br><span class="line">                head-&gt;left = <span class="built_in">reConstructBinaryTree</span>(pre + <span class="number">1</span>, vin, i);</span><br><span class="line">                head-&gt;right = <span class="built_in">reConstructBinaryTree</span>(pre + i + <span class="number">1</span>, vin + i + <span class="number">1</span>, size - i - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="链表倒数第k个值"><a href="#链表倒数第k个值" class="headerlink" title="链表倒数第k个值"></a>链表倒数第k个值</h1><h2 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h2><p>输入一个链表，输出该链表中倒数第k个结点。</p><h2 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h2><ul><li>两个指针，一个比另一个先走k步，直到遍历完整个链表返回第二个指针</li></ul><h1 id="链表翻转"><a href="#链表翻转" class="headerlink" title="链表翻转"></a>链表翻转</h1><h2 id="题目-7"><a href="#题目-7" class="headerlink" title="题目"></a>题目</h2><p>输入一个链表，反转链表后，输出新链表的表头。</p><h2 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h2><ul><li>三个指针，一个遍历，一个翻转next，一个保存前一个节点</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> ListNode* <span class="title">ReverseList</span><span class="params">(ListNode* pHead)</span> </span>&#123;</span><br><span class="line">        ListNode *p1 = <span class="literal">nullptr</span>;     <span class="comment">//跟在后面翻转next的指针</span></span><br><span class="line">        ListNode *p2 = <span class="literal">nullptr</span>;     <span class="comment">//保存前一次</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (pHead != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            p2 = p1;</span><br><span class="line">            p1 = pHead;</span><br><span class="line">            pHead = pHead-&gt;next;</span><br><span class="line">            p1-&gt;next = p2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> p1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="矩形覆盖"><a href="#矩形覆盖" class="headerlink" title="矩形覆盖"></a>矩形覆盖</h1><h2 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h2><p>我们可以用$2 \times 1$的小矩形横着或者竖着去覆盖更大的矩形。请问用n个$2 \times 1$的小矩形无重叠地覆盖一个$2 \times n$的大矩形，总共有多少种方法？</p><h2 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h2><ul><li>分析一下，相当于<a href="#H4">青蛙跳台阶</a>，竖着放就是跳一阶，横着放就是跳两阶</li></ul><h1 id="调整数组中奇数位于偶数前面"><a href="#调整数组中奇数位于偶数前面" class="headerlink" title="调整数组中奇数位于偶数前面"></a>调整数组中奇数位于偶数前面</h1><h2 id="题目-8"><a href="#题目-8" class="headerlink" title="题目"></a>题目</h2><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p><h2 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h2><h3 id="硬解-1"><a href="#硬解-1" class="headerlink" title="硬解"></a>硬解</h3><ul><li>查找到第一个偶数和后面第一个奇数</li><li>将中间的偶数后移一位，奇数前移到偶数的位置</li><li>编译直到完成</li></ul><h3 id="另加队列"><a href="#另加队列" class="headerlink" title="另加队列"></a>另加队列</h3><ul><li>遍历，偶数放入新队列，奇数前移</li><li>遍历完后拷贝新队列到老队列最后一个奇数后面</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">reOrderArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;array)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; Odd;     <span class="comment">//偶数队列</span></span><br><span class="line">        <span class="type">int</span> size = array.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;              <span class="comment">//保存最后待放偶数的位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((array[i] % <span class="number">2</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//偶数加到新队列</span></span><br><span class="line">                Odd.<span class="built_in">emplace_back</span>(array[i]);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i != j) &#123;</span><br><span class="line">                <span class="comment">//奇数前移</span></span><br><span class="line">                array[j] = array[i];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memcpy</span>(array.<span class="built_in">begin</span>().<span class="built_in">base</span>() + j, Odd.<span class="built_in">begin</span>().<span class="built_in">base</span>(), Odd.<span class="built_in">size</span>() * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="标准库-stable-partition"><a href="#标准库-stable-partition" class="headerlink" title="标准库 stable_partition"></a>标准库 stable_partition</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">reOrderArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;array)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 奇数放前面，偶数放后面，两边分别的相对位置保持不变</span></span><br><span class="line">        <span class="built_in">stable_partition</span>(array.<span class="built_in">begin</span>(), array.<span class="built_in">end</span>(),</span><br><span class="line">                            [](<span class="type">const</span> <span class="type">int</span> &amp;value) &#123; <span class="built_in">return</span> (value % <span class="number">2</span> == <span class="number">1</span>); &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="数值的整数次幂"><a href="#数值的整数次幂" class="headerlink" title="数值的整数次幂"></a>数值的整数次幂</h1><h2 id="题目-9"><a href="#题目-9" class="headerlink" title="题目"></a>题目</h2><p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。<br>保证base和exponent不同时为0</p><h2 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h2><ul><li>简单快速幂算法</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">double</span> <span class="title">Power</span><span class="params">(<span class="type">double</span> base, <span class="type">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> tmp = <span class="built_in">abs</span>(exponent);</span><br><span class="line">        <span class="type">double</span> r = <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">while</span> (tmp) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tmp &amp; (<span class="type">unsigned</span>) <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">//对应位是1时，乘以base</span></span><br><span class="line">                r *= base;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//tmp移位，base要平方</span></span><br><span class="line">            base *= base;</span><br><span class="line">            tmp &gt;&gt;= (<span class="type">unsigned</span>) <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> exponent &lt; <span class="number">0</span> ? <span class="number">1</span> / r : r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="合并两个排序的列表"><a href="#合并两个排序的列表" class="headerlink" title="合并两个排序的列表"></a>合并两个排序的列表</h1><h2 id="题目-10"><a href="#题目-10" class="headerlink" title="题目"></a>题目</h2><p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p><h2 id="思路-12"><a href="#思路-12" class="headerlink" title="思路"></a>思路</h2><h3 id="非递归版本"><a href="#非递归版本" class="headerlink" title="非递归版本"></a>非递归版本</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> ListNode *<span class="title">Merge</span><span class="params">(ListNode *pHead1, ListNode *pHead2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pHead1 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> pHead2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pHead2 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> pHead1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode* result = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> (pHead1-&gt;val &lt; pHead2-&gt;val) &#123;</span><br><span class="line">            result = pHead1;</span><br><span class="line">            pHead1 = pHead1-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result = pHead2;</span><br><span class="line">            pHead2 = pHead2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode* pTmp = result;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pHead1 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                pTmp-&gt;next = pHead2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (pHead2 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                pTmp-&gt;next = pHead1;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (pHead1-&gt;val &lt; pHead2-&gt;val) &#123;</span><br><span class="line">                pTmp-&gt;next = pHead1;</span><br><span class="line">                pHead1 = pHead1-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pTmp-&gt;next = pHead2;</span><br><span class="line">                pHead2 = pHead2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            pTmp = pTmp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="递归版本"><a href="#递归版本" class="headerlink" title="递归版本"></a>递归版本</h3><ul><li>合并链表选出较大的节点，下一跳时剩下两个链表再选</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> ListNode *<span class="title">Merge</span><span class="params">(ListNode *pHead1, ListNode *pHead2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pHead1 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> pHead2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pHead2 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> pHead1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode* result = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> (pHead1-&gt;val &lt; pHead2-&gt;val) &#123;</span><br><span class="line">            result = pHead1;</span><br><span class="line">            result-&gt;next = <span class="built_in">Merge</span>(pHead1-&gt;next, pHead2);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result = pHead2;</span><br><span class="line">            result-&gt;next = <span class="built_in">Merge</span>(pHead2-&gt;next, pHead1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="二叉树的镜像"><a href="#二叉树的镜像" class="headerlink" title="二叉树的镜像"></a>二叉树的镜像</h1><h2 id="题目-11"><a href="#题目-11" class="headerlink" title="题目"></a>题目</h2><p>操作给定的二叉树，将其变换为源二叉树的镜像。</p><p>输入描述:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">二叉树的镜像定义：源二叉树</span><br><span class="line">                    8</span><br><span class="line">                   /  \</span><br><span class="line">                  6   10</span><br><span class="line">                 / \  / \</span><br><span class="line">                 5  7 9 11</span><br><span class="line">    	        镜像二叉树</span><br><span class="line">    	            8</span><br><span class="line">    	           /  \</span><br><span class="line">    	          10   6</span><br><span class="line">    	         / \  / \</span><br><span class="line">    	        11 9 7  5</span><br></pre></td></tr></table></figure><h2 id="思路-13"><a href="#思路-13" class="headerlink" title="思路"></a>思路</h2><h3 id="递归版本-1"><a href="#递归版本-1" class="headerlink" title="递归版本"></a>递归版本</h3><ul><li>二叉树遍历，前序和后序都行，做操作即可</li><li>详见: <a href="/blogs/2018-09-18-algorithmStudy/#towTree">二叉树遍历</a></li></ul><h3 id="非递归版本-1"><a href="#非递归版本-1" class="headerlink" title="非递归版本"></a>非递归版本</h3><ul><li>进行广度优先遍历或者深度优先遍历</li><li>弹出一个节点就交换其左右子树</li><li>详见: <a href="/blogs/2018-09-18-algorithmStudy/#treeSpan">广度优先和深度优先遍历</a></li></ul><h1 id="树的子结构"><a href="#树的子结构" class="headerlink" title="树的子结构"></a>树的子结构</h1><h2 id="题目-12"><a href="#题目-12" class="headerlink" title="题目"></a>题目</h2><p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p><h2 id="思路-14"><a href="#思路-14" class="headerlink" title="思路"></a>思路</h2><p>直接递归实现，查找根节点，然后递归查找子节点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct TreeNode *left;</span></span><br><span class="line"><span class="comment">    struct TreeNode *right;</span></span><br><span class="line"><span class="comment">    TreeNode(int x) :</span></span><br><span class="line"><span class="comment">            val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">HasSubtree</span><span class="params">(TreeNode* pRoot1, TreeNode* pRoot2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pRoot1 == <span class="literal">nullptr</span> || pRoot2 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">HasSubtree1</span>(pRoot1, pRoot2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">HasSubtree1</span><span class="params">(TreeNode* pRoot1, TreeNode* pRoot2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pRoot1 == <span class="literal">nullptr</span> || pRoot2 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> pRoot2 == <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pRoot1-&gt;val == pRoot2-&gt;val &amp;&amp;</span><br><span class="line">            <span class="built_in">HasSubtree1</span>(pRoot1-&gt;right, pRoot2-&gt;right) &amp;&amp;</span><br><span class="line">            <span class="built_in">HasSubtree1</span>(pRoot1-&gt;left, pRoot2-&gt;left)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">HasSubtree1</span>(pRoot1-&gt;right, pRoot2) || <span class="built_in">HasSubtree1</span>(pRoot1-&gt;left, pRoot2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="从上往下打印二叉树"><a href="#从上往下打印二叉树" class="headerlink" title="从上往下打印二叉树"></a>从上往下打印二叉树</h1><h2 id="题目-13"><a href="#题目-13" class="headerlink" title="题目"></a>题目</h2><p>从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p><h2 id="思路-15"><a href="#思路-15" class="headerlink" title="思路"></a>思路</h2><p>二叉树的广度优先遍历，参考<a href="/blogs/2018-09-18-algorithmStudy/#treeSpan">广度优先遍历</a></p><h1 id="栈的压入、弹出序列"><a href="#栈的压入、弹出序列" class="headerlink" title="栈的压入、弹出序列"></a>栈的压入、弹出序列</h1><h2 id="题目-14"><a href="#题目-14" class="headerlink" title="题目"></a>题目</h2><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p><h2 id="思路-16"><a href="#思路-16" class="headerlink" title="思路"></a>思路</h2><p>模拟这个过程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">IsPopOrder</span><span class="params">(vector&lt;<span class="type">int</span>&gt; pushV, vector&lt;<span class="type">int</span>&gt; popV)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> size = pushV.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span> || size != popV.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; test;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; size) &#123;</span><br><span class="line">            test.<span class="built_in">push</span>(pushV[i++]);</span><br><span class="line">            <span class="keyword">while</span> (!test.<span class="built_in">empty</span>() &amp;&amp; test.<span class="built_in">top</span>() == popV[j]) &#123;</span><br><span class="line">                test.<span class="built_in">pop</span>();</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> test.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="包含min函数的栈"><a href="#包含min函数的栈" class="headerlink" title="包含min函数的栈"></a>包含min函数的栈</h1><h2 id="题目-15"><a href="#题目-15" class="headerlink" title="题目"></a>题目</h2><p>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。</p><h2 id="思路-17"><a href="#思路-17" class="headerlink" title="思路"></a>思路</h2><p>两个栈，一个放数据，一个放最小值的一个栈</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m_minData.<span class="built_in">empty</span>() || value &lt;= m_minData.<span class="built_in">top</span>()) &#123;</span><br><span class="line">            m_minData.<span class="built_in">push</span>(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        m_data.<span class="built_in">push</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m_minData.<span class="built_in">top</span>() == m_data.<span class="built_in">top</span>()) &#123;</span><br><span class="line">            m_minData.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        m_data.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_data.<span class="built_in">top</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m_minData.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m_minData.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; m_data;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; m_minData;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="顺时针打印矩阵"><a href="#顺时针打印矩阵" class="headerlink" title="顺时针打印矩阵"></a>顺时针打印矩阵</h1><h2 id="题目-16"><a href="#题目-16" class="headerlink" title="题目"></a>题目</h2><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.</p><h2 id="思路-18"><a href="#思路-18" class="headerlink" title="思路"></a>思路</h2><p>强解，直接使用四个变量保存起始位置，不断循环打印即可</p><h1 id="数组中出现次数超过一半的数字"><a href="#数组中出现次数超过一半的数字" class="headerlink" title="数组中出现次数超过一半的数字"></a>数组中出现次数超过一半的数字</h1><h2 id="题目-17"><a href="#题目-17" class="headerlink" title="题目"></a>题目</h2><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</p><h2 id="思路-19"><a href="#思路-19" class="headerlink" title="思路"></a>思路</h2><h3 id="统计"><a href="#统计" class="headerlink" title="统计"></a>统计</h3><p>使用map储存，遍历将数组每个值出现次数统计出来，找最多的对比size</p><h3 id="排序取中值"><a href="#排序取中值" class="headerlink" title="排序取中值"></a>排序取中值</h3><p>将数组排序，中位数即为出现超过一半的，找出验证一下出现次数是否超过一半</p><h3 id="相消"><a href="#相消" class="headerlink" title="相消"></a>相消</h3><p>由于出现次数超过一半，所以不断排除两个不一样的数字，超过一半的数字一定会留在最后一个，验证一下输出</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//巧解，排除相同的数，留下的即为所求</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">MoreThanHalfNum_Solution2</span><span class="params">(vector&lt;<span class="type">int</span>&gt; numbers)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> size = numbers.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> times = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;tmp : numbers) &#123;</span><br><span class="line">            <span class="keyword">if</span> (times == <span class="number">0</span>) &#123;</span><br><span class="line">                result = tmp;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (result == tmp) &#123;</span><br><span class="line">                times++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            times--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">count</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), result) &gt; size / <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="二叉搜索树后序遍历数组校验"><a href="#二叉搜索树后序遍历数组校验" class="headerlink" title="二叉搜索树后序遍历数组校验"></a>二叉搜索树后序遍历数组校验</h1><h2 id="题目-18"><a href="#题目-18" class="headerlink" title="题目"></a>题目</h2><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。</p><h2 id="思路-20"><a href="#思路-20" class="headerlink" title="思路"></a>思路</h2><ul><li>二叉树搜索树满足根节点比左边大，比右边小</li><li>后序遍历，根节点在最后</li><li>从后向前，判断最后一个树比数组前一部分都大，比后一部分都小</li><li>找到分割点，递归判断前一部分和后一部分分别满足二叉搜索树后序遍历</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">VerifySquenceOfBST</span><span class="params">(vector&lt;<span class="type">int</span>&gt; sequence)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !sequence.<span class="built_in">empty</span>() &amp;&amp;</span><br><span class="line">            <span class="built_in">VerifySquenceOfBST</span>(sequence.<span class="built_in">begin</span>().<span class="built_in">base</span>(), sequence.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">VerifySquenceOfBST</span><span class="params">(<span class="type">const</span> <span class="type">int</span> arr[], <span class="type">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> result = length;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//异或，当false时，最后一位要比前面大，否则进判断；true时最后一位要比前面小，否则进逻辑</span></span><br><span class="line">            <span class="keyword">if</span> (flag ^ (arr[i] &gt; arr[length - <span class="number">1</span>])) &#123;</span><br><span class="line">                <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                    <span class="comment">//找到中间点后，出现小的，返回false</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//中间点转判断</span></span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                result = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (i == length - <span class="number">1</span>) ||</span><br><span class="line">            (<span class="built_in">VerifySquenceOfBST</span>(arr, result) &amp;&amp;</span><br><span class="line">                <span class="built_in">VerifySquenceOfBST</span>(arr + result, length - result - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="最小k个数"><a href="#最小k个数" class="headerlink" title="最小k个数"></a><span id="minKNumber">最小k个数</span></h1><h2 id="题目-19"><a href="#题目-19" class="headerlink" title="题目"></a>题目</h2><p>输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。</p><h2 id="思路-21"><a href="#思路-21" class="headerlink" title="思路"></a>思路</h2><h3 id="排序后取前k个值"><a href="#排序后取前k个值" class="headerlink" title="排序后取前k个值"></a>排序后取前k个值</h3><ul><li>将数组排序后取前k个值返回</li></ul><h3 id="维护一个k个值的数组，找到最小的k个值"><a href="#维护一个k个值的数组，找到最小的k个值" class="headerlink" title="维护一个k个值的数组，找到最小的k个值"></a>维护一个k个值的数组，找到最小的k个值</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 遍历，找到最小的k个值</span></span><br><span class="line">    <span class="function"><span class="type">static</span> vector&lt;<span class="type">int</span>&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(vector&lt;<span class="type">int</span>&gt; input, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> inputSize = input.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span> || k &gt; inputSize) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(k)</span></span>;</span><br><span class="line">        <span class="type">int</span> size = <span class="number">1</span>;</span><br><span class="line">        result[<span class="number">0</span>] = input[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 遍历数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; inputSize; i++) &#123;</span><br><span class="line">            <span class="comment">// 不到k，且大于最后一位，直接放到最后一位</span></span><br><span class="line">            <span class="keyword">if</span> (size &lt; k &amp;&amp; input[i] &gt; result[size - <span class="number">1</span>]) &#123;</span><br><span class="line">                result[size] = input[i];</span><br><span class="line">                size++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 数组个数不到k，或者tmp小于数组最大值</span></span><br><span class="line">            <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;size %d, result[size - 1] %d, input[i] %d&quot;</span>, size,</span><br><span class="line">                    result[size - <span class="number">1</span>], input[i]);</span><br><span class="line">            <span class="keyword">if</span> (size &lt; k || input[i] &lt; result[size - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (size &lt; k) &#123;</span><br><span class="line">                    <span class="comment">// 不到k，最后一位在上面判断了肯定大于输入</span></span><br><span class="line">                    result[size] = result[size - <span class="number">1</span>];</span><br><span class="line">                    size++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 从最后一位开始，如果前一位大于tmp，后移，直到不大于跳出</span></span><br><span class="line">                <span class="type">int</span> j = size - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (; j &gt; <span class="number">0</span> &amp;&amp; result[j - <span class="number">1</span>] &gt; input[i]; --j) &#123;</span><br><span class="line">                    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;j %d, result[j - 1] %d&quot;</span>, j, result[j - <span class="number">1</span>]);</span><br><span class="line">                    result[j] = result[j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 跳出后，j指向要放的位置</span></span><br><span class="line">                result[j] = input[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="大根堆"><a href="#大根堆" class="headerlink" title="大根堆"></a>大根堆</h3><ul><li>维护一个k个值的大根堆</li><li>遍历和堆顶比，小于则弹出堆顶，插入新元素排序</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 最小堆解问题，C++标准接口</span></span><br><span class="line">    <span class="function"><span class="type">static</span> vector&lt;<span class="type">int</span>&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(vector&lt;<span class="type">int</span>&gt; input, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> inputSize = input.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span> || k &gt; inputSize) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(input.begin(), input.begin() + k + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="comment">// 插入前k+1个值并对前k个值构造最大堆</span></span><br><span class="line">        <span class="built_in">make_heap</span>(result.<span class="built_in">begin</span>(), result.<span class="built_in">begin</span>() + k);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断，如果大于最大节点，替换并重构最大堆</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = k; i &lt; inputSize; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (input[i] &lt; result[<span class="number">0</span>]) &#123;</span><br><span class="line">                result[k] = input[i];</span><br><span class="line">                <span class="comment">// 弹出堆顶，重排序大根堆</span></span><br><span class="line">                <span class="comment">// pop_heap做的操作是将头部和尾部互换，然后对[begin, end - 1)构造最大堆</span></span><br><span class="line">                <span class="built_in">pop_heap</span>(result.<span class="built_in">begin</span>(), result.<span class="built_in">end</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 多余一个删掉</span></span><br><span class="line">        result.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="明明的随机数"><a href="#明明的随机数" class="headerlink" title="明明的随机数"></a>明明的随机数</h1><h2 id="题目-20"><a href="#题目-20" class="headerlink" title="题目"></a>题目</h2><p>明明想在学校中请一些同学一起做一项问卷调查，为了实验的客观性，他先用计算机生成了N个1到1000之间的随机整数（N≤1000），对于其中重复的数字，只保留一个，把其余相同的数去掉，不同的数对应着不同的学生的学号。然后再把这些数从小到大排序，按照排好的顺序去找同学做调查。请你协助明明完成“去重”与“排序”的工作(同一个测试用例里可能会有多组数据，希望大家能正确处理)。</p><h2 id="思路-22"><a href="#思路-22" class="headerlink" title="思路"></a>思路</h2><ul><li>C++标准库有两个接口可以直接实现，一个排序，一个去重</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; num) &#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; input;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            <span class="type">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">            cin &gt;&gt; tmp;</span><br><span class="line">            input.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sort</span>(input.<span class="built_in">begin</span>(), input.<span class="built_in">end</span>());</span><br><span class="line">        input.<span class="built_in">erase</span>(<span class="built_in">unique</span>(input.<span class="built_in">begin</span>(), input.<span class="built_in">end</span>()), input.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;tmp : input) &#123;</span><br><span class="line">            cout &lt;&lt; tmp &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="连续子数组的最大和"><a href="#连续子数组的最大和" class="headerlink" title="连续子数组的最大和"></a>连续子数组的最大和</h1><h2 id="题目-21"><a href="#题目-21" class="headerlink" title="题目"></a>题目</h2><p>HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1)</p><h2 id="思路-23"><a href="#思路-23" class="headerlink" title="思路"></a>思路</h2><ul><li>动态规划</li><li>找函数，以第$i$个元素结尾的最大和是$f(i)$，则第$i + 1$个元素结尾的最大和应为$max(f(i) + array[i - 1], array[i - 1])$</li><li>所以可以表示为$f(i + 1) &#x3D; max(f(i) + array[i - 1], array[i - 1])$</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt; array)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> maxTail = <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> max = <span class="number">0x80000000</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;tmp : array) &#123;</span><br><span class="line">            <span class="comment">// f(i + 1) = max(f(i) + array[i - 1], array[i - 1])</span></span><br><span class="line">            maxTail = (maxTail + tmp) &gt; tmp ? (maxTail + tmp) : tmp;</span><br><span class="line">            max = max &lt; maxTail ? maxTail : max;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="二叉树中和为某一值的路径"><a href="#二叉树中和为某一值的路径" class="headerlink" title="二叉树中和为某一值的路径"></a>二叉树中和为某一值的路径</h1><h2 id="题目-22"><a href="#题目-22" class="headerlink" title="题目"></a>题目</h2><p>输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)</p><h2 id="思路-24"><a href="#思路-24" class="headerlink" title="思路"></a>思路</h2><ul><li>从根节点向下递归</li><li>维持一个vector放入经过的路径，返回时弹出最后一个元素</li><li>到根部则判断是否为所求，是则插入结果中</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">FindPath</span>(TreeNode *root, <span class="type">int</span> expectNumber) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; road;</span><br><span class="line">        <span class="built_in">FindPath</span>(root, expectNumber, result, road);</span><br><span class="line">        <span class="built_in">sort</span>(result.<span class="built_in">begin</span>(), result.<span class="built_in">end</span>(), comp);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">comp</span><span class="params">(vector&lt;<span class="type">int</span>&gt; a, vector&lt;<span class="type">int</span>&gt; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.<span class="built_in">size</span>() &gt; b.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">FindPath</span><span class="params">(TreeNode *root, <span class="type">int</span> expectNumber,</span></span></span><br><span class="line"><span class="params"><span class="function">                        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;result, vector&lt;<span class="type">int</span>&gt; &amp;road)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不到根部，sum增加，road放入此节点，继续递归</span></span><br><span class="line">        expectNumber -= root-&gt;val;</span><br><span class="line">        road.<span class="built_in">emplace_back</span>(root-&gt;val);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right == <span class="literal">nullptr</span> &amp;&amp; root-&gt;left == <span class="literal">nullptr</span> &amp;&amp;</span><br><span class="line">            expectNumber == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 查到根部，判断是否相等，相等则存入结果</span></span><br><span class="line">            result.<span class="built_in">emplace_back</span>(road);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">FindPath</span>(root-&gt;right, expectNumber, result, road);</span><br><span class="line">        <span class="built_in">FindPath</span>(root-&gt;left, expectNumber, result, road);</span><br><span class="line"></span><br><span class="line">        expectNumber += root-&gt;val;</span><br><span class="line">        road.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="二叉树的深度"><a href="#二叉树的深度" class="headerlink" title="二叉树的深度"></a>二叉树的深度</h1><h2 id="题目-23"><a href="#题目-23" class="headerlink" title="题目"></a>题目</h2><p>输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p><h2 id="思路-25"><a href="#思路-25" class="headerlink" title="思路"></a>思路</h2><h3 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h3><ul><li>返回左节点最大深度和右节点最大深度的最大值加一</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 递归实现</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode *pRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pRoot == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">TreeDepth</span>(pRoot-&gt;left) + <span class="number">1</span>, <span class="built_in">TreeDepth</span>(pRoot-&gt;right) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="非递归"><a href="#非递归" class="headerlink" title="非递归"></a>非递归</h3><ul><li>类似广度优先遍历，不过是一次取出同一级别所有节点</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 非递归实现，广度优先遍历</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode *pRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pRoot == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> maxDeep = <span class="number">0</span>;</span><br><span class="line">        queue&lt;TreeNode *&gt; traversal;</span><br><span class="line">        traversal.<span class="built_in">push</span>(pRoot);</span><br><span class="line">        <span class="keyword">while</span>(!traversal.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="comment">// 获取当前层的节点数，此循环全部取出</span></span><br><span class="line">            <span class="type">int</span> length = traversal.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> &amp;tmp = traversal.<span class="built_in">front</span>();</span><br><span class="line">                <span class="keyword">if</span> (tmp-&gt;left != <span class="literal">nullptr</span>) traversal.<span class="built_in">push</span>(tmp-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (tmp-&gt;right != <span class="literal">nullptr</span>) traversal.<span class="built_in">push</span>(tmp-&gt;right);</span><br><span class="line">                traversal.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            maxDeep++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxDeep;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="第一个只出现一次的字符"><a href="#第一个只出现一次的字符" class="headerlink" title="第一个只出现一次的字符"></a>第一个只出现一次的字符</h1><h2 id="题目-24"><a href="#题目-24" class="headerlink" title="题目"></a>题目</h2><p>在一个字符串(0&lt;&#x3D;字符串长度&lt;&#x3D;10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.</p><h2 id="思路-26"><a href="#思路-26" class="headerlink" title="思路"></a>思路</h2><ul><li>由于是字符，所以只有128位甚至更少，asscii可以显示的最大数</li><li>使用一个<code>int [128]</code>来统计各个字符出现次数</li><li>再次遍历找到第一个出现次数为1的字符</li></ul><h1 id="硬币方案数"><a href="#硬币方案数" class="headerlink" title="硬币方案数"></a>硬币方案数</h1><h2 id="题目-25"><a href="#题目-25" class="headerlink" title="题目"></a>题目</h2><p>有数量不限的硬币，币值为25分、10分、5分和1分，请编写代码计算n分有几种表示法。<br>给定一个int n，请返回n分有几种表示法。保证n小于等于100000，为了防止溢出，请将答案Mod 1000000007。</p><h2 id="思路-27"><a href="#思路-27" class="headerlink" title="思路"></a>思路</h2><p>n种硬币凑成sum的方案数，可以假设有$i$个第n种硬币，然后剩下的则是用n - 1种硬币凑成$sum - i * coins[n]$的最大方案数，即$dp[n][sum] &#x3D; \sum_{i &#x3D; 0}^{sum &#x2F; coins[n]}dp[n - 1][sum - i * coins[n]]$，经推导可得</p><p>$$ \begin{aligned}<br>dp[n][sum] &amp;&#x3D; dp[n - 1][sum - 0 * coins[n]] + dp[n - 1][sum - 1 * coins[n]] +…+ dp[n - 1][sum - sum &#x2F; coins[n] * coins[n]] \\<br>&amp; &#x3D; \sum_{i &#x3D; 0}^{sum &#x2F; coins[n]}dp[n - 1][sum - i * coins[n]] \\<br>&amp; &#x3D; dp[n - 1][sum] + \underbrace{\sum_{i &#x3D; 1}^{sum &#x2F; coins[n]}dp[n - 1][sum - i * coins[n]]}_{令sum1 &#x3D; sum - coins[n]} \\<br>&amp; &#x3D; dp[n - 1][sum] + \sum_{i &#x3D; 1}^{sum1 &#x2F; coins[n] + 1}dp[n - 1][sum1 - (i - 1) * coins[n]] \\<br>&amp; &#x3D; dp[n - 1][sum] + \underbrace{\sum_{i &#x3D; 0}^{sum1 &#x2F; coins[n]}dp[n - 1][sum1 - i * coins[n]]}_{dp[n][sum1]} \\<br>&amp; &#x3D; dp[n - 1][sum] + dp[n][sum - coins[n]]<br>\end{aligned} $$</p><p>所以$dp[n][sum] &#x3D; dp[n - 1][sum] + dp[n][sum - coins[n]]$，代码实现上用一个一维数组去累加即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Coins</span> &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">countWays</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> coins[] = &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">25</span>&#125;;</span><br><span class="line">        <span class="comment">// 初始化为1，只有1种硬币时，所有都只有一种方案</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="comment">// 从2种硬币开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="built_in">sizeof</span>(coins) / <span class="built_in">sizeof</span>(coins[<span class="number">0</span>]); i++) &#123;</span><br><span class="line">            <span class="comment">// dp[i][j] = dp[i - 1][j] + dp[i][j - coins[i]];，从coins[i]开始，coins[i]以内可coins[i - 1]一致</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = coins[i]; j &lt;= n; j++) &#123;</span><br><span class="line">                dp[j] += dp[j - coins[i]];</span><br><span class="line">                dp[j] %= <span class="number">1000000007</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="计算1-2-3-…-n"><a href="#计算1-2-3-…-n" class="headerlink" title="计算1 + 2 + 3 + … + n"></a>计算1 + 2 + 3 + … + n</h1><h2 id="题目-26"><a href="#题目-26" class="headerlink" title="题目"></a>题目</h2><p>求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p><h2 id="思路-28"><a href="#思路-28" class="headerlink" title="思路"></a>思路</h2><ul><li>主要运用逻辑与运算的短路特性，前一个false后一个将不会执行</li><li>计算可以强行累加或者运用公式$\frac{n(n + 1)}{2}$</li><li>运用公式则使用了乘法的位运算</li></ul><p>$$<br>x \times y &#x3D;<br>((y &gt;&gt; 0) &amp; 1) \times x \times 2^{0} + ((y &gt;&gt; 1) &amp; 1) \times x \times 2^{1} +…+ ((y &gt;&gt; 31) &amp; 1) \times x \times 2^{31} \\<br>x \times 2^n &#x3D; x &lt;&lt; n<br>$$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">Sum_Solution</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> num = <span class="number">1</span> + n;</span><br><span class="line">        <span class="built_in">Sum_Solution</span>(sum, num, n);</span><br><span class="line">        <span class="keyword">return</span> sum &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">Sum_Solution</span><span class="params">(<span class="type">int</span> &amp;sum, <span class="type">int</span> &amp;num, <span class="type">int</span> &amp;n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 某一位为1时，加上数值num * 2^x</span></span><br><span class="line">        (n &amp; <span class="number">0x01</span>) &amp;&amp; (sum += num);</span><br><span class="line">        <span class="comment">// num *= 2</span></span><br><span class="line">        num &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// n为0则结束</span></span><br><span class="line">        <span class="keyword">return</span> n &amp;&amp; (<span class="built_in">Sum_Solution</span>(sum, num, n));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="链表的公共节点"><a href="#链表的公共节点" class="headerlink" title="链表的公共节点"></a>链表的公共节点</h1><h2 id="题目-27"><a href="#题目-27" class="headerlink" title="题目"></a>题目</h2><p>输入两个链表，找出它们的第一个公共结点。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的）</p><h2 id="思路-29"><a href="#思路-29" class="headerlink" title="思路"></a>思路</h2><h3 id="暴力破解"><a href="#暴力破解" class="headerlink" title="暴力破解"></a>暴力破解</h3><ol><li>一个一个找节点是否相同</li><li>可递归可循环</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">FindFirstCommonNode</span><span class="params">(ListNode *pHead1, ListNode *pHead2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> p1 = pHead1;</span><br><span class="line">        <span class="keyword">auto</span> p2 = pHead2;</span><br><span class="line">        <span class="comment">// 要么相等，要么同时为nullptr</span></span><br><span class="line">        <span class="keyword">while</span> (p1 != p2) &#123;</span><br><span class="line">            <span class="comment">// p1到尾部，p2后移</span></span><br><span class="line">            p2 = (p1 == <span class="literal">nullptr</span> ? p2 : p2-&gt;next);</span><br><span class="line">            <span class="comment">// p1到尾部，从头再来</span></span><br><span class="line">            p1 = (p1 == <span class="literal">nullptr</span> ? pHead1 : p1-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="有点思考的解法"><a href="#有点思考的解法" class="headerlink" title="有点思考的解法"></a>有点思考的解法</h3><ol><li>如果有相同节点，必有公共尾部</li><li>从中间某个节点开始相同</li><li>先计算长度，然后从尾部公共长度开始找</li><li>一共遍历三次</li></ol><h3 id="最骚解法"><a href="#最骚解法" class="headerlink" title="最骚解法"></a>最骚解法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">FindFirstCommonNode</span><span class="params">(ListNode *pHead1, ListNode *pHead2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> p1 = pHead1;</span><br><span class="line">        <span class="keyword">auto</span> p2 = pHead2;</span><br><span class="line">        <span class="comment">// 要么相等，要么同时为nullptr</span></span><br><span class="line">        <span class="keyword">while</span> (p1 != p2) &#123;</span><br><span class="line">            p1 = (p1 == <span class="literal">nullptr</span> ? pHead2 : p1-&gt;next);</span><br><span class="line">            p2 = (p2 == <span class="literal">nullptr</span> ? pHead1 : p2-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li>如果长度相同，第一遍出结果</li><li>长度不相同，第一遍找到差值，第二遍出结果<ul><li>假设长度分别为<code>a、b，a &gt; b</code></li><li>第一遍p2先跑完指向第一个链表，p1走到第一个链表<code>a - b</code></li><li>在p1走完时，p2走到第一个链表的<code>a - (a - b) = b</code>长度位置</li><li>p1指向第二个链表，这时两个指针指向相同长度的链表</li><li>一起走，找到公共节点则返回，找不到会同时到nullptr，返回</li></ul></li></ol><h1 id="数组中重复的数字"><a href="#数组中重复的数字" class="headerlink" title="数组中重复的数字"></a>数组中重复的数字</h1><h2 id="题目-28"><a href="#题目-28" class="headerlink" title="题目"></a>题目</h2><p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p><h2 id="思路-30"><a href="#思路-30" class="headerlink" title="思路"></a>思路</h2><h3 id="常规思路"><a href="#常规思路" class="headerlink" title="常规思路"></a>常规思路</h3><ol><li>搞一个bool型数组，访问过就写成true，找到第一个为true的</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Parameters:</span></span><br><span class="line">    <span class="comment">//        numbers:     an array of integers</span></span><br><span class="line">    <span class="comment">//        length:      the length of array numbers</span></span><br><span class="line">    <span class="comment">//        duplication: (Output) the duplicated number in the array number</span></span><br><span class="line">    <span class="comment">// Return value:       true if the input is valid, and there are some</span></span><br><span class="line">    <span class="comment">// duplications in the array number</span></span><br><span class="line">    <span class="comment">//                     otherwise false</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">duplicate</span><span class="params">(<span class="type">int</span> numbers[], <span class="type">int</span> length, <span class="type">int</span>* duplication)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">count</span><span class="params">(length, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count[numbers[i]]) &#123;</span><br><span class="line">                *duplication = numbers[i];</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            count[numbers[i]] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="不骚不行，就是要骚"><a href="#不骚不行，就是要骚" class="headerlink" title="不骚不行，就是要骚"></a>不骚不行，就是要骚</h3><ol><li>就用原数组搞事情，访问某个数，以它为索引的地方加上n</li><li>找到以数索引大于n的，返回这个数</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Parameters:</span></span><br><span class="line">    <span class="comment">//        numbers:     an array of integers</span></span><br><span class="line">    <span class="comment">//        length:      the length of array numbers</span></span><br><span class="line">    <span class="comment">//        duplication: (Output) the duplicated number in the array number</span></span><br><span class="line">    <span class="comment">// Return value:       true if the input is valid, and there are some</span></span><br><span class="line">    <span class="comment">// duplications in the array number</span></span><br><span class="line">    <span class="comment">//                     otherwise false</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">duplicate</span><span class="params">(<span class="type">int</span> numbers[], <span class="type">int</span> length, <span class="type">int</span>* duplication)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="comment">// 获取原始数据</span></span><br><span class="line">            <span class="keyword">auto</span> tmp = numbers[i] &lt; length ? numbers[i] : numbers[i] - length;</span><br><span class="line">            <span class="comment">// 如果对应位小于length证明没有被访问过</span></span><br><span class="line">            <span class="keyword">if</span> (numbers[tmp] &lt; length) &#123;</span><br><span class="line">                <span class="comment">// 访问它，增加length</span></span><br><span class="line">                numbers[tmp] += length;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 访问过，就是它了</span></span><br><span class="line">            *duplication = tmp;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="数字在排序数组中出现的次数"><a href="#数字在排序数组中出现的次数" class="headerlink" title="数字在排序数组中出现的次数"></a>数字在排序数组中出现的次数</h1><h2 id="题目-29"><a href="#题目-29" class="headerlink" title="题目"></a>题目</h2><p>统计一个数字在排序数组中出现的次数。</p><h2 id="思路-31"><a href="#思路-31" class="headerlink" title="思路"></a>思路</h2><ul><li>排序数组二分查找即可</li><li>当然用标准库啊</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">GetNumberOfK</span><span class="params">(vector&lt;<span class="type">int</span>&gt; data, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> tmp =</span><br><span class="line">            <span class="built_in">equal_range</span>(data.<span class="built_in">begin</span>(), data.<span class="built_in">end</span>(), k);</span><br><span class="line">        <span class="keyword">return</span> tmp.second - tmp.first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="数组中只出现一次的数字"><a href="#数组中只出现一次的数字" class="headerlink" title="数组中只出现一次的数字"></a>数组中只出现一次的数字</h1><h2 id="题目-30"><a href="#题目-30" class="headerlink" title="题目"></a>题目</h2><p>一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</p><h2 id="思路-32"><a href="#思路-32" class="headerlink" title="思路"></a>思路</h2><ol><li>都出现了两次，说明异或为0</li><li>只有两个出现了一次，那么异或结果就是他们俩的异或</li><li><code>0 ^ 1 = 1</code>，为1的是两个数字不同的位，以此为标准分开两个数组分别异或</li><li>两个结果就为异或结果</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">FindNumsAppearOnce</span><span class="params">(vector&lt;<span class="type">int</span>&gt; data, <span class="type">int</span>* num1, <span class="type">int</span>* num2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> nor = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 先把所有数字异或，结果为两个单独出现的数字的异或</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;tmp : data) &#123;</span><br><span class="line">            nor ^= tmp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> bitNum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 找到第一个不同的位</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nor &amp; <span class="number">0x01</span>) &#123;</span><br><span class="line">                bitNum = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            nor &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        bitNum = <span class="number">1</span> &lt;&lt; bitNum;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据此位将所有数字分成两组进行异或，最终得到结果</span></span><br><span class="line">        *num1 = <span class="number">0</span>;</span><br><span class="line">        *num2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;tmp : data) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tmp &amp; bitNum) &#123;</span><br><span class="line">                *num1 ^= tmp;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            *num2 ^= tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="34、检查链表是否有环路（空间复杂度O-1-）"><a href="#34、检查链表是否有环路（空间复杂度O-1-）" class="headerlink" title="34、检查链表是否有环路（空间复杂度O(1)）"></a>34、检查链表是否有环路（空间复杂度O(1)）</h1><h2 id="题目-31"><a href="#题目-31" class="headerlink" title="题目"></a>题目</h2><p>判断给定的链表中是否有环。如果有环则返回true，否则返回false。<br>你能给出空间复杂度O(1)的解法么？</p><h2 id="思路-33"><a href="#思路-33" class="headerlink" title="思路"></a>思路</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">		<span class="comment">/* 思路1</span></span><br><span class="line"><span class="comment">         * 想象两个人在捉迷藏，一个人先走到一个地方，另一个人去找</span></span><br><span class="line"><span class="comment">         * 如果找到他的时候和他走的路程一样长，那就是原路找的</span></span><br><span class="line"><span class="comment">         * 如果比他路程还短，说明另外一个人绕了一圈，也就是有环路</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 思路2（当前实现代码）</span></span><br><span class="line"><span class="comment">         * 两个人追逐，一个走的快（一次2步），一个走的慢（一次一步）</span></span><br><span class="line"><span class="comment">         * 如果相遇，说明有环路</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 思路3</span></span><br><span class="line"><span class="comment">         * 破坏链表，遍历的同时，让前一个节点指向头指针</span></span><br><span class="line"><span class="comment">         * 遍历如果到了头指针就说明有环路</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">        ListNode *pFast = head;     <span class="comment">// 跑的快的指针</span></span><br><span class="line">        ListNode *pSlow = head;     <span class="comment">// 跑得慢的指针</span></span><br><span class="line">        <span class="keyword">while</span> (pFast != <span class="literal">nullptr</span> &amp;&amp; pFast-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            pSlow = pSlow-&gt;next;</span><br><span class="line">            pFast = pFast-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (pSlow == pFast) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="35-设计实现LRU缓存结构"><a href="#35-设计实现LRU缓存结构" class="headerlink" title="35. 设计实现LRU缓存结构"></a>35. 设计实现LRU缓存结构</h1><h2 id="题目-32"><a href="#题目-32" class="headerlink" title="题目"></a>题目</h2><p>设计LRU缓存结构，该结构在构造时确定大小，假设大小为K，并有如下两个功能</p><ol><li>set(key, value)：将记录(key, value)插入该结构</li><li>get(key)：返回key对应的value值</li></ol><p>[要求]</p><ol><li>set和get方法的时间复杂度为O(1)</li><li>某个key的set或get操作一旦发生，认为这个key的记录成了最常使用的。</li><li>当缓存的大小超过K时，移除最不经常使用的记录，即set或get最久远的。</li></ol><h2 id="思路-34"><a href="#思路-34" class="headerlink" title="思路"></a>思路</h2><ul><li>查找使用hashmap，时间复杂度O(1)满足</li><li>lru管理用链表，方便调整位置</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">lru_cache</span> &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">lru_cache</span>(<span class="type">int</span> k) : <span class="built_in">cache_size</span>(k) &#123;</span><br><span class="line">        m_lruList.<span class="built_in">clear</span>();</span><br><span class="line">        m_cache.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先查找value</span></span><br><span class="line">        <span class="keyword">auto</span> it = m_cache.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">if</span> (it != m_cache.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="comment">// 找到修改值</span></span><br><span class="line">            (*it-&gt;second).second = value;</span><br><span class="line">            <span class="comment">// 找到，将缓存插入到最前面</span></span><br><span class="line">            m_lruList.<span class="built_in">splice</span>(m_lruList.<span class="built_in">begin</span>(), m_lruList, it-&gt;second);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没找到，插入</span></span><br><span class="line">        <span class="comment">// 判断是否超过最大个数，删除最后一个，map也要删除</span></span><br><span class="line">        <span class="keyword">if</span> (m_lruList.<span class="built_in">size</span>() &gt;= cache_size) &#123;</span><br><span class="line">            <span class="keyword">auto</span> delIt = m_lruList.<span class="built_in">back</span>();</span><br><span class="line">            m_cache.<span class="built_in">erase</span>(delIt.first);</span><br><span class="line">            m_lruList.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        m_lruList.<span class="built_in">emplace_front</span>(<span class="built_in">make_pair</span>(key, value));</span><br><span class="line">        m_cache[key] = m_lruList.<span class="built_in">begin</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先查找value</span></span><br><span class="line">        <span class="keyword">auto</span> it = m_cache.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">if</span> (it == m_cache.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="comment">// 没找到返回-1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到，将缓存插入到最前面</span></span><br><span class="line">        m_lruList.<span class="built_in">splice</span>(m_lruList.<span class="built_in">begin</span>(), m_lruList, it-&gt;second);</span><br><span class="line">        <span class="comment">// 这里返回值</span></span><br><span class="line">        <span class="keyword">return</span> (*it-&gt;second).second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> cache_size;                  <span class="comment">// cache最大大小</span></span><br><span class="line">    list&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; m_lruList;  <span class="comment">// 用于存放lru的链表，值为value</span></span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, list&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;::iterator&gt;</span><br><span class="line">        m_cache;  <span class="comment">// 用于O(1)查找的map</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="36-二叉树之字型遍历"><a href="#36-二叉树之字型遍历" class="headerlink" title="36. 二叉树之字型遍历"></a>36. 二叉树之字型遍历</h1><h2 id="题目-33"><a href="#题目-33" class="headerlink" title="题目"></a>题目</h2><p>给定一个二叉树，返回该二叉树的之字形层序遍历，（第一层从左向右，下一层从右向左，一直这样交替）</p><h2 id="思路-35"><a href="#思路-35" class="headerlink" title="思路"></a>思路</h2><ul><li>肯定要用栈的，不然做不到先入后出</li></ul><p><strong>思路1</strong></p><ul><li>两个栈，一进一出</li></ul><p><strong>思路2</strong></p><ul><li>一个栈一个队列</li><li>每一层，出栈进队列</li><li>再出队列</li></ul><p><strong>思路3</strong></p><ul><li>一个链表搞定（模拟两个栈，栈底对在一起）</li><li>左出右进，右出左进</li></ul><h1 id="37-股票（一次交易）"><a href="#37-股票（一次交易）" class="headerlink" title="37. 股票（一次交易）"></a>37. 股票（一次交易）</h1><h2 id="题目-34"><a href="#题目-34" class="headerlink" title="题目"></a>题目</h2><p>假设你有一个数组，其中第 i 个元素是股票在第 i 天的价格。<br>你有一次买入和卖出的机会。（只有买入了股票以后才能卖出）。请你设计一个算法来计算可以获得的最大收益。</p><h2 id="思路-36"><a href="#思路-36" class="headerlink" title="思路"></a>思路</h2><p><strong>动态规划</strong></p><ul><li>f(n)为n天卖出的收益，max(f(n)) &#x3D; prices[n] - min(prices[n])</li><li>遍历数组，找到f(n)最大值</li></ul><h1 id="38-找出第k大"><a href="#38-找出第k大" class="headerlink" title="38. 找出第k大"></a>38. 找出第k大</h1><h2 id="题目-35"><a href="#题目-35" class="headerlink" title="题目"></a>题目</h2><p>有一个整数数组，请你根据快速排序的思路，找出数组中第K大的数。<br>给定一个整数数组a,同时给定它的大小n和要找的K(K在1到n之间)，请返回第K大的数，保证答案存在。</p><h2 id="思路-37"><a href="#思路-37" class="headerlink" title="思路"></a>思路</h2><ul><li>快排，找节点，插入</li><li>节点左右，k在哪里，对哪里做快排</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 转递归函数实现，a传入指针方便递归</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param a 头指针</span></span><br><span class="line"><span class="comment">     * @param n 数组长度</span></span><br><span class="line"><span class="comment">     * @param K K值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @return 返回第K大的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findKth</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> n, <span class="type">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>(K &gt; <span class="number">0</span> &amp;&amp; n &gt; <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">assert</span>(n &gt;= K);</span><br><span class="line">        <span class="comment">// use the first item to be the axis</span></span><br><span class="line">        <span class="type">int</span> axis = a[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = n - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// First, the right run, when right &gt; axis, left = right, then left run</span></span><br><span class="line">        <span class="comment">// when left &lt; axis, right = left, then right run</span></span><br><span class="line">        <span class="comment">// equal won&#x27;t handle</span></span><br><span class="line">        <span class="comment">// with this way, we can avoid swap item too frequently</span></span><br><span class="line">        <span class="type">bool</span> isRightRun = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (left != right) &#123;</span><br><span class="line">            <span class="comment">// right run</span></span><br><span class="line">            <span class="keyword">if</span> (isRightRun) &#123;</span><br><span class="line">                <span class="comment">// right less than axis</span></span><br><span class="line">                <span class="keyword">if</span> (a[right] &lt;= axis) &#123;</span><br><span class="line">                    right--;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                a[left] = a[right];</span><br><span class="line">                isRightRun = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// left run</span></span><br><span class="line">            <span class="comment">// left bigger than axis</span></span><br><span class="line">            <span class="keyword">if</span> (a[left] &gt;= axis) &#123;</span><br><span class="line">                left++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            a[right] = a[left];</span><br><span class="line">            isRightRun = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        a[left] = axis;</span><br><span class="line">        <span class="comment">// if left is K</span></span><br><span class="line">        <span class="keyword">if</span> ((left + <span class="number">1</span>) == K) <span class="keyword">return</span> axis;</span><br><span class="line">        <span class="comment">// left bigger than K, use right part to sort</span></span><br><span class="line">        <span class="keyword">if</span> ((left + <span class="number">1</span>) &lt; K) <span class="keyword">return</span> <span class="built_in">findKth</span>(a + left + <span class="number">1</span>, n - <span class="number">1</span> - left, K - left - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// left bigger than K, use right part to sort</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">findKth</span>(a, left, K);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findKth</span><span class="params">(vector&lt;<span class="type">int</span>&gt; a, <span class="type">int</span> n, <span class="type">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="comment">/* 思路1</span></span><br><span class="line"><span class="comment">         * 小根堆实现</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 思路2（当前）</span></span><br><span class="line"><span class="comment">         * 快排思想</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">findKth</span>(&amp;a[<span class="number">0</span>], n, K);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="39-二分查找"><a href="#39-二分查找" class="headerlink" title="39. 二分查找"></a>39. 二分查找</h1><h2 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h2><p>请实现有重复数字的升序数组的二分查找<br>给定一个 元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1</p><h2 id="思路-38"><a href="#思路-38" class="headerlink" title="思路"></a>思路</h2><ul><li>思路就是二分查找思路</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 如果目标值存在返回下标，否则返回 -1</span></span><br><span class="line"><span class="comment">     * @param nums int整型vector</span></span><br><span class="line"><span class="comment">     * @param target int整型</span></span><br><span class="line"><span class="comment">     * @return int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = len - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// check array boundary</span></span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span> || target &lt; nums.<span class="built_in">front</span>() || target &gt; nums[right])</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (target == nums.<span class="built_in">front</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// left move faster than mid and mid is more close to left, finally left</span></span><br><span class="line">        <span class="comment">// will be equal or bigger than right</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> mid = (right + left) &gt;&gt; <span class="number">1</span>;  <span class="comment">// 0-3 mid 1, more close to left</span></span><br><span class="line">            <span class="comment">// fast convergence, mid +- 1</span></span><br><span class="line">            <span class="keyword">if</span> (target &gt; nums[mid])</span><br><span class="line">                left = mid + <span class="number">1</span>;  <span class="comment">// left - 1 must less than target</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right = mid - <span class="number">1</span>;  <span class="comment">// right + 1 maybe equal target</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// if left bigger than right, judge left only</span></span><br><span class="line">        <span class="comment">// if left == right, judge left and right + 1</span></span><br><span class="line">        <span class="keyword">if</span> (nums[left] == target) <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">if</span> (left == right &amp;&amp; nums[++left] == target) <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="40-最长无重复子串"><a href="#40-最长无重复子串" class="headerlink" title="40. 最长无重复子串"></a>40. 最长无重复子串</h1><h2 id="题目-36"><a href="#题目-36" class="headerlink" title="题目"></a>题目</h2><p>给定一个数组arr，返回arr的最长无的重复子串的长度(无重复指的是所有数字都不相同)。</p><h2 id="思路-39"><a href="#思路-39" class="headerlink" title="思路"></a>思路</h2><ul><li>动态规划思想，查找最快是hashmap</li><li>用hashmap维持无重复子串的队列，</li><li>遍历数组，一个一个插入hashmap，遇到重复的，当前hashmap大小就是z无重复子串大小</li><li>将上一个重复的点包括之前的全部删掉（hashmap删除重建更好写，或许更快）</li><li>数组遍历一遍即可</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param arr int整型vector the array</span></span><br><span class="line"><span class="comment">     * @return int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; um_map;</span><br><span class="line">        <span class="type">int</span> len = arr.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="comment">// if value in map, map size may be the result, then i = last common value + 1</span></span><br><span class="line">            <span class="keyword">auto</span> it = um_map.<span class="built_in">find</span>(arr[i]);</span><br><span class="line">            <span class="keyword">if</span> (it != um_map.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="type">int</span> mapLen = um_map.<span class="built_in">size</span>();</span><br><span class="line">                result = result &gt; mapLen ? result : mapLen;</span><br><span class="line">                i = it-&gt;second + <span class="number">1</span>;</span><br><span class="line">                um_map.<span class="built_in">clear</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            um_map[arr[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mapLen = um_map.<span class="built_in">size</span>();</span><br><span class="line">        result = result &gt; mapLen ? result : mapLen;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="41-最长回文长度"><a href="#41-最长回文长度" class="headerlink" title="41. 最长回文长度"></a>41. 最长回文长度</h1><h2 id="题目-37"><a href="#题目-37" class="headerlink" title="题目"></a>题目</h2><p>对于一个字符串，请设计一个高效算法，计算其中最长回文子串的长度。<br>给定字符串A以及它的长度n，请返回最长回文子串的长度。</p><h2 id="思路-40"><a href="#思路-40" class="headerlink" title="思路"></a>思路</h2><ul><li>遍历数组，每一个点和点后面的间隔为中心，分别找到重复最大值</li><li>遍历完成得到结果</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getLongestPalindrome</span><span class="params">(string A, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// think every char as mid, caculate the same len</span></span><br><span class="line">            <span class="comment">// 1234321</span></span><br><span class="line">            <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; (i + <span class="number">1</span>) &amp;&amp; j &lt; (n - i); ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (A[i + j] != A[i - j]) &#123;</span><br><span class="line">                    <span class="type">int</span> len = (j - <span class="number">1</span>) * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">                    result = result &gt; len ? result : len;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == (i + <span class="number">1</span>) || j == (n - i)) &#123;</span><br><span class="line">                <span class="type">int</span> len = (j - <span class="number">1</span>) * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">                result = result &gt; len ? result : len;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// think every char as left first, caculate the same len</span></span><br><span class="line">            <span class="comment">// 123321</span></span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; (i + <span class="number">1</span>) &amp;&amp; j &lt; (n - i - <span class="number">1</span>); ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (A[i + j + <span class="number">1</span>] != A[i - j]) &#123;</span><br><span class="line">                    <span class="type">int</span> len = j * <span class="number">2</span>;</span><br><span class="line">                    result = result &gt; len ? result : len;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == (i + <span class="number">1</span>) || j == (n - i - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="type">int</span> len = j * <span class="number">2</span>;</span><br><span class="line">                result = result &gt; len ? result : len;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><div class="reward-container"><div></div><button onclick='var qr=document.getElementById("qr");qr.style.display="none"===qr.style.display?"block":"none"'>打赏</button><div id="qr" style="display:none"><div style="display:inline-block"><img src="/images/wechatpay.png" alt="王钰博 微信支付"><p>微信支付</p></div><div style="display:inline-block"><img src="/images/alipay.jpg" alt="王钰博 支付宝"><p>支付宝</p></div></div></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-item"><a href="/blogs/2019-09-18-sqlite/" rel="prev" title="sqlite学习笔记(C语言)"><i class="fa fa-chevron-left"></i> sqlite学习笔记(C语言)</a></div><div class="post-nav-item"><a href="/blogs/2019-12-11-php/" rel="next" title="php学习笔记">php学习笔记 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="valine-comments"></div><script>window.addEventListener("tabs:register",()=>{let{activeClass:t}=CONFIG.comments;if(CONFIG.comments.storage&&(t=localStorage.getItem("comments_active")||t),t){let e=document.querySelector(`a[href="#comment-${t}"]`);e&&e.click()}}),CONFIG.comments.storage&&window.addEventListener("tabs:click",t=>{if(!t.target.matches(".tabs-comment .tab-content .tab-pane"))return;let e=t.target.classList[1];localStorage.setItem("comments_active",e)})</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-text">前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E6%9F%A5%E6%89%BE"><span class="nav-text">1. 二维数组查找</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF"><span class="nav-text">思路</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-%E6%96%90%E6%B3%A2%E9%82%A3%E5%88%87%E6%95%B0%E5%88%97%E8%BE%93%E5%87%BA"><span class="nav-text">2. 斐波那切数列输出</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-1"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-1"><span class="nav-text">思路</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A1%AC%E8%A7%A3"><span class="nav-text">硬解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%92%E5%BD%92"><span class="nav-text">递归</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="nav-text">动态规划</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6"><span class="nav-text">3. 青蛙跳台阶</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-2"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-2"><span class="nav-text">思路</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97"><span class="nav-text">4. 两个栈实现队列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-3"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-3"><span class="nav-text">思路</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E6%9F%A5%E6%89%BE%E6%9C%80%E5%B0%8F%E5%80%BC"><span class="nav-text">旋转数组查找最小值</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-4"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-4"><span class="nav-text">思路</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%98%E6%80%81%E8%B7%B3%E5%8F%B0%E9%98%B6%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-text">变态跳台阶的问题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-5"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-5"><span class="nav-text">思路</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">重建二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%97%AE%E9%A2%98"><span class="nav-text">问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-6"><span class="nav-text">思路</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E5%80%BC"><span class="nav-text">链表倒数第k个值</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-6"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-7"><span class="nav-text">思路</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8%E7%BF%BB%E8%BD%AC"><span class="nav-text">链表翻转</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-7"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-8"><span class="nav-text">思路</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%9F%A9%E5%BD%A2%E8%A6%86%E7%9B%96"><span class="nav-text">矩形覆盖</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%97%AE%E9%A2%98-1"><span class="nav-text">问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-9"><span class="nav-text">思路</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2"><span class="nav-text">调整数组中奇数位于偶数前面</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-8"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-10"><span class="nav-text">思路</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A1%AC%E8%A7%A3-1"><span class="nav-text">硬解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%A6%E5%8A%A0%E9%98%9F%E5%88%97"><span class="nav-text">另加队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E5%87%86%E5%BA%93-stable-partition"><span class="nav-text">标准库 stable_partition</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E5%B9%82"><span class="nav-text">数值的整数次幂</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-9"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-11"><span class="nav-text">思路</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E5%88%97%E8%A1%A8"><span class="nav-text">合并两个排序的列表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-10"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-12"><span class="nav-text">思路</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%9E%E9%80%92%E5%BD%92%E7%89%88%E6%9C%AC"><span class="nav-text">非递归版本</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E7%89%88%E6%9C%AC"><span class="nav-text">递归版本</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F"><span class="nav-text">二叉树的镜像</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-11"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-13"><span class="nav-text">思路</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E7%89%88%E6%9C%AC-1"><span class="nav-text">递归版本</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%9E%E9%80%92%E5%BD%92%E7%89%88%E6%9C%AC-1"><span class="nav-text">非递归版本</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84"><span class="nav-text">树的子结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-12"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-14"><span class="nav-text">思路</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%8E%E4%B8%8A%E5%BE%80%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">从上往下打印二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-13"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-15"><span class="nav-text">思路</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97"><span class="nav-text">栈的压入、弹出序列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-14"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-16"><span class="nav-text">思路</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88"><span class="nav-text">包含min函数的栈</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-15"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-17"><span class="nav-text">思路</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5"><span class="nav-text">顺时针打印矩阵</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-16"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-18"><span class="nav-text">思路</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97"><span class="nav-text">数组中出现次数超过一半的数字</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-17"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-19"><span class="nav-text">思路</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%9F%E8%AE%A1"><span class="nav-text">统计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F%E5%8F%96%E4%B8%AD%E5%80%BC"><span class="nav-text">排序取中值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B8%E6%B6%88"><span class="nav-text">相消</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E6%95%B0%E7%BB%84%E6%A0%A1%E9%AA%8C"><span class="nav-text">二叉搜索树后序遍历数组校验</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-18"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-20"><span class="nav-text">思路</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9C%80%E5%B0%8Fk%E4%B8%AA%E6%95%B0"><span class="nav-text">最小k个数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-19"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-21"><span class="nav-text">思路</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F%E5%90%8E%E5%8F%96%E5%89%8Dk%E4%B8%AA%E5%80%BC"><span class="nav-text">排序后取前k个值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%B4%E6%8A%A4%E4%B8%80%E4%B8%AAk%E4%B8%AA%E5%80%BC%E7%9A%84%E6%95%B0%E7%BB%84%EF%BC%8C%E6%89%BE%E5%88%B0%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E5%80%BC"><span class="nav-text">维护一个k个值的数组，找到最小的k个值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%A7%E6%A0%B9%E5%A0%86"><span class="nav-text">大根堆</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%98%8E%E6%98%8E%E7%9A%84%E9%9A%8F%E6%9C%BA%E6%95%B0"><span class="nav-text">明明的随机数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-20"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-22"><span class="nav-text">思路</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C"><span class="nav-text">连续子数组的最大和</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-21"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-23"><span class="nav-text">思路</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84"><span class="nav-text">二叉树中和为某一值的路径</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-22"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-24"><span class="nav-text">思路</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6"><span class="nav-text">二叉树的深度</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-23"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-25"><span class="nav-text">思路</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%92%E5%BD%92-1"><span class="nav-text">递归</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%9E%E9%80%92%E5%BD%92"><span class="nav-text">非递归</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6"><span class="nav-text">第一个只出现一次的字符</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-24"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-26"><span class="nav-text">思路</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%A1%AC%E5%B8%81%E6%96%B9%E6%A1%88%E6%95%B0"><span class="nav-text">硬币方案数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-25"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-27"><span class="nav-text">思路</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AE%A1%E7%AE%971-2-3-%E2%80%A6-n"><span class="nav-text">计算1 + 2 + 3 + … + n</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-26"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-28"><span class="nav-text">思路</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8%E7%9A%84%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9"><span class="nav-text">链表的公共节点</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-27"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-29"><span class="nav-text">思路</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3"><span class="nav-text">暴力破解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E7%82%B9%E6%80%9D%E8%80%83%E7%9A%84%E8%A7%A3%E6%B3%95"><span class="nav-text">有点思考的解法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E9%AA%9A%E8%A7%A3%E6%B3%95"><span class="nav-text">最骚解法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97"><span class="nav-text">数组中重复的数字</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-28"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-30"><span class="nav-text">思路</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E8%A7%84%E6%80%9D%E8%B7%AF"><span class="nav-text">常规思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E9%AA%9A%E4%B8%8D%E8%A1%8C%EF%BC%8C%E5%B0%B1%E6%98%AF%E8%A6%81%E9%AA%9A"><span class="nav-text">不骚不行，就是要骚</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E5%AD%97%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0"><span class="nav-text">数字在排序数组中出现的次数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-29"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-31"><span class="nav-text">思路</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97"><span class="nav-text">数组中只出现一次的数字</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-30"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-32"><span class="nav-text">思路</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#34%E3%80%81%E6%A3%80%E6%9F%A5%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E6%9C%89%E7%8E%AF%E8%B7%AF%EF%BC%88%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6O-1-%EF%BC%89"><span class="nav-text">34、检查链表是否有环路（空间复杂度O(1)）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-31"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-33"><span class="nav-text">思路</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#35-%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0LRU%E7%BC%93%E5%AD%98%E7%BB%93%E6%9E%84"><span class="nav-text">35. 设计实现LRU缓存结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-32"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-34"><span class="nav-text">思路</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#36-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B9%8B%E5%AD%97%E5%9E%8B%E9%81%8D%E5%8E%86"><span class="nav-text">36. 二叉树之字型遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-33"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-35"><span class="nav-text">思路</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#37-%E8%82%A1%E7%A5%A8%EF%BC%88%E4%B8%80%E6%AC%A1%E4%BA%A4%E6%98%93%EF%BC%89"><span class="nav-text">37. 股票（一次交易）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-34"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-36"><span class="nav-text">思路</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#38-%E6%89%BE%E5%87%BA%E7%AC%ACk%E5%A4%A7"><span class="nav-text">38. 找出第k大</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-35"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-37"><span class="nav-text">思路</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#39-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="nav-text">39. 二分查找</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%97%AE%E9%A2%98-2"><span class="nav-text">问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-38"><span class="nav-text">思路</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#40-%E6%9C%80%E9%95%BF%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%90%E4%B8%B2"><span class="nav-text">40. 最长无重复子串</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-36"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-39"><span class="nav-text">思路</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#41-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E9%95%BF%E5%BA%A6"><span class="nav-text">41. 最长回文长度</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-37"><span class="nav-text">题目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF-40"><span class="nav-text">思路</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="王钰博" src="/images/12.jpg"><p class="site-author-name" itemprop="name">王钰博</p><div class="site-description" itemprop="description">个人博客</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">120</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">22</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">14</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/Githubwyb" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Githubwyb" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:1061322005@qq.com" title="E-Mail → mailto:1061322005@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a></span></div><div class="links-of-blogroll motion-element"><div class="links-of-blogroll-title"><i class="fa fa-fw fa-link"></i> 友情链接</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="https://githubwyb.github.io/bookPages/" title="https:&#x2F;&#x2F;githubwyb.github.io&#x2F;bookPages&#x2F;">markdown books</a></li></ul></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="beian"><a href="http://www.beian.miit.gov.cn/" rel="noopener" target="_blank">豫ICP备16023189号 </a><img src="/images/beian.png" style="display:inline-block"></div><div class="copyright">&copy; <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">王钰博</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-area-chart"></i> </span><span title="站点总字数">884k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span title="站点阅读时长">13:24</span></div><div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动</div><div class="addthis_inline_share_toolbox"><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e1986d4e4e2d132" async></script></div><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-divider">|</span> <span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer></div><script src="/lib/anime.min.js"></script><script src="/lib/medium-zoom.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><script src="/js/local-search.js"></script><script>document.querySelectorAll(".pdfobject-container").forEach(e=>{let t=e.dataset.target,a="#"+Object.entries({navpanes:0,toolbar:0,statusbar:0,pagemode:"thumbs",view:"FitH"}).map(([e,t])=>`${e}=${encodeURIComponent(t)}`).join("&"),i=`/lib/pdf/web/viewer.html?file=${encodeURIComponent(t)}${a}`;NexT.utils.supportsPDFs()?e.innerHTML=`<embed class="pdfobject" src="${t+a}" type="application/pdf" style="height: ${e.dataset.height};">`:e.innerHTML=`<iframe src="${i}" style="height: ${e.dataset.height};" frameborder="0"></iframe>`})</script><script>"undefined"==typeof MathJax?(window.MathJax={loader:{source:{"[tex]/amsCd":"[tex]/amscd","[tex]/AMScd":"[tex]/amscd"}},tex:{inlineMath:{"[+]":[["$","$"]]},tags:"ams"},options:{renderActions:{findScript:[10,e=>{document.querySelectorAll('script[type^="math/tex"]').forEach(t=>{const a=!!t.type.match(/; *mode=display/),n=new e.options.MathItem(t.textContent,e.inputJax[0],a),d=document.createTextNode("");t.parentNode.replaceChild(d,t),n.start={node:d,delim:"",n:0},n.end={node:d,delim:"",n:0},e.math.push(n)})},"",!1],insertedScript:[200,()=>{document.querySelectorAll("mjx-container").forEach(e=>{let t=e.parentNode;"li"===t.nodeName.toLowerCase()&&t.parentNode.classList.add("has-jax")})},"",!1]}}},function(){var e=document.createElement("script");e.src="/lib/mathjax/tex-mml-chtml.js",e.defer=!0,document.head.appendChild(e)}()):(MathJax.startup.document.state(0),MathJax.texReset(),MathJax.typeset())</script><script>NexT.utils.loadComments(document.querySelector("#valine-comments"),()=>{NexT.utils.getScript("//unpkg.com/valine/dist/Valine.min.js",()=>{var e=["nick","mail","link"],a="nick,mail";a=a.split(",").filter(a=>e.includes(a)),new Valine({el:"#valine-comments",verify:!1,notify:!1,appId:"qmLbUHV1HOr841BOYkl84riu-gzGzoHsz",appKey:"j4fgTcf1yHRDD5X3HUH5EH95",placeholder:"^_^ happy everyday!",avatar:"wavatar",meta:a,pageSize:"10",visitor:!1,lang:"zh-cn",path:location.pathname,recordIP:!1,serverURLs:""})},window.Valine)})</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":true,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"bottom":-30,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body><script type="text/javascript" src="/lib/jquery-3.4.1.min.js"></script><script type="text/javascript" src="/js/src/love.js"></script></html>