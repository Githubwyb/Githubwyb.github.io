<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.0.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-diy.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-diy.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-diy.png"><link rel="mask-icon" href="/images/logo-diy.svg" color="#222"><meta name="baidu-site-verification" content="y1cfESbTt9nd3LsA"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="/lib/pace/pace-theme-flash.min.css"><script src="/lib/pace/pace.min.js"></script><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"githubwyb.github.io",root:"/",scheme:"Pisces",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:null},back2top:{enable:!0,sidebar:!1,scrollpercent:!0},bookmark:{enable:!0,color:"#ff0000",save:"auto"},fancybox:!1,mediumzoom:!0,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="前言本文是《30天自制操作系统》中的windows翻译为linux上的一些实践，过程中也在逐步迁移linux的源码到里面。本身作为对linux上的汇编、启动、内存管理等的一个学习实践。在30天之前都是将此工程翻译到linux，30天后将变成linux移植过程的笔记  参考: https:&#x2F;&#x2F;github.com&#x2F;cherishsir&#x2F;ubuntu230os  关键词解释 启动区: (bootsec"><meta property="og:type" content="article"><meta property="og:title" content="30天自制操作系统笔记"><meta property="og:url" content="https://githubwyb.github.io/blogs/2019-04-25-createOS30daysNotes/index.html"><meta property="og:site_name" content="技术的路上奔跑"><meta property="og:description" content="前言本文是《30天自制操作系统》中的windows翻译为linux上的一些实践，过程中也在逐步迁移linux的源码到里面。本身作为对linux上的汇编、启动、内存管理等的一个学习实践。在30天之前都是将此工程翻译到linux，30天后将变成linux移植过程的笔记  参考: https:&#x2F;&#x2F;github.com&#x2F;cherishsir&#x2F;ubuntu230os  关键词解释 启动区: (bootsec"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://githubwyb.github.io/blogs/2019-04-25-createOS30daysNotes/2022-10-24-01.png"><meta property="og:image" content="https://githubwyb.github.io/blogs/2019-04-25-createOS30daysNotes/2022-10-24-03.png"><meta property="og:image" content="https://githubwyb.github.io/blogs/2019-04-25-createOS30daysNotes/2022-10-24-02.png"><meta property="og:image" content="https://githubwyb.github.io/blogs/2019-04-25-createOS30daysNotes/2022-10-23-01.png"><meta property="article:published_time" content="2019-04-25T07:58:18.000Z"><meta property="article:modified_time" content="2024-09-20T07:15:30.000Z"><meta property="article:author" content="王钰博"><meta property="article:tag" content="wyb"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://githubwyb.github.io/blogs/2019-04-25-createOS30daysNotes/2022-10-24-01.png"><link rel="canonical" href="https://githubwyb.github.io/blogs/2019-04-25-createOS30daysNotes/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>30天自制操作系统笔记 | 技术的路上奔跑</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">技术的路上奔跑</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">入门</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-fw fa-sitemap"></i>站点地图</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><div class="reading-progress-bar"></div><a role="button" class="book-mark-link book-mark-link-fixed"></a> <a href="https://github.com/Githubwyb" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://githubwyb.github.io/blogs/2019-04-25-createOS30daysNotes/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/12.jpg"><meta itemprop="name" content="王钰博"><meta itemprop="description" content="个人博客"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="技术的路上奔跑"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">30天自制操作系统笔记</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-04-25 15:58:18" itemprop="dateCreated datePublished" datetime="2019-04-25T15:58:18+08:00">2019-04-25</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2024-09-20 15:15:30" itemprop="dateModified" datetime="2024-09-20T15:15:30+08:00">2024-09-20</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Knowledge/" itemprop="url" rel="index"><span itemprop="name">Knowledge</span></a> </span>， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Knowledge/Study/" itemprop="url" rel="index"><span itemprop="name">Study</span></a> </span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span id="busuanzi_value_page_pv"></span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><span class="post-meta-item-text">Valine：</span> <a title="valine" href="/blogs/2019-04-25-createOS30daysNotes/#valine-comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/blogs/2019-04-25-createOS30daysNotes/" itemprop="commentCount"></span></a></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>33k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>30 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文是《30天自制操作系统》中的windows翻译为linux上的一些实践，过程中也在逐步迁移linux的源码到里面。本身作为对linux上的汇编、启动、内存管理等的一个学习实践。在30天之前都是将此工程翻译到linux，30天后将变成linux移植过程的笔记</p><ul><li>参考: <a target="_blank" rel="noopener" href="https://github.com/cherishsir/ubuntu230os">https://github.com/cherishsir/ubuntu230os</a></li></ul><h1 id="关键词解释"><a href="#关键词解释" class="headerlink" title="关键词解释"></a>关键词解释</h1><ul><li>启动区: (bootsector) 软盘第一个的扇区称为启动区。那么什么是扇区呢？计算机读写软盘的时候，并不是一个字节一个字节地读写的，而是以512字节为一个单位进行读写。因此，软盘的512字节就称为一个扇区。一张软盘的空间共有1440KB, 也就是1474560字节，除以512得2880, 这也就是说一张软盘共有2880个扇区。那为什么第一个扇区称为启动区呢？那是因为计算机首先从最初一个扇区开始读软盘，然后去检查这个扇区最后2个字节的内容。</li><li>IPL: （initial program loader）启动程序加载器。启动区只有区区512字节，实际的操作系统不像hello-os这么小，根本装不进去。所以几乎所有的操作系统，都是把加载操作系统本身的程序放在启动区里的。有鉴于此，有时也将启动区称为IPL。但hello-os没有加载程序的功能，所以HELLOIPL这个名字不太顺理成章。如果有人正义感特别强，觉得“这是撒谎造假，万万不能容忍！＂，那也可以改成其他的名字。但是必须起一个8字节的名字，如果名字长度不到8字节的话，常要在最后补上空格。</li></ul><h1 id="第1天-从计算机结构到汇编程序入门"><a href="#第1天-从计算机结构到汇编程序入门" class="headerlink" title="第1天 从计算机结构到汇编程序入门"></a>第1天 从计算机结构到汇编程序入门</h1><ol><li>环境windows</li><li>二进制编辑器 notepad++安装hexeditor插件</li><li>汇编编辑器 vscode安装x86 and x86_64 Assembly</li><li>编译需要使用光盘中的nask编译器</li></ol><h2 id="1-vmware启动img"><a href="#1-vmware启动img" class="headerlink" title="1. vmware启动img"></a>1. vmware启动img</h2><ul><li>创建系统选择other&#x2F;other</li><li>创建好需要添加硬件，选择软盘，然后使用文件，选择img即可启动</li></ul><h2 id="2-qemu启动img"><a href="#2-qemu启动img" class="headerlink" title="2. qemu启动img"></a>2. qemu启动img</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64 -enable-kvm -m 4G -smp 1 -fda common/haribote.img</span><br></pre></td></tr></table></figure><h1 id="第2天-汇编语言学习与Makefile入门"><a href="#第2天-汇编语言学习与Makefile入门" class="headerlink" title="第2天 汇编语言学习与Makefile入门"></a>第2天 汇编语言学习与Makefile入门</h1><h2 id="1-标准FAT12软盘格式"><a href="#1-标准FAT12软盘格式" class="headerlink" title="1. 标准FAT12软盘格式"></a>1. 标准FAT12软盘格式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">; 以下的记述用于标准FAT12格式的软盘</span><br><span class="line">    JMP     entry</span><br><span class="line">    DB      0x90</span><br><span class="line">    DB      &quot;HELLOIPL&quot;      ; 启动区的名称可以是任意的字符串</span><br><span class="line">    DW      512             ; 每个扇区（sector）的大小（必须为512字节）</span><br><span class="line">    DB      1               ; 簇（cluster）的大小（必须为1个扇区）</span><br><span class="line">    DW      1               ; FAT的起始位置（一般从第一个扇区开始）</span><br><span class="line">    DB      2               ; FAT的个数（必须为2）</span><br><span class="line">    DW      224             ; 根目录的大小（一般设成224项）</span><br><span class="line">    DW      2880            ; 该磁盘的大小（必须是2880扇区）</span><br><span class="line">    DB      0xf0            ; 磁盘的种类</span><br><span class="line">    DW      9               ; FAT的长度（必须是9扇区）</span><br><span class="line">    DW      18              ; 1个磁道（track）有几个扇区（必须是18）</span><br><span class="line">    DW      2               ; 磁头数（必须是2）</span><br><span class="line">    DD      0               ; 不使用分区，必须是0</span><br><span class="line">    DD      2880            ; 重写一次磁盘大小</span><br><span class="line">    DB      0, 0, 0x29      ; 意义不明，固定</span><br><span class="line">    DD      0xffffffff      ; （可能是）卷标号码</span><br><span class="line">    DB      &quot;HELLO-OS   &quot;   ; 磁盘的名称（11字节）</span><br><span class="line">    DB      &quot;FAT12   &quot;      ; 磁盘格式名称（8字节）</span><br><span class="line">    RESB    18              ; 先空出18字节</span><br></pre></td></tr></table></figure><h2 id="2-汇编代表性寄存器介绍"><a href="#2-汇编代表性寄存器介绍" class="headerlink" title="2. 汇编代表性寄存器介绍"></a>2. 汇编代表性寄存器介绍</h2><h3 id="16位寄存器"><a href="#16位寄存器" class="headerlink" title="16位寄存器"></a>16位寄存器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">AX ---- accumulator         累加寄存器</span><br><span class="line">CX ---- counter             计数寄存器</span><br><span class="line">DX ---- data                数据寄存器</span><br><span class="line">BX ---- base                基址寄存器</span><br><span class="line">SP ---- stack pointer       栈指针寄存器</span><br><span class="line">BP ---- base pointer        基址指针寄存器</span><br><span class="line">SI ---- source index        源变址寄存器</span><br><span class="line">DI ---- destination index   目的变址寄存器</span><br></pre></td></tr></table></figure><h3 id="8位寄存器"><a href="#8位寄存器" class="headerlink" title="8位寄存器"></a>8位寄存器</h3><p>8位寄存器为16位寄存器的扩展，AL和AH一起代表AX，并不是单独的寄存器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">AL ---- accumulator         累加寄存器低位</span><br><span class="line">CL ---- counter             计数寄存器低位</span><br><span class="line">DL ---- data                数据寄存器低位</span><br><span class="line">BL ---- base                基址寄存器低位</span><br><span class="line">AH ---- accumulator         累加寄存器高位</span><br><span class="line">CH ---- counter             计数寄存器高位</span><br><span class="line">DH ---- data                数据寄存器高位</span><br><span class="line">BH ---- base                基址寄存器高位</span><br></pre></td></tr></table></figure><h3 id="32位寄存器"><a href="#32位寄存器" class="headerlink" title="32位寄存器"></a>32位寄存器</h3><ul><li>32位系统中使用的32位寄存器，低16位和上述16位相同，高16位没有寄存器名字</li><li>32位寄存器加<code>E</code>代表，如<code>EAX, ECX, EDX, EBX, ESP, EBP, ESI, EDI</code></li></ul><h3 id="段寄存器，16位"><a href="#段寄存器，16位" class="headerlink" title="段寄存器，16位"></a>段寄存器，16位</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ES ---- extra segment       附加段寄存器</span><br><span class="line">CS ---- code segment        代码段寄存器</span><br><span class="line">SS ---- stack segment       栈段寄存器</span><br><span class="line">DS ---- data segment        数据段寄存器</span><br><span class="line">FS ---- segment part 2      没有名称</span><br><span class="line">GS ---- segment part 3      没有名称</span><br></pre></td></tr></table></figure><h2 id="3-CPU和内存"><a href="#3-CPU和内存" class="headerlink" title="3. CPU和内存"></a>3. CPU和内存</h2><ul><li>CPU寄存器很少，32位也只有44个字节的空间，所以需要内存当<strong>外部储存器</strong></li><li>内存和CPU使用管脚连接，速度虽然光速，但是比起来内部寄存器还是慢很多</li><li>程序代码储存在内存中，一条一条读取出来进行运行</li><li><code>0xf0000</code>附近存在bios本身</li><li>启动区内容的装载地址为<code>0x00007c00 -- 0x00007dff</code>，为IBM和intel规定的。所以ORG指令选择此处为起始地址，也仅有512字节</li></ul><h2 id="4-Makefile编写"><a href="#4-Makefile编写" class="headerlink" title="4. Makefile编写"></a>4. Makefile编写</h2><ul><li><code>ipl.S</code>是启动时最先执行的代码，需要编译到软盘镜像的第一个分区</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">all: img</span></span><br><span class="line"></span><br><span class="line"><span class="section">boot:</span></span><br><span class="line">	nasm -w-zeroing -o bootloader ipl.S</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成img文件</span></span><br><span class="line"><span class="comment">#   将ipl.S的512B内容写入到软盘镜像的C0-H0-S1的位置，用于启动扇区</span></span><br><span class="line"><span class="comment">#   剩余需要将软盘扩容到2880个扇区，也就是1440KB</span></span><br><span class="line"><span class="section">img: boot</span></span><br><span class="line">	dd if=bootloader of=haribote.img count=1 bs=512</span><br><span class="line">	dd if=/dev/zero of=haribote.img bs=512 seek=1 skip=1 count=2879</span><br><span class="line"></span><br><span class="line">run :</span><br><span class="line">	qemu-system-x86_64 -enable-kvm -m 4G -smp 1 -fda haribote.img</span><br><span class="line"></span><br><span class="line">clean :</span><br><span class="line">	rm -f bootloader haribote.img</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="第3天-进入32位模式并导入C语言"><a href="#第3天-进入32位模式并导入C语言" class="headerlink" title="第3天 进入32位模式并导入C语言"></a>第3天 进入32位模式并导入C语言</h1><h2 id="1-软盘构成"><a href="#1-软盘构成" class="headerlink" title="1. 软盘构成"></a>1. 软盘构成</h2><img src="2019_06_14_01.bmp" width="60%"><ul><li>一面80个柱面</li><li>磁盘有两面</li><li>每个柱面18个扇区</li><li>一个扇区512字节</li><li>一共80 * 2 * 18 * 512 &#x3D; 1474560 Byte &#x3D; 1440 KB</li><li><code>C0-H0-S1</code>代表柱面0，磁头0，扇区1</li><li>扇区从1开始计数，柱面从0开始计数</li></ul><h3 id="1-软盘保存文件"><a href="#1-软盘保存文件" class="headerlink" title="(1) 软盘保存文件"></a>(1) 软盘保存文件</h3><p>参考 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/pacoson/p/4816614.html">制作FAT12软盘以查看软盘的根目录条目+文件属性+文件内容</a></p><ul><li>使用命令保存二进制到软盘中</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成img文件</span></span><br><span class="line"><span class="comment">#   将ipl.S的512B内容写入到软盘镜像的C0-H0-S1的位置，用于启动扇区</span></span><br><span class="line"><span class="comment">#   剩余需要将软盘扩容到2880个扇区，也就是1440KB</span></span><br><span class="line"><span class="comment">#   将编译出来的二进制放到软盘里面，也就放到了0x4400的位置</span></span><br><span class="line"><span class="section">img: bootloader kernel</span></span><br><span class="line">	dd if=bootloader.bin of=haribote.img count=1 bs=512 &amp;&gt;/dev/null</span><br><span class="line">	dd if=/dev/zero of=haribote.img bs=512 seek=1 skip=1 count=2879 &amp;&gt;/dev/null</span><br><span class="line">	mkdir -p ./floppy</span><br><span class="line">	mount -o loop haribote.img ./floppy -o fat=12</span><br><span class="line">	sleep 1</span><br><span class="line">	cp kernel ./floppy</span><br><span class="line">	sleep 1</span><br><span class="line">	umount ./floppy</span><br><span class="line">	rm -rf ./floppy</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">=&gt; hexdump -C haribote.img</span><br><span class="line">00000000  eb 4e 90 48 45 4c 4c 4f  49 50 4c 00 02 01 01 00  |.N.HELLOIPL.....|</span><br><span class="line">00000010  02 e0 00 40 0b f0 09 00  12 00 02 00 00 00 00 00  |...@............|</span><br><span class="line">00000020  40 0b 00 00 00 00 29 ff  ff ff ff 48 41 52 49 42  |@.....)....HARIB|</span><br><span class="line">00000030  4f 54 45 4f 53 20 46 41  54 31 32 20 20 20 00 00  |OTEOS FAT12   ..|</span><br><span class="line">00000040  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">00000050  b8 00 00 8e d0 bc 00 7c  8e d8 b8 20 08 8e c0 b5  |.......|... ....|</span><br><span class="line">00000060  00 b6 00 b1 02 be 00 00  b4 02 b0 01 bb 00 00 b2  |................|</span><br><span class="line">00000070  00 cd 13 73 10 83 c6 01  83 fe 05 73 32 b4 00 b2  |...s.......s2...|</span><br><span class="line">00000080  00 cd 13 eb e3 8c c0 83  c0 20 8e c0 80 c1 01 80  |......... ......|</span><br><span class="line">00000090  f9 12 76 d1 b1 01 80 c6  01 80 fe 02 72 c7 b6 00  |..v.........r...|</span><br><span class="line">000000a0  80 c5 01 80 fd 0a 72 bd  88 2e f0 0f e9 51 45 be  |......r......QE.|</span><br><span class="line">000000b0  c7 7c 8a 04 83 c6 01 3c  00 74 09 b4 0e bb 0f 00  |.|.....&lt;.t......|</span><br><span class="line">000000c0  cd 10 eb ee f4 eb fd 0a  0a 4c 6f 61 64 20 65 72  |.........Load er|</span><br><span class="line">000000d0  72 6f 72 0a 00 00 00 00  00 00 00 00 00 00 00 00  |ror.............|</span><br><span class="line">000000e0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">*</span><br><span class="line">000001f0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 55 aa  |..............U.|</span><br><span class="line">00000200  00 00 00 00 f0 ff 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">00000210  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">*</span><br><span class="line">00001400  00 00 00 00 f0 ff 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">00001410  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">*</span><br><span class="line">00002600  41 6b 00 65 00 72 00 6e  00 65 00 0f 00 0f 6c 00  |Ak.e.r.n.e....l.|</span><br><span class="line">00002610  00 00 ff ff ff ff ff ff  ff ff 00 00 ff ff ff ff  |................|</span><br><span class="line">00002620  4b 45 52 4e 45 4c 20 20  20 20 20 20 00 16 05 62  |KERNEL      ...b|</span><br><span class="line">00002630  23 59 23 59 00 00 05 62  23 59 03 00 39 01 00 00  |#Y#Y...b#Y..9...|</span><br><span class="line">00002640  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">*</span><br><span class="line">00004400  b0 13 b4 00 cd 10 c6 06  f2 0f 08 c7 06 f4 0f 40  |...............@|</span><br><span class="line">00004410  01 c7 06 f6 0f c8 00 66  c7 06 f8 0f 00 00 0a 00  |.......f........|</span><br><span class="line">00004420  b4 02 cd 16 a2 f1 0f be  5a c4 e8 50 00 b0 ff e6  |........Z..P....|</span><br><span class="line">00004430  21 90 e6 21 fa e8 d0 00  b0 d1 e6 64 e8 c9 00 b0  |!..!.......d....|</span><br><span class="line">00004440  df e6 60 e8 c2 00 0f 01  16 30 c5 0f 20 c0 66 83  |..`......0.. .f.|</span><br><span class="line">00004450  c8 01 0f 22 c0 ea 90 c4  10 00 0a 0a 6b 65 72 6e  |...&quot;........kern|</span><br><span class="line">00004460  65 6c 20 69 73 20 6c 6f  61 64 69 6e 67 00 0a 0a  |el is loading...|</span><br><span class="line">00004470  74 72 79 20 69 74 20 61  67 61 69 6e 00 8a 04 83  |try it again....|</span><br><span class="line">00004480  c6 01 3c 00 74 09 b4 0e  bb 0f 00 cd 10 eb ee c3  |..&lt;.t...........|</span><br><span class="line">00004490  66 b8 08 00 8e d8 8e c0  8e e0 8e e8 8e d0 bc ff  |f...............|</span><br><span class="line">000044a0  ff 3f 00 be 36 c5 00 00  bf 00 00 28 00 b9 00 00  |.?..6......(....|</span><br><span class="line">000044b0  02 00 e8 41 00 00 00 be  00 7c 00 00 bf 00 00 10  |...A.....|......|</span><br><span class="line">000044c0  00 b9 80 00 00 00 e8 2d  00 00 00 be 00 82 00 00  |.......-........|</span><br><span class="line">000044d0  bf 00 02 10 00 8a 0d f0  0f 00 00 69 c9 00 12 00  |...........i....|</span><br><span class="line">000044e0  00 81 e9 80 00 00 00 e8  0c 00 00 00 ea 00 00 00  |................|</span><br><span class="line">000044f0  00 18 00 eb fe f4 eb fd  8b 06 83 c6 04 89 07 83  |................|</span><br><span class="line">00004500  c7 04 83 e9 01 75 f1 c3  e4 64 a8 02 75 fa c3 90  |.....u...d..u...|</span><br><span class="line">00004510  00 00 00 00 00 00 00 00  ff ff 00 00 00 92 cf 00  |................|</span><br><span class="line">00004520  ff ff 00 00 00 9a 47 00  ff ff 00 00 28 9a 47 00  |......G.....(.G.|</span><br><span class="line">00004530  1f 00 10 c5 00 00 f4 eb  fd 00 00 00 00 00 00 00  |................|</span><br><span class="line">00004540  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</span><br><span class="line">*</span><br><span class="line">00168000</span><br></pre></td></tr></table></figure><ul><li>文件名写在<code>0x0002600</code>的地方</li><li>文件内容写在<code>0x004400</code>的地方，这个和书本上的<code>0x004200</code>不太一样，linux上mount后写入文件就在<code>0x004400</code>位置</li><li>编译生成的第三阶段启动程序代码在<code>0x004400</code>位置</li></ul><h3 id="2-当前编译出来的软盘分布"><a href="#2-当前编译出来的软盘分布" class="headerlink" title="(2) 当前编译出来的软盘分布"></a>(2) 当前编译出来的软盘分布</h3><ul><li><code>C0-H0-S1</code>: IPL启动区位于此扇区，操作系统启动时会自动装载到<code>0x7c00-0x7dff</code>，这个是iIBM和intel规定的默认行为</li><li><code>booloader.S + header.S</code>编译出来的<code>kernel</code>保存在软盘的<code>0x004400</code></li></ul><h2 id="2-内存寻址"><a href="#2-内存寻址" class="headerlink" title="2. 内存寻址"></a>2. 内存寻址</h2><ul><li><code>ES : BX</code>代表内存寻址的地址，其中BX为0-3位，ES为4-位。如<code>ES=0x0820，BX=0，代表0x8200地址</code>。总内存为12位，1M左右。</li><li>内存<code>0x7c00-0x7dff</code>为启动区使用，<code>0x7e00-0x9fbff</code>没有什么用，留给操作系统开发使用</li><li>内存寻址需要指定段寄存器DS，不然就会加上其16倍的数据，所以一般DS &#x3D; 0</li></ul><h2 id="3-汇编和C语言链接"><a href="#3-汇编和C语言链接" class="headerlink" title="3. 汇编和C语言链接"></a>3. 汇编和C语言链接</h2><ul><li>使用汇编可以编译出<code>.obj</code>（<code>.o</code>）文件，这个文件和C文件编译出来的是一个效果</li><li>可以使用<code>objdump</code>来查看c语言生成的汇编指令代码</li><li>既然都是原生汇编，按照c语言生成的汇编格式来写汇编，同样可以链接到c语言中</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.code32</span><br><span class="line"></span><br><span class="line"># 定义全局符号，这个类似于C语言的export</span><br><span class="line">.global io_hlt</span><br><span class="line"></span><br><span class="line"># 指定.text段</span><br><span class="line">.section .text</span><br><span class="line"></span><br><span class="line"># 函数实现</span><br><span class="line">io_hlt:</span><br><span class="line">    hlt</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><h2 id="4-BIOS介绍"><a href="#4-BIOS介绍" class="headerlink" title="4. BIOS介绍"></a>4. BIOS介绍</h2><ul><li>BIOS是使用16位机器语言，32位模式不能调用BIOS函数</li><li>VRAM（video RAM）在当前画面模式下是<code>0xa0000 ~ 0xaffff</code>，这个是在BIOS文档中<code>INT 0x10</code>说明最后写着</li></ul><h3 id="1-BIOS函数"><a href="#1-BIOS函数" class="headerlink" title="1) BIOS函数"></a>1) BIOS函数</h3><h4 id="1-0x10-设置画面模式"><a href="#1-0x10-设置画面模式" class="headerlink" title="(1) 0x10 设置画面模式"></a>(1) 0x10 设置画面模式</h4><ul><li>设置AH寄存器为00</li><li>设置AL寄存器为下面的值（省略部分模式）<ul><li>0x03: 16色字符模式，80 x 25</li><li>0x12: VGA图形模式，640 x 480 x 4位彩色模式，独特的4面储存模式</li><li>0x13: VGA图形模式，320 x 200 x 8位彩色模式，调色板模式</li><li>0x12: VGA图形模式，800 x 600 x 4位彩色模式，独特的4面储存模式（部分显卡不支持此模式）</li></ul></li><li>无返回值</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">; 设置屏幕模式</span><br><span class="line">MOV		AL,0x13			; VGA图形，320 x 200 x 8位颜色</span><br><span class="line">MOV		AH,0x00</span><br><span class="line">INT		0x10</span><br></pre></td></tr></table></figure><h2 id="5-cpu介绍"><a href="#5-cpu介绍" class="headerlink" title="5. cpu介绍"></a>5. cpu介绍</h2><ul><li>为什么写程序使用<code>i486p</code>，这个是cpu指令集</li><li>i486p是给486cpu使用，但是如果只是用16位寄存器，也可以8086用</li><li>intel系列cpu家谱</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8086-&gt;80186-&gt;286-&gt;386-&gt;486-&gt;Pentium-&gt;PentiumPro-&gt;PentiumII-&gt;PentiumIII-&gt;Pentium4-&gt;...</span><br></pre></td></tr></table></figure><ul><li>到286为止是16位cpu，386之后为32位</li></ul><h2 id="6-内存重新分配"><a href="#6-内存重新分配" class="headerlink" title="6. 内存重新分配"></a>6. 内存重新分配</h2><ul><li>引入C语言后，代码编译出的大小越来越大，之前的空间不足。32位模式下可用内存达到4G，重新将磁盘上的代码拷贝到内存新的地址中。</li><li>选择0x00100000为软盘拷贝的首地址</li><li>选择0x00280000为c语言代码开始位置</li><li>选择0x002fffff-0x003fffff为c语言栈的大小，栈设定为1MB。esp从c语言开始赋值为0x003fffff（栈顶是高地址，栈底为低地址）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">; header.S文件节选</span><br><span class="line"># 栈起始位置，共1MB。0x002fffff-0x003fffff</span><br><span class="line">#define STACK    0x003fffff</span><br><span class="line"># C语言代码所在内存位置</span><br><span class="line">#define C_CODE	0x00280000</span><br><span class="line"># 软盘数据所在内存位置</span><br><span class="line">#define	DISK_ADDR		0x00100000</span><br><span class="line"># 软盘数据所在内存位置（真实模式）</span><br><span class="line">#define DISK_ADDR_REAL	0x00008000</span><br><span class="line">...</span><br><span class="line">	# 拷贝c代码到内存中</span><br><span class="line">	movl	$start_kernel,%esi		# 源地址</span><br><span class="line">	movl	$C_CODE,%edi			# 目的地址</span><br><span class="line">	movl	$(512*1024/4),%ecx		# 拷贝512K，注意后面的C语言编译超过512K就要修改这里</span><br><span class="line">	call	memcpy</span><br><span class="line"></span><br><span class="line">	# 拷贝软盘数据到内存对应位置</span><br><span class="line">	# 拷贝启动扇区</span><br><span class="line">	movl	$0x00007c00,%esi		# 源地址</span><br><span class="line">	movl	$DISK_ADDR,%edi			# 目的地址</span><br><span class="line">	movl	$(512/4),%ecx			# 拷贝512B</span><br><span class="line">	call	memcpy</span><br><span class="line">	# 拷贝剩余数据</span><br><span class="line">	movl	$(DISK_ADDR_REAL+512),%esi		# 源地址</span><br><span class="line">	movl	$(DISK_ADDR+512),%edi			# 目的地址</span><br><span class="line">	movb	(CYLS),%cl						# 把cyls地址内的值赋值给cl</span><br><span class="line">	# 将ecx乘上512*8*2/4，cyls是bootloader读取的软盘中柱面数，一个柱面18个磁道，一个磁道2个扇区，一个扇区512B</span><br><span class="line">	imul	$(512*18*2/4),%ecx</span><br><span class="line">	subl	$(512/4),%ecx					# 去除启动扇区</span><br><span class="line">	call	memcpy</span><br><span class="line"></span><br><span class="line">	# 调用c语言第一个指令，位置是第3个段的首地址</span><br><span class="line">	ljmp	$(3*8),$0x0000</span><br><span class="line">...</span><br><span class="line">start_kernel:</span><br></pre></td></tr></table></figure><ul><li>由于makefile中是直接将<code>cobjs</code>加到<code>hader</code>后面的，所以在<code>header.S</code>后面的<code>start_kernel</code>就是c语言的起始位置</li></ul><h2 id="7-makefile解释"><a href="#7-makefile解释" class="headerlink" title="7. makefile解释"></a>7. makefile解释</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">INCLUDE = -I<span class="variable">$(TOOLPATH)</span>/haribote/ -I./<span class="keyword">include</span>/ -I./arch/x86/<span class="keyword">include</span>/ -I./arch/x86/<span class="keyword">include</span>/uapi/ -I.</span><br><span class="line">CFLAGS  = -Wall -Werror -Wno-int-to-pointer-cast -Wno-unused</span><br><span class="line"><span class="comment"># -fno-pie 生成位置相关代码，位置无关代码暂时不清楚为什么会运行有问题，访问全局变量失败导致调色板设置有问题</span></span><br><span class="line"><span class="comment"># -fno-stack-protector gcc默认会添加栈安全检查，但是这个会依赖glibc的库，导致undefined reference to `__stack_chk_fail&#x27;的问题</span></span><br><span class="line">CFLAGS += -MD -Os -fno-pie -nostdinc -nostdlib -fno-builtin -fno-stack-protector -fno-omit-frame-pointer -D_SIZE_T -DCONFIG_X86_32 -m32</span><br><span class="line">LDFLAGS	= -m elf_i386 -no-pie</span><br><span class="line"></span><br><span class="line"><span class="section">all: img</span></span><br><span class="line"></span><br><span class="line">bootloader : bootloader.S</span><br><span class="line">	nasm -w-zeroing -o <span class="variable">$@</span>.bin <span class="variable">$@</span>.S</span><br><span class="line"></span><br><span class="line"><span class="comment">#下面四个命令通过模式匹配获取当前目录下的所有C文件</span></span><br><span class="line">SRCDIR = ./ ./lib/ ./init/</span><br><span class="line"></span><br><span class="line">C_SOURCES = <span class="variable">$(<span class="built_in">foreach</span> d,<span class="variable">$(SRCDIR)</span>,$(<span class="built_in">wildcard</span> <span class="variable">$(d)</span>*.c)</span>)</span><br><span class="line">C_OBJS = <span class="variable">$(<span class="built_in">patsubst</span> %.c,%.o,<span class="variable">$(C_SOURCES)</span>)</span></span><br><span class="line">C_DEPS = <span class="variable">$(<span class="built_in">patsubst</span> %.c,%.d,<span class="variable">$(C_SOURCES)</span>)</span></span><br><span class="line"></span><br><span class="line">%.o : %.c</span><br><span class="line">	gcc <span class="variable">$(INCLUDE)</span> <span class="variable">$(CFLAGS)</span> -c -o <span class="variable">$*</span>.o <span class="variable">$*</span>.c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成img文件</span></span><br><span class="line"><span class="comment">#   将ipl.S的512B内容写入到软盘镜像的C0-H0-S1的位置，用于启动扇区</span></span><br><span class="line"><span class="comment">#   剩余需要将软盘扩容到2880个扇区，也就是1440KB</span></span><br><span class="line"><span class="comment">#   将编译出来的二进制放到软盘里面，也就放到了0x4400的位置</span></span><br><span class="line"><span class="section">img: bootloader kernel</span></span><br><span class="line">	dd if=bootloader.bin of=haribote.img count=1 bs=512 &amp;&gt;/dev/null</span><br><span class="line">	dd if=/dev/zero of=haribote.img bs=512 seek=1 skip=1 count=2879 &amp;&gt;/dev/null</span><br><span class="line">	mkdir -p ./floppy</span><br><span class="line">	mount -o loop haribote.img ./floppy -o fat=12</span><br><span class="line">	sleep 1</span><br><span class="line">	cp kernel ./floppy</span><br><span class="line">	sleep 1</span><br><span class="line">	umount ./floppy</span><br><span class="line">	rm -rf ./floppy</span><br><span class="line"></span><br><span class="line"><span class="section">kernel: header cobjs</span></span><br><span class="line">	cat cobjs &gt;&gt; header</span><br><span class="line">	cp header kernel</span><br><span class="line"></span><br><span class="line"><span class="comment"># kernel存在软盘的0x4400，拷贝到0x8000后就是0xc400</span></span><br><span class="line"><span class="comment"># header.S启动从bootsect_start开始</span></span><br><span class="line"><span class="comment"># header.S只能保留text段，因为cobjs在header.S最后面，多了段会导致拷贝磁盘出现偏移问题</span></span><br><span class="line"><span class="section">header: header.S</span></span><br><span class="line">	gcc <span class="variable">$(INCLUDE)</span> <span class="variable">$(CFLAGS)</span> -c -o <span class="variable">$@</span>.bin <span class="variable">$&lt;</span></span><br><span class="line">	ld <span class="variable">$(LDFLAGS)</span> -N -e bootsect_start -Ttext 0xc400 -o <span class="variable">$@</span>.out <span class="variable">$@</span>.bin</span><br><span class="line">	objdump -S -D <span class="variable">$@</span>.out &gt; <span class="variable">$@</span>.asm</span><br><span class="line">	objcopy -S -O binary -j .text <span class="variable">$@</span>.out <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">asmfunc.o: asmfunc.S</span></span><br><span class="line">	gcc <span class="variable">$(INCLUDE)</span> <span class="variable">$(CFLAGS)</span> -c -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># c语言起始函数为start_kernel</span></span><br><span class="line"><span class="section">cobjs: <span class="variable">$(C_OBJS)</span> asmfunc.o</span></span><br><span class="line">	ld <span class="variable">$(LDFLAGS)</span> -N -T cobjs.ld -o <span class="variable">$@</span>.out <span class="variable">$^</span></span><br><span class="line">	objdump -S -D <span class="variable">$@</span>.out &gt; <span class="variable">$@</span>.asm</span><br><span class="line">	objcopy -S -O binary <span class="variable">$@</span>.out <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line">run :</span><br><span class="line">	qemu-system-x86_64 -enable-kvm -m 4G -smp 1 -fda haribote.img</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f kernel</span><br><span class="line">	rm -f cobjs cobjs.out cobjs.asm</span><br><span class="line">	rm -f header header.bin header.out header.asm</span><br><span class="line">	rm -f bootloader.bin haribote.img</span><br><span class="line">	rm -f <span class="variable">$(C_OBJS)</span> <span class="variable">$(C_DEPS)</span></span><br><span class="line">	rm -f *.o *.d *.bin *.asm *.out</span><br></pre></td></tr></table></figure><ul><li>我们需要让<code>start_kernel</code>在cobjs的<code>.text</code>段第一个，有两个方案<ol><li>将main.o在链接的时候放到第一个位置，需要在main.c中唯一</li><li>使用<code>.text.first</code>配合ld链接配置文件实现</li></ol></li><li>这里使用第二个方案</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HariMain</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __attribute__((<span class="built_in">section</span>(<span class="string">&quot;.text.first&quot;</span>))) <span class="built_in">start_kernel</span>(<span class="type">void</span>) &#123;</span><br><span class="line">    <span class="built_in">HariMain</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>对应的<code>cobjs.ld</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(start_kernel)</span><br><span class="line"></span><br><span class="line">SECTIONS &#123;</span><br><span class="line">    . = 0x00280000;</span><br><span class="line">	.text :  &#123;</span><br><span class="line">		*(.text.first)</span><br><span class="line">        *(.text)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="第4天-C语言与画面显示的练习"><a href="#第4天-C语言与画面显示的练习" class="headerlink" title="第4天 C语言与画面显示的练习"></a>第4天 C语言与画面显示的练习</h1><h2 id="1-图形化界面"><a href="#1-图形化界面" class="headerlink" title="1. 图形化界面"></a>1. 图形化界面</h2><p>参考<a href="/blogs/2021-03-22-linux-kernel">linux-kernel启动过程</a></p><h2 id="2-调色板"><a href="#2-调色板" class="headerlink" title="2. 调色板"></a>2. 调色板</h2><ul><li>调色板是显卡的一个模块，由于颜色只有8位，也就是256色，但是正常RGB有24位</li><li>所以我们可以给显卡设置256种颜色，0-255分别表示一种颜色</li><li><strong><font color="red">在用的时候直接设置对应内存为一个号码，显卡就会直接将对应位置显示成对应的颜色</font></strong></li><li>但是cpu中断和调色板的io存取需要使用汇编来实现，c语言无法实现</li></ul><p><strong>设置调色板</strong></p><ul><li>先屏蔽中断</li><li>将想要设置的号码（0-255）写入到<code>0x03c8</code></li><li>然后按照RGB的顺序写入<code>0x03c9</code>，想要继续设定，就直接继续写就行了</li><li>想要读出来对应号码的RGB，将号码写入到<code>0x03c7</code>，再从<code>0x03c9</code>读取3次。同理继续读就是下一个号码</li><li>最后恢复中断位</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_palette</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end, <span class="type">unsigned</span> <span class="type">char</span> *rgb)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i, eflags;</span><br><span class="line">    eflags = <span class="built_in">io_load_eflags</span>(); <span class="comment">/* 记录终端许可标志的值 */</span></span><br><span class="line">    <span class="built_in">io_cli</span>();                  <span class="comment">/* 将许可标志置0，禁止中断 */</span></span><br><span class="line">    <span class="built_in">io_out8</span>(<span class="number">0x03c8</span>, start);</span><br><span class="line">    <span class="keyword">for</span> (i = start; i &lt;= end; i++) &#123;</span><br><span class="line">        <span class="built_in">io_out8</span>(<span class="number">0x03c9</span>, rgb[<span class="number">0</span>] / <span class="number">4</span>);    <span class="comment">// R</span></span><br><span class="line">        <span class="built_in">io_out8</span>(<span class="number">0x03c9</span>, rgb[<span class="number">1</span>] / <span class="number">4</span>);    <span class="comment">// G</span></span><br><span class="line">        <span class="built_in">io_out8</span>(<span class="number">0x03c9</span>, rgb[<span class="number">2</span>] / <span class="number">4</span>);    <span class="comment">// B</span></span><br><span class="line">        rgb += <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">io_store_eflags</span>(eflags); <span class="comment">/* 恢复许可标志 */</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-速度问题"><a href="#3-速度问题" class="headerlink" title="3. 速度问题"></a>3. 速度问题</h2><p>运行起来后，要显示有颜色的画面一直是黑屏。等待了几分钟后才显示预期画面，差点以为代码有bug。不过这么慢也是个bug</p><p>排查了很久发现，原始makefile编译出来的其实是64位的c程序，运行的时候特别慢，应该是不兼容导致的。修改了makefile的cflags和ldflags后就运行特别快了。之前就算导入了c语言，也只是hlt，看不出效果，所以没有发现</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CFLAGS += -m32</span><br><span class="line">LDFLAGS	= -m elf_i386</span><br></pre></td></tr></table></figure><h2 id="4-使用c语言遇到的几个问题"><a href="#4-使用c语言遇到的几个问题" class="headerlink" title="4. 使用c语言遇到的几个问题"></a>4. 使用c语言遇到的几个问题</h2><ul><li>switch不能超过5个case，否则会出问题，不清楚为什么</li><li>while中不能使用i–，不清楚为什么</li></ul><h1 id="第5天-结构体、文字显示与GDT-IDT初始化"><a href="#第5天-结构体、文字显示与GDT-IDT初始化" class="headerlink" title="第5天 结构体、文字显示与GDT&#x2F;IDT初始化"></a>第5天 结构体、文字显示与GDT&#x2F;IDT初始化</h1><h2 id="1-字符点阵"><a href="#1-字符点阵" class="headerlink" title="1. 字符点阵"></a>1. 字符点阵</h2><ul><li>假设一个字符占用像素点为8x16，那么可以使用<code>char[16]</code>表示一个字符的点阵</li><li>作者找其他人要了一个<code>hankaku.txt</code>里面包含了<code>char</code>里面所有可见字符的点阵，总共由256个字符，占用4096个字节</li><li>在对应的vram位置设置color就可以直接显示字符</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由hankaku.txt编译而来</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> hankaku[<span class="number">4096</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 输入一个字符</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param vram 显示内存起始位置</span></span><br><span class="line"><span class="comment"> * @param xsize 屏幕的宽度，因为要换行显示，需要知道宽度</span></span><br><span class="line"><span class="comment"> * @param x 位置x</span></span><br><span class="line"><span class="comment"> * @param y 位置y</span></span><br><span class="line"><span class="comment"> * @param color 字体颜色</span></span><br><span class="line"><span class="comment"> * @param c 字符</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">put_font8</span><span class="params">(<span class="type">char</span> *vram, <span class="type">int</span> xsize, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">char</span> color, <span class="type">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="type">char</span> *font8 = hankaku + c * <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">16</span>; ++i) &#123;</span><br><span class="line">        <span class="comment">// 找到对应行的最左边</span></span><br><span class="line">        <span class="type">char</span> *p = vram + (y + i) * xsize + x;</span><br><span class="line">        <span class="type">char</span> tmp = font8[i];</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">8</span>; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((tmp &amp; (<span class="number">0x80</span> &gt;&gt; j)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                p[j] = color;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-GDT和IDT"><a href="#2-GDT和IDT" class="headerlink" title="2. GDT和IDT"></a>2. GDT和IDT</h2><h3 id="2-1-分段"><a href="#2-1-分段" class="headerlink" title="2.1. 分段"></a>2.1. 分段</h3><ul><li>因为操作系统可以执行多个进程，但是每个进程使用的内存是独立的，需要使用分段让每个进程使用的内存隔开</li></ul><h3 id="2-2-GDT-global-segment-descriptor-table"><a href="#2-2-GDT-global-segment-descriptor-table" class="headerlink" title="2.2. GDT: global segment descriptor table"></a>2.2. GDT: global segment descriptor table</h3><ul><li>全局段记录表</li><li>段寄存器是16位，一位一个字节。一个段描述结构体是8个字节占用3位，所以低三位不能用，只有13位，一共8192个段描述结构体组成表</li><li>段寄存器可以指示65536个字节（64KB），cpu没这么大内存存储，所以需要放到内存里面，我们可以任意指定一块内存，将首地址和个数信息放到GDTR寄存器中就好了</li><li>段描述结构体见下面定义，来自于cpu手册，一共8个字节</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 8 byte segment descriptor */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">desc_struct</span> &#123;</span><br><span class="line">    u16 limit0;         <span class="comment">// 段管理的内存上限low</span></span><br><span class="line">    u16 base0;          <span class="comment">// 段的对应的内存实际地址low</span></span><br><span class="line">    u16 base1 : <span class="number">8</span>;      <span class="comment">// 段的对应的内存实际地址mid</span></span><br><span class="line">    u16 type : <span class="number">4</span>;</span><br><span class="line">    u16 s : <span class="number">1</span>;          <span class="comment">// 系统段为1，普通段为0</span></span><br><span class="line">    u16 dpl : <span class="number">2</span>;</span><br><span class="line">    u16 p : <span class="number">1</span>;</span><br><span class="line">    u16 limit1 : <span class="number">4</span>;     <span class="comment">// 段管理的内存上限low</span></span><br><span class="line">    u16 avl : <span class="number">1</span>;</span><br><span class="line">    u16 l : <span class="number">1</span>;</span><br><span class="line">    u16 d : <span class="number">1</span>;</span><br><span class="line">    u16 g : <span class="number">1</span>;          <span class="comment">// 为1就是4K为单位定义上限（上限1，管理内存4K），为0则以一个字节为单位</span></span><br><span class="line">    u16 base2 : <span class="number">8</span>;      <span class="comment">// 段的对应的内存实际地址high</span></span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure><ul><li>随意取内存一段地址 <code>0x00270000 - 0x0027ffff</code> 这一段存储</li><li>将所有段初始化成全0</li><li>将段号1设置位cpu管理段，在内存的地址为0，大小为4GB，为32位内管理的最大内存，可读可写</li><li>段号为3的设置为<code>kernel</code>程序所在的内存段，地址在0x00280000，大小512K，可读可执行</li><li>最后通过汇编导出的函数写入GDTR，因为c语言无法设置GDTR</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ADR_GDT 0x00270000       <span class="comment">// GDT的内存位置</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIMIT_GDT 0x0000ffff     <span class="comment">// GDT占用的字节数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADR_BOTPAK 0x00280000    <span class="comment">// kernel所在的地址</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIMIT_BOTPAK 0x0007ffff  <span class="comment">// kernel最大为512k</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AR_DATA32_RW 0x4092      <span class="comment">// 数据段，可读写</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AR_CODE32_ER 0x409a      <span class="comment">// 代码段，可读可执行，不可写</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">set_segmdesc</span><span class="params">(<span class="keyword">struct</span> SEGMENT_DESCRIPTOR *sd, <span class="type">unsigned</span> <span class="type">int</span> limit, <span class="type">int</span> base, <span class="type">int</span> ar)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (limit &gt; <span class="number">0xfffff</span>) &#123;</span><br><span class="line">        ar |= <span class="number">0x8000</span>; <span class="comment">/* G_bit = 1 */</span></span><br><span class="line">        limit /= <span class="number">0x1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sd-&gt;limit_low = limit &amp; <span class="number">0xffff</span>;</span><br><span class="line">    sd-&gt;base_low = base &amp; <span class="number">0xffff</span>;</span><br><span class="line">    sd-&gt;base_mid = (base &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">    sd-&gt;access_right = ar &amp; <span class="number">0xff</span>;</span><br><span class="line">    sd-&gt;limit_high = ((limit &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0x0f</span>) | ((ar &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xf0</span>);</span><br><span class="line">    sd-&gt;base_high = (base &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_gdtidt</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">SEGMENT_DESCRIPTOR</span> *gdt = (<span class="keyword">struct</span> SEGMENT_DESCRIPTOR *)ADR_GDT;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">GATE_DESCRIPTOR</span> *idt = (<span class="keyword">struct</span> GATE_DESCRIPTOR *)ADR_IDT;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化GDT</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; LIMIT_GDT / <span class="built_in">sizeof</span>(<span class="keyword">struct</span> SEGMENT_DESCRIPTOR); i++) &#123;</span><br><span class="line">        <span class="built_in">set_segmdesc</span>(gdt + i, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cpu管理的总内存</span></span><br><span class="line">    <span class="built_in">set_segmdesc</span>(gdt + <span class="number">1</span>, <span class="number">0xffffffff</span>, <span class="number">0x00000000</span>, AR_DATA32_RW);</span><br><span class="line">    <span class="comment">// c语言的段，C语言只能使用第3个段，使用第4个或第2个都会在中断里面崩溃，不知道为什么</span></span><br><span class="line">    <span class="built_in">set_segmdesc</span>(gdt + <span class="number">3</span>, LIMIT_BOTPAK, ADR_BOTPAK, AR_CODE32_ER);</span><br><span class="line">    <span class="built_in">load_gdtr</span>(LIMIT_GDT, ADR_GDT);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>对应汇编里面的实现</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 第0个段是空的，全部是0</span><br><span class="line"># 第1个段是数据段，cpu管理的总内存，从0x00000000开始，0x92代表可读可写，内存上限为0xfffff，g = 1代表4K为单位，4G</span><br><span class="line"># 	按照结构体和16位低位高位计算 0xffff, 0x0000, 0x9200, 0x00cf</span><br><span class="line"># 第2个段是代码段，启动区所在位置，从0x00000000开始，0x9a代表可读可执行，内存上限为0x7ffff，g = 0代表字节为单位，512K</span><br><span class="line"># 	按照结构体和16位低位高位计算 0xffff, 0x0000, 0x9a00, 0x0047</span><br><span class="line"># 第3个段是代码段，c代码所在位置，从0x00280000开始，0x9a代表可读可执行，内存上限为0x7ffff，g = 0代表字节为单位，512K</span><br><span class="line"># 	按照结构体和16位低位高位计算 0xffff, 0x0000, 0x9a28, 0x0047</span><br><span class="line">.p2align	2	# 按照2^2 = 4字节对齐</span><br><span class="line">gdt:</span><br><span class="line">	.word	0x0000,0x0000,0x0000,0x0000		# null seg</span><br><span class="line">	.word	0xffff,0x0000,0x9200,0x00cf		# 可读写的段，数据段</span><br><span class="line">	.word	0xffff,0x0000,0x9a00,0x0047		# 汇编代码所在内存位置</span><br><span class="line">	.word	0xffff,0x0000,0x9a28,0x0047		# 给c代码使用的段</span><br></pre></td></tr></table></figure><h3 id="2-3-IDT-interrupt-descriptor-table"><a href="#2-3-IDT-interrupt-descriptor-table" class="headerlink" title="2.3. IDT: interrupt descriptor table"></a>2.3. IDT: interrupt descriptor table</h3><ul><li>中断记录表，结构定义在cpu手册中</li></ul><img src="2022-10-24-01.png"><ul><li>代码定义的结构</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">idt_bits</span> &#123;</span><br><span class="line">    u16 ist : <span class="number">3</span>;</span><br><span class="line">    u16 zero : <span class="number">5</span>;</span><br><span class="line">    u16 type : <span class="number">5</span>;</span><br><span class="line">    u16 dpl : <span class="number">2</span>;    <span class="comment">// Descriptor Privilege Level</span></span><br><span class="line">    u16 p : <span class="number">1</span>;</span><br><span class="line">&#125; __attribute__((packed));</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">gate_struct</span> &#123;</span><br><span class="line">    u16 offset_low;         <span class="comment">// 函数在段内的偏移地址low</span></span><br><span class="line">    u16 segment;            <span class="comment">// 段配置对应的偏移，比如第2号段，就是 2 * 8，一个段配置8个字节</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">idt_bits</span> bits;</span><br><span class="line">    u16 offset_middle;      <span class="comment">// 函数在段内的偏移地址mid</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_X86_64</span></span><br><span class="line">    u32 offset_high;</span><br><span class="line">    u32 reserved;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure><h3 id="2-4-GDT、IDT、LDT和TSS的关系"><a href="#2-4-GDT、IDT、LDT和TSS的关系" class="headerlink" title="2.4. GDT、IDT、LDT和TSS的关系"></a>2.4. GDT、IDT、LDT和TSS的关系</h3><ul><li>GDT，IDT都是全局的。LDT是局部的（在GDT中有它的描述符）</li><li>GDT用来存储描述符（门或非门）；系统中几个CPU,就有几个GDT</li><li>IDT整个系统只有一个</li><li>系统启动时候需要初始化GDT和IDT。LDT和进程相关，并不一定必有</li><li>TSS: Task-State Segment，任务状态段，保存任务状态信息的系统段</li><li>TSS只能存在于GDT中</li><li>Task-Gate Descriptor，任务门描述符，用来保存和恢复任务的上下文信息。可以放到GDT、LDT、IDT中，里面的TSS段选择指向GDT的TSS描述符</li><li>下图为32位TSS结构</li></ul><img src="2022-10-24-03.png"><ul><li>下图为64位TSS结构</li></ul><img src="2022-10-24-02.png"><h1 id="第6天-中断处理"><a href="#第6天-中断处理" class="headerlink" title="第6天 中断处理"></a>第6天 中断处理</h1><h2 id="1-PIC-Programmable-interrupt-controller"><a href="#1-PIC-Programmable-interrupt-controller" class="headerlink" title="1. PIC: Programmable interrupt controller"></a>1. PIC: Programmable interrupt controller</h2><ul><li>可编程中断控制器</li><li>就是一个芯片，将8个中断信号合成一个中断信号输出给cpu</li><li>当前电脑上不止8个外部设备，所以使用两个pic合并成15个中断信号（主PIC的IRQ2被从PIC占据）</li></ul><img src="2022-10-23-01.png"><ul><li>PIC是外部设备，不能直接使用C语言的等于赋值，需要使用<code>io_out8</code></li><li>主从PIC的寄存器赋值需要使用端口进行，具体端口定义如下</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PIC0_ICW1 0x0020    <span class="comment">// initial controlword，初始化控制数据。用于设置中断的模式，0x11为边沿触发</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC0_OCW2 0x0020    <span class="comment">// 用于通知PIC已经收到某中断，0x60+IRQ号即可，IRQ1就是0x61</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC0_IMR 0x0021     <span class="comment">// interrupt maskregister，中断屏蔽寄存器，8位对应8路中断信号，为1就屏蔽</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC0_ICW2 0x0021    <span class="comment">// 中断号的起始，设置为0x20，0-7号IRQ触发的中断号为0x20-0x27</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC0_ICW3 0x0021    <span class="comment">// 控制主从设定，第几位为1就代表几号IRQ和从PIC相连，当前cpu写死使用0x00000100，也就是IRQ2</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC0_ICW4 0x0021    <span class="comment">// 用于设置中断模式，0x01为无缓冲区模式</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC1_ICW1 0x00a0    <span class="comment">// 用于设置中断的模式，0x11为边沿触发</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC1_OCW2 0x00a0    <span class="comment">// 用于通知PIC已经收到某中断，设置这个同时也要设置PIC0_OCW2，0x62</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC1_IMR 0x00a1     <span class="comment">// interrupt maskregister，中断屏蔽寄存器，8位对应8路中断信号，为1就屏蔽</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC1_ICW2 0x00a1    <span class="comment">// 中断号的起始，设置为0x28，0-7号IRQ（对应主PIC的8-15号IRQ）触发的中断号为0x28-0x2f</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC1_ICW3 0x00a1    <span class="comment">// 仅用低3位表示和主设备的几号IRQ相连，当前写死为2，为主PIC的IRQ2</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC1_ICW4 0x00a1    <span class="comment">// 用于设置中断模式，0x01为无缓冲区模式</span></span></span><br></pre></td></tr></table></figure><ul><li><code>0x00-0x1f</code>中断号不能使用，是cpu内部用于产生错误的中断号，所以从0x20开始</li><li>设置PIC的代码如下</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_pic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">io_out8</span>(PIC0_IMR, <span class="number">0xff</span>);  <span class="comment">// 禁止所有中断</span></span><br><span class="line">    <span class="built_in">io_out8</span>(PIC1_IMR, <span class="number">0xff</span>);  <span class="comment">// 禁止所有中断</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">io_out8</span>(PIC0_ICW1, <span class="number">0x11</span>);    <span class="comment">// 边沿触发模式</span></span><br><span class="line">    <span class="built_in">io_out8</span>(PIC0_ICW2, <span class="number">0x20</span>);    <span class="comment">// IRQ0-7由INT20-27接收</span></span><br><span class="line">    <span class="built_in">io_out8</span>(PIC0_ICW3, <span class="number">1</span> &lt;&lt; <span class="number">2</span>);  <span class="comment">// PIC1由IRQ2连接</span></span><br><span class="line">    <span class="built_in">io_out8</span>(PIC0_ICW4, <span class="number">0x01</span>);    <span class="comment">// 无缓冲区模式</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">io_out8</span>(PIC1_ICW1, <span class="number">0x11</span>);    <span class="comment">// 边沿触发模式</span></span><br><span class="line">    <span class="built_in">io_out8</span>(PIC1_ICW2, <span class="number">0x28</span>);    <span class="comment">// IRQ8-15由INT28-2f接收</span></span><br><span class="line">    <span class="built_in">io_out8</span>(PIC1_ICW3, <span class="number">1</span> &lt;&lt; <span class="number">1</span>);  <span class="comment">// PIC1由IRQ2连接</span></span><br><span class="line">    <span class="built_in">io_out8</span>(PIC1_ICW4, <span class="number">0x01</span>);    <span class="comment">// 无缓冲区模式</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">io_out8</span>(PIC0_IMR, <span class="number">0xfb</span>);  <span class="comment">// 11111011 PIC1以外全部禁止</span></span><br><span class="line">    <span class="built_in">io_out8</span>(PIC1_IMR, <span class="number">0xff</span>);  <span class="comment">// 禁止所有中断</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-中断号对应的中断类型"><a href="#2-中断号对应的中断类型" class="headerlink" title="2. 中断号对应的中断类型"></a>2. 中断号对应的中断类型</h2><table><thead><tr><th>硬件中断号</th><th>系统中断号</th><th>用途</th></tr></thead><tbody><tr><td>IRQ0</td><td>INT20</td><td></td></tr><tr><td>IRQ1</td><td>INT21</td><td>PS&#x2F;2键盘</td></tr><tr><td>IRQ2</td><td>INT22</td><td>PIC1的中断</td></tr><tr><td>IRQ3</td><td>INT23</td><td></td></tr><tr><td>IRQ4</td><td>INT24</td><td></td></tr><tr><td>IRQ5</td><td>INT25</td><td></td></tr><tr><td>IRQ6</td><td>INT26</td><td></td></tr><tr><td>IRQ7</td><td>INT27</td><td>初始化PIC可能引发的中断</td></tr><tr><td>IRQ8</td><td>INT28</td><td></td></tr><tr><td>IRQ9</td><td>INT29</td><td></td></tr><tr><td>IRQ10</td><td>INT2a</td><td></td></tr><tr><td>IRQ11</td><td>INT2b</td><td></td></tr><tr><td>IRQ12</td><td>INT2c</td><td>PS&#x2F;2鼠标</td></tr><tr><td>IRQ13</td><td>INT2d</td><td></td></tr><tr><td>IRQ14</td><td>INT2e</td><td></td></tr><tr><td>IRQ15</td><td>INT2f</td><td></td></tr></tbody></table><h2 id="3-注册中断函数"><a href="#3-注册中断函数" class="headerlink" title="3. 注册中断函数"></a>3. 注册中断函数</h2><ul><li>也就是将中断函数地址写入idt中</li><li>找到对应中断号对应的idt地址，将函数地址和对应的段号放进去，设置标志位即可</li><li>由于中断最终要调用IRETD汇编指令退出，所以使用汇编函数调用c函数的方式来进行，并在里面存储了中断打断的进程的上下文信息</li><li>gcc链接的时候，已经指定了地址在0x00280000，所有函数在汇编代码中就是真实地址（0x00280000后面），在汇编启动时拷贝到0x00280000，其他c代码实际使用就是这个地址，但是对于cpu来说，不关注是否拷贝到内存的哪个位置，只关注段内偏移，所以idt中设置的是在段中的偏移，这里需要减去ADR_BOTPAK</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册中断处理函数</span></span><br><span class="line"><span class="built_in">set_gatedesc</span>(idt + <span class="number">0x21</span>, (<span class="type">int</span>)asm_inthandler21-ADR_BOTPAK, <span class="number">3</span> * <span class="number">8</span>, AR_INTGATE32);</span><br><span class="line"><span class="built_in">set_gatedesc</span>(idt + <span class="number">0x27</span>, (<span class="type">int</span>)asm_inthandler27-ADR_BOTPAK, <span class="number">3</span> * <span class="number">8</span>, AR_INTGATE32);</span><br><span class="line"><span class="built_in">set_gatedesc</span>(idt + <span class="number">0x2c</span>, (<span class="type">int</span>)asm_inthandler2c-ADR_BOTPAK, <span class="number">3</span> * <span class="number">8</span>, AR_INTGATE32);</span><br></pre></td></tr></table></figure><h2 id="4-中断处理"><a href="#4-中断处理" class="headerlink" title="4. 中断处理"></a>4. 中断处理</h2><ul><li>中断中尽可能少执行代码，所以将中断数据放到全局变量中，在外部进程上下文中读取变量进行处理</li></ul><h1 id="第7天-FIFO与鼠标控制"><a href="#第7天-FIFO与鼠标控制" class="headerlink" title="第7天 FIFO与鼠标控制"></a>第7天 FIFO与鼠标控制</h1><h2 id="1-鼠标键盘数据读取"><a href="#1-鼠标键盘数据读取" class="headerlink" title="1. 鼠标键盘数据读取"></a>1. 鼠标键盘数据读取</h2><ul><li>鼠标键盘都属于键盘控制电路，数据获取都在端口<code>0x0060</code></li><li>只能通过中断号来判断此端口数据是属于鼠标还是键盘</li></ul><h2 id="2-fifo"><a href="#2-fifo" class="headerlink" title="2. fifo"></a>2. fifo</h2><ul><li>由于中断数据可能很多，所以需要使用fifo进行存取，防止数据丢失</li><li>fifo自己参考linux的实现，没有使用书上的实现，具体原理查看 <a href="/bookPages/docs/linux-kernel/data-structures/kfifo/">linux源码分析-kfifo</a></li></ul><h2 id="3-鼠标初始化"><a href="#3-鼠标初始化" class="headerlink" title="3. 鼠标初始化"></a>3. 鼠标初始化</h2><ul><li>由于一开始鼠标并不是必须品，后来鼠标才加入</li><li>鼠标加入后，当时使用者并不怎么使用，为了防止频繁中断，将鼠标控制默认关闭了</li><li>所以想要使用鼠标，需要先通过键盘控制电路设置模式启用鼠标，再进行特定操作进行激活鼠标</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PORT_KEYDAT 0x0060</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT_KEYSTA 0x0064</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT_KEYCMD 0x0064</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEYSTA_SEND_NOTREADY 0x02</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEYCMD_WRITE_MODE 0x60</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KBC_MODE 0x47   <span class="comment">// 鼠标模式</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 等待键盘控制器可以发送数据</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wait_KBC_sendready</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="built_in">io_in8</span>(PORT_KEYSTA) &amp; KEYSTA_SEND_NOTREADY) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 键盘控制器的初始化</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_keyboard</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">wait_KBC_sendready</span>();</span><br><span class="line">    <span class="built_in">io_out8</span>(PORT_KEYCMD, KEYCMD_WRITE_MODE);</span><br><span class="line">    <span class="built_in">wait_KBC_sendready</span>();</span><br><span class="line">    <span class="comment">// 设置模式使用鼠标</span></span><br><span class="line">    <span class="built_in">io_out8</span>(PORT_KEYDAT, KBC_MODE);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEYCMD_SENDTO_MOUSE 0xd4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOUSECMD_ENABLE 0xf4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 使能鼠标</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">enable_mouse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">wait_KBC_sendready</span>();</span><br><span class="line">    <span class="built_in">io_out8</span>(PORT_KEYCMD, KEYCMD_SENDTO_MOUSE);</span><br><span class="line">    <span class="built_in">wait_KBC_sendready</span>();</span><br><span class="line">    <span class="built_in">io_out8</span>(PORT_KEYDAT, MOUSECMD_ENABLE);</span><br><span class="line">    <span class="comment">// 如果成功，就会发送ACK(0xfa)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-使用linux的idt和gdt的实现"><a href="#4-使用linux的idt和gdt的实现" class="headerlink" title="4. 使用linux的idt和gdt的实现"></a>4. 使用linux的idt和gdt的实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/desc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/desc_defs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;asmfunc.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADR_IDT 0x0026f800       <span class="comment">// IDT的内存位置</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIMIT_IDT 0x000007ff     <span class="comment">// IDT占用的字节数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADR_GDT 0x00270000       <span class="comment">// GDT的内存位置</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIMIT_GDT 0x0000ffff     <span class="comment">// GDT占用的字节数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADR_BOTPAK 0x00280000    <span class="comment">// kernel所在的地址</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIMIT_BOTPAK 0x0000007f  <span class="comment">// kernel最大为4K x 128 = 512KB</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局gdt表</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">gdt_page</span> gdt_page = &#123;.gdt = &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_X86_64</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">                                             <span class="comment">// kernel的代码段，也就是bootpack所在位置</span></span><br><span class="line">                                             [GDT_ENTRY_KERNEL_CS] = <span class="built_in">GDT_ENTRY_INIT</span>(<span class="number">0xc09a</span>, ADR_BOTPAK, LIMIT_BOTPAK),</span><br><span class="line">                                             <span class="comment">// kernel控制的总内存大小</span></span><br><span class="line">                                             [GDT_ENTRY_KERNEL_DS] = <span class="built_in">GDT_ENTRY_INIT</span>(<span class="number">0xc092</span>, <span class="number">0</span>, <span class="number">0xfffff</span>),</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">                                         &#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DPL0 0x0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DPL3 0x3</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFAULT_STACK 0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> G(_vector, _addr, _ist, _type, _dpl, _segment) \</span></span><br><span class="line"><span class="meta">    &#123;                                                  \</span></span><br><span class="line"><span class="meta">        .vector = _vector,                             \</span></span><br><span class="line"><span class="meta">        .bits.ist = _ist,                              \</span></span><br><span class="line"><span class="meta">        .bits.type = _type,                            \</span></span><br><span class="line"><span class="meta">        .bits.dpl = _dpl,                              \</span></span><br><span class="line"><span class="meta">        .bits.p = 1,                                   \</span></span><br><span class="line"><span class="meta">        .addr = _addr,                                 \</span></span><br><span class="line"><span class="meta">        .segment = _segment,                           \</span></span><br><span class="line"><span class="meta">    &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Interrupt gate */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INTG(_vector, _addr) G(_vector, _addr, DEFAULT_STACK, GATE_INTERRUPT, DPL0, __KERNEL_CS)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* System interrupt gate */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SYSG(_vector, _addr) G(_vector, _addr, DEFAULT_STACK, GATE_INTERRUPT, DPL3, __KERNEL_CS)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// idt表</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">idt_data</span> idt_table[] = &#123;</span><br><span class="line">    <span class="comment">// gcc链接的时候，已经指定了地址在0x00280000，所有函数在汇编代码中就是真实地址（0x00280000后面）</span></span><br><span class="line">    <span class="comment">// 在汇编启动时拷贝到0x00280000，其他c代码实际使用就是这个地址</span></span><br><span class="line">    <span class="comment">// 但是对于cpu来说，不关注是否拷贝到内存的哪个位置，只关注段内偏移，所以idt中设置的是在段中的偏移</span></span><br><span class="line">    <span class="comment">// 这里需要减去ADR_BOTPAK</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// PS/2键盘中断</span></span><br><span class="line">    <span class="built_in">INTG</span>(<span class="number">0x21</span>, (<span class="type">int</span>)asm_inthandler21-ADR_BOTPAK),</span><br><span class="line">    <span class="comment">// 处理27中断</span></span><br><span class="line">    <span class="built_in">INTG</span>(<span class="number">0x27</span>, (<span class="type">int</span>)asm_inthandler27-ADR_BOTPAK),</span><br><span class="line">    <span class="comment">// PS/2鼠标中断</span></span><br><span class="line">    <span class="built_in">INTG</span>(<span class="number">0x2c</span>, (<span class="type">int</span>)asm_inthandler2c-ADR_BOTPAK),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_gdtidt</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化GDT</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">desc_struct</span> *gdt = (<span class="keyword">struct</span> desc_struct *)ADR_GDT;</span><br><span class="line">    <span class="comment">// C语言的段</span></span><br><span class="line">    <span class="built_in">write_gdt_entry</span>(gdt, GDT_ENTRY_KERNEL_CS, &amp;gdt_page.gdt[GDT_ENTRY_KERNEL_CS], DESCTYPE_S);</span><br><span class="line">    <span class="comment">// cpu管理的总内存</span></span><br><span class="line">    <span class="built_in">write_gdt_entry</span>(gdt, GDT_ENTRY_KERNEL_DS, &amp;gdt_page.gdt[GDT_ENTRY_KERNEL_DS], DESCTYPE_S);</span><br><span class="line">    <span class="comment">// 设置gdtr</span></span><br><span class="line">    <span class="built_in">load_gdtr</span>(LIMIT_GDT, ADR_GDT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化IDT</span></span><br><span class="line">    gate_desc *idt = (gate_desc *)ADR_IDT;</span><br><span class="line">    gate_desc desc = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">// 所有中断位置设置为空</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; LIMIT_IDT / <span class="built_in">sizeof</span>(gate_desc); i++) &#123;</span><br><span class="line">        <span class="built_in">write_idt_entry</span>(idt, i, &amp;desc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化要使用的中断</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">idt_data</span> *t = idt_table;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">ARRAY_SIZE</span>(idt_table); ++i, ++t) &#123;</span><br><span class="line">        <span class="built_in">idt_init_desc</span>(&amp;desc, t);</span><br><span class="line">        <span class="built_in">write_idt_entry</span>(idt, t-&gt;vector, &amp;desc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">load_idtr</span>(LIMIT_IDT, ADR_IDT);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不过发现了一个问题，gcc编译不能使用<code>-O1</code>，只能使用<code>-Os</code>，否则中断会崩溃</li></ul><h1 id="第8天-鼠标控制与32位模式切换"><a href="#第8天-鼠标控制与32位模式切换" class="headerlink" title="第8天 鼠标控制与32位模式切换"></a>第8天 鼠标控制与32位模式切换</h1><h2 id="1-鼠标数据解读"><a href="#1-鼠标数据解读" class="headerlink" title="1. 鼠标数据解读"></a>1. 鼠标数据解读</h2><ul><li>鼠标使能后会先发送<code>0xfa</code>数据，然后会连续三个中断发送三个字节数据</li></ul><h2 id="2-当前操作系统内存分布图"><a href="#2-当前操作系统内存分布图" class="headerlink" title="2. 当前操作系统内存分布图"></a>2. 当前操作系统内存分布图</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">0x00000000 - 0x000fffff: 启动中多次使用。（1MB）</span><br><span class="line">  - 0x00007c00 - 0x00007dff: 启动区装载地址，默认行为（512B）</span><br><span class="line">  - 0x00008000 - 0x000081ff: 预留磁盘的C0-H0-S1位置，好计算偏移量（512B）</span><br><span class="line">  - 0x00008200 - 0x00034fff: 磁盘上C0-H0-S2到C9-H1-S18读取位置（180KB）</span><br><span class="line">    - 0x0000c400 -         : 磁盘的0x4400位置的内容，asmhead.nas</span><br><span class="line">  - 0x000a0000 - 0x000affff: vram内存地址</span><br><span class="line">  - 0x000f0000 附近存在bios本身</span><br><span class="line">0x00100000 - 0x00267fff: 用于保存软盘内容。（1440KB）</span><br><span class="line">0x00268000 - 0x0026f7ff: 空（30KB）</span><br><span class="line">0x0026f800 - 0x0026ffff: IDT（2KB）</span><br><span class="line">0x00270000 - 0x0027ffff: GDT（64KB）</span><br><span class="line">0x00280000 - 0x002fffff: kernel（512KB）</span><br><span class="line">0x00300000 - 0x003fffff: 栈及其他（1MB）</span><br><span class="line">0x00400000 -           : 空</span><br></pre></td></tr></table></figure><h1 id="第9天-内存管理"><a href="#第9天-内存管理" class="headerlink" title="第9天 内存管理"></a>第9天 内存管理</h1><h2 id="1-禁用高速缓存"><a href="#1-禁用高速缓存" class="headerlink" title="1. 禁用高速缓存"></a>1. 禁用高速缓存</h2><ul><li>486之后的cpu存在高速缓存，如果代码上设置一个内存立刻使用或修改，cpu会先用在缓存中，并不会直接写到内存中</li><li>内存检查就是写入内存一个值操作后读出来是否正常，这个时候就需要禁用cpu的高速缓存</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// asmfunc.h</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">uint32_t</span> <span class="title">io_load_eflags</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> eflags;</span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">&quot;pushfl; popl %0&quot;</span> : <span class="string">&quot;=r&quot;</span>(eflags))</span></span>;</span><br><span class="line">    <span class="keyword">return</span> eflags;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title">io_store_eflags</span><span class="params">(<span class="type">uint32_t</span> eflags)</span> </span>&#123; <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">&quot;pushl %0; popfl&quot;</span> : : <span class="string">&quot;r&quot;</span>(eflags))</span></span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">uint32_t</span> <span class="title">load_cr0</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> cr0;</span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">&quot;movl %%cr0, %0&quot;</span> : <span class="string">&quot;=r&quot;</span>(cr0))</span></span>;</span><br><span class="line">    <span class="keyword">return</span> cr0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title">store_cr0</span><span class="params">(<span class="type">uint32_t</span> cr0)</span> </span>&#123; <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">&quot;movl %0, %%cr0&quot;</span> : : <span class="string">&quot;r&quot;</span>(cr0))</span></span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bootpack.c</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">memtest</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> start, <span class="type">unsigned</span> <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> before_386;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> eflg, cr0, i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 386及之前的cpu，没有AC这个标记位，所以设置之后还是返回0，使用此方式判断是否为386及以前</span></span><br><span class="line">    eflg = <span class="built_in">io_load_eflags</span>();</span><br><span class="line">    eflg |= EFLAGS_AC_BIT;</span><br><span class="line">    <span class="built_in">io_store_eflags</span>(eflg);</span><br><span class="line">    eflg = <span class="built_in">io_load_eflags</span>();</span><br><span class="line">    before_386 = (eflg &amp; EFLAGS_AC_BIT) == <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 还原AC标记位</span></span><br><span class="line">    eflg &amp;= ~EFLAGS_AC_BIT;</span><br><span class="line">    <span class="built_in">io_store_eflags</span>(eflg);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!before_386) &#123;</span><br><span class="line">        cr0 = <span class="built_in">load_cr0</span>();</span><br><span class="line">        cr0 |= CR0_CACHE_DISABLE; <span class="comment">/* 禁止缓存 */</span></span><br><span class="line">        <span class="built_in">store_cr0</span>(cr0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    i = <span class="built_in">memtest_sub</span>(start, end);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!before_386) &#123;</span><br><span class="line">        cr0 = <span class="built_in">load_cr0</span>();</span><br><span class="line">        cr0 &amp;= ~CR0_CACHE_DISABLE; <span class="comment">/* 高速缓存许可 */</span></span><br><span class="line">        <span class="built_in">store_cr0</span>(cr0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-内存检查和编译器优化"><a href="#2-内存检查和编译器优化" class="headerlink" title="2. 内存检查和编译器优化"></a>2. 内存检查和编译器优化</h2><p>如果使用c语言实现内存检查</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">memtest_sub</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> start, <span class="type">unsigned</span> <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> i, old, pat0 = <span class="number">0xaa55aa55</span>, pat1 = <span class="number">0x55aa55aa</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> *p;</span><br><span class="line">    <span class="keyword">for</span> (i = start; i &lt;= end; i += <span class="number">0x1000</span>) &#123;</span><br><span class="line">        p = (<span class="type">unsigned</span> <span class="type">int</span> *)(i + <span class="number">0xffc</span>);</span><br><span class="line">        old = *p;         <span class="comment">/* 记录以前的值 */</span></span><br><span class="line">        *p = pat0;        <span class="comment">/* 尝试写 */</span></span><br><span class="line">        *p ^= <span class="number">0xffffffff</span>; <span class="comment">/* 反转 */</span></span><br><span class="line">        <span class="keyword">if</span> (*p != pat1) &#123; <span class="comment">/* 检查反转结果 */</span></span><br><span class="line">        not_memory:</span><br><span class="line">            *p = old;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        *p ^= <span class="number">0xffffffff</span>; <span class="comment">/* 再次反转 */</span></span><br><span class="line">        <span class="keyword">if</span> (*p != pat0) &#123; <span class="comment">/* 检查反转结果 */</span></span><br><span class="line">            <span class="keyword">goto</span> not_memory;</span><br><span class="line">        &#125;</span><br><span class="line">        *p = old; <span class="comment">/* 恢复原来的值 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器会进行优化，发现第一个if判断没有意义，<code>pat0^0xffffffff</code>本来就是等于<code>pat1</code>啊，就算赋值给了<code>*p</code>不是一样吗</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">memtest_sub</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> start, <span class="type">unsigned</span> <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> i, old, pat0 = <span class="number">0xaa55aa55</span>, pat1 = <span class="number">0x55aa55aa</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> *p;</span><br><span class="line">    <span class="keyword">for</span> (i = start; i &lt;= end; i += <span class="number">0x1000</span>) &#123;</span><br><span class="line">        p = (<span class="type">unsigned</span> <span class="type">int</span> *)(i + <span class="number">0xffc</span>);</span><br><span class="line">        old = *p;         <span class="comment">/* 记录以前的值 */</span></span><br><span class="line">        *p = pat0;        <span class="comment">/* 尝试写 */</span></span><br><span class="line">        *p ^= <span class="number">0xffffffff</span>; <span class="comment">/* 反转 */</span></span><br><span class="line">        *p ^= <span class="number">0xffffffff</span>; <span class="comment">/* 再次反转 */</span></span><br><span class="line">        <span class="keyword">if</span> (*p != pat0) &#123; <span class="comment">/* 检查反转结果 */</span></span><br><span class="line">            <span class="keyword">goto</span> not_memory;</span><br><span class="line">        &#125;</span><br><span class="line">        *p = old; <span class="comment">/* 恢复原来的值 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两次<code>*p^0xffffffff</code>数据保持原样，那就没有必要了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">memtest_sub</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> start, <span class="type">unsigned</span> <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> i, old, pat0 = <span class="number">0xaa55aa55</span>, pat1 = <span class="number">0x55aa55aa</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> *p;</span><br><span class="line">    <span class="keyword">for</span> (i = start; i &lt;= end; i += <span class="number">0x1000</span>) &#123;</span><br><span class="line">        p = (<span class="type">unsigned</span> <span class="type">int</span> *)(i + <span class="number">0xffc</span>);</span><br><span class="line">        old = *p;         <span class="comment">/* 记录以前的值 */</span></span><br><span class="line">        *p = pat0;        <span class="comment">/* 尝试写 */</span></span><br><span class="line">        <span class="keyword">if</span> (*p != pat0) &#123; <span class="comment">/* 检查反转结果 */</span></span><br><span class="line">            <span class="keyword">goto</span> not_memory;</span><br><span class="line">        &#125;</span><br><span class="line">        *p = old; <span class="comment">/* 恢复原来的值 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>*p = pat0</code>后比较两个的值，肯定一样啊</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">memtest_sub</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> start, <span class="type">unsigned</span> <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> i, old, pat0 = <span class="number">0xaa55aa55</span>, pat1 = <span class="number">0x55aa55aa</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> *p;</span><br><span class="line">    <span class="keyword">for</span> (i = start; i &lt;= end; i += <span class="number">0x1000</span>) &#123;</span><br><span class="line">        p = (<span class="type">unsigned</span> <span class="type">int</span> *)(i + <span class="number">0xffc</span>);</span><br><span class="line">        old = *p;         <span class="comment">/* 记录以前的值 */</span></span><br><span class="line">        *p = old; <span class="comment">/* 恢复原来的值 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复制old后又赋值回去，等于没变</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">memtest_sub</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> start, <span class="type">unsigned</span> <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> i, old, pat0 = <span class="number">0xaa55aa55</span>, pat1 = <span class="number">0x55aa55aa</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> *p;</span><br><span class="line">    <span class="keyword">for</span> (i = start; i &lt;= end; i += <span class="number">0x1000</span>) &#123;</span><br><span class="line">        p = (<span class="type">unsigned</span> <span class="type">int</span> *)(i + <span class="number">0xffc</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>p就赋了一个值，全局都没有使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">memtest_sub</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> start, <span class="type">unsigned</span> <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> i, old, pat0 = <span class="number">0xaa55aa55</span>, pat1 = <span class="number">0x55aa55aa</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> *p;</span><br><span class="line">    <span class="keyword">for</span> (i = start; i &lt;= end; i += <span class="number">0x1000</span>) &#123;&#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个函数就剩下for循环了，所以一定返回输入什么就怎么样。解决这样的问题只需要在p前面修饰上<code>volatile</code>即可，编译器认为这个p是要实时变化的，就不会进行优化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">memtest_sub</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> start, <span class="type">unsigned</span> <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> i, old, pat0 = <span class="number">0xaa55aa55</span>, pat1 = <span class="number">0x55aa55aa</span>;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *p;       <span class="comment">// 这里加上volatile，防止编译器优化</span></span><br><span class="line">    <span class="comment">// unsigned int *p = 0;</span></span><br><span class="line">    <span class="keyword">for</span> (i = start; i &lt;= end; i += <span class="number">0x1000</span>) &#123;</span><br><span class="line">        p = (<span class="type">unsigned</span> <span class="type">int</span> *)(i + <span class="number">0xffc</span>);</span><br><span class="line">        old = *p;         <span class="comment">/* 记录以前的值 */</span></span><br><span class="line">        *p = pat0;        <span class="comment">/* 尝试写 */</span></span><br><span class="line">        *p ^= <span class="number">0xffffffff</span>; <span class="comment">/* 反转 */</span></span><br><span class="line">        <span class="keyword">if</span> (*p != pat1) &#123; <span class="comment">/* 检查反转结果 */</span></span><br><span class="line">        not_memory:</span><br><span class="line">            *p = old;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        *p ^= <span class="number">0xffffffff</span>; <span class="comment">/* 再次反转 */</span></span><br><span class="line">        <span class="keyword">if</span> (*p != pat0) &#123; <span class="comment">/* 检查反转结果 */</span></span><br><span class="line">            <span class="keyword">goto</span> not_memory;</span><br><span class="line">        &#125;</span><br><span class="line">        *p = old; <span class="comment">/* 恢复原来的值 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="第10天和第11天-窗口处理"><a href="#第10天和第11天-窗口处理" class="headerlink" title="第10天和第11天 窗口处理"></a>第10天和第11天 窗口处理</h1><p>主要处理图层、刷新等方式，使用图层添加了一个窗口，鼠标放到最上层。在刷新过程中发现了闪烁的问题，将刷新的方式优化了几板后没有了闪烁。主要结构如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SHEET_USE 1</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SHTCTL</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SHEET</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">SHTCTL</span> *ctl;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *buf;</span><br><span class="line">    <span class="type">int</span> bxsize;   <span class="comment">// 宽度</span></span><br><span class="line">    <span class="type">int</span> bysize;   <span class="comment">// 高度</span></span><br><span class="line">    <span class="type">int</span> vx0;      <span class="comment">// 左上角坐标</span></span><br><span class="line">    <span class="type">int</span> vy0;      <span class="comment">// 左上角坐标</span></span><br><span class="line">    <span class="type">int</span> col_inv;  <span class="comment">// 透明标识，buf中和此值相同的值会被透明化</span></span><br><span class="line">    <span class="type">int</span> height;   <span class="comment">// 高度，越大越在上面0-max</span></span><br><span class="line">    <span class="type">int</span> flags;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SHEETS 256</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SHTCTL</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *vram;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *map;  <span class="comment">// 标识哪里被哪一层sheet覆盖</span></span><br><span class="line">    <span class="type">int</span> xsize, ysize;</span><br><span class="line">    <span class="type">int</span> top;                           <span class="comment">// 最高的sheet的索引+1</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">SHEET</span> *sheets[MAX_SHEETS];  <span class="comment">// 按照高度顺序排列的已使用sheet的数组，最低的sheet在sheets[0]</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">SHEET</span> sheets0[MAX_SHEETS];  <span class="comment">// 全部sheet包含使用和未使用</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>刷新只刷新某一个区域，对区域内的点，根据map取哪一层要写入则写入vram。</p><h1 id="第12天-定时器（1）"><a href="#第12天-定时器（1）" class="headerlink" title="第12天 定时器（1）"></a>第12天 定时器（1）</h1><h2 id="PIT（Programmable-Interval-Timer）-可编程的间隔型定时器"><a href="#PIT（Programmable-Interval-Timer）-可编程的间隔型定时器" class="headerlink" title="PIT（Programmable Interval Timer） 可编程的间隔型定时器"></a>PIT（Programmable Interval Timer） 可编程的间隔型定时器</h2><p>cpu有一个旁路芯片，8254芯片（或替代品），定时向cpu的IRQ0发起中断。如果我们接收此中断，设置中断周期就可以用于做定时器中断。</p><ul><li>此芯片频率大概为1.19318MHz，我们设置一个计数来让计数到某个值产生一次中断<ul><li>1：1.19318MHz</li><li>1000：1.19318KHz</li><li>10000：119.318Hz</li><li>11932：100Hz</li></ul></li></ul><p>对应的设置指令为</p><ul><li>OUT(0x43, 0x34): 0x43为pit_ctrl寄存器，0x34为mode</li><li>OUT(0x40, 中断周期低8位):</li><li>OUT(0x40, 中断周期高8位):</li></ul><p>基于linux的实现，定义如下宏进行处理</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/linux/timex.h</span></span><br><span class="line"><span class="comment">/* The clock frequency of the i8253/i8254 PIT */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIT_TICK_RATE 1193182ul</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// include/asm-generic/param.h</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> HZ		CONFIG_HZ	<span class="comment">/* Internal kernel timer frequency */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// include/linux/i8253.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIT_LATCH	((PIT_TICK_RATE + HZ/2) / HZ)</span></span><br></pre></td></tr></table></figure><p>在makefile中定义<code>-DCONFIG_HZ=1000</code>即可实现，直接使用<code>PIT_LATCH</code>设置到中断周期里面</p><h2 id="定时器中断优化"><a href="#定时器中断优化" class="headerlink" title="定时器中断优化"></a>定时器中断优化</h2><p>可以一步到位，使用链表管理定时器，设置定时器插入到链表里面按照超时时间从小到大排序。中断中仅关注第一个定时器是否到期即可。这里使用内核的hlist处理定时器，不需要timer_alloc也可以使用定时器。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bookpack.h</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">long</span> jiffies;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_pit</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_TIMER 500</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">STRUCT_KFIFO</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span>, <span class="number">8</span>)</span> TimerBufType</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TIMER</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">hlist_node</span> entry;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> expires;  <span class="comment">// 超时时间，取绝对时间，基于jiffies</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> flags;</span><br><span class="line">    TimerBufType *fifo;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">timer_free</span><span class="params">(<span class="keyword">struct</span> TIMER *timer)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">timer_init</span><span class="params">(<span class="keyword">struct</span> TIMER *timer, TimerBufType *fifo, <span class="type">unsigned</span> <span class="type">char</span> data)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">timer_settime</span><span class="params">(<span class="keyword">struct</span> TIMER *timer, <span class="type">unsigned</span> <span class="type">long</span> timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// timer.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/list.h&gt;</span></span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">long</span> jiffies = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="title">HLIST_HEAD</span><span class="params">(s_timer_list)</span></span>;  <span class="comment">// 按照到期时间排序</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_pit</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 芯片主频为PIT_TICK_RATE，想要1ms触发1次，HZ为1000，设置PIT_LATCH = PIT_TICK_RATE / HZ</span></span><br><span class="line">    <span class="built_in">io_out8</span>(PIT_MODE, <span class="number">0x34</span>);</span><br><span class="line">    <span class="built_in">io_out8</span>(PIT_CH0, PIT_LATCH &amp; <span class="number">0xff</span>);</span><br><span class="line">    <span class="built_in">io_out8</span>(PIT_CH0, PIT_LATCH &gt;&gt; <span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">timer_free</span><span class="params">(<span class="keyword">struct</span> TIMER *timer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">TIMER</span> *node;</span><br><span class="line">    timer-&gt;flags = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">hlist_for_each_entry</span>(node, &amp;s_timer_list, entry) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == timer) &#123;</span><br><span class="line">            <span class="built_in">hlist_del_init</span>(&amp;node-&gt;entry);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">timer_init</span><span class="params">(<span class="keyword">struct</span> TIMER *timer, TimerBufType *fifo, <span class="type">unsigned</span> <span class="type">char</span> data)</span> </span>&#123;</span><br><span class="line">    timer-&gt;fifo = fifo;</span><br><span class="line">    timer-&gt;data = data;</span><br><span class="line">    <span class="built_in">INIT_HLIST_NODE</span>(&amp;timer-&gt;entry);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">timer_settime</span><span class="params">(<span class="keyword">struct</span> TIMER *timer, <span class="type">unsigned</span> <span class="type">long</span> timeout)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> e;</span><br><span class="line">    timer-&gt;expires = timeout;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 操作s_timer_list需要关中断，防止并行操作</span></span><br><span class="line">    e = <span class="built_in">io_load_eflags</span>();</span><br><span class="line">    <span class="built_in">io_cli</span>();</span><br><span class="line">    <span class="comment">// 按照到期时间排序插入</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">TIMER</span> *node;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">TIMER</span> *prev = <span class="literal">NULL</span>;  <span class="comment">// 记录要插入的节点前一个的节点</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">hlist_for_each_entry</span>(node, &amp;s_timer_list, entry) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;expires &gt; timer-&gt;expires) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 没有前一个节点，说明要插入到第一个</span></span><br><span class="line">        <span class="comment">// 1. 有节点，但是都不满足条件，插入最前面</span></span><br><span class="line">        <span class="comment">// 2. 没有节点，直接插入最前面</span></span><br><span class="line">        <span class="built_in">hlist_add_head</span>(&amp;timer-&gt;entry, &amp;s_timer_list);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 有前一个节点，插入到前一个节点后面</span></span><br><span class="line">        <span class="built_in">hlist_add_behind</span>(&amp;timer-&gt;entry, &amp;prev-&gt;entry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 恢复中断</span></span><br><span class="line">    <span class="built_in">io_store_eflags</span>(e);</span><br><span class="line">    <span class="built_in">io_sti</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inthandler20</span><span class="params">(<span class="type">int</span> *esp)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">io_out8</span>(PIC0_OCW2, <span class="number">0x60</span>);  <span class="comment">// 通知PIC已经处理完毕</span></span><br><span class="line">    ++jiffies;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">TIMER</span> *node;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">hlist_node</span> *n;</span><br><span class="line">    <span class="built_in">hlist_for_each_entry_safe</span>(node, n, &amp;s_timer_list, entry) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;expires &lt;= jiffies) &#123;</span><br><span class="line">            <span class="built_in">hlist_del_init</span>(&amp;node-&gt;entry);</span><br><span class="line">            <span class="built_in">kfifo_put</span>(node-&gt;fifo, node-&gt;data);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="第13天-定时器（2）"><a href="#第13天-定时器（2）" class="headerlink" title="第13天 定时器（2）"></a>第13天 定时器（2）</h1><h2 id="串口输出日志"><a href="#串口输出日志" class="headerlink" title="串口输出日志"></a>串口输出日志</h2><p>搞了这么久，发现出现一些问题没有办法进行排查，只能通过比较搓的方式直接在屏幕上输出某个字符串代表跑到了某个逻辑。而linux启动整个过程中可以有很多输出到串口或控制台上，参考linux的实现将日志加到操作系统中。</p><ul><li>对于串口，直接将字符串写到<code>0x3f8</code>即可输出到串口中</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// log.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/jiffies.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;asmfunc.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Serial functions loosely based on a similar package from Klaus P. Gerlicher */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> early_serial_base = <span class="number">0x3f8</span>; <span class="comment">/* ttyS0 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XMTRDY 0x20</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DLAB 0x80</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TXR 0 <span class="comment">/*  Transmit register (WRITE) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RXR 0 <span class="comment">/*  Receive register  (READ)  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IER 1 <span class="comment">/*  Interrupt Enable          */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IIR 2 <span class="comment">/*  Interrupt ID              */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FCR 2 <span class="comment">/*  FIFO control              */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCR 3 <span class="comment">/*  Line control              */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MCR 4 <span class="comment">/*  Modem control             */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LSR 5 <span class="comment">/*  Line Status               */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSR 6 <span class="comment">/*  Modem Status              */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DLL 0 <span class="comment">/*  Divisor Latch Low         */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DLH 1 <span class="comment">/*  Divisor latch High        */</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">io_serial_in</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> addr, <span class="type">int</span> offset)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">inb</span>(addr + offset); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title">io_serial_out</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> addr, <span class="type">int</span> offset, <span class="type">int</span> value)</span> </span>&#123; <span class="built_in">outb</span>(value, addr + offset); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title">serial_putc</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> ch)</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> timeout = <span class="number">0xffff</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((<span class="built_in">io_serial_in</span>(early_serial_base, LSR) &amp; XMTRDY) == <span class="number">0</span>) &#123;</span><br><span class="line">        --timeout;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">io_serial_out</span>(early_serial_base, TXR, ch);</span><br><span class="line">    <span class="keyword">return</span> timeout ? <span class="number">0</span> : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title">serial_write</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s, <span class="type">unsigned</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (*s &amp;&amp; n-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*s == <span class="string">&#x27;\n&#x27;</span>) <span class="built_in">serial_putc</span>(<span class="string">&#x27;\r&#x27;</span>);</span><br><span class="line">        <span class="built_in">serial_putc</span>(*s);</span><br><span class="line">        s++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">serial_printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt, ...)</span> </span>&#123;</span><br><span class="line">    va_list ap;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">512</span>];</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">va_start</span>(ap, fmt);</span><br><span class="line">    n = <span class="built_in">vscnprintf</span>(buf, <span class="built_in">sizeof</span>(buf), fmt, ap);</span><br><span class="line">    <span class="built_in">va_end</span>(ap);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">serial_write</span>(buf, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> _print_current_time(<span class="type">void</span>) &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> msecs = <span class="built_in">jiffies_to_msecs</span>(jiffies);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> secs = msecs / <span class="number">1000</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> msec = msecs % <span class="number">1000</span>;</span><br><span class="line">    <span class="built_in">serial_printf</span>(<span class="string">&quot;[%5lu.%03lu]&quot;</span>, secs, msec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// log.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __LOG_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __LOG_H__</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">serial_printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt, ...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> _print_current_time(<span class="type">void</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_INFO(fmt, ...) \</span></span><br><span class="line"><span class="meta">    _print_current_time(); \</span></span><br><span class="line"><span class="meta">    serial_printf(<span class="string">&quot;[%s:%d %s] &quot;</span> fmt <span class="string">&quot;\r\n&quot;</span>, __FILE__, __LINE__, __FUNCTION__, ##__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// __LOG_H__</span></span></span><br></pre></td></tr></table></figure><p>makefile中修改一下qemu的参数，添加<code>-serial stdio</code>，然后在控制台就可以看到输出，代码中使用<code>LOG_INFO</code>打印即可。输出效果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[    0.000][bootpack.c:21 HariMain] HariMain start</span><br><span class="line">[    0.000][bootpack.c:30 HariMain] init gdtidt done</span><br><span class="line">[    0.002][bootpack.c:44 HariMain] create timer done</span><br><span class="line">[    0.002][bootpack.c:50 HariMain] init keyboard and mouse done</span><br><span class="line">[    0.004][bootpack.c:54 HariMain] init palette done</span><br><span class="line">[    0.314][bootpack.c:64 HariMain] init memory done, cost 310ms, memory 2048MB, free: 2093688KB</span><br><span class="line">[    0.324][bootpack.c:106 HariMain] init windows done</span><br></pre></td></tr></table></figure><h2 id="中断处理优化"><a href="#中断处理优化" class="headerlink" title="中断处理优化"></a>中断处理优化</h2><p>其实就是搞了个数组实现链表的方式，将timer管理起来。之前使用了hlist来管理timer，天然就是链表，后面两个优化就不做了。</p><h1 id="第14天-提高分辨率及键盘输入"><a href="#第14天-提高分辨率及键盘输入" class="headerlink" title="第14天 提高分辨率及键盘输入"></a>第14天 提高分辨率及键盘输入</h1><h2 id="VBE（VESA-BIOS-Extensions）"><a href="#VBE（VESA-BIOS-Extensions）" class="headerlink" title="VBE（VESA BIOS Extensions）"></a>VBE（VESA BIOS Extensions）</h2><p>参考：<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/VESA_BIOS_Extensions">https://en.wikipedia.org/wiki/VESA_BIOS_Extensions</a></p><p>最开始电脑规格是IBM公司决定的，也制定了相关的规格，各家显卡公司只能迎合IBM规格制作显卡。一段时间后，显卡公司图像处理技术超过了IBM公司，就出现了各式各样的画面模式，造成了显卡公司竞争和设定方法使用方法各不相同。由于开发人员不想记忆那么多情况，所以很多高性能显卡也只使用最原始的320x200来使用。为了解决这个问题，各个显卡公司经过协商，成立了VESA协会（Video Electronics Standards Association，视频电子标准协会）。协会制定了一个通用设定方法，虽然不能完全兼容，但是可以通用。这个BIOS操作称为“VESA BIOS Extension”简称VBE。</p><p>在qemu上测试支持下面几个模式</p><ul><li>0x0100: 640x400</li><li>0x0101: 640x480</li><li>0x0105: 1024x768</li><li>0x0107: 1280x1024</li><li>0x011c: 1600x1200</li></ul><p>不过设置之后的vram的地址不是<code>0xe0000000</code>而是<code>0xfd000000</code>。设置方法为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#define VBEMODE         0x0105</span><br><span class="line"></span><br><span class="line">	mov 	$(VBEMODE+0x4000),%bx</span><br><span class="line">	mov 	$0x4f02,%ax</span><br><span class="line">	int 	$0x10</span><br><span class="line">	movb 	$8,(VMODE)</span><br></pre></td></tr></table></figure><p>需要ax设置<code>0x4f02</code>，bx设置<code>vbemode+0x4000</code>，然后调用<code>int 10</code></p><h2 id="VBE检查"><a href="#VBE检查" class="headerlink" title="VBE检查"></a>VBE检查</h2><p>部分显卡可能真不支持VBE的情况，我们的代码就有问题了，无法显示屏幕，所以需要做一个自适应检查。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"># 确认VBE是否存在</span><br><span class="line">mov 	$0x9000,%ax</span><br><span class="line">mov 	%ax,%es</span><br><span class="line">mov 	$0,%di</span><br><span class="line">mov 	$0x4f00,%ax</span><br><span class="line">int 	$0x10</span><br><span class="line">cmp 	$0x004f,%ax</span><br><span class="line">jne 	scrn320</span><br><span class="line"></span><br><span class="line"># 检查vbe版本需要是0x200，即VBE 2.0</span><br><span class="line">mov 	%es:(%di,4),%ax</span><br><span class="line">cmp 	$0x0200,%ax</span><br><span class="line">jb  	scrn320</span><br><span class="line"></span><br><span class="line"># 测试画面模式是否能使用，需要ax为0x004f</span><br><span class="line">mov 	$VBEMODE,%cx</span><br><span class="line">mov 	$0x4f01,%ax</span><br><span class="line">int 	$0x10</span><br><span class="line">cmp 	$0x004f,%ax</span><br><span class="line">jne  	scrn320</span><br><span class="line"></span><br><span class="line"># 画面的模式 包含了非常多的重要信息，如模式属性</span><br><span class="line">   # WORD  [es:di+0x00]: 模式属性，第7位需要是1，这样才能加上0x4000</span><br><span class="line">   # WORD  [es:di+0x12]: X的分辨率</span><br><span class="line">   # WORD  [es:di+0x14]: Y的分辨率</span><br><span class="line">   # BYTE  [es:di+0x19]: 颜色数，必须为8，我们代码用的就是8</span><br><span class="line">   # BYTE  [es:di+0x1b]: 颜色的指定方法，必须为4，即调色板模式</span><br><span class="line">   # DWORD [es:di+0x28]: VRAM的地址</span><br><span class="line"></span><br><span class="line">   # 确认颜色数</span><br><span class="line">movb 	%es:0x19(%di),%al</span><br><span class="line">cmp 	$8,%al</span><br><span class="line">jne 	scrn320</span><br><span class="line">   # 确认颜色指定方法</span><br><span class="line">movb 	%es:0x1b(%di),%al</span><br><span class="line">cmp 	$4,%al</span><br><span class="line">jne 	scrn320</span><br><span class="line"></span><br><span class="line">   # 重新调用设置画面模式，需要加上0x4000</span><br><span class="line">   mov 	$(VBEMODE+0x4000),%bx</span><br><span class="line">mov 	$0x4f02,%ax</span><br><span class="line">int 	$0x10</span><br><span class="line"></span><br><span class="line"># 记录对应信息给到c语言</span><br><span class="line">movb 	$8,(VMODE)</span><br><span class="line">mov 	%es:0x12(%di),%ax</span><br><span class="line">mov 	%ax,(SCRNX)</span><br><span class="line">mov 	%es:0x14(%di),%ax</span><br><span class="line">mov 	%ax,(SCRNY)</span><br><span class="line">movl 	%es:0x28(%di),%eax</span><br><span class="line">movl 	%eax,(VRAM)</span><br></pre></td></tr></table></figure></div><div class="reward-container"><div></div><button onclick='var qr=document.getElementById("qr");qr.style.display="none"===qr.style.display?"block":"none"'>打赏</button><div id="qr" style="display:none"><div style="display:inline-block"><img src="/images/wechatpay.png" alt="王钰博 微信支付"><p>微信支付</p></div><div style="display:inline-block"><img src="/images/alipay.jpg" alt="王钰博 支付宝"><p>支付宝</p></div></div></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-item"><a href="/blogs/2019-04-25-assemblyLanguage/" rel="prev" title="汇编语言学习笔记"><i class="fa fa-chevron-left"></i> 汇编语言学习笔记</a></div><div class="post-nav-item"><a href="/blogs/2019-05-28-paperWriting/" rel="next" title="论文书写的重点">论文书写的重点 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="valine-comments"></div><script>window.addEventListener("tabs:register",()=>{let{activeClass:t}=CONFIG.comments;if(CONFIG.comments.storage&&(t=localStorage.getItem("comments_active")||t),t){let e=document.querySelector(`a[href="#comment-${t}"]`);e&&e.click()}}),CONFIG.comments.storage&&window.addEventListener("tabs:click",t=>{if(!t.target.matches(".tabs-comment .tab-content .tab-pane"))return;let e=t.target.classList[1];localStorage.setItem("comments_active",e)})</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-text">前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E8%AF%8D%E8%A7%A3%E9%87%8A"><span class="nav-text">关键词解释</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC1%E5%A4%A9-%E4%BB%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%93%E6%9E%84%E5%88%B0%E6%B1%87%E7%BC%96%E7%A8%8B%E5%BA%8F%E5%85%A5%E9%97%A8"><span class="nav-text">第1天 从计算机结构到汇编程序入门</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-vmware%E5%90%AF%E5%8A%A8img"><span class="nav-text">1. vmware启动img</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-qemu%E5%90%AF%E5%8A%A8img"><span class="nav-text">2. qemu启动img</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC2%E5%A4%A9-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B8%8EMakefile%E5%85%A5%E9%97%A8"><span class="nav-text">第2天 汇编语言学习与Makefile入门</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E6%A0%87%E5%87%86FAT12%E8%BD%AF%E7%9B%98%E6%A0%BC%E5%BC%8F"><span class="nav-text">1. 标准FAT12软盘格式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E6%B1%87%E7%BC%96%E4%BB%A3%E8%A1%A8%E6%80%A7%E5%AF%84%E5%AD%98%E5%99%A8%E4%BB%8B%E7%BB%8D"><span class="nav-text">2. 汇编代表性寄存器介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#16%E4%BD%8D%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-text">16位寄存器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8%E4%BD%8D%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-text">8位寄存器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#32%E4%BD%8D%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-text">32位寄存器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%8C16%E4%BD%8D"><span class="nav-text">段寄存器，16位</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-CPU%E5%92%8C%E5%86%85%E5%AD%98"><span class="nav-text">3. CPU和内存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-Makefile%E7%BC%96%E5%86%99"><span class="nav-text">4. Makefile编写</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC3%E5%A4%A9-%E8%BF%9B%E5%85%A532%E4%BD%8D%E6%A8%A1%E5%BC%8F%E5%B9%B6%E5%AF%BC%E5%85%A5C%E8%AF%AD%E8%A8%80"><span class="nav-text">第3天 进入32位模式并导入C语言</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E8%BD%AF%E7%9B%98%E6%9E%84%E6%88%90"><span class="nav-text">1. 软盘构成</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E8%BD%AF%E7%9B%98%E4%BF%9D%E5%AD%98%E6%96%87%E4%BB%B6"><span class="nav-text">(1) 软盘保存文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%BD%93%E5%89%8D%E7%BC%96%E8%AF%91%E5%87%BA%E6%9D%A5%E7%9A%84%E8%BD%AF%E7%9B%98%E5%88%86%E5%B8%83"><span class="nav-text">(2) 当前编译出来的软盘分布</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%86%85%E5%AD%98%E5%AF%BB%E5%9D%80"><span class="nav-text">2. 内存寻址</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E6%B1%87%E7%BC%96%E5%92%8CC%E8%AF%AD%E8%A8%80%E9%93%BE%E6%8E%A5"><span class="nav-text">3. 汇编和C语言链接</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-BIOS%E4%BB%8B%E7%BB%8D"><span class="nav-text">4. BIOS介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-BIOS%E5%87%BD%E6%95%B0"><span class="nav-text">1) BIOS函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-0x10-%E8%AE%BE%E7%BD%AE%E7%94%BB%E9%9D%A2%E6%A8%A1%E5%BC%8F"><span class="nav-text">(1) 0x10 设置画面模式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-cpu%E4%BB%8B%E7%BB%8D"><span class="nav-text">5. cpu介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E5%86%85%E5%AD%98%E9%87%8D%E6%96%B0%E5%88%86%E9%85%8D"><span class="nav-text">6. 内存重新分配</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-makefile%E8%A7%A3%E9%87%8A"><span class="nav-text">7. makefile解释</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC4%E5%A4%A9-C%E8%AF%AD%E8%A8%80%E4%B8%8E%E7%94%BB%E9%9D%A2%E6%98%BE%E7%A4%BA%E7%9A%84%E7%BB%83%E4%B9%A0"><span class="nav-text">第4天 C语言与画面显示的练习</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%95%8C%E9%9D%A2"><span class="nav-text">1. 图形化界面</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E8%B0%83%E8%89%B2%E6%9D%BF"><span class="nav-text">2. 调色板</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E9%80%9F%E5%BA%A6%E9%97%AE%E9%A2%98"><span class="nav-text">3. 速度问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E4%BD%BF%E7%94%A8c%E8%AF%AD%E8%A8%80%E9%81%87%E5%88%B0%E7%9A%84%E5%87%A0%E4%B8%AA%E9%97%AE%E9%A2%98"><span class="nav-text">4. 使用c语言遇到的几个问题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC5%E5%A4%A9-%E7%BB%93%E6%9E%84%E4%BD%93%E3%80%81%E6%96%87%E5%AD%97%E6%98%BE%E7%A4%BA%E4%B8%8EGDT-IDT%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">第5天 结构体、文字显示与GDT&#x2F;IDT初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%AD%97%E7%AC%A6%E7%82%B9%E9%98%B5"><span class="nav-text">1. 字符点阵</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-GDT%E5%92%8CIDT"><span class="nav-text">2. GDT和IDT</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E5%88%86%E6%AE%B5"><span class="nav-text">2.1. 分段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-GDT-global-segment-descriptor-table"><span class="nav-text">2.2. GDT: global segment descriptor table</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-IDT-interrupt-descriptor-table"><span class="nav-text">2.3. IDT: interrupt descriptor table</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-GDT%E3%80%81IDT%E3%80%81LDT%E5%92%8CTSS%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-text">2.4. GDT、IDT、LDT和TSS的关系</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC6%E5%A4%A9-%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86"><span class="nav-text">第6天 中断处理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-PIC-Programmable-interrupt-controller"><span class="nav-text">1. PIC: Programmable interrupt controller</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E4%B8%AD%E6%96%AD%E5%8F%B7%E5%AF%B9%E5%BA%94%E7%9A%84%E4%B8%AD%E6%96%AD%E7%B1%BB%E5%9E%8B"><span class="nav-text">2. 中断号对应的中断类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E6%B3%A8%E5%86%8C%E4%B8%AD%E6%96%AD%E5%87%BD%E6%95%B0"><span class="nav-text">3. 注册中断函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86"><span class="nav-text">4. 中断处理</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC7%E5%A4%A9-FIFO%E4%B8%8E%E9%BC%A0%E6%A0%87%E6%8E%A7%E5%88%B6"><span class="nav-text">第7天 FIFO与鼠标控制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E9%BC%A0%E6%A0%87%E9%94%AE%E7%9B%98%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%8F%96"><span class="nav-text">1. 鼠标键盘数据读取</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-fifo"><span class="nav-text">2. fifo</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E9%BC%A0%E6%A0%87%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">3. 鼠标初始化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E4%BD%BF%E7%94%A8linux%E7%9A%84idt%E5%92%8Cgdt%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-text">4. 使用linux的idt和gdt的实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC8%E5%A4%A9-%E9%BC%A0%E6%A0%87%E6%8E%A7%E5%88%B6%E4%B8%8E32%E4%BD%8D%E6%A8%A1%E5%BC%8F%E5%88%87%E6%8D%A2"><span class="nav-text">第8天 鼠标控制与32位模式切换</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E9%BC%A0%E6%A0%87%E6%95%B0%E6%8D%AE%E8%A7%A3%E8%AF%BB"><span class="nav-text">1. 鼠标数据解读</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%BD%93%E5%89%8D%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83%E5%9B%BE"><span class="nav-text">2. 当前操作系统内存分布图</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC9%E5%A4%A9-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-text">第9天 内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E7%A6%81%E7%94%A8%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98"><span class="nav-text">1. 禁用高速缓存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%86%85%E5%AD%98%E6%A3%80%E6%9F%A5%E5%92%8C%E7%BC%96%E8%AF%91%E5%99%A8%E4%BC%98%E5%8C%96"><span class="nav-text">2. 内存检查和编译器优化</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC10%E5%A4%A9%E5%92%8C%E7%AC%AC11%E5%A4%A9-%E7%AA%97%E5%8F%A3%E5%A4%84%E7%90%86"><span class="nav-text">第10天和第11天 窗口处理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC12%E5%A4%A9-%E5%AE%9A%E6%97%B6%E5%99%A8%EF%BC%881%EF%BC%89"><span class="nav-text">第12天 定时器（1）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#PIT%EF%BC%88Programmable-Interval-Timer%EF%BC%89-%E5%8F%AF%E7%BC%96%E7%A8%8B%E7%9A%84%E9%97%B4%E9%9A%94%E5%9E%8B%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="nav-text">PIT（Programmable Interval Timer） 可编程的间隔型定时器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8%E4%B8%AD%E6%96%AD%E4%BC%98%E5%8C%96"><span class="nav-text">定时器中断优化</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC13%E5%A4%A9-%E5%AE%9A%E6%97%B6%E5%99%A8%EF%BC%882%EF%BC%89"><span class="nav-text">第13天 定时器（2）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%B2%E5%8F%A3%E8%BE%93%E5%87%BA%E6%97%A5%E5%BF%97"><span class="nav-text">串口输出日志</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E4%BC%98%E5%8C%96"><span class="nav-text">中断处理优化</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC14%E5%A4%A9-%E6%8F%90%E9%AB%98%E5%88%86%E8%BE%A8%E7%8E%87%E5%8F%8A%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5"><span class="nav-text">第14天 提高分辨率及键盘输入</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#VBE%EF%BC%88VESA-BIOS-Extensions%EF%BC%89"><span class="nav-text">VBE（VESA BIOS Extensions）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#VBE%E6%A3%80%E6%9F%A5"><span class="nav-text">VBE检查</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="王钰博" src="/images/12.jpg"><p class="site-author-name" itemprop="name">王钰博</p><div class="site-description" itemprop="description">个人博客</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">122</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">21</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">14</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/Githubwyb" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Githubwyb" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:1061322005@qq.com" title="E-Mail → mailto:1061322005@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a></span></div><div class="links-of-blogroll motion-element"><div class="links-of-blogroll-title"><i class="fa fa-fw fa-link"></i> 友情链接</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="https://githubwyb.github.io/bookPages/" title="https:&#x2F;&#x2F;githubwyb.github.io&#x2F;bookPages&#x2F;">markdown books</a></li></ul></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="beian"><a href="http://www.beian.miit.gov.cn/" rel="noopener" target="_blank">豫ICP备16023189号 </a><img src="/images/beian.png" style="display:inline-block"></div><div class="copyright">&copy; <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">王钰博</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-area-chart"></i> </span><span title="站点总字数">1.2m</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span title="站点阅读时长">17:54</span></div><div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动</div><div class="addthis_inline_share_toolbox"><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e1986d4e4e2d132" async></script></div><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-divider">|</span> <span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer></div><script src="/lib/anime.min.js"></script><script src="/lib/medium-zoom.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><script src="/js/local-search.js"></script><script>document.querySelectorAll(".pdfobject-container").forEach(e=>{let t=e.dataset.target,a="#"+Object.entries({navpanes:0,toolbar:0,statusbar:0,pagemode:"thumbs",view:"FitH"}).map(([e,t])=>`${e}=${encodeURIComponent(t)}`).join("&"),i=`/lib/pdf/web/viewer.html?file=${encodeURIComponent(t)}${a}`;NexT.utils.supportsPDFs()?e.innerHTML=`<embed class="pdfobject" src="${t+a}" type="application/pdf" style="height: ${e.dataset.height};">`:e.innerHTML=`<iframe src="${i}" style="height: ${e.dataset.height};" frameborder="0"></iframe>`})</script><script>"undefined"==typeof MathJax?(window.MathJax={loader:{source:{"[tex]/amsCd":"[tex]/amscd","[tex]/AMScd":"[tex]/amscd"}},tex:{inlineMath:{"[+]":[["$","$"]]},tags:"ams"},options:{renderActions:{findScript:[10,e=>{document.querySelectorAll('script[type^="math/tex"]').forEach(t=>{const a=!!t.type.match(/; *mode=display/),n=new e.options.MathItem(t.textContent,e.inputJax[0],a),d=document.createTextNode("");t.parentNode.replaceChild(d,t),n.start={node:d,delim:"",n:0},n.end={node:d,delim:"",n:0},e.math.push(n)})},"",!1],insertedScript:[200,()=>{document.querySelectorAll("mjx-container").forEach(e=>{let t=e.parentNode;"li"===t.nodeName.toLowerCase()&&t.parentNode.classList.add("has-jax")})},"",!1]}}},function(){var e=document.createElement("script");e.src="/lib/mathjax/tex-mml-chtml.js",e.defer=!0,document.head.appendChild(e)}()):(MathJax.startup.document.state(0),MathJax.texReset(),MathJax.typeset())</script><script>NexT.utils.loadComments(document.querySelector("#valine-comments"),()=>{NexT.utils.getScript("//unpkg.com/valine/dist/Valine.min.js",()=>{var e=["nick","mail","link"],a="nick,mail";a=a.split(",").filter(a=>e.includes(a)),new Valine({el:"#valine-comments",verify:!1,notify:!1,appId:"qmLbUHV1HOr841BOYkl84riu-gzGzoHsz",appKey:"j4fgTcf1yHRDD5X3HUH5EH95",placeholder:"^_^ happy everyday!",avatar:"wavatar",meta:a,pageSize:"10",visitor:!1,lang:"zh-cn",path:location.pathname,recordIP:!1,serverURLs:""})},window.Valine)})</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":true,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"bottom":-30,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body><script type="text/javascript" src="/lib/jquery-3.4.1.min.js"></script><script type="text/javascript" src="/js/src/love.js"></script></html>