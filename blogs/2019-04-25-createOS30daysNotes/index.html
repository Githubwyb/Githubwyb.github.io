<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.0.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-diy.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-diy.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-diy.png"><link rel="mask-icon" href="/images/logo-diy.svg" color="#222"><meta name="baidu-site-verification" content="y1cfESbTt9nd3LsA"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="/lib/pace/pace-theme-flash.min.css"><script src="/lib/pace/pace.min.js"></script><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"githubwyb.github.io",root:"/",scheme:"Pisces",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:null},back2top:{enable:!0,sidebar:!1,scrollpercent:!0},bookmark:{enable:!0,color:"#ff0000",save:"auto"},fancybox:!1,mediumzoom:!0,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="关键词解释 启动区: (bootsector) 软盘第一个的扇区称为启动区。那么什么是扇区呢？计算机读写软盘的时候，并不是一个字节一个字节地读写的，而是以512字节为一个单位进行读写。因此，软盘的512字节就称为一个扇区。一张软盘的空间共有1440KB, 也就是1474560字节，除以512得2880, 这也就是说一张软盘共有2880个扇区。那为什么第一个扇区称为启动区呢？那是因为计算机首先从最初"><meta property="og:type" content="article"><meta property="og:title" content="30天自制操作系统笔记"><meta property="og:url" content="https://githubwyb.github.io/blogs/2019-04-25-createOS30daysNotes/index.html"><meta property="og:site_name" content="技术的路上奔跑"><meta property="og:description" content="关键词解释 启动区: (bootsector) 软盘第一个的扇区称为启动区。那么什么是扇区呢？计算机读写软盘的时候，并不是一个字节一个字节地读写的，而是以512字节为一个单位进行读写。因此，软盘的512字节就称为一个扇区。一张软盘的空间共有1440KB, 也就是1474560字节，除以512得2880, 这也就是说一张软盘共有2880个扇区。那为什么第一个扇区称为启动区呢？那是因为计算机首先从最初"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://githubwyb.github.io/blogs/2019-04-25-createOS30daysNotes/2022-10-24-01.png"><meta property="og:image" content="https://githubwyb.github.io/blogs/2019-04-25-createOS30daysNotes/2022-10-24-03.png"><meta property="og:image" content="https://githubwyb.github.io/blogs/2019-04-25-createOS30daysNotes/2022-10-24-02.png"><meta property="og:image" content="https://githubwyb.github.io/blogs/2019-04-25-createOS30daysNotes/2022-10-23-01.png"><meta property="article:published_time" content="2019-04-25T07:58:18.000Z"><meta property="article:modified_time" content="2023-10-15T02:28:27.647Z"><meta property="article:author" content="王钰博"><meta property="article:tag" content="wyb"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://githubwyb.github.io/blogs/2019-04-25-createOS30daysNotes/2022-10-24-01.png"><link rel="canonical" href="https://githubwyb.github.io/blogs/2019-04-25-createOS30daysNotes/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>30天自制操作系统笔记 | 技术的路上奔跑</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">技术的路上奔跑</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">入门</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-fw fa-sitemap"></i>站点地图</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><div class="reading-progress-bar"></div><a role="button" class="book-mark-link book-mark-link-fixed"></a> <a href="https://github.com/Githubwyb" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://githubwyb.github.io/blogs/2019-04-25-createOS30daysNotes/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/12.jpg"><meta itemprop="name" content="王钰博"><meta itemprop="description" content="个人博客"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="技术的路上奔跑"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">30天自制操作系统笔记</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-04-25 15:58:18" itemprop="dateCreated datePublished" datetime="2019-04-25T15:58:18+08:00">2019-04-25</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-10-15 10:28:27" itemprop="dateModified" datetime="2023-10-15T10:28:27+08:00">2023-10-15</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Knowledge/" itemprop="url" rel="index"><span itemprop="name">Knowledge</span></a> </span>， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Knowledge/Study/" itemprop="url" rel="index"><span itemprop="name">Study</span></a> </span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span id="busuanzi_value_page_pv"></span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><span class="post-meta-item-text">Valine：</span> <a title="valine" href="/blogs/2019-04-25-createOS30daysNotes/#valine-comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/blogs/2019-04-25-createOS30daysNotes/" itemprop="commentCount"></span></a></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>10k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>9 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="关键词解释"><a href="#关键词解释" class="headerlink" title="关键词解释"></a>关键词解释</h1><ul><li>启动区: (bootsector) 软盘第一个的扇区称为启动区。那么什么是扇区呢？计算机读写软盘的时候，并不是一个字节一个字节地读写的，而是以512字节为一个单位进行读写。因此，软盘的512字节就称为一个扇区。一张软盘的空间共有1440KB, 也就是1474560字节，除以512得2880, 这也就是说一张软盘共有2880个扇区。那为什么第一个扇区称为启动区呢？那是因为计算机首先从最初一个扇区开始读软盘，然后去检查这个扇区最后2个字节的内容。</li><li>IPL: （initial program loader）启动程序加载器。启动区只有区区512字节，实际的操作系统不像hello-os这么小，根本装不进去。所以几乎所有的操作系统，都是把加载操作系统本身的程序放在启动区里的。有鉴于此，有时也将启动区称为IPL。但hello-os没有加载程序的功能，所以HELLOIPL这个名字不太顺理成章。如果有人正义感特别强，觉得“这是撒谎造假，万万不能容忍！＂，那也可以改成其他的名字。但是必须起一个8字节的名字，如果名字长度不到8字节的话，常要在最后补上空格。</li></ul><h1 id="第1天"><a href="#第1天" class="headerlink" title="第1天"></a>第1天</h1><ol><li>环境windows</li><li>二进制编辑器 notepad++安装hexeditor插件</li><li>汇编编辑器 vscode安装x86 and x86_64 Assembly</li><li>编译需要使用光盘中的nask编译器</li></ol><h2 id="1-1-vmware启动img"><a href="#1-1-vmware启动img" class="headerlink" title="1.1. vmware启动img"></a>1.1. vmware启动img</h2><ul><li>创建系统选择other&#x2F;other</li><li>创建好需要添加硬件，选择软盘，然后使用文件，选择img即可启动</li></ul><h1 id="第2天"><a href="#第2天" class="headerlink" title="第2天"></a>第2天</h1><h2 id="2-1-标准FAT12软盘格式"><a href="#2-1-标准FAT12软盘格式" class="headerlink" title="2.1. 标准FAT12软盘格式"></a>2.1. 标准FAT12软盘格式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">; 以下的记述用于标准FAT12格式的软盘</span><br><span class="line">    JMP     entry</span><br><span class="line">    DB      0x90</span><br><span class="line">    DB      &quot;HELLOIPL&quot;      ; 启动区的名称可以是任意的字符串</span><br><span class="line">    DW      512             ; 每个扇区（sector）的大小（必须为512字节）</span><br><span class="line">    DB      1               ; 簇（cluster）的大小（必须为1个扇区）</span><br><span class="line">    DW      1               ; FAT的起始位置（一般从第一个扇区开始）</span><br><span class="line">    DB      2               ; FAT的个数（必须为2）</span><br><span class="line">    DW      224             ; 根目录的大小（一般设成224项）</span><br><span class="line">    DW      2880            ; 该磁盘的大小（必须是2880扇区）</span><br><span class="line">    DB      0xf0            ; 磁盘的种类</span><br><span class="line">    DW      9               ; FAT的长度（必须是9扇区）</span><br><span class="line">    DW      18              ; 1个磁道（track）有几个扇区（必须是18）</span><br><span class="line">    DW      2               ; 磁头数（必须是2）</span><br><span class="line">    DD      0               ; 不使用分区，必须是0</span><br><span class="line">    DD      2880            ; 重写一次磁盘大小</span><br><span class="line">    DB      0, 0, 0x29      ; 意义不明，固定</span><br><span class="line">    DD      0xffffffff      ; （可能是）卷标号码</span><br><span class="line">    DB      &quot;HELLO-OS   &quot;   ; 磁盘的名称（11字节）</span><br><span class="line">    DB      &quot;FAT12   &quot;      ; 磁盘格式名称（8字节）</span><br><span class="line">    RESB    18              ; 先空出18字节</span><br></pre></td></tr></table></figure><h2 id="2-2-汇编代表性寄存器介绍"><a href="#2-2-汇编代表性寄存器介绍" class="headerlink" title="2.2. 汇编代表性寄存器介绍"></a>2.2. 汇编代表性寄存器介绍</h2><h3 id="16位寄存器"><a href="#16位寄存器" class="headerlink" title="16位寄存器"></a>16位寄存器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">AX ---- accumulator         累加寄存器</span><br><span class="line">CX ---- counter             计数寄存器</span><br><span class="line">DX ---- data                数据寄存器</span><br><span class="line">BX ---- base                基址寄存器</span><br><span class="line">SP ---- stack pointer       栈指针寄存器</span><br><span class="line">BP ---- base pointer        基址指针寄存器</span><br><span class="line">SI ---- source index        源变址寄存器</span><br><span class="line">DI ---- destination index   目的变址寄存器</span><br></pre></td></tr></table></figure><h3 id="8位寄存器"><a href="#8位寄存器" class="headerlink" title="8位寄存器"></a>8位寄存器</h3><p>8位寄存器为16位寄存器的扩展，AL和AH一起代表AX，并不是单独的寄存器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">AL ---- accumulator         累加寄存器低位</span><br><span class="line">CL ---- counter             计数寄存器低位</span><br><span class="line">DL ---- data                数据寄存器低位</span><br><span class="line">BL ---- base                基址寄存器低位</span><br><span class="line">AH ---- accumulator         累加寄存器高位</span><br><span class="line">CH ---- counter             计数寄存器高位</span><br><span class="line">DH ---- data                数据寄存器高位</span><br><span class="line">BH ---- base                基址寄存器高位</span><br></pre></td></tr></table></figure><h3 id="32位寄存器"><a href="#32位寄存器" class="headerlink" title="32位寄存器"></a>32位寄存器</h3><ul><li>32位系统中使用的32位寄存器，低16位和上述16位相同，高16位没有寄存器名字</li><li>32位寄存器加<code>E</code>代表，如<code>EAX, ECX, EDX, EBX, ESP, EBP, ESI, EDI</code></li></ul><h3 id="段寄存器，16位"><a href="#段寄存器，16位" class="headerlink" title="段寄存器，16位"></a>段寄存器，16位</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ES ---- extra segment       附加段寄存器</span><br><span class="line">CS ---- code segment        代码段寄存器</span><br><span class="line">SS ---- stack segment       栈段寄存器</span><br><span class="line">DS ---- data segment        数据段寄存器</span><br><span class="line">FS ---- segment part 2      没有名称</span><br><span class="line">GS ---- segment part 3      没有名称</span><br></pre></td></tr></table></figure><h2 id="2-3-CPU和内存"><a href="#2-3-CPU和内存" class="headerlink" title="2.3. CPU和内存"></a>2.3. CPU和内存</h2><ul><li>CPU寄存器很少，32位也只有44个字节的空间，所以需要内存当<strong>外部储存器</strong></li><li>内存和CPU使用管脚连接，速度虽然光速，但是比起来内部寄存器还是慢很多</li><li>程序代码储存在内存中，一条一条读取出来进行运行</li><li><code>0xf0000</code>附近存在bios本身</li><li>启动区内容的装载地址为<code>0x00007c00 -- 0x00007dff</code>，为IBM和intel规定的。所以ORG指令选择此处为起始地址，也仅有512字节</li></ul><h1 id="第3天"><a href="#第3天" class="headerlink" title="第3天"></a>第3天</h1><h2 id="3-1-软盘构成"><a href="#3-1-软盘构成" class="headerlink" title="3.1. 软盘构成"></a>3.1. 软盘构成</h2><img src="2019_06_14_01.bmp" width="60%"><ul><li>一面80个柱面</li><li>磁盘有两面</li><li>每个柱面18个扇区</li><li>一个扇区512字节</li><li>一共80 * 2 * 18 * 512 &#x3D; 1474560 Byte &#x3D; 1440 KB</li><li><code>C0-H0-S1</code>代表柱面0，磁头0，扇区1</li><li>扇区从1开始计数，柱面从0开始计数</li></ul><h3 id="1-软盘保存文件"><a href="#1-软盘保存文件" class="headerlink" title="(1) 软盘保存文件"></a>(1) 软盘保存文件</h3><ul><li>文件名写在<code>0x0002600</code>的地方</li><li>文件内容写在<code>0x004200</code>的地方</li><li>编译生成的第三阶段启动程序代码在0x004200位置</li></ul><h2 id="3-2-内存寻址"><a href="#3-2-内存寻址" class="headerlink" title="3.2. 内存寻址"></a>3.2. 内存寻址</h2><ul><li><code>ES : BX</code>代表内存寻址的地址，其中BX为0-3位，ES为4-位。如<code>ES=0x0820，BX=0，代表0x8200地址</code>。总内存为12位，1M左右。</li><li>内存<code>0x7c00-0x7dff</code>为启动区使用，<code>0x7e00-0x9fbff</code>没有什么用，留给操作系统开发使用</li><li>内存寻址需要指定段寄存器DS，不然就会加上其16倍的数据，所以一般DS &#x3D; 0</li></ul><h2 id="3-3-汇编和C语言链接"><a href="#3-3-汇编和C语言链接" class="headerlink" title="3.3. 汇编和C语言链接"></a>3.3. 汇编和C语言链接</h2><ul><li>使用汇编可以编译出<code>.obj</code>（<code>.o</code>）文件，这个文件和C文件编译出来的是一个效果</li><li>可以使用<code>objdump</code>来查看c语言生成的汇编指令代码</li><li>既然都是原生汇编，按照c语言生成的汇编格式来写汇编，同样可以链接到c语言中</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">; naskfunc</span><br><span class="line">; TAB=4</span><br><span class="line"></span><br><span class="line">[FORMAT &quot;WCOFF&quot;]    ; 制作目标文件的模式</span><br><span class="line">[BITS 32]						; 制作32位的机器语言</span><br><span class="line"></span><br><span class="line">; 制作目标文件的信息</span><br><span class="line">[FILE &quot;naskfunc.nas&quot;]   ; 源文件名称</span><br><span class="line">		GLOBAL	_io_hlt     ; 函数名</span><br><span class="line"></span><br><span class="line">; 函数的实现</span><br><span class="line">[SECTION .text]		; text段，储存程序代码</span><br><span class="line">_io_hlt:	; void io_hlt(void);</span><br><span class="line">		HLT</span><br><span class="line">		RET</span><br></pre></td></tr></table></figure><h2 id="3-4-BIOS介绍"><a href="#3-4-BIOS介绍" class="headerlink" title="3.4. BIOS介绍"></a>3.4. BIOS介绍</h2><ul><li>BIOS是使用16位机器语言，32位模式不能调用BIOS函数</li><li>VRAM（video RAM）在当前画面模式下是<code>0xa0000 ~ 0xaffff</code>，这个是在BIOS文档中<code>INT 0x10</code>说明最后写着</li></ul><h3 id="1-BIOS函数"><a href="#1-BIOS函数" class="headerlink" title="1) BIOS函数"></a>1) BIOS函数</h3><h4 id="1-0x10-设置画面模式"><a href="#1-0x10-设置画面模式" class="headerlink" title="(1) 0x10 设置画面模式"></a>(1) 0x10 设置画面模式</h4><ul><li>设置AH寄存器为00</li><li>设置AL寄存器为下面的值（省略部分模式）<ul><li>0x03: 16色字符模式，80 x 25</li><li>0x12: VGA图形模式，640 x 480 x 4位彩色模式，独特的4面储存模式</li><li>0x13: VGA图形模式，320 x 200 x 8位彩色模式，调色板模式</li><li>0x12: VGA图形模式，800 x 600 x 4位彩色模式，独特的4面储存模式（部分显卡不支持此模式）</li></ul></li><li>无返回值</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">; 设置屏幕模式</span><br><span class="line">MOV		AL,0x13			; VGA图形，320 x 200 x 8位颜色</span><br><span class="line">MOV		AH,0x00</span><br><span class="line">INT		0x10</span><br></pre></td></tr></table></figure><h2 id="3-5-cpu介绍"><a href="#3-5-cpu介绍" class="headerlink" title="3.5. cpu介绍"></a>3.5. cpu介绍</h2><ul><li>为什么写程序使用<code>i486p</code>，这个是cpu指令集</li><li>i486p是给486cpu使用，但是如果只是用16位寄存器，也可以8086用</li><li>intel系列cpu家谱</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8086-&gt;80186-&gt;286-&gt;386-&gt;486-&gt;Pentium-&gt;PentiumPro-&gt;PentiumII-&gt;PentiumIII-&gt;Pentium4-&gt;...</span><br></pre></td></tr></table></figure><ul><li>到286为止是16位cpu，386之后为32位</li></ul><h1 id="第4天"><a href="#第4天" class="headerlink" title="第4天"></a>第4天</h1><h2 id="1-图形化界面"><a href="#1-图形化界面" class="headerlink" title="1. 图形化界面"></a>1. 图形化界面</h2><p>参考<a href="/blogs/2021-03-22-linux-kernel">linux-kernel启动过程</a></p><h2 id="2-调色板"><a href="#2-调色板" class="headerlink" title="2. 调色板"></a>2. 调色板</h2><ul><li>调色板是显卡的一个模块，由于颜色只有8位，也就是256色，但是正常RGB有24位</li><li>所以我们可以给显卡设置256种颜色，0-255分别表示一种颜色</li><li><strong><font color="red">在用的时候直接设置对应内存为一个号码，显卡就会直接将对应位置显示成对应的颜色</font></strong></li><li>但是cpu中断和调色板的io存取需要使用汇编来实现，c语言无法实现</li></ul><p><strong>设置调色板</strong></p><ul><li>先屏蔽中断</li><li>将想要设置的号码（0-255）写入到<code>0x03c8</code></li><li>然后按照RGB的顺序写入<code>0x03c9</code>，想要继续设定，就直接继续写就行了</li><li>想要读出来对应号码的RGB，将号码写入到<code>0x03c7</code>，再从<code>0x03c9</code>读取3次。同理继续读就是下一个号码</li><li>最后恢复中断位</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_palette</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end, <span class="type">unsigned</span> <span class="type">char</span> *rgb)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i, eflags;</span><br><span class="line">    eflags = <span class="built_in">io_load_eflags</span>(); <span class="comment">/* 记录终端许可标志的值 */</span></span><br><span class="line">    <span class="built_in">io_cli</span>();                  <span class="comment">/* 将许可标志置0，禁止中断 */</span></span><br><span class="line">    <span class="built_in">io_out8</span>(<span class="number">0x03c8</span>, start);</span><br><span class="line">    <span class="keyword">for</span> (i = start; i &lt;= end; i++) &#123;</span><br><span class="line">        <span class="built_in">io_out8</span>(<span class="number">0x03c9</span>, rgb[<span class="number">0</span>] / <span class="number">4</span>);    <span class="comment">// R</span></span><br><span class="line">        <span class="built_in">io_out8</span>(<span class="number">0x03c9</span>, rgb[<span class="number">1</span>] / <span class="number">4</span>);    <span class="comment">// G</span></span><br><span class="line">        <span class="built_in">io_out8</span>(<span class="number">0x03c9</span>, rgb[<span class="number">2</span>] / <span class="number">4</span>);    <span class="comment">// B</span></span><br><span class="line">        rgb += <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">io_store_eflags</span>(eflags); <span class="comment">/* 恢复许可标志 */</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="第5天"><a href="#第5天" class="headerlink" title="第5天"></a>第5天</h1><h2 id="1-字符点阵"><a href="#1-字符点阵" class="headerlink" title="1. 字符点阵"></a>1. 字符点阵</h2><ul><li>假设一个字符占用像素点为8x16，那么可以使用<code>char[16]</code>表示一个字符的点阵</li><li>作者找其他人要了一个<code>hankaku.txt</code>里面包含了<code>char</code>里面所有可见字符的点阵，总共由256个字符，占用4096个字节</li><li>在对应的vram位置设置color就可以直接显示字符</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由hankaku.txt编译而来</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> hankaku[<span class="number">4096</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 输入一个字符</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param vram 显示内存起始位置</span></span><br><span class="line"><span class="comment"> * @param xsize 屏幕的宽度，因为要换行显示，需要知道宽度</span></span><br><span class="line"><span class="comment"> * @param x 位置x</span></span><br><span class="line"><span class="comment"> * @param y 位置y</span></span><br><span class="line"><span class="comment"> * @param color 字体颜色</span></span><br><span class="line"><span class="comment"> * @param c 字符</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">put_font8</span><span class="params">(<span class="type">char</span> *vram, <span class="type">int</span> xsize, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">char</span> color, <span class="type">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="type">char</span> *font8 = hankaku + c * <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">16</span>; ++i) &#123;</span><br><span class="line">        <span class="comment">// 找到对应行的最左边</span></span><br><span class="line">        <span class="type">char</span> *p = vram + (y + i) * xsize + x;</span><br><span class="line">        <span class="type">char</span> tmp = font8[i];</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">8</span>; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((tmp &amp; (<span class="number">0x80</span> &gt;&gt; j)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                p[j] = color;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-GDT和IDT"><a href="#2-GDT和IDT" class="headerlink" title="2. GDT和IDT"></a>2. GDT和IDT</h2><h3 id="2-1-分段"><a href="#2-1-分段" class="headerlink" title="2.1. 分段"></a>2.1. 分段</h3><ul><li>因为操作系统可以执行多个进程，但是每个进程使用的内存是独立的，需要使用分段让每个进程使用的内存隔开</li></ul><h3 id="2-2-GDT-global-segment-descriptor-table"><a href="#2-2-GDT-global-segment-descriptor-table" class="headerlink" title="2.2. GDT: global segment descriptor table"></a>2.2. GDT: global segment descriptor table</h3><ul><li>全局段记录表</li><li>段寄存器是16位，一位一个字节。一个段描述结构体是8个字节占用3位，所以低三位不能用，只有13位，一共8192个段描述结构体组成表</li><li>段寄存器可以指示65536个字节（64KB），cpu没这么大内存存储，所以需要放到内存里面，我们可以任意指定一块内存，将首地址和个数信息放到GDTR寄存器中就好了</li><li>段描述结构体见下面定义，来自于cpu手册，一共8个字节</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 8 byte segment descriptor */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">desc_struct</span> &#123;</span><br><span class="line">    u16 limit0;         <span class="comment">// 段管理的内存上限low</span></span><br><span class="line">    u16 base0;          <span class="comment">// 段的对应的内存实际地址low</span></span><br><span class="line">    u16 base1 : <span class="number">8</span>;      <span class="comment">// 段的对应的内存实际地址mid</span></span><br><span class="line">    u16 type : <span class="number">4</span>;</span><br><span class="line">    u16 s : <span class="number">1</span>;          <span class="comment">// 系统段为1，普通段为0</span></span><br><span class="line">    u16 dpl : <span class="number">2</span>;</span><br><span class="line">    u16 p : <span class="number">1</span>;</span><br><span class="line">    u16 limit1 : <span class="number">4</span>;     <span class="comment">// 段管理的内存上限low</span></span><br><span class="line">    u16 avl : <span class="number">1</span>;</span><br><span class="line">    u16 l : <span class="number">1</span>;</span><br><span class="line">    u16 d : <span class="number">1</span>;</span><br><span class="line">    u16 g : <span class="number">1</span>;          <span class="comment">// 为1就是4K为单位定义上限（上限1，管理内存4K），为0则以一个字节为单位</span></span><br><span class="line">    u16 base2 : <span class="number">8</span>;      <span class="comment">// 段的对应的内存实际地址high</span></span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure><ul><li>随意取内存一段地址 <code>0x00270000 - 0x0027ffff</code> 这一段存储</li><li>将所有段初始化成全0</li><li>将段号1设置位cpu管理段，在内存的地址为0，大小为4GB，为32位内管理的最大内存，可读可写</li><li>段号为2的设置为<code>bootpack.hrb</code>程序所在的内存段，地址在0x00280000，大小512K，可读可执行</li><li>最后通过汇编导出的函数写入GDTR，因为c语言无法设置GDTR</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ADR_GDT 0x00270000       <span class="comment">// GDT的内存位置</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIMIT_GDT 0x0000ffff     <span class="comment">// GDT占用的字节数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADR_BOTPAK 0x00280000    <span class="comment">// bootpack.hrb所在的地址</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIMIT_BOTPAK 0x0007ffff  <span class="comment">// bootpack.hrb最大为512k</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AR_DATA32_RW 0x4092      <span class="comment">// 数据段，可读写</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AR_CODE32_ER 0x409a      <span class="comment">// 代码段，可读可执行，不可写</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">set_segmdesc</span><span class="params">(<span class="keyword">struct</span> SEGMENT_DESCRIPTOR *sd, <span class="type">unsigned</span> <span class="type">int</span> limit, <span class="type">int</span> base, <span class="type">int</span> ar)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (limit &gt; <span class="number">0xfffff</span>) &#123;</span><br><span class="line">        ar |= <span class="number">0x8000</span>; <span class="comment">/* G_bit = 1 */</span></span><br><span class="line">        limit /= <span class="number">0x1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sd-&gt;limit_low = limit &amp; <span class="number">0xffff</span>;</span><br><span class="line">    sd-&gt;base_low = base &amp; <span class="number">0xffff</span>;</span><br><span class="line">    sd-&gt;base_mid = (base &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">    sd-&gt;access_right = ar &amp; <span class="number">0xff</span>;</span><br><span class="line">    sd-&gt;limit_high = ((limit &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0x0f</span>) | ((ar &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xf0</span>);</span><br><span class="line">    sd-&gt;base_high = (base &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_gdtidt</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">SEGMENT_DESCRIPTOR</span> *gdt = (<span class="keyword">struct</span> SEGMENT_DESCRIPTOR *)ADR_GDT;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">GATE_DESCRIPTOR</span> *idt = (<span class="keyword">struct</span> GATE_DESCRIPTOR *)ADR_IDT;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化GDT</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; LIMIT_GDT / <span class="built_in">sizeof</span>(<span class="keyword">struct</span> SEGMENT_DESCRIPTOR); i++) &#123;</span><br><span class="line">        <span class="built_in">set_segmdesc</span>(gdt + i, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cpu管理的总内存</span></span><br><span class="line">    <span class="built_in">set_segmdesc</span>(gdt + <span class="number">1</span>, <span class="number">0xffffffff</span>, <span class="number">0x00000000</span>, AR_DATA32_RW);</span><br><span class="line">    <span class="comment">// bootpack.hrb的段</span></span><br><span class="line">    <span class="built_in">set_segmdesc</span>(gdt + <span class="number">2</span>, LIMIT_BOTPAK, ADR_BOTPAK, AR_CODE32_ER);</span><br><span class="line">    <span class="built_in">load_gdtr</span>(LIMIT_GDT, ADR_GDT);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-IDT-interrupt-descriptor-table"><a href="#2-3-IDT-interrupt-descriptor-table" class="headerlink" title="2.3. IDT: interrupt descriptor table"></a>2.3. IDT: interrupt descriptor table</h3><ul><li>中断记录表，结构定义在cpu手册中</li></ul><img src="2022-10-24-01.png"><ul><li>代码定义的结构</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">idt_bits</span> &#123;</span><br><span class="line">    u16 ist : <span class="number">3</span>;</span><br><span class="line">    u16 zero : <span class="number">5</span>;</span><br><span class="line">    u16 type : <span class="number">5</span>;</span><br><span class="line">    u16 dpl : <span class="number">2</span>;    <span class="comment">// Descriptor Privilege Level</span></span><br><span class="line">    u16 p : <span class="number">1</span>;</span><br><span class="line">&#125; __attribute__((packed));</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">gate_struct</span> &#123;</span><br><span class="line">    u16 offset_low;         <span class="comment">// 函数在段内的偏移地址low</span></span><br><span class="line">    u16 segment;            <span class="comment">// 段配置对应的偏移，比如第2号段，就是 2 * 8，一个段配置8个字节</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">idt_bits</span> bits;</span><br><span class="line">    u16 offset_middle;      <span class="comment">// 函数在段内的偏移地址mid</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_X86_64</span></span><br><span class="line">    u32 offset_high;</span><br><span class="line">    u32 reserved;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure><h3 id="2-4-GDT、IDT、LDT和TSS的关系"><a href="#2-4-GDT、IDT、LDT和TSS的关系" class="headerlink" title="2.4. GDT、IDT、LDT和TSS的关系"></a>2.4. GDT、IDT、LDT和TSS的关系</h3><ul><li>GDT，IDT都是全局的。LDT是局部的（在GDT中有它的描述符）</li><li>GDT用来存储描述符（门或非门）；系统中几个CPU,就有几个GDT</li><li>IDT整个系统只有一个</li><li>系统启动时候需要初始化GDT和IDT。LDT和进程相关，并不一定必有</li><li>TSS: Task-State Segment，任务状态段，保存任务状态信息的系统段</li><li>TSS只能存在于GDT中</li><li>Task-Gate Descriptor，任务门描述符，用来间接的宝玉引用任务。可以放到GDT、LDT、IDT中，里面的TSS段选择指向GDT的TSS描述符</li><li>下图为32位TSS结构</li></ul><img src="2022-10-24-03.png"><ul><li>下图为64位TSS结构</li></ul><img src="2022-10-24-02.png"><h1 id="第六天-中断处理"><a href="#第六天-中断处理" class="headerlink" title="第六天 中断处理"></a>第六天 中断处理</h1><h2 id="1-PIC-Programmable-interrupt-controller"><a href="#1-PIC-Programmable-interrupt-controller" class="headerlink" title="1. PIC: Programmable interrupt controller"></a>1. PIC: Programmable interrupt controller</h2><ul><li>可编程中断控制器</li><li>就是一个芯片，将8个中断信号合成一个中断信号输出给cpu</li><li>当前电脑上不止8个外部设备，所以使用两个pic合并成15个中断信号（主PIC的IRQ2被从PIC占据）</li></ul><img src="2022-10-23-01.png"><ul><li>PIC是外部设备，不能直接使用C语言的等于赋值，需要使用<code>io_out8</code></li><li>主从PIC的寄存器赋值需要使用端口进行，具体端口定义如下</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PIC0_ICW1 0x0020    <span class="comment">// initial controlword，初始化控制数据。用于设置中断的模式，0x11为边沿触发</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC0_OCW2 0x0020    <span class="comment">// 用于通知PIC已经收到某中断，0x60+IRQ号即可，IRQ1就是0x61</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC0_IMR 0x0021     <span class="comment">// interrupt maskregister，中断屏蔽寄存器，8位对应8路中断信号，为1就屏蔽</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC0_ICW2 0x0021    <span class="comment">// 中断号的起始，设置为0x20，0-7号IRQ触发的中断号为0x20-0x27</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC0_ICW3 0x0021    <span class="comment">// 控制主从设定，第几位为1就代表几号IRQ和从PIC相连，当前cpu写死使用0x00000100，也就是IRQ2</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC0_ICW4 0x0021    <span class="comment">// 用于设置中断模式，0x01为无缓冲区模式</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC1_ICW1 0x00a0    <span class="comment">// 用于设置中断的模式，0x11为边沿触发</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC1_OCW2 0x00a0    <span class="comment">// 用于通知PIC已经收到某中断，设置这个同时也要设置PIC0_OCW2，0x62</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC1_IMR 0x00a1     <span class="comment">// interrupt maskregister，中断屏蔽寄存器，8位对应8路中断信号，为1就屏蔽</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC1_ICW2 0x00a1    <span class="comment">// 中断号的起始，设置为0x28，0-7号IRQ（对应主PIC的8-15号IRQ）触发的中断号为0x28-0x2f</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC1_ICW3 0x00a1    <span class="comment">// 仅用低3位表示和主设备的几号IRQ相连，当前写死为2，为主PIC的IRQ2</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIC1_ICW4 0x00a1    <span class="comment">// 用于设置中断模式，0x01为无缓冲区模式</span></span></span><br></pre></td></tr></table></figure><ul><li><code>0x00-0x1f</code>中断号不能使用，是cpu内部用于产生错误的中断号，所以从0x20开始</li><li>设置PIC的代码如下</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_pic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">io_out8</span>(PIC0_IMR, <span class="number">0xff</span>);  <span class="comment">// 禁止所有中断</span></span><br><span class="line">    <span class="built_in">io_out8</span>(PIC1_IMR, <span class="number">0xff</span>);  <span class="comment">// 禁止所有中断</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">io_out8</span>(PIC0_ICW1, <span class="number">0x11</span>);    <span class="comment">// 边沿触发模式</span></span><br><span class="line">    <span class="built_in">io_out8</span>(PIC0_ICW2, <span class="number">0x20</span>);    <span class="comment">// IRQ0-7由INT20-27接收</span></span><br><span class="line">    <span class="built_in">io_out8</span>(PIC0_ICW3, <span class="number">1</span> &lt;&lt; <span class="number">2</span>);  <span class="comment">// PIC1由IRQ2连接</span></span><br><span class="line">    <span class="built_in">io_out8</span>(PIC0_ICW4, <span class="number">0x01</span>);    <span class="comment">// 无缓冲区模式</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">io_out8</span>(PIC1_ICW1, <span class="number">0x11</span>);    <span class="comment">// 边沿触发模式</span></span><br><span class="line">    <span class="built_in">io_out8</span>(PIC1_ICW2, <span class="number">0x28</span>);    <span class="comment">// IRQ8-15由INT28-2f接收</span></span><br><span class="line">    <span class="built_in">io_out8</span>(PIC1_ICW3, <span class="number">1</span> &lt;&lt; <span class="number">1</span>);  <span class="comment">// PIC1由IRQ2连接</span></span><br><span class="line">    <span class="built_in">io_out8</span>(PIC1_ICW4, <span class="number">0x01</span>);    <span class="comment">// 无缓冲区模式</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">io_out8</span>(PIC0_IMR, <span class="number">0xfb</span>);  <span class="comment">// 11111011 PIC1以外全部禁止</span></span><br><span class="line">    <span class="built_in">io_out8</span>(PIC1_IMR, <span class="number">0xff</span>);  <span class="comment">// 禁止所有中断</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-中断号对应的中断类型"><a href="#2-中断号对应的中断类型" class="headerlink" title="2. 中断号对应的中断类型"></a>2. 中断号对应的中断类型</h2><table><thead><tr><th>硬件中断号</th><th>系统中断号</th><th>用途</th></tr></thead><tbody><tr><td>IRQ0</td><td>INT20</td><td></td></tr><tr><td>IRQ1</td><td>INT21</td><td>PS&#x2F;2键盘</td></tr><tr><td>IRQ2</td><td>INT22</td><td>PIC1的中断</td></tr><tr><td>IRQ3</td><td>INT23</td><td></td></tr><tr><td>IRQ4</td><td>INT24</td><td></td></tr><tr><td>IRQ5</td><td>INT25</td><td></td></tr><tr><td>IRQ6</td><td>INT26</td><td></td></tr><tr><td>IRQ7</td><td>INT27</td><td>初始化PIC可能引发的中断</td></tr><tr><td>IRQ8</td><td>INT28</td><td></td></tr><tr><td>IRQ9</td><td>INT29</td><td></td></tr><tr><td>IRQ10</td><td>INT2a</td><td></td></tr><tr><td>IRQ11</td><td>INT2b</td><td></td></tr><tr><td>IRQ12</td><td>INT2c</td><td>PS&#x2F;2鼠标</td></tr><tr><td>IRQ13</td><td>INT2d</td><td></td></tr><tr><td>IRQ14</td><td>INT2e</td><td></td></tr><tr><td>IRQ15</td><td>INT2f</td><td></td></tr></tbody></table><h2 id="3-注册中断函数"><a href="#3-注册中断函数" class="headerlink" title="3. 注册中断函数"></a>3. 注册中断函数</h2><ul><li>也就是将中断函数地址写入idt中</li><li>找到对应中断号对应的idt地址，将函数地址和对应的段号放进去，设置标志位即可</li><li>由于中断最终要调用IRETD汇编指令退出，所以使用汇编函数调用c函数的方式来进行，并在里面存储了中断打断的进程的上下文信息</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册中断处理函数</span></span><br><span class="line"><span class="built_in">set_gatedesc</span>(idt + <span class="number">0x21</span>, (<span class="type">int</span>)asm_inthandler21, <span class="number">2</span> * <span class="number">8</span>, AR_INTGATE32);</span><br><span class="line"><span class="built_in">set_gatedesc</span>(idt + <span class="number">0x27</span>, (<span class="type">int</span>)asm_inthandler27, <span class="number">2</span> * <span class="number">8</span>, AR_INTGATE32);</span><br><span class="line"><span class="built_in">set_gatedesc</span>(idt + <span class="number">0x2c</span>, (<span class="type">int</span>)asm_inthandler2c, <span class="number">2</span> * <span class="number">8</span>, AR_INTGATE32);</span><br></pre></td></tr></table></figure><h2 id="4-中断处理"><a href="#4-中断处理" class="headerlink" title="4. 中断处理"></a>4. 中断处理</h2><ul><li>中断中尽可能少执行代码，所以将中断数据放到全局变量中，在外部进程上下文中读取变量进行处理</li></ul><h1 id="第七天-FIFO与鼠标控制"><a href="#第七天-FIFO与鼠标控制" class="headerlink" title="第七天 FIFO与鼠标控制"></a>第七天 FIFO与鼠标控制</h1><h2 id="1-鼠标键盘数据读取"><a href="#1-鼠标键盘数据读取" class="headerlink" title="1. 鼠标键盘数据读取"></a>1. 鼠标键盘数据读取</h2><ul><li>鼠标键盘都属于键盘控制电路，数据获取都在端口<code>0x0060</code></li><li>只能通过中断号来判断此端口数据是属于鼠标还是键盘</li></ul><h2 id="2-fifo"><a href="#2-fifo" class="headerlink" title="2. fifo"></a>2. fifo</h2><ul><li>由于中断数据可能很多，所以需要使用fifo进行存取，防止数据丢失</li><li>fifo自己参考linux的实现，没有使用书上的实现，具体原理查看 <a href="/bookPages/docs/linux-kernel/data-structures/kfifo/">linux源码分析-kfifo</a></li></ul><h2 id="3-鼠标初始化"><a href="#3-鼠标初始化" class="headerlink" title="3. 鼠标初始化"></a>3. 鼠标初始化</h2><ul><li>由于一开始鼠标并不是必须品，后来鼠标才加入</li><li>鼠标加入后，当时使用者并不怎么使用，为了防止频繁中断，将鼠标控制默认关闭了</li><li>所以想要使用鼠标，还需要进行特定操作进行激活鼠标</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PORT_KEYDAT 0x0060</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT_KEYSTA 0x0064</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT_KEYCMD 0x0064</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEYSTA_SEND_NOTREADY 0x02</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEYCMD_WRITE_MODE 0x60</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KBC_MODE 0x47</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 等待键盘控制器可以发送数据</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wait_KBC_sendready</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="built_in">io_in8</span>(PORT_KEYSTA) &amp; KEYSTA_SEND_NOTREADY) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 键盘控制器的初始化</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_keyboard</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">wait_KBC_sendready</span>();</span><br><span class="line">    <span class="built_in">io_out8</span>(PORT_KEYCMD, KEYCMD_WRITE_MODE);</span><br><span class="line">    <span class="built_in">wait_KBC_sendready</span>();</span><br><span class="line">    <span class="built_in">io_out8</span>(PORT_KEYDAT, KBC_MODE);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEYCMD_SENDTO_MOUSE 0xd4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOUSECMD_ENABLE 0xf4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 使能鼠标</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">enable_mouse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">wait_KBC_sendready</span>();</span><br><span class="line">    <span class="built_in">io_out8</span>(PORT_KEYCMD, KEYCMD_SENDTO_MOUSE);</span><br><span class="line">    <span class="built_in">wait_KBC_sendready</span>();</span><br><span class="line">    <span class="built_in">io_out8</span>(PORT_KEYDAT, MOUSECMD_ENABLE);</span><br><span class="line">    <span class="comment">// 如果成功，就会发送ACK(0xfa)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="第八天-鼠标控制与32位模式切换"><a href="#第八天-鼠标控制与32位模式切换" class="headerlink" title="第八天 鼠标控制与32位模式切换"></a>第八天 鼠标控制与32位模式切换</h1><h2 id="1-鼠标数据解读"><a href="#1-鼠标数据解读" class="headerlink" title="1. 鼠标数据解读"></a>1. 鼠标数据解读</h2><ul><li>鼠标使能后会先发送<code>0xfa</code>数据，然后会连续三个中断发送三个字节数据</li></ul></div><div class="reward-container"><div></div><button onclick='var qr=document.getElementById("qr");qr.style.display="none"===qr.style.display?"block":"none"'>打赏</button><div id="qr" style="display:none"><div style="display:inline-block"><img src="/images/wechatpay.png" alt="王钰博 微信支付"><p>微信支付</p></div><div style="display:inline-block"><img src="/images/alipay.jpg" alt="王钰博 支付宝"><p>支付宝</p></div></div></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-item"><a href="/blogs/2019-04-25-assemblyLanguage/" rel="prev" title="汇编语言学习笔记"><i class="fa fa-chevron-left"></i> 汇编语言学习笔记</a></div><div class="post-nav-item"><a href="/blogs/2019-05-28-paperWriting/" rel="next" title="论文书写的重点">论文书写的重点 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="valine-comments"></div><script>window.addEventListener("tabs:register",()=>{let{activeClass:t}=CONFIG.comments;if(CONFIG.comments.storage&&(t=localStorage.getItem("comments_active")||t),t){let e=document.querySelector(`a[href="#comment-${t}"]`);e&&e.click()}}),CONFIG.comments.storage&&window.addEventListener("tabs:click",t=>{if(!t.target.matches(".tabs-comment .tab-content .tab-pane"))return;let e=t.target.classList[1];localStorage.setItem("comments_active",e)})</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E8%AF%8D%E8%A7%A3%E9%87%8A"><span class="nav-text">关键词解释</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC1%E5%A4%A9"><span class="nav-text">第1天</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-vmware%E5%90%AF%E5%8A%A8img"><span class="nav-text">1.1. vmware启动img</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC2%E5%A4%A9"><span class="nav-text">第2天</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-%E6%A0%87%E5%87%86FAT12%E8%BD%AF%E7%9B%98%E6%A0%BC%E5%BC%8F"><span class="nav-text">2.1. 标准FAT12软盘格式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-%E6%B1%87%E7%BC%96%E4%BB%A3%E8%A1%A8%E6%80%A7%E5%AF%84%E5%AD%98%E5%99%A8%E4%BB%8B%E7%BB%8D"><span class="nav-text">2.2. 汇编代表性寄存器介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#16%E4%BD%8D%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-text">16位寄存器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8%E4%BD%8D%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-text">8位寄存器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#32%E4%BD%8D%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-text">32位寄存器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%8C16%E4%BD%8D"><span class="nav-text">段寄存器，16位</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-CPU%E5%92%8C%E5%86%85%E5%AD%98"><span class="nav-text">2.3. CPU和内存</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC3%E5%A4%A9"><span class="nav-text">第3天</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-%E8%BD%AF%E7%9B%98%E6%9E%84%E6%88%90"><span class="nav-text">3.1. 软盘构成</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E8%BD%AF%E7%9B%98%E4%BF%9D%E5%AD%98%E6%96%87%E4%BB%B6"><span class="nav-text">(1) 软盘保存文件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-%E5%86%85%E5%AD%98%E5%AF%BB%E5%9D%80"><span class="nav-text">3.2. 内存寻址</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-%E6%B1%87%E7%BC%96%E5%92%8CC%E8%AF%AD%E8%A8%80%E9%93%BE%E6%8E%A5"><span class="nav-text">3.3. 汇编和C语言链接</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4-BIOS%E4%BB%8B%E7%BB%8D"><span class="nav-text">3.4. BIOS介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-BIOS%E5%87%BD%E6%95%B0"><span class="nav-text">1) BIOS函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-0x10-%E8%AE%BE%E7%BD%AE%E7%94%BB%E9%9D%A2%E6%A8%A1%E5%BC%8F"><span class="nav-text">(1) 0x10 设置画面模式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-5-cpu%E4%BB%8B%E7%BB%8D"><span class="nav-text">3.5. cpu介绍</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC4%E5%A4%A9"><span class="nav-text">第4天</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%95%8C%E9%9D%A2"><span class="nav-text">1. 图形化界面</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E8%B0%83%E8%89%B2%E6%9D%BF"><span class="nav-text">2. 调色板</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC5%E5%A4%A9"><span class="nav-text">第5天</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%AD%97%E7%AC%A6%E7%82%B9%E9%98%B5"><span class="nav-text">1. 字符点阵</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-GDT%E5%92%8CIDT"><span class="nav-text">2. GDT和IDT</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E5%88%86%E6%AE%B5"><span class="nav-text">2.1. 分段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-GDT-global-segment-descriptor-table"><span class="nav-text">2.2. GDT: global segment descriptor table</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-IDT-interrupt-descriptor-table"><span class="nav-text">2.3. IDT: interrupt descriptor table</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-GDT%E3%80%81IDT%E3%80%81LDT%E5%92%8CTSS%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-text">2.4. GDT、IDT、LDT和TSS的关系</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%85%AD%E5%A4%A9-%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86"><span class="nav-text">第六天 中断处理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-PIC-Programmable-interrupt-controller"><span class="nav-text">1. PIC: Programmable interrupt controller</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E4%B8%AD%E6%96%AD%E5%8F%B7%E5%AF%B9%E5%BA%94%E7%9A%84%E4%B8%AD%E6%96%AD%E7%B1%BB%E5%9E%8B"><span class="nav-text">2. 中断号对应的中断类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E6%B3%A8%E5%86%8C%E4%B8%AD%E6%96%AD%E5%87%BD%E6%95%B0"><span class="nav-text">3. 注册中断函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86"><span class="nav-text">4. 中断处理</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%83%E5%A4%A9-FIFO%E4%B8%8E%E9%BC%A0%E6%A0%87%E6%8E%A7%E5%88%B6"><span class="nav-text">第七天 FIFO与鼠标控制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E9%BC%A0%E6%A0%87%E9%94%AE%E7%9B%98%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%8F%96"><span class="nav-text">1. 鼠标键盘数据读取</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-fifo"><span class="nav-text">2. fifo</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E9%BC%A0%E6%A0%87%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">3. 鼠标初始化</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%85%AB%E5%A4%A9-%E9%BC%A0%E6%A0%87%E6%8E%A7%E5%88%B6%E4%B8%8E32%E4%BD%8D%E6%A8%A1%E5%BC%8F%E5%88%87%E6%8D%A2"><span class="nav-text">第八天 鼠标控制与32位模式切换</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E9%BC%A0%E6%A0%87%E6%95%B0%E6%8D%AE%E8%A7%A3%E8%AF%BB"><span class="nav-text">1. 鼠标数据解读</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="王钰博" src="/images/12.jpg"><p class="site-author-name" itemprop="name">王钰博</p><div class="site-description" itemprop="description">个人博客</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">122</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">22</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">14</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/Githubwyb" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Githubwyb" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:1061322005@qq.com" title="E-Mail → mailto:1061322005@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a></span></div><div class="links-of-blogroll motion-element"><div class="links-of-blogroll-title"><i class="fa fa-fw fa-link"></i> 友情链接</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="https://githubwyb.github.io/bookPages/" title="https:&#x2F;&#x2F;githubwyb.github.io&#x2F;bookPages&#x2F;">markdown books</a></li></ul></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="beian"><a href="http://www.beian.miit.gov.cn/" rel="noopener" target="_blank">豫ICP备16023189号 </a><img src="/images/beian.png" style="display:inline-block"></div><div class="copyright">&copy; <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">王钰博</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-area-chart"></i> </span><span title="站点总字数">919k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span title="站点阅读时长">13:56</span></div><div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动</div><div class="addthis_inline_share_toolbox"><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e1986d4e4e2d132" async></script></div><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-divider">|</span> <span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer></div><script src="/lib/anime.min.js"></script><script src="/lib/medium-zoom.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><script src="/js/local-search.js"></script><script>document.querySelectorAll(".pdfobject-container").forEach(e=>{let t=e.dataset.target,a="#"+Object.entries({navpanes:0,toolbar:0,statusbar:0,pagemode:"thumbs",view:"FitH"}).map(([e,t])=>`${e}=${encodeURIComponent(t)}`).join("&"),i=`/lib/pdf/web/viewer.html?file=${encodeURIComponent(t)}${a}`;NexT.utils.supportsPDFs()?e.innerHTML=`<embed class="pdfobject" src="${t+a}" type="application/pdf" style="height: ${e.dataset.height};">`:e.innerHTML=`<iframe src="${i}" style="height: ${e.dataset.height};" frameborder="0"></iframe>`})</script><script>"undefined"==typeof MathJax?(window.MathJax={loader:{source:{"[tex]/amsCd":"[tex]/amscd","[tex]/AMScd":"[tex]/amscd"}},tex:{inlineMath:{"[+]":[["$","$"]]},tags:"ams"},options:{renderActions:{findScript:[10,e=>{document.querySelectorAll('script[type^="math/tex"]').forEach(t=>{const a=!!t.type.match(/; *mode=display/),n=new e.options.MathItem(t.textContent,e.inputJax[0],a),d=document.createTextNode("");t.parentNode.replaceChild(d,t),n.start={node:d,delim:"",n:0},n.end={node:d,delim:"",n:0},e.math.push(n)})},"",!1],insertedScript:[200,()=>{document.querySelectorAll("mjx-container").forEach(e=>{let t=e.parentNode;"li"===t.nodeName.toLowerCase()&&t.parentNode.classList.add("has-jax")})},"",!1]}}},function(){var e=document.createElement("script");e.src="/lib/mathjax/tex-mml-chtml.js",e.defer=!0,document.head.appendChild(e)}()):(MathJax.startup.document.state(0),MathJax.texReset(),MathJax.typeset())</script><script>NexT.utils.loadComments(document.querySelector("#valine-comments"),()=>{NexT.utils.getScript("//unpkg.com/valine/dist/Valine.min.js",()=>{var e=["nick","mail","link"],a="nick,mail";a=a.split(",").filter(a=>e.includes(a)),new Valine({el:"#valine-comments",verify:!1,notify:!1,appId:"qmLbUHV1HOr841BOYkl84riu-gzGzoHsz",appKey:"j4fgTcf1yHRDD5X3HUH5EH95",placeholder:"^_^ happy everyday!",avatar:"wavatar",meta:a,pageSize:"10",visitor:!1,lang:"zh-cn",path:location.pathname,recordIP:!1,serverURLs:""})},window.Valine)})</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":true,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"bottom":-30,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body><script type="text/javascript" src="/lib/jquery-3.4.1.min.js"></script><script type="text/javascript" src="/js/src/love.js"></script></html>