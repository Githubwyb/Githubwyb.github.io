<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.0.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-diy.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-diy.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-diy.png"><link rel="mask-icon" href="/images/logo-diy.svg" color="#222"><meta name="baidu-site-verification" content="y1cfESbTt9nd3LsA"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="/lib/pace/pace-theme-flash.min.css"><script src="/lib/pace/pace.min.js"></script><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"githubwyb.github.io",root:"/",scheme:"Pisces",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:null},back2top:{enable:!0,sidebar:!1,scrollpercent:!0},bookmark:{enable:!0,color:"#ff0000",save:"auto"},fancybox:!1,mediumzoom:!0,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="一、语法1. 对象1.1. 类的大小空类C++标准指出，不允许一个对象（当然包括类对象）的大小为 0，不同的对象不能具有相同的地址。这是由于：  new 需要分配不同的内存地址，不能分配内存大小为 0 的空间 避免除以 sizeof(T)时得到除以 0 错误  故使用 1 个字节来区分空类。结构体与此相同，空结构体大小为 1 个字节 1234567class A&#123;&#125;;class"><meta property="og:type" content="article"><meta property="og:title" content="C++学习笔记"><meta property="og:url" content="https://githubwyb.github.io/blogs/2018-07-06-CppStudy/index.html"><meta property="og:site_name" content="技术的路上奔跑"><meta property="og:description" content="一、语法1. 对象1.1. 类的大小空类C++标准指出，不允许一个对象（当然包括类对象）的大小为 0，不同的对象不能具有相同的地址。这是由于：  new 需要分配不同的内存地址，不能分配内存大小为 0 的空间 避免除以 sizeof(T)时得到除以 0 错误  故使用 1 个字节来区分空类。结构体与此相同，空结构体大小为 1 个字节 1234567class A&#123;&#125;;class"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://githubwyb.github.io/blogs/2018-07-06-CppStudy/2023-02-12-01.png"><meta property="og:image" content="https://githubwyb.github.io/blogs/2018-07-06-CppStudy/2023-02-12-02.png"><meta property="article:published_time" content="2018-07-06T11:23:23.000Z"><meta property="article:modified_time" content="2023-10-15T02:28:27.247Z"><meta property="article:author" content="王钰博"><meta property="article:tag" content="wyb"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://githubwyb.github.io/blogs/2018-07-06-CppStudy/2023-02-12-01.png"><link rel="canonical" href="https://githubwyb.github.io/blogs/2018-07-06-CppStudy/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>C++学习笔记 | 技术的路上奔跑</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">技术的路上奔跑</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">入门</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-fw fa-sitemap"></i>站点地图</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><div class="reading-progress-bar"></div><a role="button" class="book-mark-link book-mark-link-fixed"></a> <a href="https://github.com/Githubwyb" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://githubwyb.github.io/blogs/2018-07-06-CppStudy/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/12.jpg"><meta itemprop="name" content="王钰博"><meta itemprop="description" content="个人博客"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="技术的路上奔跑"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">C++学习笔记</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2018-07-06 19:23:23" itemprop="dateCreated datePublished" datetime="2018-07-06T19:23:23+08:00">2018-07-06</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-10-15 10:28:27" itemprop="dateModified" datetime="2023-10-15T10:28:27+08:00">2023-10-15</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Program/" itemprop="url" rel="index"><span itemprop="name">Program</span></a> </span>， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Program/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a> </span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span id="busuanzi_value_page_pv"></span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><span class="post-meta-item-text">Valine：</span> <a title="valine" href="/blogs/2018-07-06-CppStudy/#valine-comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/blogs/2018-07-06-CppStudy/" itemprop="commentCount"></span></a></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>58k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>53 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="一、语法"><a href="#一、语法" class="headerlink" title="一、语法"></a>一、语法</h1><h2 id="1-对象"><a href="#1-对象" class="headerlink" title="1. 对象"></a>1. 对象</h2><h3 id="1-1-类的大小"><a href="#1-1-类的大小" class="headerlink" title="1.1. 类的大小"></a>1.1. 类的大小</h3><h4 id="空类"><a href="#空类" class="headerlink" title="空类"></a>空类</h4><p>C++标准指出，不允许一个对象（当然包括类对象）的大小为 0，不同的对象不能具有相同的地址。这是由于：</p><ul><li>new 需要分配不同的内存地址，不能分配内存大小为 0 的空间</li><li>避免除以 sizeof(T)时得到除以 0 错误</li></ul><p>故使用 1 个字节来区分空类。结构体与此相同，空结构体大小为 1 个字节</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;<span class="type">int</span> a&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sizeof empty class %d&quot;</span>, <span class="built_in">sizeof</span>(A));     <span class="comment">//输出1，空类大小为1个字节</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sizeof not empty class %d&quot;</span>, <span class="built_in">sizeof</span>(B)); <span class="comment">//输出4，int为4个字节</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="字节对齐"><a href="#字节对齐" class="headerlink" title="字节对齐"></a>字节对齐</h4><p>类中变量大小需要字节对齐，计算大小时需注意</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">char</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sizeof class A %d&quot;</span>, <span class="built_in">sizeof</span>(A));     <span class="comment">//输出8，字节对齐4+4=8字节</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h4><p>静态成员属于类作用域，但不属于类对象，它的生命周期和普通的静态变量一样，程序运行时进行分配内存和初始化，程序结束时则被释放。所以不能在类的构造函数中进行初始化。</p><h5 id="static-成员的优点"><a href="#static-成员的优点" class="headerlink" title="static 成员的优点"></a>static 成员的优点</h5><ul><li>static 成员的名字是在类的作用域中，因此可以避免与其它类成员或全局对象名字冲突。</li><li>可以实施封装，static 成员可以是私有的，而全局对象不可以。</li><li>阅读程序容易看出 static 成员与某个类相关联，这种可见性可以清晰地反映程序员的意图。</li></ul><h5 id="static-成员函数特点"><a href="#static-成员函数特点" class="headerlink" title="static 成员函数特点"></a>static 成员函数特点</h5><ul><li>因为 static 成员函数没有 this 指针，所以静态成员函数不可以访问非静态成员。</li><li>非静态成员函数可以访问静态成员。</li><li>静态数据成员与类的大小无关，因为静态成员只是作用在类的范围而已。</li></ul><h5 id="大小"><a href="#大小" class="headerlink" title="大小"></a>大小</h5><p>静态变量不占用类的大小中，所以 sizeof 输出的大小不包含静态变量的大小</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">char</span> b;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//输出8，字节对齐4+4=8字节，静态变量不参与运算</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sizeof class A %d&quot;</span>, <span class="built_in">sizeof</span>(A));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h4><p>成员函数不算在类的大小中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">char</span> b;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">fun2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//输出8，字节对齐4+4=8字节，成员函数不参与大小计算</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sizeof class A %d&quot;</span>, <span class="built_in">sizeof</span>(A));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-实例化"><a href="#1-2-实例化" class="headerlink" title="1.2. 实例化"></a>1.2. 实例化</h3><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><ul><li>如果不写构造函数，系统会默认初始化一个默认构造函数</li><li>当写了带参数的构造函数（拷贝、移动构造函数均属于带参数的构造函数），系统将不会创建默认构造函数，默认构造函数不可用，除非自己定义</li><li>如果存在无法进行拷贝的成员（如std::mutex），需要显式定义拷贝构造函数，并且不能使用default。不写和使用default在调用拷贝时会编译失败</li><li>对于包含动态分配成员或包含指针成员的类都应该提供拷贝构造函数；在提供拷贝构造函数的同时，还应该考虑重载”&#x3D;”赋值操作符号。</li><li>拷贝构造函数的调用一般为变量初始化时使用另一个变量的复制体构造，拷贝赋值函数为变量已经初始化了，使用另一个变量进行拷贝赋值</li><li>移动构造函数的调用一般为变量初始化时使用右值构造，移动赋值函数为变量已经初始化了，使用右值进行移动赋值</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 无参构造函数</span></span><br><span class="line">    <span class="built_in">A</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="comment">// 有参构造函数</span></span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> n) &#123;&#125;</span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> A &amp;a) = <span class="keyword">default</span>;</span><br><span class="line">    <span class="comment">// 拷贝赋值函数</span></span><br><span class="line">    A &amp;<span class="keyword">operator</span>=(<span class="type">const</span> A &amp;a) = <span class="keyword">default</span>;</span><br><span class="line">    <span class="comment">// 移动构造函数</span></span><br><span class="line">    <span class="built_in">A</span>(A &amp;&amp;a) = <span class="keyword">default</span>;</span><br><span class="line">    <span class="comment">// 移动赋值函数</span></span><br><span class="line">    A &amp;<span class="keyword">operator</span>=(A &amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A var1;                     <span class="comment">// 无参构造</span></span><br><span class="line">    <span class="function">A <span class="title">var2</span><span class="params">(<span class="number">1</span>)</span></span>;                  <span class="comment">// 有参构造</span></span><br><span class="line">    A var3 = var1;              <span class="comment">// 拷贝构造</span></span><br><span class="line">    var3 = var2;                <span class="comment">// 拷贝赋值</span></span><br><span class="line">    A var4 = std::<span class="built_in">move</span>(var1);   <span class="comment">// 移动构造</span></span><br><span class="line">    var4 = std::<span class="built_in">move</span>(var2);     <span class="comment">// 移动赋值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="explicit-关键字"><a href="#explicit-关键字" class="headerlink" title="explicit 关键字"></a>explicit 关键字</h5><ul><li>禁止构造函数的隐式调用，即非预期的转换</li><li>单参数构造函数会要求声明，多参数可选，无参不需要</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> n) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a = <span class="number">10</span>;   <span class="comment">// 隐式调用构造函数</span></span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;    <span class="comment">// 显式调用构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h4><ul><li>析构函数不能写成纯虚函数，因为析构会从子类析构函数向上调用，父类未定义会有问题，编译都放不过</li><li>如果存在继承关系，析构函数要写虚析构，这样会在析构的时候找继承表调用子类析构函数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">A</span>() &#123; <span class="built_in">LOG_INFO</span>(<span class="string">&quot;~A() destructor&quot;</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">B</span>() &#123; <span class="built_in">LOG_INFO</span>(<span class="string">&quot;~B() destructor&quot;</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">C</span>() &#123; <span class="built_in">LOG_INFO</span>(<span class="string">&quot;~C() destructor&quot;</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> C &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">D</span>() &#123; <span class="built_in">LOG_INFO</span>(<span class="string">&quot;~C() destructor&quot;</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argC, <span class="type">char</span> *argV[])</span> </span>&#123;</span><br><span class="line">    A *var1 = <span class="keyword">new</span> <span class="built_in">B</span>();</span><br><span class="line">    <span class="keyword">delete</span> var1;        <span class="comment">// 调用B的析构函数后调用A的析构函数</span></span><br><span class="line"></span><br><span class="line">    C *var2 = <span class="keyword">new</span> <span class="built_in">D</span>();</span><br><span class="line">    <span class="keyword">delete</span> var2;        <span class="comment">// 仅调用C的析构函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用和不适用-new"><a href="#使用和不适用-new" class="headerlink" title="使用和不适用 new"></a>使用和不适用 new</h4><ol><li>用类名创建对象，相当于局部变量，变量在栈上，系统自动销毁。</li><li>使用 new 创建对象，在堆上申请内存，返回指针，需要 delete 进行销毁。</li></ol><h4 id="加不加括号的区别"><a href="#加不加括号的区别" class="headerlink" title="加不加括号的区别"></a>加不加括号的区别</h4><ul><li>类名 对象名<ul><li>默认调用“对象名()”这个构造函数，在栈内存中存在对象名，在堆内存中存在实际对象；</li></ul></li><li>类名 对象名()<ul><li>相当于定义了一个返回值为类的函数，没有任何意义；</li></ul></li><li>类名 对象名(一个或以上个参数)<ul><li>默认调用相应的构造函数，在栈内存中存在对象名，在堆内存中也是存在实际对象的；</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> n) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a1;       <span class="comment">//调用A()实例化对象</span></span><br><span class="line">    <span class="function">A <span class="title">a2</span><span class="params">()</span></span>;     <span class="comment">//定义返回值为A的函数，没有意义</span></span><br><span class="line">    <span class="function">A <span class="title">a3</span><span class="params">(<span class="number">5</span>)</span></span>;    <span class="comment">//调用A(int n)实例化对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="参数是否初始化"><a href="#参数是否初始化" class="headerlink" title="参数是否初始化"></a>参数是否初始化</h4><h5 id="使用-new"><a href="#使用-new" class="headerlink" title="使用 new"></a>使用 new</h5><ul><li>new 一个对象不加括号，如果有默认构造函数则会初始化；没有默认构造函数相当于只分配了内存，灭有初始化</li><li>new 一个对象加括号，有默认构造函数或者没有构造函数会初始化，但是写空的构造函数不会初始化</li><li>带参数的构造函数会先调用不带参数的默认构造函数，参数是否初始化同上</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_a;</span><br><span class="line">    <span class="built_in">A</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> n)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_c;</span><br><span class="line">    <span class="built_in">C</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">C</span>(<span class="type">int</span> n) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argC, <span class="type">char</span>* arg[])</span> </span>&#123;</span><br><span class="line">    A *pA1 = <span class="keyword">new</span> A;</span><br><span class="line">    A *pA2 = <span class="keyword">new</span> <span class="built_in">A</span>();</span><br><span class="line">    A *pA3 = <span class="keyword">new</span> <span class="built_in">A</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;&#x27;A *pA1 = new A;&#x27; is at 0x%p, a %d&quot;</span>, pA1, pA1-&gt;m_a);</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;&#x27;A *pA2 = new A();&#x27; is at 0x%p, a %d&quot;</span>, pA2, pA2-&gt;m_a);</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;&#x27;A *pA3 = new A(5);&#x27; is at 0x%p, a %d&quot;</span>, pA3, pA3-&gt;m_a);</span><br><span class="line"></span><br><span class="line">    B *pB1 = <span class="keyword">new</span> B;</span><br><span class="line">    B *pB2 = <span class="keyword">new</span> <span class="built_in">B</span>();</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;&#x27;B *pB1 = new B;&#x27; is at 0x%p, b %d&quot;</span>, pB1, pB1-&gt;m_b);</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;&#x27;B *pB2 = new B();&#x27; is at 0x%p, b %d&quot;</span>, pB2, pB2-&gt;m_b);</span><br><span class="line"></span><br><span class="line">    C *pC1 = <span class="keyword">new</span> C;</span><br><span class="line">    C *pC2 = <span class="keyword">new</span> <span class="built_in">C</span>();</span><br><span class="line">    C *pC3 = <span class="keyword">new</span> <span class="built_in">C</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;&#x27;C *pC1 = new C;&#x27; is at 0x%p, c %d&quot;</span>, pC1, pC1-&gt;m_c);</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;&#x27;C *pC2 = new C();&#x27; is at 0x%p, c %d&quot;</span>, pC2, pC2-&gt;m_c);</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;&#x27;C *pC3 = new C(5);&#x27; is at 0x%p, c %d&quot;</span>, pC3, pC3-&gt;m_c);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> pA1;</span><br><span class="line">    <span class="keyword">delete</span> pA2;</span><br><span class="line">    <span class="keyword">delete</span> pA3;</span><br><span class="line">    <span class="keyword">delete</span> pB1;</span><br><span class="line">    <span class="keyword">delete</span> pB2;</span><br><span class="line">    <span class="keyword">delete</span> pC1;</span><br><span class="line">    <span class="keyword">delete</span> pC2;</span><br><span class="line">    <span class="keyword">delete</span> pC3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x27;A *pA1 = new A;&#x27; is at 0x0x55575e582e70, a 0</span><br><span class="line">&#x27;A *pA2 = new A();&#x27; is at 0x0x55575e582e90, a 0</span><br><span class="line">&#x27;A *pA3 = new A(5);&#x27; is at 0x0x55575e582eb0, a 0</span><br><span class="line">&#x27;B *pB1 = new B;&#x27; is at 0x0x55575e583590, b 1413816944</span><br><span class="line">&#x27;B *pB2 = new B();&#x27; is at 0x0x55575e5835b0, b 0</span><br><span class="line">&#x27;C *pC1 = new C;&#x27; is at 0x0x55575e5835d0, c 1413815456</span><br><span class="line">&#x27;C *pC2 = new C();&#x27; is at 0x0x55575e5835f0, c 1413815456</span><br><span class="line">&#x27;C *pC3 = new C(5);&#x27; is at 0x0x55575e583610, c 1413815456</span><br></pre></td></tr></table></figure><h3 id="1-3-new-和-malloc-的区别"><a href="#1-3-new-和-malloc-的区别" class="headerlink" title="1.3. new 和 malloc 的区别"></a>1.3. new 和 malloc 的区别</h3><table><thead><tr><th>特征</th><th>new&#x2F;delete</th><th>malloc&#x2F;free</th></tr></thead><tbody><tr><td>分配内存的位置</td><td>自由存储区</td><td>堆</td></tr><tr><td>内存分配失败返回值</td><td>完整类型指针</td><td><code>void*</code></td></tr><tr><td>内存分配失败返回值</td><td>默认抛出异常</td><td>返回 NULL</td></tr><tr><td>分配内存的大小</td><td>由编译器根据类型计算得出</td><td>必须显式指定字节数</td></tr><tr><td>处理数组</td><td>有处理数组的 new 版本 new[]</td><td>需要用户计算数组的大小后进行内存分配</td></tr><tr><td>已分配内存的扩充</td><td>无法直观地处理</td><td>使用 realloc 简单完成</td></tr><tr><td>是否相互调用</td><td>可以，看具体的 operator new&#x2F;delete 实现</td><td>不可调用 new</td></tr><tr><td>分配内存时内存不足</td><td>客户能够指定处理函数或重新制定分配器</td><td>无法通过用户代码进行处理</td></tr><tr><td>函数重载</td><td>允许</td><td>不允许</td></tr><tr><td>构造函数与析构函数</td><td>调用</td><td>不调用</td></tr></tbody></table><h3 id="1-4-继承"><a href="#1-4-继承" class="headerlink" title="1.4. 继承"></a>1.4. 继承</h3><h4 id="1-构造函数"><a href="#1-构造函数" class="headerlink" title="(1) 构造函数"></a>(1) 构造函数</h4><ul><li>子类会默认调用父类的无参构造函数</li><li>父类的有参构造函数不会默认继承，需要显示声明，可以用下面两种方式<ul><li>child(int i) : father(i) {}</li><li>using father:father;</li></ul></li></ul><h4 id="2-virtual"><a href="#2-virtual" class="headerlink" title="(2) virtual"></a>(2) virtual</h4><ul><li>virtual 定义的函数会在调用时，根据指针找到子类实现去调用</li><li>private 函数，可以使用 virtual，虽然子类无法访问，但是不影响重写</li><li>纯虚函数必须在子类中声明，不能只实现</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;class A, func&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">privFunc</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;class A, privFunc&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">pureFunc</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A, <span class="keyword">public</span> C &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;class B, func&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pureFunc</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;class B, pureFunc&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">privFunc</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;class B, privFunc&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A *a = <span class="keyword">new</span> <span class="built_in">A</span>();</span><br><span class="line">    a-&gt;<span class="built_in">func</span>(); <span class="comment">// 调用A的实现</span></span><br><span class="line">    A *b = <span class="keyword">new</span> <span class="built_in">B</span>();</span><br><span class="line">    b-&gt;<span class="built_in">func</span>(); <span class="comment">// 虽然指针是A，但是调用B的实现</span></span><br><span class="line">    C *c = <span class="keyword">new</span> <span class="built_in">C</span>();     <span class="comment">// 此行编译不过，类存在纯虚函数，无法初始化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-override-编译时检查重写"><a href="#3-override-编译时检查重写" class="headerlink" title="(3) override 编译时检查重写"></a>(3) override 编译时检查重写</h4><ul><li>override 是可以在编译期检查是否是重写了父类的函数，要求父类必须是 virtual 定义的函数</li><li>override 函数可以再次在子类被 override 掉</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 定义纯虚接口函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span> <span class="keyword">override</span> </span>&#123;&#125;  <span class="comment">// 报错，因为父类没有此函数的virtual定义</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> B &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;&#125;    <span class="comment">// 父类的函数是override，子类可以再次override，不需要父类定义virtual</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="4-final-禁止继承-重写"><a href="#4-final-禁止继承-重写" class="headerlink" title="(4) final 禁止继承&#x2F;重写"></a>(4) final 禁止继承&#x2F;重写</h4><ul><li>final类禁止继承</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">final</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;&#125;;  <span class="comment">// 编译报错，final类禁止继承</span></span><br></pre></td></tr></table></figure><ul><li>final方法禁止重写</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">override</span> <span class="keyword">final</span> </span>&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> B &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;&#125;;    <span class="comment">// 报错，因为函数在B中定义了final</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-虚继承"><a href="#5-虚继承" class="headerlink" title="(5) 虚继承"></a>(5) 虚继承</h4><ul><li>先看代码</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() &#123;</span><br><span class="line">        <span class="built_in">LOG_INFO</span>(<span class="string">&quot;A()&quot;</span>);</span><br><span class="line">        m_a = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> m_a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>() &#123;</span><br><span class="line">        <span class="built_in">LOG_INFO</span>(<span class="string">&quot;B()&quot;</span>);</span><br><span class="line">        m_a = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">C</span>() &#123;</span><br><span class="line">        <span class="built_in">LOG_INFO</span>(<span class="string">&quot;C()&quot;</span>);</span><br><span class="line">        m_a = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> m_c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">D</span>() &#123;</span><br><span class="line">        <span class="built_in">LOG_INFO</span>(<span class="string">&quot;D()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, m_a);  <span class="comment">// 编译报错 &quot;D::m_a&quot; is ambiguous</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, B::m_a);  <span class="comment">// 这样就没问题</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argC, <span class="type">char</span> *argV[])</span> </span>&#123;</span><br><span class="line">    D d;</span><br><span class="line">    d.<span class="built_in">func</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这时D调用属性<code>m_a</code>是从B继承来的还是从C继承来的就会造成歧义，直接调用编译器会报错，不知道从谁而来。</li><li>指定从谁来的就不会有问题，可以理解为下图的关系，其实是有两个A</li></ul><img src="2023-02-12-01.png"><ul><li>构造函数调用也是<code>A -&gt; B -&gt; A -&gt; C -&gt; D</code></li><li>而使用virtual继承后</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">D</span>() &#123;</span><br><span class="line">        <span class="built_in">LOG_INFO</span>(<span class="string">&quot;D()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, m_a);  <span class="comment">// 这样就没问题</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_d;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ul><li>构造函数调用顺序<code>A -&gt; B -&gt; C -&gt; D</code>，可以看出A只有一份，也就是下图的样子</li></ul><img src="2023-02-12-02.png"><h2 id="2-引用"><a href="#2-引用" class="headerlink" title="2. 引用"></a>2. 引用</h2><h3 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h3><table><thead><tr><th>指针 <code>*</code></th><th>引用 <code>&amp;</code></th></tr></thead><tbody><tr><td>可以指向空地址</td><td>不可为空</td></tr><tr><td>变量，储存地址，初始化后可变</td><td>就是所引用的变量，初始化后不可变</td></tr><tr><td>可以有多级，如<code>**p</code></td><td>只有一级</td></tr><tr><td>sizeof 为指针变量的大小</td><td>sizeof 为对象大小</td></tr></tbody></table><h2 id="3-异常处理"><a href="#3-异常处理" class="headerlink" title="3. 异常处理"></a>3. 异常处理</h2><h3 id="3-1-抛出异常和捕获异常"><a href="#3-1-抛出异常和捕获异常" class="headerlink" title="3.1. 抛出异常和捕获异常"></a>3.1. 抛出异常和捕获异常</h3><ul><li>抛出异常可以使用任意类型，包括内置类型，也可以抛出一个异常类</li><li>使用<code>...</code>可以捕获所有异常</li><li>使用<code>throw</code>语句，类的析构函数会被调用</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抛出异常</span></span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">MyError</span>(<span class="string">&quot;Something bad happened&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//捕获异常</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//会造成异常的程序</span></span><br><span class="line">&#125; <span class="built_in">catch</span>(type1 id1) &#123;</span><br><span class="line">    <span class="comment">//处理type1类型的异常</span></span><br><span class="line">&#125; <span class="built_in">catch</span>(type2 id2) &#123;</span><br><span class="line">    <span class="comment">//处理type2类型的异常</span></span><br><span class="line">&#125; <span class="built_in">catch</span>(...) &#123;</span><br><span class="line">    <span class="comment">//处理所有类型的异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-重新抛出异常"><a href="#3-2-重新抛出异常" class="headerlink" title="3.2. 重新抛出异常"></a>3.2. 重新抛出异常</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">catch</span> (...) &#123;</span><br><span class="line">    <span class="comment">//做一些处理工作，然后将异常重新抛出到上一级</span></span><br><span class="line">    <span class="keyword">throw</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>如果异常抛出一个类，将抛出一个类的拷贝，所以此类必须可拷贝</li><li>如果异常抛出一个派生类，捕获使用基类可以捕获基类和所有派生类的异常，通常将派生类的捕获放在前面，基类的捕获放在最后用于捕获其他不常用的所有派生类的异常</li></ul><h3 id="3-3-terminator"><a href="#3-3-terminator" class="headerlink" title="3.3. terminator()"></a>3.3. terminator()</h3><ul><li>当没有一个异常处理器捕获某种异常的时候，<code>terminator()</code>会被调用</li><li>当析构函数中抛出异常时，<code>terminator()</code>会被调用</li></ul><h4 id="set-terminator"><a href="#set-terminator" class="headerlink" title="set_terminator()"></a>set_terminator()</h4><ul><li>用户可以自定义<code>void terminator()</code>函数</li><li>首次调用会返回默认的函数指针</li></ul><p>示例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">terminator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;I&#x27;ll be back!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">void</span> (*old_terminate)() = <span class="built_in">set_terminate</span>(terminator);</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Botch</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Fruit</span> &#123;&#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Botch::f()&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">Fruit</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Botch</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;~Botch()&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Botch b;</span><br><span class="line">        b.<span class="built_in">f</span>();</span><br><span class="line">    &#125; <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Inside catch(...)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Botch::f()</span><br><span class="line">~Botch()</span><br><span class="line">I&#x27;ll be back!</span><br></pre></td></tr></table></figure><h2 id="4-显式转换"><a href="#4-显式转换" class="headerlink" title="4. 显式转换"></a>4. 显式转换</h2><ul><li>C++对类型转换有下面几种专门的类进行转换，使用 C 语言的强制转换在编译时可能会报错</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">static_cast</span>&lt;new_type&gt;      (expression)</span><br><span class="line"><span class="built_in">dynamic_cast</span>&lt;new_type&gt;     (expression)</span><br><span class="line"><span class="built_in">const_cast</span>&lt;new_type&gt;       (expression)</span><br><span class="line"><span class="built_in">reinterpret_cast</span>&lt;new_type&gt; (expression)</span><br></pre></td></tr></table></figure><h3 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a><code>static_cast</code></h3><ul><li>基本类型转换，不能用于不同指针类型的转换</li><li>不能去除<code>const</code>、<code>volatile</code>、<code>__unaligned</code>属性</li><li>可以将<code>void *</code>转成其他类型的指针</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(a);               <span class="comment">// 正确，将char型数据转换成int型数据</span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> *c = <span class="keyword">new</span> <span class="type">double</span>;</span><br><span class="line"><span class="type">void</span> *d = <span class="built_in">static_cast</span>&lt;<span class="type">void</span>*&gt;(c);            <span class="comment">// 正确，将double指针转换成void指针</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> e = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> f = <span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="type">int</span>&gt;(e);    <span class="comment">// 正确，将int型数据转换成const int型数据</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> g = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> *h = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>*&gt;(&amp;g);             <span class="comment">// 编译错误，static_cast不能转换掉g的const属性</span></span><br></pre></td></tr></table></figure><h3 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a><code>const_cast</code></h3><ul><li>用于去除指针和引用的<code>const</code>或<code>volatile</code>属性</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> *b = <span class="built_in">const_cast</span>&lt;<span class="type">int</span>*&gt;(&amp;a);      <span class="comment">// 去掉const常量const属性</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> &amp;b = <span class="built_in">const_cast</span>&lt;<span class="type">int</span> &amp;&gt;(a);      <span class="comment">// 去掉const引用const属性</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *a = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">char</span> *b = <span class="built_in">const_cast</span>&lt;<span class="type">char</span> *&gt;(a);    <span class="comment">// 去掉const指针const属性</span></span><br></pre></td></tr></table></figure><h3 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a><code>reinterpret_cast</code></h3><ul><li>主要用于不同指针类型的转换</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *a;</span><br><span class="line"><span class="type">char</span> *b = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span> *&gt;(a);</span><br></pre></td></tr></table></figure><h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><ul><li><code>reinterpret_cast</code>是强制转换，不关心是否存在继承关系</li><li><code>static_cast</code>会根据具体类型进行一点转换，继承关系下，父类转子类时会做偏移</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A, <span class="keyword">public</span> B &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    C c;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p, %p, %p&quot;</span>, &amp;c, <span class="built_in">reinterpret_cast</span>&lt;B *&gt;(&amp;c), <span class="built_in">static_cast</span>&lt;B *&gt;(&amp;c));</span><br><span class="line">    <span class="comment">// 输出，前两个一样，后一个会做偏移</span></span><br><span class="line">    <span class="comment">// 0x7ffcc3b56340, 0x7ffcc3b56340, 0x7ffcc3b56344</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>reinterpret_cast</code>会造成不可预知的行为，比如下面，继承的兄弟类，强转成自己会造成调用的方法实际还是兄弟类的，而非自己的</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">LOGI</span>(<span class="built_in">WHAT</span>(<span class="string">&quot;I&#x27;m A&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="built_in">LOGI</span>(<span class="built_in">WHAT</span>(<span class="string">&quot;I&#x27;m B&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>: <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="built_in">LOGI</span>(<span class="built_in">WHAT</span>(<span class="string">&quot;I&#x27;m C&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    B b;</span><br><span class="line">    C *testc = <span class="built_in">reinterpret_cast</span>&lt;C*&gt;(&amp;b);</span><br><span class="line">    testc-&gt;<span class="built_in">print</span>();     <span class="comment">// I&#x27;m B，仅仅类型变了，虚指针的指向还是B，所以调用还是B</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a><code>dynamic_cast</code></h3><ul><li>主要适用于继承关系的转换，会检查转换的是否有效，无效将会返回nullptr</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">LOGI</span>(<span class="built_in">WHAT</span>(<span class="string">&quot;I&#x27;m A&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="built_in">LOGI</span>(<span class="built_in">WHAT</span>(<span class="string">&quot;I&#x27;m B&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>: <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="built_in">LOGI</span>(<span class="built_in">WHAT</span>(<span class="string">&quot;I&#x27;m C&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    B b;</span><br><span class="line">    b.<span class="built_in">print</span>();          <span class="comment">// I&#x27;m B</span></span><br><span class="line"></span><br><span class="line">    A *testa = <span class="built_in">dynamic_cast</span>&lt;A*&gt;(&amp;b);        <span class="comment">// B的指针转成A，是子类转基类，和static_cast一个效果，没问题</span></span><br><span class="line">    <span class="built_in">LOGI</span>(<span class="built_in">WHAT</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, testa == <span class="literal">nullptr</span>));     <span class="comment">// false</span></span><br><span class="line">    testa-&gt;<span class="built_in">print</span>();     <span class="comment">// I&#x27;m B</span></span><br><span class="line"></span><br><span class="line">    B *testb = <span class="built_in">dynamic_cast</span>&lt;B*&gt;(testa);     <span class="comment">// A的指针转成B，本质是B，所以没问题</span></span><br><span class="line">    testb-&gt;<span class="built_in">print</span>();     <span class="comment">// I&#x27;m B</span></span><br><span class="line"></span><br><span class="line">    C *testc = <span class="built_in">dynamic_cast</span>&lt;C*&gt;(testa);     <span class="comment">// A的指针转成C，但本质还是B，所以这里是nullptr</span></span><br><span class="line">    <span class="built_in">LOGI</span>(<span class="built_in">WHAT</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, testc == <span class="literal">nullptr</span>));     <span class="comment">// true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-模板"><a href="#7-模板" class="headerlink" title="7. 模板"></a>7. 模板</h2><h3 id="7-1-模板类"><a href="#7-1-模板类" class="headerlink" title="7.1. 模板类"></a>7.1. 模板类</h3><h4 id="1-静态成员函数"><a href="#1-静态成员函数" class="headerlink" title="1) 静态成员函数"></a>1) 静态成员函数</h4><ul><li>C++模板类中的静态成员函数需要在头文件里定义，否则会出现 LNK2019，找不到所定义的函数。也就是说对于静态函数，C++的编译器默认是不会查找相应的源文件的。</li></ul><h3 id="7-2-模板类型"><a href="#7-2-模板类型" class="headerlink" title="7.2. 模板类型"></a>7.2. 模板类型</h3><h4 id="1-获取类型名"><a href="#1-获取类型名" class="headerlink" title="1) 获取类型名"></a>1) 获取类型名</h4><ul><li>获取的是类型在二进制中的符号名，不是类型在代码中的名字</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="built_in">typeid</span>(_Tp).<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><h2 id="8-C-11-新特性"><a href="#8-C-11-新特性" class="headerlink" title="8. C++11 新特性"></a>8. C++11 新特性</h2><h3 id="8-1-智能指针"><a href="#8-1-智能指针" class="headerlink" title="8.1. 智能指针"></a>8.1. 智能指针</h3><h4 id="1-weak-ptr-弱指针"><a href="#1-weak-ptr-弱指针" class="headerlink" title="1) weak_ptr 弱指针"></a>1) weak_ptr 弱指针</h4><p>弱指针判断指向的对象是否存在只能通过<code>lock()</code>方法，如果不为空则返回强引用指针，否则返回<code>nullptr</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::weak_ptr&lt;type&gt; tmp = a;</span><br><span class="line"><span class="keyword">if</span> (tmp.<span class="built_in">lock</span>() == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">//指向地址不存在</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//指向地址存在</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-shared-ptr-共享指针"><a href="#2-shared-ptr-共享指针" class="headerlink" title="2) shared_ptr 共享指针"></a>2) shared_ptr 共享指针</h4><h5 id="1-方法"><a href="#1-方法" class="headerlink" title="(1) 方法"></a>(1) 方法</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">p1.<span class="built_in">reset</span>();     <span class="comment">// 会将p1赋值成nullptr</span></span><br></pre></td></tr></table></figure><h5 id="2-类型转换"><a href="#2-类型转换" class="headerlink" title="(2) 类型转换"></a>(2) 类型转换</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">    std::shared_ptr&lt;<span class="type">void</span>&gt; p2 = p1;</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; p3 = std::<span class="built_in">static_pointer_cast</span>&lt;<span class="type">int</span>&gt;(p2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-源码分析和注意事项"><a href="#3-源码分析和注意事项" class="headerlink" title="(3) 源码分析和注意事项"></a>(3) 源码分析和注意事项</h5><p><a href="/bookPages/docs/c++/shared_ptr/">shared_ptr</a></p><h4 id="3-unique-ptr-唯一持有的指针"><a href="#3-unique-ptr-唯一持有的指针" class="headerlink" title="3) unique_ptr 唯一持有的指针"></a>3) unique_ptr 唯一持有的指针</h4><ul><li><code>unique_ptr</code>不允许拷贝</li></ul><h5 id="1-转换"><a href="#1-转换" class="headerlink" title="(1) 转换"></a>(1) 转换</h5><ul><li><code>unique_ptr</code>释放所有权可以转为<code>shared_ptr</code></li><li>但是<code>shared_ptr</code>不能转成<code>unique_ptr</code></li></ul><h3 id="8-2-Lambda-函数"><a href="#8-2-Lambda-函数" class="headerlink" title="8.2. Lambda 函数"></a>8.2. Lambda 函数</h3><h4 id="1-语法"><a href="#1-语法" class="headerlink" title="1) 语法"></a>1) 语法</h4><p><strong>简单示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不带返回值</span></span><br><span class="line"><span class="type">int</span> sum;</span><br><span class="line"><span class="keyword">auto</span> testFunc = [&amp;sum](<span class="type">int</span> x, <span class="type">int</span> y) &#123;</span><br><span class="line">    sum = x + y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带返回值</span></span><br><span class="line"><span class="keyword">auto</span> testFunc1 = [sum](<span class="type">int</span> x, <span class="type">int</span> y) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">    sum = x + y;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong><code>[]</code>定义函数外变量的引用行为</strong></p><ul><li><code>[&amp;sum]</code>: 仅使用引用传递外部 sum 变量</li><li><code>[&amp;]</code>: 使用引用传递外部变量</li><li><code>[sum]</code>: 仅使用值传递外部 sum 变量</li><li><code>[=]</code>: 仅使用值捕获外部变量</li><li><code>[=, &amp;sum]</code>: 除 sum 外其他都是值传递</li><li><code>[&amp;, sum]</code>: 除 sum 外其他都是引用传递</li><li><code>[&amp;, sum, this]</code>: this 仅能值传递，并且仅在非静态函数中才能传递，Lambda 函数和它所在函数具有相同的属性（public、private）</li><li>值捕获只在定义当时的值会传递，如果定义后更改了捕获的变量，不影响 Lambda 里面使用的值</li></ul><p><strong>this传递安全写法</strong></p><ul><li>根据能否锁定ptr判断父类是否存在</li><li>如果存在，this指针才有效，相当于lambda运行在类环境中，可以直接调用类成员函数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> : std::enable_shared_from_this&lt;A&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::weak_ptr&lt;A&gt; weak_ptr = <span class="built_in">shared_from_this</span>();</span><br><span class="line">        <span class="keyword">auto</span> test_func = [weak_ptr, <span class="keyword">this</span>]() &#123;</span><br><span class="line">            <span class="keyword">auto</span> self = weak_ptr.<span class="built_in">lock</span>();</span><br><span class="line">            <span class="keyword">if</span> (!self) <span class="keyword">return</span>;</span><br><span class="line">            <span class="built_in">funcB</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">funcB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;funcB&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-实现"><a href="#2-实现" class="headerlink" title="2) 实现"></a>2) 实现</h4><p>编译器对lambda表达式在底层是创建了一个类，重载了<code>()</code>运算符</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">lambda_xxx</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(X &amp;elem)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        elem.<span class="built_in">op</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于捕获的变量，lambda类在创建的时候通过成员函数保存了需要捕获的变量</p><h3 id="8-3-原生字符串"><a href="#8-3-原生字符串" class="headerlink" title="8.3. 原生字符串"></a>8.3. 原生字符串</h3><ul><li>字符串类似格式化的 json，放到代码里面，需要将换行和双引号转义，c++11 支持原生字符串，不需要进行转义，使用此类型格式<code>R&quot;()&quot;</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">std::string test = <span class="string">R&quot;(&#123;</span></span><br><span class="line"><span class="string">    &quot;a&quot;: &quot;b&quot;,</span></span><br><span class="line"><span class="string">    &quot;c&quot;: 1,</span></span><br><span class="line"><span class="string">    &quot;d&quot;: &#123;</span></span><br><span class="line"><span class="string">        &quot;e&quot;: [2]</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;)&quot;</span>;</span><br></pre></td></tr></table></figure><h3 id="8-4-shared-from-this"><a href="#8-4-shared-from-this" class="headerlink" title="8.4. shared_from_this"></a>8.4. shared_from_this</h3><ul><li>使用<code>shared_from_this()</code>可以将当前类的 this 指针转成 shared</li><li>需要继承一个模板类<code>std::enable_shared_from_this&lt;T&gt;</code></li><li>使用<code>share_ptr&lt;A&gt;(this)</code>会导致二次析构，因为不会增加引用计数</li><li>注意在<code>void func1() const</code>下只能生成<code>std::shared_ptr&lt;const A&gt;</code>的指针</li><li>必须类本身存在<code>shared_ptr</code>才可以调用<code>shared_from_this()</code>，即外部持有类必须用共享指针进行持有</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> : <span class="keyword">public</span> std::enable_shared_from_this&lt;A&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::shared_ptr&lt;A&gt; p = <span class="built_in">shared_from_this</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里只能生成const A的共享指针，没有A的共享指针</span></span><br><span class="line">        std::shared_ptr&lt;<span class="type">const</span> A&gt; p = <span class="built_in">shared_from_this</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a;                                <span class="comment">// 这样构造，上面的shared_from_this会抛异常</span></span><br><span class="line">    <span class="keyword">auto</span> pA = std::<span class="built_in">make_shared</span>&lt;A&gt;();    <span class="comment">// 这样才能正常调用shared_from_this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-5-enum-class-强类型枚举"><a href="#8-5-enum-class-强类型枚举" class="headerlink" title="8.5. enum class 强类型枚举"></a>8.5. enum class 强类型枚举</h3><ul><li>就将枚举看成一个类，可以提前声明</li><li>强类型，不允许隐式类型转换</li><li>使用必须加类型前缀</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 提前声明</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">TestType</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">TestType</span> &#123;</span><br><span class="line">    HHHHH,</span><br><span class="line">    ASSSS</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(TestType type)</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="built_in">func</span>(a);                <span class="comment">// 编译报错</span></span><br><span class="line">    TestType a1 = HHHHH;    <span class="comment">// 编译报错，未定义</span></span><br><span class="line">    TestType a2 = TestType::HHHHH;</span><br><span class="line">    <span class="built_in">func</span>(a2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-6-future和promise"><a href="#8-6-future和promise" class="headerlink" title="8.6. future和promise"></a>8.6. future和promise</h3><p>见<a href="/blogs/2020-08-01-threadPool/#-future-%E6%9C%AA%E6%9D%A5%E5%80%BC%E8%8E%B7%E5%8F%96">future 未来值获取</a></p><h4 id="踩坑记"><a href="#踩坑记" class="headerlink" title="踩坑记"></a>踩坑记</h4><h5 id="1-future和shared-from-this造成的崩溃"><a href="#1-future和shared-from-this造成的崩溃" class="headerlink" title="(1) future和shared_from_this造成的崩溃"></a>(1) future和<code>shared_from_this</code>造成的崩溃</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> : <span class="keyword">public</span> enable_shared_from_this&lt;Test&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>() : <span class="built_in">m_work</span>(m_ioContext) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Test()&quot;</span> &lt;&lt; endl;</span><br><span class="line">        m_future = <span class="built_in">async</span>(launch::async, [<span class="keyword">this</span>]() &#123; m_ioContext.<span class="built_in">run</span>(); &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Test</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;~Test()&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span> (!m_ioContext.<span class="built_in">stopped</span>()) &#123;</span><br><span class="line">            m_ioContext.<span class="built_in">stop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (m_future.<span class="built_in">valid</span>()) &#123;</span><br><span class="line">            m_future.<span class="built_in">wait</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">post</span><span class="params">(std::function&lt;<span class="type">void</span>()&gt; func)</span> </span>&#123;</span><br><span class="line">        std::weak_ptr&lt;Test&gt; weakPtr = <span class="built_in">shared_from_this</span>();</span><br><span class="line">        m_ioContext.<span class="built_in">post</span>([func, weakPtr, <span class="keyword">this</span>] &#123;</span><br><span class="line">            <span class="keyword">auto</span> self = weakPtr.<span class="built_in">lock</span>();</span><br><span class="line">            <span class="keyword">if</span> (self == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">            <span class="built_in">func</span>();</span><br><span class="line">            <span class="comment">// 睡眠100ms，构造self为最后一个引用计数</span></span><br><span class="line">            this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    future&lt;<span class="type">void</span>&gt; m_future;</span><br><span class="line">    boost::asio::io_context m_ioContext;</span><br><span class="line">    boost::asio::io_context::work m_work;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;Test&gt; pTest = std::<span class="built_in">make_shared</span>&lt;Test&gt;();</span><br><span class="line"></span><br><span class="line">    std::promise&lt;<span class="type">void</span>&gt; p;</span><br><span class="line">    <span class="keyword">auto</span> taskFunc = [&amp;p]() &#123;</span><br><span class="line">        <span class="built_in">LOGI</span>(<span class="built_in">WHAT</span>(<span class="string">&quot;task run&quot;</span>));</span><br><span class="line">        p.<span class="built_in">set_value</span>();</span><br><span class="line">    &#125;;</span><br><span class="line">    pTest-&gt;<span class="built_in">post</span>(taskFunc);</span><br><span class="line"></span><br><span class="line">    p.<span class="built_in">get_future</span>().<span class="built_in">wait</span>();</span><br><span class="line">    <span class="built_in">LOGI</span>(<span class="built_in">WHAT</span>(<span class="string">&quot;taskDone&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argC, <span class="type">char</span> *argV[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line">    <span class="comment">// 这里造成还在继续跑的情况，防止因为进程退出而吃掉异常</span></span><br><span class="line">    this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">milliseconds</span>(<span class="number">200</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>上面代码在<code>func()</code>调用退出后，函数内的<code>pTest</code>会释放引用计数，但是<code>Test</code>的<code>post</code>里面的任务函数使用了<code>weakPtr.lock()</code>，将<code>Test</code>的引用计数加1而成为最后一个引用<code>Test</code>的指针</li><li>在最后任务函数退出时，引用计数清0，调用析构函数。此时发现析构函数调用线程为类本身的工作线程，工作线程中调用<code>m_future.wait()</code>会抛出<code>Resource deadlock avoided</code>的异常，即死锁</li></ul><h3 id="8-7-async-线程的封装类"><a href="#8-7-async-线程的封装类" class="headerlink" title="8.7. async 线程的封装类"></a>8.7. async 线程的封装类</h3><ul><li>存在thread、promise和future，还要async干嘛</li><li>由于用起来太麻烦，async将这三者结合了一下，更加方便调用</li></ul><h4 id="1-参数"><a href="#1-参数" class="headerlink" title="1) 参数"></a>1) 参数</h4><ul><li>第一个参数为模式<ul><li><code>std::launch::async</code>: 调用async时创建线程</li><li><code>std::launch::deferred</code>: 返回的future调用<code>get</code>和<code>wait</code>时才创建线程</li></ul></li><li>第二个参数为函数指针，可以使用lambda表达式</li></ul><h4 id="2-返回值"><a href="#2-返回值" class="headerlink" title="2) 返回值"></a>2) 返回值</h4><ul><li>返回future变量，需要使用变量接受，因为future在析构时会自动调用<code>wait()</code>，如果没有接受返回的future，相当用起了一个线程，还等这个线程退出</li><li>返回的future为第二个参数的函数返回值类型</li></ul><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::future&lt;<span class="type">int</span>&gt; f1 = std::<span class="built_in">async</span>(std::launch::async, []() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOGI</span>(<span class="built_in">WHAT</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, f1.<span class="built_in">get</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-8-chrono-时间库"><a href="#8-8-chrono-时间库" class="headerlink" title="8.8. chrono 时间库"></a>8.8. chrono 时间库</h3><h4 id="1-基础用法"><a href="#1-基础用法" class="headerlink" title="1) 基础用法"></a>1) 基础用法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono;</span><br><span class="line">    <span class="comment">// 获取当前系统启动时间</span></span><br><span class="line">    <span class="keyword">auto</span> sysSec = <span class="built_in">duration_cast</span>&lt;seconds&gt;(steady_clock::<span class="built_in">now</span>().<span class="built_in">time_since_epoch</span>()).<span class="built_in">count</span>();</span><br><span class="line">    <span class="comment">// 获取当前时间戳，基于1970-01-01</span></span><br><span class="line">    <span class="keyword">auto</span> dateSec = <span class="built_in">duration_cast</span>&lt;seconds&gt;(system_clock::<span class="built_in">now</span>().<span class="built_in">time_since_epoch</span>()).<span class="built_in">count</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-工具函数"><a href="#2-工具函数" class="headerlink" title="2) 工具函数"></a>2) 工具函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 获取当前时间字符串</span></span><br><span class="line"><span class="comment"> * 时间字符串(如：2020-05-02 14:40:31.015)</span></span><br><span class="line"><span class="comment"> * @param bLocal</span></span><br><span class="line"><span class="comment"> * @param bIncludeMS</span></span><br><span class="line"><span class="comment"> * @return std::string</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">std::string <span class="title">getTimeString</span><span class="params">(<span class="type">bool</span> bLocal = <span class="literal">true</span>, <span class="type">bool</span> bIncludeMS = <span class="literal">true</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono;</span><br><span class="line">    <span class="keyword">auto</span> tNow = system_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="keyword">auto</span> tSeconds = <span class="built_in">duration_cast</span>&lt;seconds&gt;(tNow.<span class="built_in">time_since_epoch</span>());</span><br><span class="line">    <span class="keyword">auto</span> secNow = tSeconds.<span class="built_in">count</span>();</span><br><span class="line">    tm* tmNow = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (bLocal) &#123;</span><br><span class="line">        tmNow = ::<span class="built_in">localtime</span>((<span class="type">time_t</span>*)&amp;secNow);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        tmNow = ::<span class="built_in">gmtime</span>((<span class="type">time_t</span>*)&amp;secNow);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::ostringstream oss;</span><br><span class="line">    oss  &lt;&lt; std::<span class="built_in">put_time</span>(tmNow, <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (bIncludeMS) &#123;</span><br><span class="line">        <span class="keyword">auto</span> tMilli  = <span class="built_in">duration_cast</span>&lt;milliseconds&gt;(tNow.<span class="built_in">time_since_epoch</span>());</span><br><span class="line">        <span class="keyword">auto</span> ms  = tMilli  - tSeconds;</span><br><span class="line">        oss  &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">3</span>) &lt;&lt; ms.<span class="built_in">count</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oss.<span class="built_in">str</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 根据系统启动时间（秒）获取时间字符串</span></span><br><span class="line"><span class="comment"> * 时间字符串(如：2020-05-02 14:40:31)</span></span><br><span class="line"><span class="comment"> * @param bLocal</span></span><br><span class="line"><span class="comment"> * @return std::string</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">std::string <span class="title">getTimeStrBySysStartTimeS</span><span class="params">(<span class="type">int64_t</span> timeS, <span class="type">bool</span> bLocal = <span class="literal">true</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono;</span><br><span class="line">    <span class="comment">// 获取当前系统启动时间</span></span><br><span class="line">    <span class="keyword">auto</span> sysSec = <span class="built_in">duration_cast</span>&lt;seconds&gt;(steady_clock::<span class="built_in">now</span>().<span class="built_in">time_since_epoch</span>()).<span class="built_in">count</span>();</span><br><span class="line">    <span class="comment">// 获取当前时间戳</span></span><br><span class="line">    <span class="keyword">auto</span> dateSec = <span class="built_in">duration_cast</span>&lt;seconds&gt;(system_clock::<span class="built_in">now</span>().<span class="built_in">time_since_epoch</span>()).<span class="built_in">count</span>();</span><br><span class="line">    <span class="comment">// 计算相对差值更新时间戳</span></span><br><span class="line">    dateSec = dateSec - sysSec + timeS;</span><br><span class="line"></span><br><span class="line">    tm* tmNow = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (bLocal) tmNow = ::<span class="built_in">localtime</span>((<span class="type">time_t</span>*)&amp;dateSec);</span><br><span class="line">    <span class="keyword">else</span> tmNow = ::<span class="built_in">gmtime</span>((<span class="type">time_t</span>*)&amp;dateSec);</span><br><span class="line"></span><br><span class="line">    std::ostringstream oss;</span><br><span class="line">    oss  &lt;&lt; std::<span class="built_in">put_time</span>(tmNow, <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oss.<span class="built_in">str</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 根据系统启动时间（毫秒）获取时间字符串</span></span><br><span class="line"><span class="comment"> * 时间字符串(如：2020-05-02 14:40:31.123)</span></span><br><span class="line"><span class="comment"> * @param bLocal</span></span><br><span class="line"><span class="comment"> * @return std::string</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">std::string <span class="title">getTimeStrBySysStartTimeMS</span><span class="params">(<span class="type">int64_t</span> timeMS, <span class="type">bool</span> bLocal = <span class="literal">true</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono;</span><br><span class="line">    <span class="comment">// 获取当前系统启动时间</span></span><br><span class="line">    <span class="keyword">auto</span> sysMS = <span class="built_in">duration_cast</span>&lt;milliseconds&gt;(steady_clock::<span class="built_in">now</span>().<span class="built_in">time_since_epoch</span>()).<span class="built_in">count</span>();</span><br><span class="line">    <span class="comment">// 获取当前时间戳</span></span><br><span class="line">    <span class="keyword">auto</span> dateMS = <span class="built_in">duration_cast</span>&lt;milliseconds&gt;(system_clock::<span class="built_in">now</span>().<span class="built_in">time_since_epoch</span>()).<span class="built_in">count</span>();</span><br><span class="line">    <span class="comment">// 计算相对差值更新时间戳</span></span><br><span class="line">    dateMS = dateMS - sysMS + timeMS;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> dateSec = dateMS / <span class="number">1000</span>;</span><br><span class="line">    tm* tmNow = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (bLocal) tmNow = ::<span class="built_in">localtime</span>((<span class="type">time_t</span>*)&amp;dateSec);</span><br><span class="line">    <span class="keyword">else</span> tmNow = ::<span class="built_in">gmtime</span>((<span class="type">time_t</span>*)&amp;dateSec);</span><br><span class="line"></span><br><span class="line">    std::ostringstream oss;</span><br><span class="line">    oss  &lt;&lt; std::<span class="built_in">put_time</span>(tmNow, <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取秒级时间戳后，将毫秒放到后面</span></span><br><span class="line">    oss  &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">3</span>) &lt;&lt; (dateMS % <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oss.<span class="built_in">str</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-使用注意事项"><a href="#3-使用注意事项" class="headerlink" title="3) 使用注意事项"></a>3) 使用注意事项</h4><ul><li>参考 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/414702182">自顶向下地聊聊C++的时间处理和chrono库</a></li><li>不同平台对<code>steady_clock</code>和<code>system_clock</code>的实现不同</li></ul><table><thead><tr><th></th><th>windows</th><th>linux</th><th>mac</th></tr></thead><tbody><tr><td>system_clock</td><td>GetSystemTimePreciseAsFileTime(&amp;ft)<br>GetSystemTimeAsFileTime(&amp;ft)</td><td>clock_gettime(CLOCK_REALTIME, &amp;tp)<br>gettimeofday(&amp;tv, 0)</td><td></td></tr><tr><td>steady_clock</td><td>QueryPerformanceFrequency()<br>QueryPerformanceCounter(&amp;counter)</td><td>clock_gettime(CLOCK_MONOTONIC, &amp;tp)</td><td>mach_timebase_info(&amp;MachInfo)</td></tr></tbody></table><ul><li>根据实验 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/kex1n/p/3297607.html">windows平台时间函数性能比较QueryPerformanceCounter，GetTickCount，ftime，time,GetLocalTime，GetSystemTimeAsFileTime</a> 和 <a target="_blank" rel="noopener" href="https://blog.csdn.net/jacicson1987/article/details/123816212">gettimeofday和clock_gettime性能对比</a> 可以看出<ul><li>windows上<code>steady_clock</code>和<code>system_clock</code>性能相差几十倍</li><li>linux上两个调用几乎没差别</li></ul></li></ul><h3 id="8-9-error-code-错误码"><a href="#8-9-error-code-错误码" class="headerlink" title="8.9. error_code 错误码"></a>8.9. error_code 错误码</h3><ul><li>需要自己定义<code>error_category</code>，一般作为函数返回错误信息使用，可以自定义错误码和message</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DiyEC</span> : <span class="keyword">public</span> std::error_category &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> &#123;</span><br><span class="line">        SUCCESS = <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">        FAILED_IOCONTEXT_IS_NULL,</span><br><span class="line">        FAILED_IOCONTEXT_NOT_RUN,</span><br><span class="line">        FAILED_TIMEOUT,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span> *<span class="title">name</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;DiyEC&quot;</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">message</span><span class="params">(<span class="type">int</span> val)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="type">static</span> <span class="type">const</span> std::map&lt;<span class="type">int</span>, std::string&gt; ecMap = &#123;</span><br><span class="line">            &#123;<span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(SUCCESS),                  <span class="string">&quot;success&quot;</span>               &#125;,</span><br><span class="line">            &#123;<span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(FAILED_IOCONTEXT_IS_NULL), <span class="string">&quot;io context is null&quot;</span>    &#125;,</span><br><span class="line">            &#123;<span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(FAILED_IOCONTEXT_NOT_RUN), <span class="string">&quot;io context not running&quot;</span>&#125;,</span><br><span class="line">            &#123;<span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(FAILED_TIMEOUT),           <span class="string">&quot;timeout&quot;</span>               &#125;,</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> &amp;iter = ecMap.<span class="built_in">find</span>(val);</span><br><span class="line">        <span class="keyword">if</span> (iter != ecMap.<span class="built_in">end</span>()) <span class="keyword">return</span> iter-&gt;second;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">const</span> std::string <span class="title">unknown</span><span class="params">(<span class="string">&quot;unknown error&quot;</span>)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> unknown;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">const</span> DiyEC &amp;<span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">static</span> DiyEC category;</span><br><span class="line">        <span class="keyword">return</span> category;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">testFunc</span><span class="params">(std::error_code &amp;ec)</span> </span>&#123;</span><br><span class="line">    ec.<span class="built_in">assign</span>(DiyEC::FAILED_IOCONTEXT_IS_NULL, DiyEC::<span class="built_in">getInstance</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::error_code ec;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">testFunc</span>(ec)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;code: &quot;</span> &lt;&lt; ec.<span class="built_in">value</span>() &lt;&lt; <span class="string">&quot;, message: &quot;</span> &lt;&lt; ec.<span class="built_in">message</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-系统错误码转error-code"><a href="#1-系统错误码转error-code" class="headerlink" title="1) 系统错误码转error_code"></a>1) 系统错误码转<code>error_code</code></h4><ul><li>存在两种转换方式，一种是<code>generic_category</code>，一种是<code>system_category</code></li><li><code>generic_category</code>主要用于<code>c++</code>定义的一些错误，在linux上和<code>system_category</code>一样都和<code>errno</code>一致</li><li>windows上使用<code>system_category</code>可以获取到<code>GetLastError()</code>的错误</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// windows</span></span><br><span class="line"><span class="keyword">auto</span> ec = std::<span class="built_in">error_code</span>(<span class="built_in">GetLastError</span>(), std::<span class="built_in">system_category</span>());</span><br><span class="line"><span class="comment">// linux，下面两种结果一样</span></span><br><span class="line"><span class="keyword">auto</span> ec = std::<span class="built_in">error_code</span>(errno, std::<span class="built_in">system_category</span>());</span><br><span class="line"><span class="keyword">auto</span> ec = std::<span class="built_in">error_code</span>(errno, std::<span class="built_in">generic_category</span>());</span><br></pre></td></tr></table></figure><h2 id="9-自定义类型定义操作符"><a href="#9-自定义类型定义操作符" class="headerlink" title="9. 自定义类型定义操作符"></a>9. 自定义类型定义操作符</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __WIN32</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WinSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief IP地址类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">ip_type</span> &#123;</span><br><span class="line">    ipv4,  <span class="comment">///&lt; ipv4地址</span></span><br><span class="line">    ipv6,  <span class="comment">///&lt; ipv6地址</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ip_address</span> &#123;</span><br><span class="line">    ip_type type;  <span class="comment">///&lt; ip地址类型 @ref ip_type</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="type">char</span> v4[<span class="number">4</span>];             <span class="comment">///&lt; ipv4地址</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> uv4[<span class="number">4</span>];   <span class="comment">///&lt; ipv4地址,unsigned char</span></span><br><span class="line">        <span class="type">uint32_t</span> v4_addr;       <span class="comment">///&lt; ipv4地址,网络字节序</span></span><br><span class="line">        <span class="type">uint32_t</span> reserved[<span class="number">4</span>];   <span class="comment">///&lt; 用来存储临时数据</span></span><br><span class="line">        <span class="type">char</span> v6[<span class="number">16</span>];            <span class="comment">///&lt; ipv6地址</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> uv6[<span class="number">16</span>];  <span class="comment">///&lt; ipv6地址</span></span><br><span class="line">    &#125; ip;                       <span class="comment">///&lt; ip地址</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">ip_address</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用uint32进行构造，传入主机字节序即可</span></span><br><span class="line">    <span class="built_in">ip_address</span>(<span class="type">uint32_t</span> ipv4) &#123;</span><br><span class="line">        type = ip_type::ipv4;</span><br><span class="line">        ip.v4_addr = <span class="built_in">htonl</span>(ipv4);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用uint32进行赋值，传入主机字节序即可</span></span><br><span class="line">    ip_address&amp; <span class="keyword">operator</span>=(<span class="type">uint32_t</span> ipv4) &#123;</span><br><span class="line">        type = ip_type::ipv4;</span><br><span class="line">        ip.v4_addr = <span class="built_in">htonl</span>(ipv4);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ip_address</span>(<span class="type">const</span> <span class="type">uint8_t</span>* buf, <span class="type">uint32_t</span> len) &#123;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">4</span>) &#123;</span><br><span class="line">            type = ip_type::ipv4;</span><br><span class="line">            <span class="built_in">memcpy</span>(ip.uv4, buf, <span class="number">4</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">16</span>) &#123;</span><br><span class="line">            type = ip_type::ipv6;</span><br><span class="line">            <span class="built_in">memcpy</span>(ip.uv6, buf, <span class="number">16</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义各种类型操作符</span></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> ip_address&amp; A, <span class="type">const</span> ip_address&amp; B) &#123;</span><br><span class="line">    <span class="comment">// 类型不等，ipv4 &lt; ipv6</span></span><br><span class="line">    <span class="keyword">if</span> (A.type != B.type) &#123;</span><br><span class="line">        <span class="keyword">if</span> (A.type == ip_type::ipv4) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (A.type == ip_type::ipv4) &#123;</span><br><span class="line">        <span class="comment">// 转主机字节序对比</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">ntohl</span>(A.ip.v4_addr) &lt; <span class="built_in">ntohl</span>(B.ip.v4_addr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ipv6，从头部开始对比</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="built_in">sizeof</span>(A.ip.uv6) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (A.ip.uv6[i] &lt; B.ip.uv6[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> ip_address&amp; lhs, <span class="type">const</span> ip_address&amp; rhs) &#123; <span class="keyword">return</span> lhs &lt; rhs || rhs &lt; lhs; &#125;</span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> ip_address&amp; lhs, <span class="type">const</span> ip_address&amp; rhs) &#123; <span class="keyword">return</span> !(lhs != rhs); &#125;</span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;=(<span class="type">const</span> ip_address&amp; lhs, <span class="type">const</span> ip_address&amp; rhs) &#123; <span class="built_in">return</span> (lhs &lt; rhs) || (lhs == rhs); &#125;</span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="keyword">operator</span>&gt;(<span class="type">const</span> ip_address&amp; lhs, <span class="type">const</span> ip_address&amp; rhs) &#123; <span class="keyword">return</span> !(lhs &lt;= rhs); &#125;</span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="keyword">operator</span>&gt;=(<span class="type">const</span> ip_address&amp; lhs, <span class="type">const</span> ip_address&amp; rhs) &#123; <span class="keyword">return</span> !(lhs &lt; rhs); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 ++ip 的操作， ip++不会调用此操作符</span></span><br><span class="line"><span class="type">static</span> ip_address&amp; <span class="keyword">operator</span>++(ip_address&amp; lhs) &#123;</span><br><span class="line">    <span class="keyword">if</span> (lhs.type == ip_type::ipv6) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">sizeof</span>(lhs.ip.v6) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lhs.ip.uv6[i] != <span class="number">0xff</span>) &#123;</span><br><span class="line">                lhs.ip.uv6[i]++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            lhs.ip.uv6[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lhs.type == ip_type::ipv4) &#123;</span><br><span class="line">        <span class="comment">// 转主机字节序直接++</span></span><br><span class="line">        lhs.ip.v4_addr = <span class="built_in">htonl</span>(<span class="built_in">ntohl</span>(lhs.ip.v4_addr) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> lhs;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> ip_address&amp; <span class="keyword">operator</span>--(ip_address&amp; lhs) &#123;</span><br><span class="line">    <span class="keyword">if</span> (lhs.type == ip_type::ipv6) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">sizeof</span>(lhs.ip.v6) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lhs.ip.uv6[i] != <span class="number">0x00</span>) &#123;</span><br><span class="line">                lhs.ip.uv6[i]--;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            lhs.ip.uv6[i] = <span class="number">0xff</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lhs.type == ip_type::ipv4) &#123;</span><br><span class="line">        <span class="comment">// 转主机字节序直接--</span></span><br><span class="line">        lhs.ip.v4_addr = <span class="built_in">htonl</span>(<span class="built_in">ntohl</span>(lhs.ip.v4_addr) - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> lhs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ip = ip + 1</span></span><br><span class="line"><span class="type">static</span> ip_address <span class="keyword">operator</span>+(ip_address ip, <span class="type">int</span> value) &#123;</span><br><span class="line">    <span class="keyword">if</span> (value &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; value; ++i) &#123;</span><br><span class="line">            ++ip;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &gt; value; --i) &#123;</span><br><span class="line">            --ip;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ip;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> ip_address <span class="keyword">operator</span>-(ip_address ip, <span class="type">int</span> value) &#123; <span class="keyword">return</span> ip + (-value); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ip += 1</span></span><br><span class="line"><span class="type">static</span> ip_address <span class="keyword">operator</span>+=(ip_address&amp; ip, <span class="type">int</span> value) &#123;</span><br><span class="line">    <span class="keyword">if</span> (value &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; value; ++i) &#123;</span><br><span class="line">            ++ip;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &gt; value; --i) &#123;</span><br><span class="line">            --ip;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ip;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> ip_address <span class="keyword">operator</span>-=(ip_address&amp; ip, <span class="type">int</span> value) &#123;</span><br><span class="line">    ip += (-value);</span><br><span class="line">    <span class="keyword">return</span> ip;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 ip++ 的行为</span></span><br><span class="line"><span class="type">static</span> ip_address <span class="keyword">operator</span>++(ip_address&amp; ip, <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">auto</span> tmp = ip;</span><br><span class="line">    ++ip;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> ip_address <span class="keyword">operator</span>--(ip_address&amp; ip, <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">auto</span> tmp = ip;</span><br><span class="line">    --ip;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// std::cout &lt;&lt; ip 和 std::cout &lt;&lt; ip &lt;&lt; std::endl</span></span><br><span class="line"><span class="type">static</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; out, <span class="type">const</span> ip_address&amp; ip) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ip.type == ip_type::ipv4) &#123;</span><br><span class="line">        out &lt;&lt; (std::<span class="built_in">to_string</span>(ip.ip.uv4[<span class="number">0</span>]) + <span class="string">&quot;.&quot;</span> + std::<span class="built_in">to_string</span>(ip.ip.uv4[<span class="number">1</span>]) + <span class="string">&quot;.&quot;</span> + std::<span class="built_in">to_string</span>(ip.ip.uv4[<span class="number">2</span>]) +</span><br><span class="line">                <span class="string">&quot;.&quot;</span> + std::<span class="built_in">to_string</span>(ip.ip.uv4[<span class="number">3</span>]));</span><br><span class="line">        <span class="keyword">return</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    std::stringstream ss;</span><br><span class="line">    ss &lt;&lt; std::hex;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; <span class="built_in">sizeof</span>(ip.ip.uv6); i += <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ss &lt;&lt; <span class="string">&quot;:&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ss &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">uint16_t</span>&gt;(ip.ip.uv6[i]);</span><br><span class="line">        ss &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">2</span>) &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">uint16_t</span>&gt;(ip.ip.uv6[i + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    out &lt;&lt; ss.<span class="built_in">str</span>();</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ip &lt;&lt; 0xc0a80001</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="keyword">operator</span>&lt;&lt;(ip_address&amp; ip, <span class="type">uint32_t</span> ipv4) &#123; ip = ipv4; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">ip_address <span class="title">ip</span><span class="params">(<span class="number">0xc0a80001</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; ip &lt;&lt; std::endl;  <span class="comment">// 192.168.0.1</span></span><br><span class="line">    ip &lt;&lt; <span class="number">0xc0a80001</span>;</span><br><span class="line">    std::cout &lt;&lt; ip &lt;&lt; std::endl;  <span class="comment">// 192.168.0.1</span></span><br><span class="line">    ++ip;</span><br><span class="line">    std::cout &lt;&lt; ip &lt;&lt; std::endl;                   <span class="comment">// 192.168.0.2</span></span><br><span class="line">    std::cout &lt;&lt; (ip++) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ip &lt;&lt; std::endl;  <span class="comment">// 192.168.0.2 192.168.0.3</span></span><br><span class="line">    --ip;</span><br><span class="line">    std::cout &lt;&lt; ip &lt;&lt; std::endl;                   <span class="comment">// 192.168.0.1</span></span><br><span class="line">    std::cout &lt;&lt; (ip--) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ip &lt;&lt; std::endl;  <span class="comment">// 192.168.0.2 192.168.0.1</span></span><br><span class="line">    ip = ip + <span class="number">255</span>;</span><br><span class="line">    std::cout &lt;&lt; ip &lt;&lt; std::endl;  <span class="comment">// 192.168.1.0</span></span><br><span class="line">    ip = ip - <span class="number">255</span>;</span><br><span class="line">    std::cout &lt;&lt; ip &lt;&lt; std::endl;  <span class="comment">// 192.168.0.1</span></span><br><span class="line">    ip += <span class="number">255</span>;</span><br><span class="line">    std::cout &lt;&lt; ip &lt;&lt; std::endl;  <span class="comment">// 192.168.1.0</span></span><br><span class="line">    ip -= <span class="number">255</span>;</span><br><span class="line">    std::cout &lt;&lt; ip &lt;&lt; std::endl;  <span class="comment">// 192.168.0.1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-1-赋值运算符"><a href="#9-1-赋值运算符" class="headerlink" title="9.1. 赋值运算符"></a>9.1. 赋值运算符</h3><ul><li>赋值运算符一般在类或结构体内部定义，隐含一个this指针</li><li>分为拷贝赋值和移动赋值，移动赋值需要等号右边是一个右值</li><li>两种赋值语句都需要返回<code>*this</code></li><li>返回值为自身的引用是为了可以写出<code>str1 = str2 = str3</code>这样的连续赋值语句</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 无参构造函数</span></span><br><span class="line">    <span class="built_in">A</span>() &#123; <span class="built_in">LOGI</span>(<span class="built_in">WHAT</span>(<span class="string">&quot;contruct A&quot;</span>)); &#125;</span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> A&amp; a) &#123; <span class="built_in">LOGI</span>(<span class="built_in">WHAT</span>(<span class="string">&quot;copy contruct A&quot;</span>)); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动构造函数</span></span><br><span class="line">    <span class="built_in">A</span>(A&amp;&amp; a) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="built_in">LOGI</span>(<span class="built_in">WHAT</span>(<span class="string">&quot;move contruct A&quot;</span>));</span><br><span class="line">        m_str = std::<span class="built_in">move</span>(a.m_str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">A</span>() &#123;</span><br><span class="line">        <span class="built_in">LOGI</span>(<span class="built_in">WHAT</span>(<span class="string">&quot;destruct A&quot;</span>));</span><br><span class="line">        <span class="keyword">if</span> (m_ptr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span>[] m_ptr;</span><br><span class="line">            m_ptr = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝赋值函数</span></span><br><span class="line">    A&amp; <span class="keyword">operator</span>=(<span class="type">const</span> A&amp; a) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;a) <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">LOGI</span>(<span class="built_in">WHAT</span>(<span class="string">&quot;copy assign A&quot;</span>));</span><br><span class="line">        m_str = a.m_str;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动赋值函数</span></span><br><span class="line">    A&amp; <span class="keyword">operator</span>=(A&amp;&amp; a) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;a) <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">LOGI</span>(<span class="built_in">WHAT</span>(<span class="string">&quot;move assign A&quot;</span>));</span><br><span class="line">        m_str = std::<span class="built_in">move</span>(a.m_str);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::string m_str;</span><br><span class="line">    <span class="type">int</span>* m_ptr = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    a.m_str = <span class="string">&quot;adasdfas&quot;</span>;</span><br><span class="line">    A b;</span><br><span class="line">    b = a;              <span class="comment">// 拷贝赋值</span></span><br><span class="line">    b = std::<span class="built_in">move</span>(a);   <span class="comment">// 移动赋值</span></span><br><span class="line">    <span class="built_in">LOGI</span>(<span class="built_in">WHAT</span>(<span class="string">&quot;a str &#123;&#125;&quot;</span>, a.m_str));</span><br><span class="line">    <span class="built_in">LOGI</span>(<span class="built_in">WHAT</span>(<span class="string">&quot;b str &#123;&#125;&quot;</span>, b.m_str));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>拷贝赋值和移动赋值都需要判断是否为自己，否则可能出现下面的情况</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">A&amp; <span class="keyword">operator</span>=(<span class="type">const</span> A&amp; a) &#123;</span><br><span class="line">    <span class="comment">// 如果是a也是this，下面的语句会导致a里面的m_ptr原来指向的内存泄漏，而且memcpy拷贝的也是无效内存</span></span><br><span class="line">    m_ptr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>];</span><br><span class="line">    <span class="built_in">memcpy</span>(m_ptr, a.m_ptr, <span class="built_in">sizeof</span>(<span class="type">int</span>) * <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>还需要考虑异常安全性，如果在移动赋值中，原始内存被释放，单纯的浅拷贝<code>m_ptr</code>同样会出问题</li></ul><h2 id="10-extern-C"><a href="#10-extern-C" class="headerlink" title="10. extern &quot;C&quot;"></a>10. <code>extern &quot;C&quot;</code></h2><ul><li>被修饰的变量和函数是按照C语言方式进行编译和链接</li></ul><h2 id="11-右值和右值引用"><a href="#11-右值和右值引用" class="headerlink" title="11. 右值和右值引用"></a>11. 右值和右值引用</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">A <span class="title">getA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    a.a = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">A <span class="title">getMoveA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    a.a = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">move</span>(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 下面的函数编译失败，a不是右值</span></span><br><span class="line"><span class="comment">A &amp;&amp;getRightA() &#123;</span></span><br><span class="line"><span class="comment">    A a;</span></span><br><span class="line"><span class="comment">    a.a = 2;</span></span><br><span class="line"><span class="comment">    return a;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function">A &amp;&amp;<span class="title">getRightA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">A</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">A &amp;&amp;<span class="title">getMoveRightA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    a.a = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">move</span>(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">LOGI</span>(<span class="built_in">WHAT</span>(<span class="string">&quot;gcc default&quot;</span>));</span><br><span class="line">    <span class="comment">// gcc default</span></span><br><span class="line">    A a = <span class="built_in">getA</span>();</span><br><span class="line">    <span class="comment">// contruct A</span></span><br><span class="line">    a = <span class="built_in">getA</span>();</span><br><span class="line">    <span class="comment">// contruct A</span></span><br><span class="line">    <span class="comment">// move assign A</span></span><br><span class="line">    <span class="comment">// destruct A</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOGI</span>(<span class="built_in">WHAT</span>(<span class="string">&quot;getMoveA&quot;</span>));</span><br><span class="line">    <span class="comment">// getMoveA</span></span><br><span class="line">    A b = <span class="built_in">getMoveA</span>();</span><br><span class="line">    <span class="comment">// contruct A</span></span><br><span class="line">    <span class="comment">// move contruct A</span></span><br><span class="line">    <span class="comment">// destruct A</span></span><br><span class="line">    b = <span class="built_in">getMoveA</span>();</span><br><span class="line">    <span class="comment">// contruct A</span></span><br><span class="line">    <span class="comment">// move contruct A</span></span><br><span class="line">    <span class="comment">// destruct A</span></span><br><span class="line">    <span class="comment">// move assign A</span></span><br><span class="line">    <span class="comment">// destruct A</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOGI</span>(<span class="built_in">WHAT</span>(<span class="string">&quot;getRightA&quot;</span>));</span><br><span class="line">    <span class="comment">// getRightA</span></span><br><span class="line">    A c = <span class="built_in">getRightA</span>();</span><br><span class="line">    <span class="comment">// contruct A</span></span><br><span class="line">    <span class="comment">// destruct A</span></span><br><span class="line">    <span class="comment">// move contruct A</span></span><br><span class="line">    c = <span class="built_in">getRightA</span>();</span><br><span class="line">    <span class="comment">// contruct A</span></span><br><span class="line">    <span class="comment">// destruct A</span></span><br><span class="line">    <span class="comment">// move assign A</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">LOGI</span>(<span class="built_in">WHAT</span>(<span class="string">&quot;getMoveRightA&quot;</span>));</span><br><span class="line">    <span class="comment">// getMoveRightA</span></span><br><span class="line">    A d = <span class="built_in">getMoveRightA</span>();</span><br><span class="line">    <span class="comment">// contruct A</span></span><br><span class="line">    <span class="comment">// destruct A</span></span><br><span class="line">    <span class="comment">// move contruct A</span></span><br><span class="line">    d = <span class="built_in">getMoveRightA</span>();</span><br><span class="line">    <span class="comment">// contruct A</span></span><br><span class="line">    <span class="comment">// destruct A</span></span><br><span class="line">    <span class="comment">// move assign A</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二、std-标准库"><a href="#二、std-标准库" class="headerlink" title="二、std 标准库"></a>二、std 标准库</h1><h2 id="1-输入输出-iostream"><a href="#1-输入输出-iostream" class="headerlink" title="1. 输入输出 iostream"></a>1. 输入输出 iostream</h2><h3 id="1-1-输入"><a href="#1-1-输入" class="headerlink" title="1.1. 输入"></a>1.1. 输入</h3><h4 id="1-读取一行（包含空格，回车结束）"><a href="#1-读取一行（包含空格，回车结束）" class="headerlink" title="1) 读取一行（包含空格，回车结束）"></a>1) 读取一行（包含空格，回车结束）</h4><p>cin 只能读取到空格结束，想要读取一行可以用 getline 函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string input;</span><br><span class="line">    <span class="built_in">getline</span>(cin, input);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-文件流-fstream"><a href="#2-文件流-fstream" class="headerlink" title="2. 文件流 fstream"></a>2. 文件流 fstream</h2><h3 id="2-1-读取文件-ifstream"><a href="#2-1-读取文件-ifstream" class="headerlink" title="2.1. 读取文件 ifstream"></a>2.1. 读取文件 ifstream</h3><h4 id="1-判断文件是否可读"><a href="#1-判断文件是否可读" class="headerlink" title="1) 判断文件是否可读"></a>1) 判断文件是否可读</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::ifstream <span class="title">inFile</span><span class="params">(<span class="string">&quot;xxx.txt&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!inFile) &#123;</span><br><span class="line">        <span class="comment">// 不可读，错误信息在errno中，windows在GetLastError()</span></span><br><span class="line">        <span class="keyword">auto</span> ec = std::<span class="built_in">error_code</span>(errno, std::<span class="built_in">system_category</span>());</span><br><span class="line">        <span class="built_in">LOGI</span>(<span class="built_in">WHAT</span>(<span class="string">&quot;open file failed, &#123;&#125; &#123;&#125;&quot;</span>, ec.<span class="built_in">value</span>(), ec.<span class="built_in">message</span>()));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    inFile.<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-按行读取"><a href="#2-按行读取" class="headerlink" title="2) 按行读取"></a>2) 按行读取</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;system_error&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::ifstream <span class="title">inFile</span><span class="params">(<span class="string">&quot;test.txt&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!inFile) &#123;</span><br><span class="line">        <span class="keyword">auto</span> ec = std::<span class="built_in">error_code</span>(errno, std::<span class="built_in">system_category</span>());</span><br><span class="line">        <span class="built_in">LOGI</span>(<span class="built_in">WHAT</span>(<span class="string">&quot;open file failed, &#123;&#125; &#123;&#125;&quot;</span>, ec.<span class="built_in">value</span>(), ec.<span class="built_in">message</span>()));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!inFile.<span class="built_in">eof</span>()) &#123;</span><br><span class="line">        std::string line;</span><br><span class="line">        inFile &gt;&gt; line;     <span class="comment">// 以空格和换行分割，自动识别换行类型</span></span><br><span class="line">        <span class="built_in">LOG_HEX</span>(line.<span class="built_in">data</span>(), line.<span class="built_in">size</span>());  <span class="comment">// 不带空格和换行符</span></span><br><span class="line">    &#125;</span><br><span class="line">    inFile.<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-函数包装器模板-function"><a href="#3-函数包装器模板-function" class="headerlink" title="3. 函数包装器模板 function"></a>3. 函数包装器模板 function</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/heartchord/p/5017071.html">std::function 介绍</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> callback = std::function&lt;<span class="built_in">void</span>()&gt;;</span><br></pre></td></tr></table></figure><h3 id="3-1-比较两个function相等"><a href="#3-1-比较两个function相等" class="headerlink" title="3.1. 比较两个function相等"></a>3.1. 比较两个function相等</h3><ul><li>C++11还没有实现function类的直接对比，建议使用其他方案，不要判断相等</li></ul><h2 id="4-原子操作-atomic"><a href="#4-原子操作-atomic" class="headerlink" title="4. 原子操作 atomic"></a>4. 原子操作 atomic</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/taiyang-li/p/5914331.html">std::atomic 原子操作</a></p><h2 id="5-对象转移所有权-move"><a href="#5-对象转移所有权-move" class="headerlink" title="5. 对象转移所有权 move"></a>5. 对象转移所有权 move</h2><ul><li><code>std::move</code>的本质是将对象的类型转成右值，在使用<code>=</code>时会根据类型匹配最合适的也就是移动赋值函数，里面会将对象的所有属性赋值给新变量，所以看起来老变量属性消失了</li><li>如果单纯调用<code>std::move</code>仅仅是做了一个转换，没有任何效果</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::future&lt;<span class="type">void</span>&gt; <span class="title">testFunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> f1 = std::<span class="built_in">async</span>(std::launch::async, [&amp;ioc]() &#123;</span><br><span class="line">        std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line">        <span class="built_in">LOGI</span>(<span class="built_in">WHAT</span>(<span class="string">&quot;async exit&quot;</span>));</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> f1;  <span class="comment">// 编译器优化，直接将对象返回，不产生拷贝也不产生移动，外面直接拿到此变量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argC, <span class="type">char</span> *argV[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> f1 = <span class="built_in">testFunc</span>();</span><br><span class="line">    std::future&lt;<span class="type">void</span>&gt; f2 = f1;              <span class="comment">// 编译报错，f1不存在拷贝构造函数</span></span><br><span class="line">    std::future&lt;<span class="type">void</span>&gt; f2 = std::<span class="built_in">move</span>(f1);   <span class="comment">// 可以运行，因为调用了移动构造函数，将f1移动给f2</span></span><br><span class="line">    f1.<span class="built_in">wait</span>();      <span class="comment">// 运行报错，因为f1已经被移动给了f2，f1已经没有作用了</span></span><br><span class="line">    f2.<span class="built_in">wait</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-字符串流-sstream"><a href="#6-字符串流-sstream" class="headerlink" title="6. 字符串流 sstream"></a>6. 字符串流 sstream</h2><h3 id="6-1-stringstream"><a href="#6-1-stringstream" class="headerlink" title="6.1. stringstream"></a>6.1. stringstream</h3><ul><li>stringstream并没有比string优化性能，主要作用是数据类型转化和数据切割</li><li>使用流的方式可以不用关心数据类型，默认会转成字符串</li><li>stringstream只是把string的操作转成了流的概念，但是操作上会构造析构类，<code>str()</code>还存在字符串拷贝</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> string <span class="title">to_string</span><span class="params">(DomainType type)</span> </span>&#123;</span><br><span class="line">    stringstream ss;</span><br><span class="line">    ss &lt;&lt; <span class="string">&quot;&#123;&quot;</span>;</span><br><span class="line">    ss &lt;&lt; <span class="string">R&quot;(&quot;resource&quot;:)&quot;</span> &lt;&lt; type.resource &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">    ss &lt;&lt; <span class="string">R&quot;(&quot;outerDNSEnable&quot;:)&quot;</span> &lt;&lt; type.outerDNSEnable &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">    ss &lt;&lt; <span class="string">R&quot;(&quot;reserved&quot;:)&quot;</span> &lt;&lt; type.reserved &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">    ss &lt;&lt; <span class="string">R&quot;(&quot;type&quot;:)&quot;</span> &lt;&lt; type.type;</span><br><span class="line">    ss &lt;&lt; <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> ss.<span class="built_in">str</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace std</span></span><br></pre></td></tr></table></figure><h2 id="7-流格式控制符-iomanip"><a href="#7-流格式控制符-iomanip" class="headerlink" title="7. 流格式控制符 iomanip"></a>7. 流格式控制符 iomanip</h2><h3 id="7-1-setfill-setw"><a href="#7-1-setfill-setw" class="headerlink" title="7.1. setfill setw"></a>7.1. setfill setw</h3><ul><li>只能对流对象操作，不能对string操作</li><li>setfill作用于流上会一直生效到流析构，setw只对紧跟的一个输入有效</li></ul><h4 id="1-输出宽度和前缀控制"><a href="#1-输出宽度和前缀控制" class="headerlink" title="1) 输出宽度和前缀控制"></a>1) 输出宽度和前缀控制</h4><ul><li><code>std::left</code>和<code>std::right</code>都是全局生效的</li><li>&#96;&#96;</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出乘法口诀表</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argC, <span class="type">char</span> *argV[])</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> colwidth = <span class="number">5</span>;</span><br><span class="line">    std::stringstream ss;</span><br><span class="line">    ss &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27; &#x27;</span>);    <span class="comment">// 全局生效使用空格填充</span></span><br><span class="line">    <span class="comment">// 标题 左对齐用left，右对齐用right，默认右对齐</span></span><br><span class="line">    ss &lt;&lt; std::left &lt;&lt; std::<span class="built_in">setw</span>(colwidth) &lt;&lt; <span class="string">&quot;l&quot;</span></span><br><span class="line">       &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    ss &lt;&lt; std::right &lt;&lt; std::<span class="built_in">setw</span>(colwidth) &lt;&lt; <span class="string">&quot;r&quot;</span>;</span><br><span class="line">    ss &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 表头</span></span><br><span class="line">    ss &lt;&lt; std::<span class="built_in">setw</span>(colwidth) &lt;&lt; <span class="string">&quot;*&quot;</span></span><br><span class="line">       &lt;&lt; <span class="string">&quot;|&quot;</span>;      <span class="comment">// setw只对*生效，|不固定长度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        ss &lt;&lt; std::<span class="built_in">setw</span>(colwidth) &lt;&lt; i;</span><br><span class="line">    &#125;</span><br><span class="line">    ss &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 分割符</span></span><br><span class="line">    ss &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;-&#x27;</span>);    <span class="comment">// 全局生效使用-填充</span></span><br><span class="line">    ss &lt;&lt; std::<span class="built_in">setw</span>(colwidth) &lt;&lt; <span class="string">&quot;&quot;</span></span><br><span class="line">       &lt;&lt; <span class="string">&quot;+&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        ss &lt;&lt; std::<span class="built_in">setw</span>(colwidth) &lt;&lt; <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ss &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 内容</span></span><br><span class="line">    ss &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27; &#x27;</span>);    <span class="comment">// 全局生效使用空格填充</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        ss &lt;&lt; std::<span class="built_in">setw</span>(colwidth) &lt;&lt; i &lt;&lt; <span class="string">&quot;|&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">            ss &lt;&lt; std::<span class="built_in">setw</span>(colwidth) &lt;&lt; i * j;</span><br><span class="line">        &#125;</span><br><span class="line">        ss &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; ss.<span class="built_in">str</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">l         r</span><br><span class="line">    *|    1    2    3    4    5    6    7    8    9</span><br><span class="line">-----+---------------------------------------------</span><br><span class="line">    1|    1    2    3    4    5    6    7    8    9</span><br><span class="line">    2|    2    4    6    8   10   12   14   16   18</span><br><span class="line">    3|    3    6    9   12   15   18   21   24   27</span><br><span class="line">    4|    4    8   12   16   20   24   28   32   36</span><br><span class="line">    5|    5   10   15   20   25   30   35   40   45</span><br><span class="line">    6|    6   12   18   24   30   36   42   48   54</span><br><span class="line">    7|    7   14   21   28   35   42   49   56   63</span><br><span class="line">    8|    8   16   24   32   40   48   56   64   72</span><br><span class="line">    9|    9   18   27   36   45   54   63   72   81</span><br></pre></td></tr></table></figure><h4 id="2-进制转化输出"><a href="#2-进制转化输出" class="headerlink" title="2) 进制转化输出"></a>2) 进制转化输出</h4><ul><li><code>std::oct</code>、<code>std::dec</code>和<code>std::hex</code>同样是全局生效的，设置完需要重置，否则后续输出都会变化</li><li>进制转换对于char和uint8_t类型的数据，输出的是字符，而不是对应进制的数字，如果需要输出数字，需要使用<code>static_cast&lt;uint16_t&gt;</code></li><li><code>std::uppercase</code>和<code>std::nouppercase</code>控制大小写，全局生效</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argC, <span class="type">char</span> *argV[])</span> </span>&#123;</span><br><span class="line">    std::stringstream ss;</span><br><span class="line">    <span class="comment">// 二进制输出需要包含 &lt;bitset&gt; 头文件，使用bitset才可以输出二进制字符串</span></span><br><span class="line">    <span class="comment">// 前缀0b，二进制输出，固定宽度16，前面补0</span></span><br><span class="line">    ss &lt;&lt; <span class="string">&quot;0b&quot;</span> &lt;&lt; std::<span class="built_in">bitset</span>&lt;<span class="number">16</span>&gt;(<span class="number">0x123</span>) &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 前缀0，八进制输出，固定宽度4，前面补0</span></span><br><span class="line">    ss &lt;&lt; <span class="string">&quot;0&quot;</span> &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">4</span>) &lt;&lt; std::oct &lt;&lt; <span class="number">0x123</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 前缀无，十进制输出，固定宽度16，左对齐</span></span><br><span class="line">    ss &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27; &#x27;</span>) &lt;&lt; std::left &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">4</span>) &lt;&lt; std::dec &lt;&lt; <span class="number">0x123</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 前缀0x，十六进制输出，固定宽度4，前面补0</span></span><br><span class="line">    ss &lt;&lt; <span class="string">&quot;0x&quot;</span> &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">4</span>) &lt;&lt; std::hex &lt;&lt; <span class="number">0x123</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; ss.<span class="built_in">str</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0b0000000100100011</span><br><span class="line">00443</span><br><span class="line">291</span><br><span class="line">0x1230</span><br></pre></td></tr></table></figure><h1 id="三、STL-容器"><a href="#三、STL-容器" class="headerlink" title="三、STL 容器"></a>三、STL 容器</h1><ol><li><p>vector （连续的空间存储,可以使用[]操作符）快速的访问随机的元素，快速的在末尾插入元素，但是在序列中间岁间的插入，删除元素要慢，而且如果一开始分配的空间不够的话，有一个重新分配更大空间，然后拷贝的性能开销.</p></li><li><p>deque （小片的连续，小片间用链表相连，实际上内部有一个 map 的指针，因为知道类型，所以还是可以使用[]，只是速度没有 vector 快）快速的访问随机的元素，快速的在开始和末尾插入元素，随机的插入，删除元素要慢，空间的重新分配要比 vector 快,重新分配空间后，原有的元素不需要拷贝。对 deque 的排序操作，可将 deque 先复制到 vector，排序后在复制回 deque。</p></li><li><p>list （每个元素间用链表相连）访问随机元素不如 vector 快，随机的插入元素比 vector 快，对每个元素分配空间，所以不存在空间不够，重新分配的情况</p></li><li><p>set  内部元素唯一，用一棵平衡树结构来存储，因此遍历的时候就排序了，查找也比较快的哦。</p></li><li><p>map  一对一的映射的结合，key 不能重复。</p></li><li><p>stack  适配器，必须结合其他的容器使用，stl 中默认的内部容器是 deque。先进后出，只有一个出口，不允许遍历。</p></li><li><p>queue  是受限制的 deque，内部容器一般使用 list 较简单。先进先出，不允许遍历。</p></li></ol><p><strong>下面是选择顺序容器类型的一些准则</strong></p><ol><li><p>如果我们需要随机访问一个容器则 vector 要比 list 好得多。</p></li><li><p>如果我们已知要存储元素的个数则 vector  又是一个比 list 好的选择。</p></li><li><p>如果我们需要的不只是在容器两端插入和删除元素则 list 显然要比 vector 好</p></li><li><p>除非我们需要在容器首部插入和删除元素否则 vector 要比 deque 好。</p></li><li><p>如果只在容易的首部和尾部插入数据元素，则选择 deque。</p></li><li><p>如果只需要在读取输入时在容器的中间位置插入元素，然后需要随机访问元素，则可考虑输入时将元素读入到一个 List 容器，接着对此容器重新拍学，使其适合顺序访问，然后将排序后的 list 容器复制到一个 vector 容器中</p></li></ol><h2 id="std-vector-向量"><a href="#std-vector-向量" class="headerlink" title="std::vector 向量"></a>std::vector 向量</h2><h3 id="1-操作接口"><a href="#1-操作接口" class="headerlink" title="(1) 操作接口"></a>(1) 操作接口</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;Type&gt; vType;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description 传回最后一个数据，不检查这个数据是否存在，不存在会抛出异常。</span></span><br><span class="line"><span class="comment"> * @return 返回值描述 (const vType &amp;)(vType &amp;)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">vType.<span class="built_in">back</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description 传回第一个数据，不检查这个数据是否存在，不存在会抛出异常。</span></span><br><span class="line"><span class="comment"> * @return 返回值描述 (const vType &amp;)(vType &amp;)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">vType.<span class="built_in">front</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description 判断容器是否为空。</span></span><br><span class="line"><span class="comment"> * @return 返回值描述 bool</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">vType.<span class="built_in">empty</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description 删除最后一个数据，空向量不会报错。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">vType.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description 移除容器中所有数据。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">vType.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description C++11前使用的插入函数</span></span><br><span class="line"><span class="comment"> * @param (const Type &amp;)要插入的数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">vType.<span class="built_in">push_back</span>(<span class="built_in">Type</span>(param));</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description C++11使用的插入函数</span></span><br><span class="line"><span class="comment"> * @param (const Type &amp;)要插入的数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">vType.<span class="built_in">emplace_back</span>(<span class="built_in">Type</span>(param));</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description 返回第i个数据，相当于vType[i]</span></span><br><span class="line"><span class="comment"> * @param (size_type)数据索引</span></span><br><span class="line"><span class="comment"> * @return 返回值描述 (const vType &amp;)(vType &amp;)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">vType.<span class="built_in">at</span>(i);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description 返回指向数组第一个元素的指针，空向量返回NULL</span></span><br><span class="line"><span class="comment"> * @return 返回值描述 (const vType *)(vType *)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">vType.<span class="built_in">data</span>();</span><br></pre></td></tr></table></figure><h3 id="2-初始化"><a href="#2-初始化" class="headerlink" title="(2) 初始化"></a>(2) 初始化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从数组初始化</span></span><br><span class="line">    <span class="type">uint8_t</span> data[] = &#123;<span class="number">0x11</span>, <span class="number">0x34</span>, <span class="number">0x12</span>, <span class="number">0xa3</span>, <span class="number">0x01</span>, <span class="number">0x23</span>&#125;;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">uint8_t</span>&gt; <span class="title">vData</span><span class="params">(data, data + <span class="keyword">sizeof</span>(data))</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-删除元素"><a href="#3-删除元素" class="headerlink" title="(3) 删除元素"></a>(3) 删除元素</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;std::string&gt; sessionMap;</span><br><span class="line">sessionMap.<span class="built_in">emplace_back</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">sessionMap.<span class="built_in">emplace_back</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iter = sessionMap.<span class="built_in">begin</span>(); iter != sessionMap.<span class="built_in">end</span>();) &#123;</span><br><span class="line">    <span class="comment">// 删除元素后，需要重新拿到iter，erase接口返回的就是下一个iter</span></span><br><span class="line">    <span class="keyword">if</span> (*iter == <span class="string">&quot;b&quot;</span>) &#123;</span><br><span class="line">        iter = sessionMap.<span class="built_in">erase</span>(iter);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ++iter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="std-map"><a href="#std-map" class="headerlink" title="std::map"></a>std::map</h2><h3 id="1-查找元素"><a href="#1-查找元素" class="headerlink" title="(1) 查找元素"></a>(1) 查找元素</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;QString, std::shared_ptr&lt;Session&gt;&gt; sessionMap;</span><br><span class="line">sessionMap[<span class="string">&quot;Hello&quot;</span>] = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="comment">// count查找</span></span><br><span class="line"><span class="keyword">if</span> (sessionMap.<span class="built_in">count</span>(<span class="string">&quot;Hello&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;Key \&quot;Hello\&quot; isn&#x27;t in map&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// find查找</span></span><br><span class="line"><span class="keyword">if</span> (sessionMap.<span class="built_in">find</span>(<span class="string">&quot;Hello&quot;</span>) != sessionMap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;Key \&quot;Hello\&quot; isn&#x27;t in map&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> sessionMap[<span class="string">&quot;Hello&quot;</span>];</span><br></pre></td></tr></table></figure><h3 id="2-遍历元素"><a href="#2-遍历元素" class="headerlink" title="(2) 遍历元素"></a>(2) 遍历元素</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;std::string, std::string&gt; sessionMap;</span><br><span class="line">sessionMap[<span class="string">&quot;a&quot;</span>] = <span class="string">&quot;b&quot;</span>;</span><br><span class="line">sessionMap[<span class="string">&quot;c&quot;</span>] = <span class="string">&quot;d&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iter = sessionMap.<span class="built_in">begin</span>(); iter != sessionMap.<span class="built_in">end</span>(); iter++) &#123;</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;key &#123;&#125;, value &#123;&#125;&quot;</span>, iter-&gt;first.<span class="built_in">c_str</span>(), iter-&gt;second.<span class="built_in">c_str</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-删除元素-1"><a href="#3-删除元素-1" class="headerlink" title="(3) 删除元素"></a>(3) 删除元素</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;std::string, std::string&gt; sessionMap;</span><br><span class="line">sessionMap[<span class="string">&quot;a&quot;</span>] = <span class="string">&quot;b&quot;</span>;</span><br><span class="line">sessionMap[<span class="string">&quot;c&quot;</span>] = <span class="string">&quot;d&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iter = sessionMap.<span class="built_in">begin</span>(); iter != sessionMap.<span class="built_in">end</span>();) &#123;</span><br><span class="line">    <span class="comment">// 删除元素后，需要重新拿到iter，使用iter++会先得到iter + 1的值再做清理，这样清理后会得到下一个迭代器</span></span><br><span class="line">    <span class="comment">// 如果先清理再++，会出现段错误，因为iter已经被清理掉了</span></span><br><span class="line">    <span class="keyword">if</span> (iter-&gt;second == <span class="string">&quot;d&quot;</span>) &#123;</span><br><span class="line">        sessionMap.<span class="built_in">erase</span>(iter++);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ++iter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="std-stack"><a href="#std-stack" class="headerlink" title="std::stack"></a>std::stack</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; myStack;     <span class="comment">//定义类型为int</span></span><br><span class="line">    myStack.<span class="built_in">push</span>(<span class="number">10</span>);       <span class="comment">//入栈</span></span><br><span class="line">    myStack.<span class="built_in">push</span>(<span class="number">50</span>);       <span class="comment">//入栈</span></span><br><span class="line">    <span class="type">int</span> a = myStack.<span class="built_in">top</span>();  <span class="comment">//返回栈顶元素的引用，不会出栈</span></span><br><span class="line">    myStack.<span class="built_in">pop</span>();          <span class="comment">//出栈，void型</span></span><br><span class="line">    <span class="type">bool</span> isEmpty = myStack.<span class="built_in">empty</span>();         <span class="comment">//是否为空</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> size = myStack.<span class="built_in">size</span>();    <span class="comment">//栈的元素数量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="std-queue"><a href="#std-queue" class="headerlink" title="std::queue"></a>std::queue</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; myQueue;         <span class="comment">//定义类型为int</span></span><br><span class="line">    myQueue.<span class="built_in">push</span>(<span class="number">10</span>);           <span class="comment">//入队</span></span><br><span class="line">    myQueue.<span class="built_in">push</span>(<span class="number">50</span>);           <span class="comment">//入队</span></span><br><span class="line">    <span class="type">int</span> a = myQueue.<span class="built_in">front</span>();    <span class="comment">//返回队列最先进入的元素的引用，不会出队</span></span><br><span class="line">    <span class="type">int</span> b = myQueue.<span class="built_in">back</span>();     <span class="comment">//返回队列最后进入的元素的引用，不会出队</span></span><br><span class="line">    myQueue.<span class="built_in">pop</span>();              <span class="comment">//删除最先进入队列的元素，void型</span></span><br><span class="line">    <span class="type">bool</span> isEmpty = myQueue.<span class="built_in">empty</span>();         <span class="comment">//队列是否为空</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> size = myQueue.<span class="built_in">size</span>();    <span class="comment">//队列的元素数量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="std-set-集合"><a href="#std-set-集合" class="headerlink" title="std::set 集合"></a>std::set 集合</h2><ul><li>集合里面的值唯一，可以用于去重</li><li>集合操作可以实现类似交集、并集、差集的计算</li><li>也可以看作一个无 value 的 map，底层和 map 一样使用红黑树实现</li></ul><h3 id="1-一些基本用法"><a href="#1-一些基本用法" class="headerlink" title="(1) 一些基本用法"></a>(1) 一些基本用法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义</span></span><br><span class="line">std::set&lt;std::string&gt; testSet;</span><br><span class="line"><span class="comment">// 插入</span></span><br><span class="line">testSet.<span class="built_in">insert</span>(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line"><span class="comment">// 转vector</span></span><br><span class="line"><span class="function">std::vector <span class="title">testV</span><span class="params">(testSet.begin(), testSet.end())</span></span>;</span><br></pre></td></tr></table></figure><h3 id="2-自定义类型使用set"><a href="#2-自定义类型使用set" class="headerlink" title="(2) 自定义类型使用set"></a>(2) 自定义类型使用set</h3><ul><li>需要重载<code>bool operator&lt;()</code></li></ul><h2 id="std-multimap-允许重复键的map"><a href="#std-multimap-允许重复键的map" class="headerlink" title="std::multimap 允许重复键的map"></a>std::multimap 允许重复键的map</h2><h3 id="1-实例"><a href="#1-实例" class="headerlink" title="1) 实例"></a>1) 实例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;log.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argC, <span class="type">char</span> *argV[])</span> </span>&#123;</span><br><span class="line">    std::multimap&lt;<span class="type">int</span>, string&gt; testMap;</span><br><span class="line">    testMap.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(<span class="number">6</span>, <span class="string">&quot;12&quot;</span>));</span><br><span class="line">    testMap.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(<span class="number">5</span>, <span class="string">&quot;123&quot;</span>));</span><br><span class="line">    testMap.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(<span class="number">5</span>, <span class="string">&quot;123&quot;</span>));</span><br><span class="line">    testMap.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(<span class="number">5</span>, <span class="string">&quot;1235&quot;</span>));</span><br><span class="line">    testMap.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(<span class="number">5</span>, <span class="string">&quot;12&quot;</span>));</span><br><span class="line">    testMap.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(<span class="number">4</span>, <span class="string">&quot;12&quot;</span>));</span><br><span class="line">    testMap.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(<span class="number">5</span>, <span class="string">&quot;1245&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> np = testMap.<span class="built_in">equal_range</span>(<span class="number">5</span>);       <span class="comment">// 获取所有5作为key的元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = np.first; iter != np.second; iter++) &#123;</span><br><span class="line">        <span class="built_in">LOGI</span>(<span class="built_in">WHAT</span>(<span class="string">&quot;&#123;&#125; &#123;&#125;&quot;</span>, iter-&gt;first, iter-&gt;second));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">5 123</span><br><span class="line">5 123</span><br><span class="line">5 1235</span><br><span class="line">5 12</span><br><span class="line">5 1245</span><br></pre></td></tr></table></figure><h2 id="std-string"><a href="#std-string" class="headerlink" title="std::string"></a>std::string</h2><h3 id="1-data-和-c-str-区别"><a href="#1-data-和-c-str-区别" class="headerlink" title="1) data()和 c_str()区别"></a>1) data()和 c_str()区别</h3><p>data()效率较 c_str()高一些，但是 c_str()更加标准，结尾会加入’\0’。</p><h3 id="2-find-last-of"><a href="#2-find-last-of" class="headerlink" title="2) find_last_of()"></a>2) find_last_of()</h3><p>可以从后往前找匹配的字符，并且，这个字符可以以字串的形式给出，也就是只要匹配参数中字串的任意字符就返回其位置。第二参数可选，为起始位置，默认为 npos。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">std::string str = <span class="string">&quot;012345678&quot;</span>;</span><br><span class="line"><span class="type">int</span> index = str.<span class="built_in">find_last_of</span>(<span class="string">&quot;3&quot;</span>);  <span class="comment">//3</span></span><br><span class="line">index = str.<span class="built_in">find_last_of</span>(<span class="string">&quot;8&quot;</span>);      <span class="comment">//8</span></span><br><span class="line">index = str.<span class="built_in">find_last_of</span>(<span class="string">&quot;8&quot;</span>, <span class="number">7</span>);   <span class="comment">//-1</span></span><br><span class="line">index = str.<span class="built_in">find_last_of</span>(<span class="string">&quot;8&quot;</span>, <span class="number">8</span>);   <span class="comment">//8</span></span><br><span class="line">index = str.<span class="built_in">find_last_of</span>(<span class="string">&quot;0&quot;</span>);      <span class="comment">//0</span></span><br><span class="line">index = str.<span class="built_in">find_last_of</span>(<span class="string">&quot;9&quot;</span>);      <span class="comment">//-1</span></span><br><span class="line">index = str.<span class="built_in">find_last_of</span>(<span class="string">&quot;24&quot;</span>);     <span class="comment">//4</span></span><br></pre></td></tr></table></figure><h3 id="3-substr"><a href="#3-substr" class="headerlink" title="3) substr()"></a>3) substr()</h3><p>两个参数，第一个为起始位置，第二个为 size。</p><h2 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li><code>push()</code>，实际上是调用的底层容器的<code>push_back()</code>函数，新元素的值是 push 函数参数的一个拷贝。</li><li><code>emplace()</code>，实际上是调用的底层容器的<code>emplace_back()</code>函数，新元素的值是在容器内部就地构造的，不需要移动或者拷贝。</li></ul><h2 id="通用工具方法-algorithm"><a href="#通用工具方法-algorithm" class="headerlink" title="通用工具方法 algorithm"></a>通用工具方法 algorithm</h2><h3 id="max-最大值"><a href="#max-最大值" class="headerlink" title="max()最大值"></a>max()最大值</h3><h3 id="min-最小值"><a href="#min-最小值" class="headerlink" title="min()最小值"></a>min()最小值</h3><h3 id="swap-交换两个值"><a href="#swap-交换两个值" class="headerlink" title="swap()交换两个值"></a>swap()交换两个值</h3><h3 id="sort-排序"><a href="#sort-排序" class="headerlink" title="sort()排序"></a>sort()排序</h3><p><strong>注意事项</strong></p><ul><li>如果自定义排序函数，需要满足下面的原则</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 对于任意元素a，需满足 comp(a, a) == false</span><br><span class="line">2. 对于任意两个元素a和b，若 comp(a, b)==true 则要满足 comp(b, a)==false</span><br><span class="line">3. 对于任意三个元素a、b和c，若 comp(a, b)==true 且 comp(b, c)==true 则需要满足 comp(a, c)==true</span><br></pre></td></tr></table></figure><ul><li>具体原因可以看这个文章<a target="_blank" rel="noopener" href="https://blog.csdn.net/albertsh/article/details/119523587">C++中使用 std::sort 自定义排序规则时要注意的崩溃问题</a></li><li>解释一下原因就是<ol><li>stl 的排序使用了快排、堆排和插排</li><li>在插排时，代码为了效率，不考虑边界判断</li><li>如果写了 comp(a, a) &#x3D;&#x3D; true，会导致插排的循环一直向后找到越界</li></ol></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="built_in">LOGI</span>(<span class="built_in">WHAT</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, a.<span class="built_in">front</span>()));</span><br><span class="line">    <span class="comment">// 返回true，i排j前，返回false，j排i前；i == j，必须返回false</span></span><br><span class="line">    std::<span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), [](<span class="type">const</span> <span class="type">int</span> &amp;i, <span class="type">const</span> <span class="type">int</span> &amp;j)&#123;</span><br><span class="line">        <span class="keyword">return</span> i &gt; j;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">LOGI</span>(<span class="built_in">WHAT</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, a.<span class="built_in">front</span>()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="count-统计数量"><a href="#count-统计数量" class="headerlink" title="count()统计数量"></a>count()统计数量</h3><h3 id="unique-去重"><a href="#unique-去重" class="headerlink" title="unique()去重"></a>unique()去重</h3><ul><li>从头到尾遍历，将相邻的相同元素，留一个，其他的放到末尾</li><li>返回末尾筛选出的元素第一个</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; input;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">    <span class="type">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; tmp;</span><br><span class="line">    input.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 先排序</span></span><br><span class="line"><span class="built_in">sort</span>(input.<span class="built_in">begin</span>(), input.<span class="built_in">end</span>());</span><br><span class="line"><span class="comment">// 擦除相同元素</span></span><br><span class="line">input.<span class="built_in">erase</span>(<span class="built_in">unique</span>(input.<span class="built_in">begin</span>(), input.<span class="built_in">end</span>()), input.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;tmp : input) &#123;</span><br><span class="line">    cout &lt;&lt; tmp &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="erase-擦除"><a href="#erase-擦除" class="headerlink" title="erase()擦除"></a>erase()擦除</h3><p>使用遍历的时候，如果去除一个对象，遍历的变量会直接指向下一个，需要注意</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;Type&gt; vType;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = vType.<span class="built_in">cbegin</span>(); it != vType.<span class="built_in">cend</span>();) &#123;</span><br><span class="line">    <span class="keyword">if</span>(...) &#123;</span><br><span class="line">        <span class="comment">//擦除后会直接指向下一块地址，不需要++</span></span><br><span class="line">        vType.<span class="built_in">erase</span>(it);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    it++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二分查找-lower-bound-upper-bound-binary-search-equal-range"><a href="#二分查找-lower-bound-upper-bound-binary-search-equal-range" class="headerlink" title="二分查找 lower_bound&#x2F;upper_bound&#x2F;binary_search&#x2F;equal_range"></a>二分查找 lower_bound&#x2F;upper_bound&#x2F;binary_search&#x2F;equal_range</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; listNum = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//默认按照从小到大的顺序</span></span><br><span class="line">    <span class="comment">//指向第一个3</span></span><br><span class="line">    <span class="keyword">auto</span> ln = <span class="built_in">lower_bound</span>(listNum.<span class="built_in">begin</span>(), listNum.<span class="built_in">end</span>(), <span class="number">3</span>);</span><br><span class="line">    <span class="comment">//指向最后一个5后面的6</span></span><br><span class="line">    <span class="keyword">auto</span> rn = <span class="built_in">upper_bound</span>(listNum.<span class="built_in">begin</span>(), listNum.<span class="built_in">end</span>(), <span class="number">5</span>);</span><br><span class="line">    <span class="comment">//是否存在4</span></span><br><span class="line">    <span class="type">bool</span> isExist = <span class="built_in">binary_search</span>(listNum.<span class="built_in">begin</span>(), listNum.<span class="built_in">end</span>(), <span class="number">4</span>);</span><br><span class="line">    <span class="comment">//可以得出存在于[3, 5]区间的个数，5个</span></span><br><span class="line">    <span class="type">int</span> count = rn - ln;</span><br><span class="line">    <span class="comment">// 查找k值个数，返回为std::pair(lower_bound(listNum.begin(), listNum.end(), 3),</span></span><br><span class="line">    <span class="comment">//                              upper_bound(listNum.begin(), listNum.end(), 3))</span></span><br><span class="line">    <span class="comment">// 也就是std::pair(第一个3的地址, 最后一个3后面的4的地址)，但和两个函数实现不一样</span></span><br><span class="line">    <span class="keyword">auto</span> tmp = <span class="built_in">equal_range</span>(listNum.<span class="built_in">begin</span>(), listNum.<span class="built_in">end</span>(), <span class="number">3</span>)</span><br><span class="line">    count = tmp.second - tmp.first;</span><br><span class="line"></span><br><span class="line">    listNum = &#123;<span class="number">6</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="comment">//从大到小的顺序</span></span><br><span class="line">    <span class="comment">//lambda表达式中，3为b，找到第一个为false的地方，即第一个3</span></span><br><span class="line">    <span class="keyword">auto</span> ln = <span class="built_in">lower_bound</span>(listNum.<span class="built_in">begin</span>(), listNum.<span class="built_in">end</span>(), <span class="number">3</span>, [](<span class="type">int</span> a, <span class="type">int</span> b) &#123; <span class="built_in">return</span> (a &gt; b); &#125;);</span><br><span class="line">    <span class="comment">//lambda表达式中，3为a，找到第一个为true的地方，即最后一个3后面的2</span></span><br><span class="line">    <span class="keyword">auto</span> rn = <span class="built_in">upper_bound</span>(listNum.<span class="built_in">begin</span>(), listNum.<span class="built_in">end</span>(), <span class="number">5</span>, [](<span class="type">int</span> a, <span class="type">int</span> b) &#123; <span class="built_in">return</span> (a &gt; b); &#125;);</span><br><span class="line">    <span class="comment">//是否存在q</span></span><br><span class="line">    <span class="type">bool</span> isExist = <span class="built_in">binary_search</span>(listNum.<span class="built_in">begin</span>(), listNum.<span class="built_in">end</span>(), <span class="number">4</span>, [](<span class="type">int</span> a, <span class="type">int</span> b) &#123; <span class="built_in">return</span> (a &gt; b); &#125;);</span><br><span class="line">    <span class="comment">//可以得出存在于[l, r]区间的个数</span></span><br><span class="line">    <span class="type">int</span> count = rn - ln;</span><br><span class="line">    <span class="comment">// 查找3的个数，返回为std::pair(第一个3的地址, 最后一个3后面的4的地址)</span></span><br><span class="line">    <span class="keyword">auto</span> tmp = <span class="built_in">equal_range</span>(listNum.<span class="built_in">begin</span>(), listNum.<span class="built_in">end</span>(), <span class="number">3</span>, [](<span class="type">int</span> a, <span class="type">int</span> b) &#123; <span class="built_in">return</span> (a &gt; b); &#125;)</span><br><span class="line">    count = tmp.second - tmp.first;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="稳定分区-stable-partition"><a href="#稳定分区-stable-partition" class="headerlink" title="稳定分区 stable_partition"></a>稳定分区 stable_partition</h3><p>将符合表达式的元素前移，不符合表达式的后移，保持原本的相对位置不变</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reOrderArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;array)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 奇数放前面，偶数放后面，两边分别的相对位置保持不变</span></span><br><span class="line">    <span class="built_in">stable_partition</span>(array.<span class="built_in">begin</span>(), array.<span class="built_in">end</span>(),</span><br><span class="line">                     [](<span class="type">const</span> <span class="type">int</span> &amp;value) &#123; <span class="built_in">return</span> (value % <span class="number">2</span> == <span class="number">1</span>); &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="大（小）根堆-make-heap-push-heap-pop-heap"><a href="#大（小）根堆-make-heap-push-heap-pop-heap" class="headerlink" title="大（小）根堆 make_heap&amp;push_heap&amp;pop_heap"></a><span id="bigHeap">大（小）根堆 make_heap&amp;push_heap&amp;pop_heap</span></h3><p>示例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">8</span>&#125;;</span><br><span class="line">    <span class="comment">// 默认是大根堆</span></span><br><span class="line">    std::<span class="built_in">make_heap</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">    std::cout &lt;&lt; a[<span class="number">0</span>] &lt;&lt; std::endl;     <span class="comment">// 9</span></span><br><span class="line">    <span class="comment">// 小根堆，使用标准库的greater函数对标准类型设置比较函数</span></span><br><span class="line">    std::<span class="built_in">make_heap</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), std::<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    std::cout &lt;&lt; a[<span class="number">0</span>] &lt;&lt; std::endl;     <span class="comment">// 0</span></span><br><span class="line">    <span class="comment">// 自定义比较函数</span></span><br><span class="line">    <span class="comment">// 为true，b向堆顶移动；false，a向堆顶移动。</span></span><br><span class="line">    std::<span class="built_in">make_heap</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), [](<span class="type">const</span> <span class="type">int</span> &amp;a, <span class="type">const</span> <span class="type">int</span> &amp;b) -&gt; <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="comment">// a比b大，返回true，b向堆顶移动，也就是小根堆</span></span><br><span class="line">        <span class="keyword">return</span> a &gt; b;</span><br><span class="line">    &#125;);</span><br><span class="line">    std::cout &lt;&lt; a[<span class="number">0</span>] &lt;&lt; std::endl;     <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">make_heap</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">    <span class="comment">// 出堆，将堆顶移到末尾，一定提前是make_heap后的</span></span><br><span class="line">    <span class="type">int</span> lastTop = a[<span class="number">0</span>];</span><br><span class="line">    std::<span class="built_in">pop_heap</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">    a.<span class="built_in">pop_back</span>();</span><br><span class="line">    std::cout &lt;&lt; lastTop &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; a[<span class="number">0</span>] &lt;&lt; std::endl;  <span class="comment">// 9 8</span></span><br><span class="line">    <span class="comment">// 入堆，将末尾元素加到堆中，一定提前是make_heap后的</span></span><br><span class="line">    a.<span class="built_in">emplace_back</span>(<span class="number">9</span>);</span><br><span class="line">    std::<span class="built_in">push_heap</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">    std::cout &lt;&lt; a[<span class="number">0</span>] &lt;&lt; std::endl;  <span class="comment">// 9</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四、工程建议"><a href="#四、工程建议" class="headerlink" title="四、工程建议"></a>四、工程建议</h1><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><ul><li>所有代码文件最好使用 utf-8 编码，比较统一</li><li>需要使用中文打印的可能会要求 GB2312 等，单独列出一个头文件使用宏定义，单独使用相应的编码</li></ul><h2 id="公用常量、类型和方法"><a href="#公用常量、类型和方法" class="headerlink" title="公用常量、类型和方法"></a>公用常量、类型和方法</h2><ul><li>找一个单独的文件 constant.hpp 进行存放</li><li>定义较多分模块添加 constant 目录</li><li>使用<code>const + 类型</code>进行定义防止类型模糊使用</li><li>使用 inline 函数定义函数，防止类型混用</li></ul><h2 id="函数内部局部变量使用"><a href="#函数内部局部变量使用" class="headerlink" title="函数内部局部变量使用"></a>函数内部局部变量使用</h2><ul><li>C11 以上的标准可以在代码中间定义变量</li><li>需要用的地方进行定义，不放在函数头部定义，防止定义变量用不着导致内存浪费</li></ul><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><h3 id="文件头部描述"><a href="#文件头部描述" class="headerlink" title="文件头部描述"></a>文件头部描述</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @file xxx.hpp</span></span><br><span class="line"><span class="comment"> * @author abc (abc@163.com)</span></span><br><span class="line"><span class="comment"> * @brief xxx</span></span><br><span class="line"><span class="comment"> * @version 0.1</span></span><br><span class="line"><span class="comment"> * @date 2022-05-12</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @copyright Copyright (c) 2022</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="方法和函数在头文件写注释"><a href="#方法和函数在头文件写注释" class="headerlink" title="方法和函数在头文件写注释"></a>方法和函数在头文件写注释</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 函数描述</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param 参数名称 参数描述</span></span><br><span class="line"><span class="comment"> * @param[in] 参数名称 参数描述</span></span><br><span class="line"><span class="comment"> * @param[in,out] 参数名称 参数描述</span></span><br><span class="line"><span class="comment"> * @param[out] 参数名称 参数描述</span></span><br><span class="line"><span class="comment"> * @return 返回值描述</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="类内部属性在后面写注释"><a href="#类内部属性在后面写注释" class="headerlink" title="类内部属性在后面写注释"></a>类内部属性在后面写注释</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type param = initValue; <span class="comment">//param描述</span></span><br></pre></td></tr></table></figure><h3 id="前缀"><a href="#前缀" class="headerlink" title="前缀"></a>前缀</h3><ul><li>类中的属性使用<code>m_</code></li><li>全局变量使用<code>g_</code></li><li>静态变量使用<code>s_</code></li><li>常量使用<code>c_</code></li><li>指针使用<code>p</code>开头</li><li>变量首字母小写，驼峰命名</li><li>函数动作名称开头，首字母小写，驼峰命名</li></ul><h2 id="参数判断"><a href="#参数判断" class="headerlink" title="参数判断"></a>参数判断</h2><ul><li>参数属于程序员错误，使用断言让错误发生前移</li><li>错误码功能单一，成功即成功，失败中不可有成功情况</li></ul><h1 id="五、好用的第三方库"><a href="#五、好用的第三方库" class="headerlink" title="五、好用的第三方库"></a>五、好用的第三方库</h1><h2 id="1-google-test"><a href="#1-google-test" class="headerlink" title="1. google test"></a>1. google test</h2><p><a target="_blank" rel="noopener" href="https://github.com/google/googletest.git">https://github.com/google/googletest.git</a></p><h3 id="1-1-运行常用命令"><a href="#1-1-运行常用命令" class="headerlink" title="1.1. 运行常用命令"></a>1.1. 运行常用命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">展示所有用例</span></span><br><span class="line">=&gt; xxxTest --gtest_list_tests</span><br><span class="line">str1.</span><br><span class="line">  toString</span><br><span class="line">  toString2</span><br><span class="line">str2.</span><br><span class="line">  many_create_destroy</span><br><span class="line">  resolve_test_ok_1</span><br><span class="line">  resolve_timeout</span><br><span class="line">str3.</span><br><span class="line">  toString</span><br><span class="line">  toString2</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">仅执行部分用例</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">冒号用来添加用例，A:B 即 A和B都执行</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">不想要执行的只需要一个-号， C:-A:B 为执行C但不执行A和B</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">正则表达式需要加引号包裹，?代表一个匹配，*代表多个匹配，.还是点不代表任意字符</span></span><br><span class="line">=&gt; xxxTest --gtest_filter=IDnsResolver_DefaultImpl.toString:DnsResolver_DefaultImpl.toString2</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行strx.开头的所有，但不执行str1开头的和str2开头的</span></span><br><span class="line">=&gt; xxxTest --gtest_filter=&#x27;str?.*&#x27;:-&#x27;str1*&#x27;:&#x27;str2*&#x27;</span><br></pre></td></tr></table></figure><h3 id="1-2-gtest的main函数"><a href="#1-2-gtest的main函数" class="headerlink" title="1.2. gtest的main函数"></a>1.2. gtest的main函数</h3><ul><li>参考<code>googletest/src/gtest_main.cc</code></li></ul><h1 id="六、静态检查"><a href="#六、静态检查" class="headerlink" title="六、静态检查"></a>六、静态检查</h1><h2 id="1-cpplint"><a href="#1-cpplint" class="headerlink" title="1. cpplint"></a>1. cpplint</h2><h3 id="1-1-忽略某一行"><a href="#1-1-忽略某一行" class="headerlink" title="1.1. 忽略某一行"></a>1.1. 忽略某一行</h3><ul><li>添加<code>// NOLINT</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">print_currentTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">time_t</span> currentTime = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">    tm *currentTm = <span class="built_in">localtime</span>(&amp;currentTime);    <span class="comment">// NOLINT</span></span><br><span class="line">    <span class="built_in">log_print</span>(<span class="string">&quot;%4d-%02d-%02d %02d:%02d:%02d&quot;</span>, currentTm-&gt;tm_year + <span class="number">1900</span>, currentTm-&gt;tm_mon + <span class="number">1</span>,</span><br><span class="line">              currentTm-&gt;tm_mday, currentTm-&gt;tm_hour, currentTm-&gt;tm_min, currentTm-&gt;tm_sec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="踩坑记-1"><a href="#踩坑记-1" class="headerlink" title="踩坑记"></a>踩坑记</h3><h4 id="1-windows编译报gtest-lib-gtest-all-obj-error-LNK2038-mismatch-detected-for-RuntimeLibrary-value-MTd-StaticDebug-doesn-t-match-value-MDd-DynamicDebug-in-main-obj"><a href="#1-windows编译报gtest-lib-gtest-all-obj-error-LNK2038-mismatch-detected-for-RuntimeLibrary-value-MTd-StaticDebug-doesn-t-match-value-MDd-DynamicDebug-in-main-obj" class="headerlink" title="1) windows编译报gtest.lib(gtest-all.obj) : error LNK2038: mismatch detected for &#39;RuntimeLibrary&#39;: value &#39;MTd_StaticDebug&#39; doesn&#39;t match value &#39;MDd_DynamicDebug&#39; in main.obj"></a>1) windows编译报<code>gtest.lib(gtest-all.obj) : error LNK2038: mismatch detected for &#39;RuntimeLibrary&#39;: value &#39;MTd_StaticDebug&#39; doesn&#39;t match value &#39;MDd_DynamicDebug&#39; in main.obj</code></h4><ul><li>README.md中有写，cmake加入下面的选项即可</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (WIN32)</span><br><span class="line">    <span class="comment"># For Windows: Prevent overriding the parent project&#x27;s compiler/linker settings</span></span><br><span class="line">    <span class="keyword">set</span>(gtest_force_shared_crt <span class="keyword">ON</span> CACHE BOOL <span class="string">&quot;&quot;</span> FORCE)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure><h2 id="2-cppcheck"><a href="#2-cppcheck" class="headerlink" title="2. cppcheck"></a>2. cppcheck</h2><h3 id="1-1-忽略某一行-1"><a href="#1-1-忽略某一行-1" class="headerlink" title="1.1. 忽略某一行"></a>1.1. 忽略某一行</h3><ul><li>忽略一个错误</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> arr[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// cppcheck-suppress arrayIndexOutOfBounds</span></span><br><span class="line">    arr[<span class="number">10</span>] = arr[<span class="number">10</span>] / <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>忽略多个错误</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> arr[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// cppcheck-suppress[arrayIndexOutOfBounds,zerodiv]</span></span><br><span class="line">    arr[<span class="number">10</span>] = arr[<span class="number">10</span>] / <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="七、类的那些事（非基础知识）"><a href="#七、类的那些事（非基础知识）" class="headerlink" title="七、类的那些事（非基础知识）"></a>七、类的那些事（非基础知识）</h1><h2 id="1-虚表和虚指针"><a href="#1-虚表和虚指针" class="headerlink" title="1. 虚表和虚指针"></a>1. 虚表和虚指针</h2><ul><li>虚表是全局的，每个子类实现对应一个虚表，编译时确定</li><li>虚指针是在子类构造时初始化好的，存放于类的内存中</li><li>虚指针的初始化是在构造函数之前，因为构造函数内部可以调用对应的方法，所以需要先初始化虚指针</li><li>父类的纯虚函数在构造函数中不能被调用，因为父类构造时，虚指针指向父类的虚表，调用的是纯虚函数而非子类实现</li><li>子类构造后调用的父类的方法中，可以调用子类实现的纯虚函数，因为虽然实现在父类中，虚指针指向的是子类</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() &#123;</span><br><span class="line">        <span class="built_in">func</span>();     <span class="comment">// 这里编译会出错，未定义A::func()</span></span><br><span class="line">        <span class="built_in">func1</span>();    <span class="comment">// 这里编译可以，但是会崩溃，因为此时虚指针指向父类虚表，调用的是纯虚函数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">func</span>();  <span class="comment">// 这里如果是子类调用的func1就不会崩溃，虽然实现在父类中，但是虚指针指向子类虚表</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hhh&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A *b = <span class="keyword">new</span> <span class="built_in">B</span>();</span><br><span class="line">    b-&gt;<span class="built_in">func1</span>();</span><br><span class="line">    <span class="keyword">delete</span> b;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="踩坑记和小技巧"><a href="#踩坑记和小技巧" class="headerlink" title="踩坑记和小技巧"></a>踩坑记和小技巧</h1><h2 id="1-头文件不要-using-namespace"><a href="#1-头文件不要-using-namespace" class="headerlink" title="1. 头文件不要 using namespace"></a>1. 头文件不要 using namespace</h2><p>头文件使用<code>using namespace</code>会污染所有包含此头文件的文件</p><h2 id="2-参数传递看情况使用引用"><a href="#2-参数传递看情况使用引用" class="headerlink" title="2. 参数传递看情况使用引用"></a>2. 参数传递看情况使用引用</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">type <span class="title">function</span><span class="params">(<span class="type">const</span> type &amp;arg)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>引用的形式可以减少复制的过程</li><li>我自己的想法是对于超过 int 大小的变量使用引用的形式来传参。</li><li>对于部分对外的参数可以不使用引用比如</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> std::string <span class="title">toJson</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h2 id="3-const-的使用"><a href="#3-const-的使用" class="headerlink" title="3. const 的使用"></a>3. const 的使用</h2><h3 id="外部不可更改"><a href="#外部不可更改" class="headerlink" title="外部不可更改"></a>外部不可更改</h3><p>对于引用传递的参数，为防止外部修改，加 const 修饰。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> type &amp;<span class="title">getArg</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h3 id="内部不可更改"><a href="#内部不可更改" class="headerlink" title="内部不可更改"></a>内部不可更改</h3><p>对于 get 方法等内部参数不会被修改的方法，在后部加 const 修饰</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> std::string <span class="title">toJson</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><h2 id="4-参数赋值必须用自己的类型"><a href="#4-参数赋值必须用自己的类型" class="headerlink" title="4. 参数赋值必须用自己的类型"></a>4. 参数赋值必须用自己的类型</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误方式</span></span><br><span class="line"><span class="type">bool</span> arg = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//正确方式</span></span><br><span class="line"><span class="type">bool</span> arg = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><h2 id="5-类的建立需要添加构造函数和删除构造函数"><a href="#5-类的建立需要添加构造函数和删除构造函数" class="headerlink" title="5. 类的建立需要添加构造函数和删除构造函数"></a>5. 类的建立需要添加构造函数和删除构造函数</h2><p>拷贝构造函数，允许被拷贝才需要添加</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">temp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">//允许拷贝</span></span><br><span class="line">        <span class="built_in">temp</span>(<span class="type">const</span> temp &amp;a) = <span class="keyword">default</span>;</span><br><span class="line">        <span class="comment">//不允许拷贝</span></span><br><span class="line">        <span class="built_in">temp</span>(<span class="type">const</span> temp &amp;a) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="6-类的内部属性需要初始化"><a href="#6-类的内部属性需要初始化" class="headerlink" title="6. 类的内部属性需要初始化"></a>6. 类的内部属性需要初始化</h2><p>在参数声明的地方初始化，参数列表是给自己写的构造函数用的，并根据需要删除或声明为私有默认构造函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hpp</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">temp</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">temp</span>(<span class="type">const</span> type1 &amp;a);</span><br><span class="line">        <span class="comment">//如果需要</span></span><br><span class="line">        <span class="built_in">temp</span>() = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="comment">//或者</span></span><br><span class="line">        <span class="built_in">temp</span>();</span><br><span class="line"></span><br><span class="line">    type1 m_arg1 = type1InitValue;</span><br><span class="line">    type2 m_arg2 = type2InitValue;</span><br><span class="line">    type3 m_arg3 = type3InitValue;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//cpp</span></span><br><span class="line">temp::<span class="built_in">temp</span>(<span class="type">const</span> type1 &amp;a) : <span class="built_in">m_arg1</span>(a);</span><br></pre></td></tr></table></figure><h2 id="7-单例构建"><a href="#7-单例构建" class="headerlink" title="7. 单例构建"></a>7. 单例构建</h2><p>base&#x2F;BaseInstance.hpp 为一个模板类，用来给需要写为单例的类使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BaseInstance_hpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BaseInstance_hpp</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> cb &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">BaseNoCopy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">BaseNoCopy</span>()&#123; &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">BaseNoCopy</span>(<span class="type">const</span> BaseNoCopy &amp;obj);</span><br><span class="line">        <span class="built_in">BaseNoCopy</span>(BaseNoCopy *pObj);</span><br><span class="line">        <span class="built_in">BaseNoCopy</span>(<span class="type">const</span> BaseNoCopy *pObj);</span><br><span class="line">        BaseNoCopy&amp; <span class="keyword">operator</span> = (<span class="type">const</span> BaseNoCopy &amp;obj);</span><br><span class="line">        BaseNoCopy&amp; <span class="keyword">operator</span> = (<span class="type">const</span> BaseNoCopy *pObj);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="keyword">class</span> <span class="title class_">BaseInstance</span>: <span class="keyword">public</span> BaseNoCopy &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">static</span> T &amp;<span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="type">static</span> T s_instance;</span><br><span class="line">            CreateObject.<span class="built_in">do_nothing</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> s_instance;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        <span class="built_in">BaseInstance</span>()&#123; &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">BaseInstance</span>(<span class="type">const</span> BaseInstance &amp;obj);</span><br><span class="line">        BaseInstance <span class="keyword">operator</span> = (<span class="type">const</span> BaseInstance &amp;obj);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">ObjectCreator</span> &#123;</span><br><span class="line">            <span class="built_in">ObjectCreator</span>() &#123;</span><br><span class="line">                BaseInstance&lt;T&gt;::<span class="built_in">getInstance</span>();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">do_nothing</span><span class="params">()</span><span class="type">const</span></span>&#123; &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">static</span> ObjectCreator CreateObject;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="keyword">typename</span> BaseInstance&lt;T&gt;::ObjectCreator BaseInstance&lt;T&gt;::CreateObject;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* BaseInstance_hpp */</span></span></span><br></pre></td></tr></table></figure><p>使用方法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">temp</span> : <span class="keyword">public</span> BaseInstance&lt;temp&gt;</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-do-while-作用域的问题"><a href="#8-do-while-作用域的问题" class="headerlink" title="8. do while 作用域的问题"></a>8. do while 作用域的问题</h2><p>do while 的大括号是一个作用域，其中定义的变量不能用做 while 判断</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误用法，a已经被释放</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">bool</span> a = <span class="literal">true</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">while</span>(a);</span><br><span class="line"></span><br><span class="line"><span class="comment">//正确用法，使用外部进行判断</span></span><br><span class="line"><span class="type">bool</span> b = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">bool</span> a = <span class="literal">true</span>;</span><br><span class="line">    ...</span><br><span class="line">    b = a;</span><br><span class="line">&#125; <span class="keyword">while</span>(b);</span><br></pre></td></tr></table></figure><h2 id="9-指针引用的作用域问题"><a href="#9-指针引用的作用域问题" class="headerlink" title="9. 指针引用的作用域问题"></a>9. 指针引用的作用域问题</h2><p>指针或者引用本身作用域可能要比指向的或者引用的变量作用域大，可能出现内存泄漏</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误示例</span></span><br><span class="line">std::shared_ptr&lt;Type&gt; pType = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    Type a;</span><br><span class="line">    pType = &amp;a;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="literal">false</span>);</span><br><span class="line">pType-&gt;<span class="built_in">function</span>();</span><br></pre></td></tr></table></figure><h2 id="10-C-的-switch-中的-case-有多条语句需要加大括号"><a href="#10-C-的-switch-中的-case-有多条语句需要加大括号" class="headerlink" title="10. C++的 switch 中的 case 有多条语句需要加大括号"></a>10. C++的 switch 中的 case 有多条语句需要加大括号</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (state) &#123;</span><br><span class="line">    <span class="keyword">case</span> state1:</span><br><span class="line">        <span class="built_in">op1</span>();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> state2: &#123;</span><br><span class="line">        <span class="built_in">op1</span>();</span><br><span class="line">        <span class="built_in">op2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">default</span>: &#123;</span><br><span class="line">        <span class="built_in">op1</span>();</span><br><span class="line">        <span class="built_in">op2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11-不对外暴露接口内实现"><a href="#11-不对外暴露接口内实现" class="headerlink" title="11. 不对外暴露接口内实现"></a>11. 不对外暴露接口内实现</h2><ul><li>class 的定义需要声明 private 和 public，对外只想暴露 public，不期望暴露 private</li><li>使用继承和工厂的方式，如下，仅暴露<code>func_public();</code>，外部从头文件无法看到<code>m_a</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ITest.hpp</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ITest</span> &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func_public</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestFactory</span> &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> ITest *<span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TestImpl.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ITest.hpp&quot;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> : <span class="keyword">public</span> ITest &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func_public</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_a = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ITest *<span class="title">TestFactory::create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Test</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12-json-的处理"><a href="#12-json-的处理" class="headerlink" title="12. json 的处理"></a>12. json 的处理</h2><h3 id="12-1-schema-校验"><a href="#12-1-schema-校验" class="headerlink" title="12.1. schema 校验"></a>12.1. schema 校验</h3><ul><li>使用 rapidjson 可以校验 schema</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用法</span></span><br><span class="line">HttpJsonChecker checker;</span><br><span class="line">checker.<span class="built_in">on</span>(<span class="string">&quot;anykey&quot;</span>, schema);</span><br><span class="line"><span class="comment">// apply失败会抛异常</span></span><br><span class="line">checker.<span class="built_in">apply</span>(<span class="string">&quot;anykey&quot;</span>, jsonStr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @file HttpJsonChecker.hpp</span></span><br><span class="line"><span class="comment"> * @author dailin (dailin1989ok@163.com)</span></span><br><span class="line"><span class="comment"> * @brief</span></span><br><span class="line"><span class="comment"> * @version 1.0</span></span><br><span class="line"><span class="comment"> * @date 2019-12-06</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @copyright Copyright (c) 2019</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __JSON_CHECKER_HPP__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __JSON_CHECKER_HPP__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;system_error&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;rapidjson/error/en.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;rapidjson/schema.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;rapidjson/rapidjson.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;rapidjson/stringbuffer.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> LINK_BREAK</span></span><br><span class="line">    <span class="meta">#<span class="keyword">undef</span> LINK_BREAK</span></span><br><span class="line">        <span class="meta">#<span class="keyword">ifdef</span> _WINDOWS</span></span><br><span class="line">            <span class="meta">#<span class="keyword">define</span> LINK_BREAK  <span class="string">&quot;\r\n&quot;</span></span></span><br><span class="line">        <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">            <span class="meta">#<span class="keyword">define</span> LINK_BREAK  <span class="string">&quot;\n&quot;</span></span></span><br><span class="line">        <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief jsonchecker错误分类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">_rapidjson_category</span> : <span class="keyword">public</span> std::error_category &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">const</span> _rapidjson_category&amp; <span class="title">instance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">static</span> _rapidjson_category instance;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span> *<span class="title">name</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;jonschecker_category&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">message</span><span class="params">(<span class="type">int</span> _Errval)</span> <span class="type">const</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rapidjson::<span class="built_in">GetParseError_En</span>((rapidjson::ParseErrorCode)_Errval);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">const</span> std::error_category&amp; <span class="title">rapidjson_category</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _rapidjson_category::<span class="built_in">instance</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief json格式校验器，依赖rapidjson.schema</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HttpJsonChecker</span> &#123;</span><br><span class="line">    <span class="keyword">typedef</span> std::shared_ptr&lt;rapidjson::SchemaDocument&gt; SchemaDocumentPtr;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* schema, <span class="type">const</span> std::string&amp; json)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            HttpJsonChecker jsonChecker;</span><br><span class="line">            jsonChecker</span><br><span class="line">                .<span class="built_in">on</span>(<span class="string">&quot;any&quot;</span>, schema)</span><br><span class="line">                .<span class="built_in">apply</span>(<span class="string">&quot;any&quot;</span>, json);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">const</span> std::string&amp; schema, <span class="type">const</span> std::string&amp; json)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> HttpJsonChecker::<span class="built_in">check</span>(schema.<span class="built_in">c_str</span>(), json);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * @brief 将schema字符串存储，以便在调用apply使用key对应的schema进行校验</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * @param key 关键key</span></span><br><span class="line"><span class="comment">    * @param jsonschema jsonschema字符串，空字符串时表示此key不做校验</span></span><br><span class="line"><span class="comment">    * @return json_checker&amp; json_checker的引用，以便链式调用</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * @throw std::error_code 错误信息</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function">HttpJsonChecker&amp; <span class="title">on</span><span class="params">(<span class="type">const</span> std::string&amp; key, <span class="type">const</span> std::string&amp; jsonschema)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">on</span>(key, jsonschema.<span class="built_in">c_str</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * @brief 将schema字符串存储，以便在调用apply使用key对应的schema进行校验</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * @param key 关键key</span></span><br><span class="line"><span class="comment">    * @param jsonschema jsonschema字符串，空指针或空字符串时表示此key不做校验</span></span><br><span class="line"><span class="comment">    * @return json_checker&amp; json_checker的引用，以便链式调用</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * @throw std::error_code 错误信息</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function">HttpJsonChecker&amp; <span class="title">on</span><span class="params">(<span class="type">const</span> std::string&amp; key, <span class="type">const</span> <span class="type">char</span>* jsonschema)</span> </span>&#123;</span><br><span class="line">        std::string k = <span class="built_in">transform</span>(key);</span><br><span class="line">        <span class="comment">// 空指针，或空字符串标识对应的key不做格式校验</span></span><br><span class="line">        <span class="keyword">if</span> ((jsonschema == <span class="literal">nullptr</span>) || (<span class="built_in">strlen</span>(jsonschema) == <span class="number">0</span>)) &#123;</span><br><span class="line">            m_shcemaDocuments.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(k, <span class="string">&quot;&quot;</span>));</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::string schemaStr = jsonschema;</span><br><span class="line"></span><br><span class="line">        rapidjson::Document doc;</span><br><span class="line">        <span class="keyword">if</span> (doc.<span class="built_in">Parse</span>(jsonschema).<span class="built_in">HasParseError</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">error_code</span>(doc.<span class="built_in">GetParseError</span>(), <span class="built_in">rapidjson_category</span>());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        m_shcemaDocuments.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(k, jsonschema));</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * @brief 对参数json应用key所对应的schema进行校验</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * @param key 对应的key</span></span><br><span class="line"><span class="comment">    * @param json 需要校验的json字符串</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * @throw std::string 错误信息</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">apply</span><span class="params">(<span class="type">const</span> std::string&amp; key, <span class="type">const</span> std::string&amp; json)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">apply</span>(key, json.<span class="built_in">c_str</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * @brief 对参数json应用key所对应的schema进行校验</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * @param key 对应的key</span></span><br><span class="line"><span class="comment">    * @param json 需要校验的json字符串</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * @throw std::string 错误信息</span></span><br><span class="line"><span class="comment">    * @throw std::error_code 错误信息</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">apply</span><span class="params">(<span class="type">const</span> std::string&amp; key, <span class="type">const</span> <span class="type">char</span>* json)</span> </span>&#123;</span><br><span class="line">        rapidjson::Document doc;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span>* content = <span class="built_in">strlen</span>(json) == <span class="number">0</span> ? <span class="string">&quot;&#123;&#125;&quot;</span> : json;</span><br><span class="line">        <span class="keyword">if</span> (doc.<span class="built_in">Parse</span>(content).<span class="built_in">HasParseError</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">error_code</span>(doc.<span class="built_in">GetParseError</span>(), <span class="built_in">rapidjson_category</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">apply</span>(key, doc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * @brief 对参数json应用key所对应的schema进行校验</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * @param key 对应的key</span></span><br><span class="line"><span class="comment">    * @param doc rapidjson::Document的引用</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * @throw std::string 错误信息</span></span><br><span class="line"><span class="comment">    * @throw std::error_code 错误信息</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">apply</span><span class="params">(<span class="type">const</span> std::string&amp; key, <span class="type">const</span> rapidjson::Document&amp; doc)</span> </span>&#123;</span><br><span class="line">        std::string k = <span class="built_in">transform</span>(key);</span><br><span class="line">        <span class="keyword">auto</span> found = m_shcemaDocuments.<span class="built_in">find</span>(k);</span><br><span class="line">        <span class="keyword">if</span> (found == m_shcemaDocuments.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            std::string message = <span class="string">&quot;not found key: &quot;</span> + key;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">            <span class="comment">//throw message;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (doc.<span class="built_in">HasParseError</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">error_code</span>(doc.<span class="built_in">GetParseError</span>(), <span class="built_in">rapidjson_category</span>());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        SchemaDocumentPtr schemaDoc = <span class="built_in">SchemaDocumentPtr</span>();</span><br><span class="line">        rapidjson::Document tmpDoc;</span><br><span class="line">        <span class="keyword">auto</span> json = found-&gt;second;</span><br><span class="line">        <span class="keyword">if</span> (!json.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tmpDoc.<span class="built_in">Parse</span>(json.<span class="built_in">c_str</span>()).<span class="built_in">HasParseError</span>()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> std::<span class="built_in">error_code</span>(doc.<span class="built_in">GetParseError</span>(), <span class="built_in">rapidjson_category</span>());</span><br><span class="line">            &#125;</span><br><span class="line">            schemaDoc = std::<span class="built_in">make_shared</span>&lt;rapidjson::SchemaDocument&gt;(tmpDoc);</span><br><span class="line">        &#125;</span><br><span class="line">        std::string message;</span><br><span class="line">        <span class="keyword">if</span> (!schemaDoc) <span class="keyword">return</span>;         <span class="comment">// 空指针不做校验</span></span><br><span class="line">        <span class="function">rapidjson::SchemaValidator <span class="title">validator</span><span class="params">(*schemaDoc.get())</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (!doc.<span class="built_in">Accept</span>(validator)) &#123;</span><br><span class="line">            rapidjson::StringBuffer sb;</span><br><span class="line">            validator.<span class="built_in">GetInvalidSchemaPointer</span>().<span class="built_in">StringifyUriFragment</span>(sb);</span><br><span class="line">            message += <span class="string">&quot;Invalid schema: &quot;</span> + std::<span class="built_in">string</span>(sb.<span class="built_in">GetString</span>());</span><br><span class="line">            message += LINK_BREAK;</span><br><span class="line">            message += <span class="string">&quot;Invalid keyword: &quot;</span> + std::<span class="built_in">string</span>(validator.<span class="built_in">GetInvalidSchemaKeyword</span>());</span><br><span class="line">            message += LINK_BREAK;</span><br><span class="line">            sb.<span class="built_in">Clear</span>();</span><br><span class="line">            validator.<span class="built_in">GetInvalidDocumentPointer</span>().<span class="built_in">StringifyUriFragment</span>(sb);</span><br><span class="line">            message += <span class="string">&quot;Invalid document: &quot;</span> + std::<span class="built_in">string</span>(sb.<span class="built_in">GetString</span>());</span><br><span class="line">            message += LINK_BREAK;</span><br><span class="line">            <span class="keyword">throw</span> message;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * @brief 获取所有的Key</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * @return std::vector&lt;std::string&gt; key数组</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function">std::vector&lt;std::string&gt; <span class="title">getKeys</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::vector&lt;std::string&gt; keys;</span><br><span class="line">        std::for_each(m_shcemaDocuments.<span class="built_in">begin</span>(), m_shcemaDocuments.<span class="built_in">end</span>(),</span><br><span class="line">            [&amp;keys](<span class="type">const</span> std::pair&lt;std::string, std::string&gt;&amp; k)</span><br><span class="line">        &#123;</span><br><span class="line">            keys.<span class="built_in">push_back</span>(k.first);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> keys;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * @brief 清空所有检测规则</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        m_shcemaDocuments.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="function">std::string <span class="title">transform</span><span class="params">(<span class="type">const</span> std::string&amp; str)</span> </span>&#123;</span><br><span class="line">        std::string s = str;</span><br><span class="line">        std::<span class="built_in">transform</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>(), s.<span class="built_in">begin</span>(),</span><br><span class="line">            [](<span class="type">int</span> ch) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">&#x27;\\&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">            <span class="keyword">return</span> ::<span class="built_in">tolower</span>(ch);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line"><span class="comment">//        std::map&lt;std::string, SchemaDocumentPtr&gt; m_shcemaDocuments;</span></span><br><span class="line">    std::map&lt;std::string, std::string&gt; m_shcemaDocuments;</span><br><span class="line">&#125;; <span class="comment">// json_checker</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> LINK_BREAK</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// __JSON_CHECKER_HPP__</span></span></span><br></pre></td></tr></table></figure><h3 id="12-2-json-转结构体"><a href="#12-2-json-转结构体" class="headerlink" title="12.2. json 转结构体"></a>12.2. json 转结构体</h3><ul><li>步骤就是使用 js 生成一个支持 rttr 协议的结构体，然后使用 rttr 进行转换</li><li>下面是使用的代码，依赖库 rttr，其中<code>events/aclProcess.h</code>是生成的</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ev_tunnel_access.json就是模板json</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">xxx.events是命名空间，生成的头文件和cpp文件在/path/to/events目录下</span></span><br><span class="line">node dist/quickjson.js -p data/events/ev_tunnel_access.json -d /path/to/events -n xxx.events -f</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;events/aclProcess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;from_json.h&gt;</span></span></span><br><span class="line"><span class="keyword">if</span> (!io::<span class="built_in">from_json</span>(content, xxx::events::aclProcess)) &#123;</span><br><span class="line">    <span class="built_in">LOGE3</span>(<span class="built_in">WHAT</span>(<span class="string">&quot;deserialized aclProcess json to struct fail,aclProcess:&#123;&#125;&quot;</span>, content),</span><br><span class="line">          NO_REASON,</span><br><span class="line">          JSON_PARSE_ERROR_HOW_TO);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="13-共享指针指向数组的问题"><a href="#13-共享指针指向数组的问题" class="headerlink" title="13. 共享指针指向数组的问题"></a>13. 共享指针指向数组的问题</h2><p>参考<a target="_blank" rel="noopener" href="https://www.cnblogs.com/apocelipes/p/10346928.html">shared_ptr和动态数组</a></p><h3 id="13-1-问题代码"><a href="#13-1-问题代码" class="headerlink" title="13.1. 问题代码"></a>13.1. 问题代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">uint8_t</span>&gt; <span class="title">pData</span><span class="params">(<span class="keyword">new</span> <span class="type">uint8_t</span>[size])</span></span>;</span><br></pre></td></tr></table></figure><h3 id="13-2-问题原因"><a href="#13-2-问题原因" class="headerlink" title="13.2. 问题原因"></a>13.2. 问题原因</h3><ul><li>对于<code>shared_ptr</code>来说，认为申请的只是一个<code>uint8_t</code>类型，所以删除仅调用<code>delete pData</code></li><li>但是对于数组类型，应该要调用<code>delete []pData</code>，所以将会出现未定义行为，可能存在问题</li></ul><h4 id="实测验证"><a href="#实测验证" class="headerlink" title="实测验证"></a>实测验证</h4><ul><li>对于基本类型，delete会自动释放后续空间，所以调用<code>delete pData</code>和<code>delete []pData</code>一个效果，但是不建议第一种</li><li>对于存在构造函数的类就不同了</li><li>存在析构函数的类，<code>delete pData</code>会进行清理，但是只会调用第一个元素的析构函数，后续元素不会调用析构函数，释放空间会导致崩溃</li><li>不存在析构函数的类，调用和<code>delete []pData</code>一个效果，也不建议用</li></ul><h3 id="13-3-解决方案"><a href="#13-3-解决方案" class="headerlink" title="13.3. 解决方案"></a>13.3. 解决方案</h3><ul><li>三种方式</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++17及以上支持</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">uint8_t</span>[]&gt; <span class="title">pData</span><span class="params">(<span class="keyword">new</span> <span class="type">uint8_t</span>[size])</span></span>;</span><br><span class="line"><span class="comment">// C++17以下</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">uint8_t</span>&gt; <span class="title">pData</span><span class="params">(<span class="keyword">new</span> <span class="type">uint8_t</span>[size], std::default_delete&lt;<span class="type">uint8_t</span>[]&gt;())</span></span>;</span><br><span class="line"><span class="comment">// vector不香吗</span></span><br><span class="line">std::shared_ptr&lt;std::vector&lt;<span class="type">uint8_t</span>&gt;&gt; pData;</span><br></pre></td></tr></table></figure><h2 id="14-几种编译错误原因"><a href="#14-几种编译错误原因" class="headerlink" title="14. 几种编译错误原因"></a>14. 几种编译错误原因</h2><h3 id="14-1-undefined-reference-to-vtable-for-xxx"><a href="#14-1-undefined-reference-to-vtable-for-xxx" class="headerlink" title="14.1. undefined reference to vtable for xxx"></a>14.1. undefined reference to <code>vtable for xxx</code></h3><ul><li>一般是父类存在纯虚函数子类没有实现导致</li></ul><h3 id="14-2-error-LNK2001-unresolved-external-symbol-x"><a href="#14-2-error-LNK2001-unresolved-external-symbol-x" class="headerlink" title="14.2. error LNK2001: unresolved external symbol x"></a>14.2. <code>error LNK2001: unresolved external symbol x</code></h3><ul><li>某个文件使用了外部的一个符号，链接的时候，找不到外部符号</li></ul><h3 id="14-3-fatal-error-C1004-unexpected-end-of-file-found"><a href="#14-3-fatal-error-C1004-unexpected-end-of-file-found" class="headerlink" title="14.3. fatal error C1004: unexpected end of file found"></a>14.3. <code>fatal error C1004: unexpected end of file found</code></h3><ul><li>某个括号没有闭合，导致找另一半没找到找到了文件结束</li></ul><h3 id="14-4-error-C2371-xxx-redefinition-different-basic-types"><a href="#14-4-error-C2371-xxx-redefinition-different-basic-types" class="headerlink" title="14.4. error C2371: &#39;xxx&#39;: redefinition; different basic types"></a>14.4. <code>error C2371: &#39;xxx&#39;: redefinition; different basic types</code></h3><ul><li>一般是某个函数在调用时没有定义，编译器按照默认的<code>int xxx()</code>去识别</li><li>当后面此函数被真实定义时，发现和编译器的默认不一致，就报此错误</li></ul><h2 id="15-std-this-thread-sleep-for调整系统时间导致睡眠时间加长"><a href="#15-std-this-thread-sleep-for调整系统时间导致睡眠时间加长" class="headerlink" title="15. std::this_thread::sleep_for调整系统时间导致睡眠时间加长"></a>15. <code>std::this_thread::sleep_for</code>调整系统时间导致睡眠时间加长</h2><ul><li>标准库中的<code>sleep_for</code>实现是使用的当前系统时间进行的睡眠，如果在睡眠过程中调整系统时间可能导致睡眠时间很长或很短</li><li>如果想要和系统时间无关的睡眠，建议使用内核的系统调用，如linux下的<code>sleep()</code></li><li>想要跨平台调用，建议使用boost库的睡眠，只需要将std修改为boost即可</li></ul></div><div class="reward-container"><div></div><button onclick='var qr=document.getElementById("qr");qr.style.display="none"===qr.style.display?"block":"none"'>打赏</button><div id="qr" style="display:none"><div style="display:inline-block"><img src="/images/wechatpay.png" alt="王钰博 微信支付"><p>微信支付</p></div><div style="display:inline-block"><img src="/images/alipay.jpg" alt="王钰博 支付宝"><p>支付宝</p></div></div></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-item"><a href="/blogs/2018-07-02-project-develop/" rel="prev" title="项目开发经验"><i class="fa fa-chevron-left"></i> 项目开发经验</a></div><div class="post-nav-item"><a href="/blogs/2018-07-27-ubuntuStudy/" rel="next" title="ubuntu学习">ubuntu学习 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="valine-comments"></div><script>window.addEventListener("tabs:register",()=>{let{activeClass:t}=CONFIG.comments;if(CONFIG.comments.storage&&(t=localStorage.getItem("comments_active")||t),t){let e=document.querySelector(`a[href="#comment-${t}"]`);e&&e.click()}}),CONFIG.comments.storage&&window.addEventListener("tabs:click",t=>{if(!t.target.matches(".tabs-comment .tab-content .tab-pane"))return;let e=t.target.classList[1];localStorage.setItem("comments_active",e)})</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E8%AF%AD%E6%B3%95"><span class="nav-text">一、语法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%AF%B9%E8%B1%A1"><span class="nav-text">1. 对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E7%B1%BB%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="nav-text">1.1. 类的大小</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A9%BA%E7%B1%BB"><span class="nav-text">空类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90"><span class="nav-text">字节对齐</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F"><span class="nav-text">静态变量</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#static-%E6%88%90%E5%91%98%E7%9A%84%E4%BC%98%E7%82%B9"><span class="nav-text">static 成员的优点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#static-%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%89%B9%E7%82%B9"><span class="nav-text">static 成员函数特点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%A7%E5%B0%8F"><span class="nav-text">大小</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-text">成员函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="nav-text">1.2. 实例化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-text">构造函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#explicit-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-text">explicit 关键字</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="nav-text">析构函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%92%8C%E4%B8%8D%E9%80%82%E7%94%A8-new"><span class="nav-text">使用和不适用 new</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A0%E4%B8%8D%E5%8A%A0%E6%8B%AC%E5%8F%B7%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">加不加括号的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E6%98%AF%E5%90%A6%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">参数是否初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-new"><span class="nav-text">使用 new</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-new-%E5%92%8C-malloc-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">1.3. new 和 malloc 的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-%E7%BB%A7%E6%89%BF"><span class="nav-text">1.4. 继承</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-text">(1) 构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-virtual"><span class="nav-text">(2) virtual</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-override-%E7%BC%96%E8%AF%91%E6%97%B6%E6%A3%80%E6%9F%A5%E9%87%8D%E5%86%99"><span class="nav-text">(3) override 编译时检查重写</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-final-%E7%A6%81%E6%AD%A2%E7%BB%A7%E6%89%BF-%E9%87%8D%E5%86%99"><span class="nav-text">(4) final 禁止继承&#x2F;重写</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-%E8%99%9A%E7%BB%A7%E6%89%BF"><span class="nav-text">(5) 虚继承</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%BC%95%E7%94%A8"><span class="nav-text">2. 引用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">指针和引用的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="nav-text">3. 异常处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E5%92%8C%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8"><span class="nav-text">3.1. 抛出异常和捕获异常</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E9%87%8D%E6%96%B0%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8"><span class="nav-text">3.2. 重新抛出异常</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-text">注意事项</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-terminator"><span class="nav-text">3.3. terminator()</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#set-terminator"><span class="nav-text">set_terminator()</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E6%98%BE%E5%BC%8F%E8%BD%AC%E6%8D%A2"><span class="nav-text">4. 显式转换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#static-cast"><span class="nav-text">static_cast</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#const-cast"><span class="nav-text">const_cast</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#reinterpret-cast"><span class="nav-text">reinterpret_cast</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="nav-text">注意点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dynamic-cast"><span class="nav-text">dynamic_cast</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-%E6%A8%A1%E6%9D%BF"><span class="nav-text">7. 模板</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-%E6%A8%A1%E6%9D%BF%E7%B1%BB"><span class="nav-text">7.1. 模板类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-text">1) 静态成员函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-%E6%A8%A1%E6%9D%BF%E7%B1%BB%E5%9E%8B"><span class="nav-text">7.2. 模板类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E8%8E%B7%E5%8F%96%E7%B1%BB%E5%9E%8B%E5%90%8D"><span class="nav-text">1) 获取类型名</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-C-11-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-text">8. C++11 新特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-1-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="nav-text">8.1. 智能指针</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-weak-ptr-%E5%BC%B1%E6%8C%87%E9%92%88"><span class="nav-text">1) weak_ptr 弱指针</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-shared-ptr-%E5%85%B1%E4%BA%AB%E6%8C%87%E9%92%88"><span class="nav-text">2) shared_ptr 共享指针</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%96%B9%E6%B3%95"><span class="nav-text">(1) 方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-text">(2) 类型转换</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%92%8C%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-text">(3) 源码分析和注意事项</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-unique-ptr-%E5%94%AF%E4%B8%80%E6%8C%81%E6%9C%89%E7%9A%84%E6%8C%87%E9%92%88"><span class="nav-text">3) unique_ptr 唯一持有的指针</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E8%BD%AC%E6%8D%A2"><span class="nav-text">(1) 转换</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-Lambda-%E5%87%BD%E6%95%B0"><span class="nav-text">8.2. Lambda 函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E8%AF%AD%E6%B3%95"><span class="nav-text">1) 语法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%AE%9E%E7%8E%B0"><span class="nav-text">2) 实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-3-%E5%8E%9F%E7%94%9F%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-text">8.3. 原生字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-4-shared-from-this"><span class="nav-text">8.4. shared_from_this</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-5-enum-class-%E5%BC%BA%E7%B1%BB%E5%9E%8B%E6%9E%9A%E4%B8%BE"><span class="nav-text">8.5. enum class 强类型枚举</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-6-future%E5%92%8Cpromise"><span class="nav-text">8.6. future和promise</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B8%A9%E5%9D%91%E8%AE%B0"><span class="nav-text">踩坑记</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-future%E5%92%8Cshared-from-this%E9%80%A0%E6%88%90%E7%9A%84%E5%B4%A9%E6%BA%83"><span class="nav-text">(1) future和shared_from_this造成的崩溃</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-7-async-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B0%81%E8%A3%85%E7%B1%BB"><span class="nav-text">8.7. async 线程的封装类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%8F%82%E6%95%B0"><span class="nav-text">1) 参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="nav-text">2) 返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B"><span class="nav-text">示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-8-chrono-%E6%97%B6%E9%97%B4%E5%BA%93"><span class="nav-text">8.8. chrono 时间库</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95"><span class="nav-text">1) 基础用法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0"><span class="nav-text">2) 工具函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-text">3) 使用注意事项</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-9-error-code-%E9%94%99%E8%AF%AF%E7%A0%81"><span class="nav-text">8.9. error_code 错误码</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E7%B3%BB%E7%BB%9F%E9%94%99%E8%AF%AF%E7%A0%81%E8%BD%ACerror-code"><span class="nav-text">1) 系统错误码转error_code</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-text">9. 自定义类型定义操作符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#9-1-%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">9.1. 赋值运算符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-extern-C"><span class="nav-text">10. extern &quot;C&quot;</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-%E5%8F%B3%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="nav-text">11. 右值和右值引用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E3%80%81std-%E6%A0%87%E5%87%86%E5%BA%93"><span class="nav-text">二、std 标准库</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA-iostream"><span class="nav-text">1. 输入输出 iostream</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E8%BE%93%E5%85%A5"><span class="nav-text">1.1. 输入</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E8%AF%BB%E5%8F%96%E4%B8%80%E8%A1%8C%EF%BC%88%E5%8C%85%E5%90%AB%E7%A9%BA%E6%A0%BC%EF%BC%8C%E5%9B%9E%E8%BD%A6%E7%BB%93%E6%9D%9F%EF%BC%89"><span class="nav-text">1) 读取一行（包含空格，回车结束）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E6%96%87%E4%BB%B6%E6%B5%81-fstream"><span class="nav-text">2. 文件流 fstream</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6-ifstream"><span class="nav-text">2.1. 读取文件 ifstream</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%88%A4%E6%96%AD%E6%96%87%E4%BB%B6%E6%98%AF%E5%90%A6%E5%8F%AF%E8%AF%BB"><span class="nav-text">1) 判断文件是否可读</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E6%8C%89%E8%A1%8C%E8%AF%BB%E5%8F%96"><span class="nav-text">2) 按行读取</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%87%BD%E6%95%B0%E5%8C%85%E8%A3%85%E5%99%A8%E6%A8%A1%E6%9D%BF-function"><span class="nav-text">3. 函数包装器模板 function</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E6%AF%94%E8%BE%83%E4%B8%A4%E4%B8%AAfunction%E7%9B%B8%E7%AD%89"><span class="nav-text">3.1. 比较两个function相等</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C-atomic"><span class="nav-text">4. 原子操作 atomic</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E5%AF%B9%E8%B1%A1%E8%BD%AC%E7%A7%BB%E6%89%80%E6%9C%89%E6%9D%83-move"><span class="nav-text">5. 对象转移所有权 move</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%B5%81-sstream"><span class="nav-text">6. 字符串流 sstream</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-stringstream"><span class="nav-text">6.1. stringstream</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-%E6%B5%81%E6%A0%BC%E5%BC%8F%E6%8E%A7%E5%88%B6%E7%AC%A6-iomanip"><span class="nav-text">7. 流格式控制符 iomanip</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-setfill-setw"><span class="nav-text">7.1. setfill setw</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E8%BE%93%E5%87%BA%E5%AE%BD%E5%BA%A6%E5%92%8C%E5%89%8D%E7%BC%80%E6%8E%A7%E5%88%B6"><span class="nav-text">1) 输出宽度和前缀控制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E8%BF%9B%E5%88%B6%E8%BD%AC%E5%8C%96%E8%BE%93%E5%87%BA"><span class="nav-text">2) 进制转化输出</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E3%80%81STL-%E5%AE%B9%E5%99%A8"><span class="nav-text">三、STL 容器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#std-vector-%E5%90%91%E9%87%8F"><span class="nav-text">std::vector 向量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%93%8D%E4%BD%9C%E6%8E%A5%E5%8F%A3"><span class="nav-text">(1) 操作接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">(2) 初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0"><span class="nav-text">(3) 删除元素</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#std-map"><span class="nav-text">std::map</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0"><span class="nav-text">(1) 查找元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E9%81%8D%E5%8E%86%E5%85%83%E7%B4%A0"><span class="nav-text">(2) 遍历元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0-1"><span class="nav-text">(3) 删除元素</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#std-stack"><span class="nav-text">std::stack</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#std-queue"><span class="nav-text">std::queue</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#std-set-%E9%9B%86%E5%90%88"><span class="nav-text">std::set 集合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="nav-text">(1) 一些基本用法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E4%BD%BF%E7%94%A8set"><span class="nav-text">(2) 自定义类型使用set</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#std-multimap-%E5%85%81%E8%AE%B8%E9%87%8D%E5%A4%8D%E9%94%AE%E7%9A%84map"><span class="nav-text">std::multimap 允许重复键的map</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%AE%9E%E4%BE%8B"><span class="nav-text">1) 实例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#std-string"><span class="nav-text">std::string</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-data-%E5%92%8C-c-str-%E5%8C%BA%E5%88%AB"><span class="nav-text">1) data()和 c_str()区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-find-last-of"><span class="nav-text">2) find_last_of()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-substr"><span class="nav-text">3) substr()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-1"><span class="nav-text">注意事项</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%9A%E7%94%A8%E5%B7%A5%E5%85%B7%E6%96%B9%E6%B3%95-algorithm"><span class="nav-text">通用工具方法 algorithm</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#max-%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="nav-text">max()最大值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#min-%E6%9C%80%E5%B0%8F%E5%80%BC"><span class="nav-text">min()最小值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#swap-%E4%BA%A4%E6%8D%A2%E4%B8%A4%E4%B8%AA%E5%80%BC"><span class="nav-text">swap()交换两个值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sort-%E6%8E%92%E5%BA%8F"><span class="nav-text">sort()排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#count-%E7%BB%9F%E8%AE%A1%E6%95%B0%E9%87%8F"><span class="nav-text">count()统计数量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#unique-%E5%8E%BB%E9%87%8D"><span class="nav-text">unique()去重</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#erase-%E6%93%A6%E9%99%A4"><span class="nav-text">erase()擦除</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-lower-bound-upper-bound-binary-search-equal-range"><span class="nav-text">二分查找 lower_bound&#x2F;upper_bound&#x2F;binary_search&#x2F;equal_range</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A8%B3%E5%AE%9A%E5%88%86%E5%8C%BA-stable-partition"><span class="nav-text">稳定分区 stable_partition</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%A7%EF%BC%88%E5%B0%8F%EF%BC%89%E6%A0%B9%E5%A0%86-make-heap-push-heap-pop-heap"><span class="nav-text">大（小）根堆 make_heap&amp;push_heap&amp;pop_heap</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E5%B7%A5%E7%A8%8B%E5%BB%BA%E8%AE%AE"><span class="nav-text">四、工程建议</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E7%A0%81"><span class="nav-text">编码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AC%E7%94%A8%E5%B8%B8%E9%87%8F%E3%80%81%E7%B1%BB%E5%9E%8B%E5%92%8C%E6%96%B9%E6%B3%95"><span class="nav-text">公用常量、类型和方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%86%85%E9%83%A8%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E4%BD%BF%E7%94%A8"><span class="nav-text">函数内部局部变量使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%A8%E9%87%8A"><span class="nav-text">注释</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E5%A4%B4%E9%83%A8%E6%8F%8F%E8%BF%B0"><span class="nav-text">文件头部描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%92%8C%E5%87%BD%E6%95%B0%E5%9C%A8%E5%A4%B4%E6%96%87%E4%BB%B6%E5%86%99%E6%B3%A8%E9%87%8A"><span class="nav-text">方法和函数在头文件写注释</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%86%85%E9%83%A8%E5%B1%9E%E6%80%A7%E5%9C%A8%E5%90%8E%E9%9D%A2%E5%86%99%E6%B3%A8%E9%87%8A"><span class="nav-text">类内部属性在后面写注释</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%8D%E7%BC%80"><span class="nav-text">前缀</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E5%88%A4%E6%96%AD"><span class="nav-text">参数判断</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E5%A5%BD%E7%94%A8%E7%9A%84%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93"><span class="nav-text">五、好用的第三方库</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-google-test"><span class="nav-text">1. google test</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E8%BF%90%E8%A1%8C%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="nav-text">1.1. 运行常用命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-gtest%E7%9A%84main%E5%87%BD%E6%95%B0"><span class="nav-text">1.2. gtest的main函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%AD%E3%80%81%E9%9D%99%E6%80%81%E6%A3%80%E6%9F%A5"><span class="nav-text">六、静态检查</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-cpplint"><span class="nav-text">1. cpplint</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E5%BF%BD%E7%95%A5%E6%9F%90%E4%B8%80%E8%A1%8C"><span class="nav-text">1.1. 忽略某一行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B8%A9%E5%9D%91%E8%AE%B0-1"><span class="nav-text">踩坑记</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-windows%E7%BC%96%E8%AF%91%E6%8A%A5gtest-lib-gtest-all-obj-error-LNK2038-mismatch-detected-for-RuntimeLibrary-value-MTd-StaticDebug-doesn-t-match-value-MDd-DynamicDebug-in-main-obj"><span class="nav-text">1) windows编译报gtest.lib(gtest-all.obj) : error LNK2038: mismatch detected for &#39;RuntimeLibrary&#39;: value &#39;MTd_StaticDebug&#39; doesn&#39;t match value &#39;MDd_DynamicDebug&#39; in main.obj</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-cppcheck"><span class="nav-text">2. cppcheck</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E5%BF%BD%E7%95%A5%E6%9F%90%E4%B8%80%E8%A1%8C-1"><span class="nav-text">1.1. 忽略某一行</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%83%E3%80%81%E7%B1%BB%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%EF%BC%88%E9%9D%9E%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%89"><span class="nav-text">七、类的那些事（非基础知识）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E8%99%9A%E8%A1%A8%E5%92%8C%E8%99%9A%E6%8C%87%E9%92%88"><span class="nav-text">1. 虚表和虚指针</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%92%8C%E5%B0%8F%E6%8A%80%E5%B7%A7"><span class="nav-text">踩坑记和小技巧</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%A4%B4%E6%96%87%E4%BB%B6%E4%B8%8D%E8%A6%81-using-namespace"><span class="nav-text">1. 头文件不要 using namespace</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E7%9C%8B%E6%83%85%E5%86%B5%E4%BD%BF%E7%94%A8%E5%BC%95%E7%94%A8"><span class="nav-text">2. 参数传递看情况使用引用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-const-%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-text">3. const 的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%96%E9%83%A8%E4%B8%8D%E5%8F%AF%E6%9B%B4%E6%94%B9"><span class="nav-text">外部不可更改</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E4%B8%8D%E5%8F%AF%E6%9B%B4%E6%94%B9"><span class="nav-text">内部不可更改</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E5%8F%82%E6%95%B0%E8%B5%8B%E5%80%BC%E5%BF%85%E9%A1%BB%E7%94%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-text">4. 参数赋值必须用自己的类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E7%B1%BB%E7%9A%84%E5%BB%BA%E7%AB%8B%E9%9C%80%E8%A6%81%E6%B7%BB%E5%8A%A0%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E5%88%A0%E9%99%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-text">5. 类的建立需要添加构造函数和删除构造函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E7%B1%BB%E7%9A%84%E5%86%85%E9%83%A8%E5%B1%9E%E6%80%A7%E9%9C%80%E8%A6%81%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">6. 类的内部属性需要初始化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-%E5%8D%95%E4%BE%8B%E6%9E%84%E5%BB%BA"><span class="nav-text">7. 单例构建</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-do-while-%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-text">8. do while 作用域的问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-%E6%8C%87%E9%92%88%E5%BC%95%E7%94%A8%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%97%AE%E9%A2%98"><span class="nav-text">9. 指针引用的作用域问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-C-%E7%9A%84-switch-%E4%B8%AD%E7%9A%84-case-%E6%9C%89%E5%A4%9A%E6%9D%A1%E8%AF%AD%E5%8F%A5%E9%9C%80%E8%A6%81%E5%8A%A0%E5%A4%A7%E6%8B%AC%E5%8F%B7"><span class="nav-text">10. C++的 switch 中的 case 有多条语句需要加大括号</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-%E4%B8%8D%E5%AF%B9%E5%A4%96%E6%9A%B4%E9%9C%B2%E6%8E%A5%E5%8F%A3%E5%86%85%E5%AE%9E%E7%8E%B0"><span class="nav-text">11. 不对外暴露接口内实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-json-%E7%9A%84%E5%A4%84%E7%90%86"><span class="nav-text">12. json 的处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#12-1-schema-%E6%A0%A1%E9%AA%8C"><span class="nav-text">12.1. schema 校验</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-2-json-%E8%BD%AC%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-text">12.2. json 转结构体</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-%E5%85%B1%E4%BA%AB%E6%8C%87%E9%92%88%E6%8C%87%E5%90%91%E6%95%B0%E7%BB%84%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-text">13. 共享指针指向数组的问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#13-1-%E9%97%AE%E9%A2%98%E4%BB%A3%E7%A0%81"><span class="nav-text">13.1. 问题代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-2-%E9%97%AE%E9%A2%98%E5%8E%9F%E5%9B%A0"><span class="nav-text">13.2. 问题原因</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E6%B5%8B%E9%AA%8C%E8%AF%81"><span class="nav-text">实测验证</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-3-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-text">13.3. 解决方案</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-%E5%87%A0%E7%A7%8D%E7%BC%96%E8%AF%91%E9%94%99%E8%AF%AF%E5%8E%9F%E5%9B%A0"><span class="nav-text">14. 几种编译错误原因</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#14-1-undefined-reference-to-vtable-for-xxx"><span class="nav-text">14.1. undefined reference to vtable for xxx</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-2-error-LNK2001-unresolved-external-symbol-x"><span class="nav-text">14.2. error LNK2001: unresolved external symbol x</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-3-fatal-error-C1004-unexpected-end-of-file-found"><span class="nav-text">14.3. fatal error C1004: unexpected end of file found</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-4-error-C2371-xxx-redefinition-different-basic-types"><span class="nav-text">14.4. error C2371: &#39;xxx&#39;: redefinition; different basic types</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-std-this-thread-sleep-for%E8%B0%83%E6%95%B4%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4%E5%AF%BC%E8%87%B4%E7%9D%A1%E7%9C%A0%E6%97%B6%E9%97%B4%E5%8A%A0%E9%95%BF"><span class="nav-text">15. std::this_thread::sleep_for调整系统时间导致睡眠时间加长</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="王钰博" src="/images/12.jpg"><p class="site-author-name" itemprop="name">王钰博</p><div class="site-description" itemprop="description">个人博客</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">122</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">22</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">14</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/Githubwyb" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Githubwyb" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:1061322005@qq.com" title="E-Mail → mailto:1061322005@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a></span></div><div class="links-of-blogroll motion-element"><div class="links-of-blogroll-title"><i class="fa fa-fw fa-link"></i> 友情链接</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="https://githubwyb.github.io/bookPages/" title="https:&#x2F;&#x2F;githubwyb.github.io&#x2F;bookPages&#x2F;">markdown books</a></li></ul></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="beian"><a href="http://www.beian.miit.gov.cn/" rel="noopener" target="_blank">豫ICP备16023189号 </a><img src="/images/beian.png" style="display:inline-block"></div><div class="copyright">&copy; <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">王钰博</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-area-chart"></i> </span><span title="站点总字数">919k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span title="站点阅读时长">13:56</span></div><div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动</div><div class="addthis_inline_share_toolbox"><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e1986d4e4e2d132" async></script></div><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-divider">|</span> <span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer></div><script src="/lib/anime.min.js"></script><script src="/lib/medium-zoom.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><script src="/js/local-search.js"></script><script>document.querySelectorAll(".pdfobject-container").forEach(e=>{let t=e.dataset.target,a="#"+Object.entries({navpanes:0,toolbar:0,statusbar:0,pagemode:"thumbs",view:"FitH"}).map(([e,t])=>`${e}=${encodeURIComponent(t)}`).join("&"),i=`/lib/pdf/web/viewer.html?file=${encodeURIComponent(t)}${a}`;NexT.utils.supportsPDFs()?e.innerHTML=`<embed class="pdfobject" src="${t+a}" type="application/pdf" style="height: ${e.dataset.height};">`:e.innerHTML=`<iframe src="${i}" style="height: ${e.dataset.height};" frameborder="0"></iframe>`})</script><script>"undefined"==typeof MathJax?(window.MathJax={loader:{source:{"[tex]/amsCd":"[tex]/amscd","[tex]/AMScd":"[tex]/amscd"}},tex:{inlineMath:{"[+]":[["$","$"]]},tags:"ams"},options:{renderActions:{findScript:[10,e=>{document.querySelectorAll('script[type^="math/tex"]').forEach(t=>{const a=!!t.type.match(/; *mode=display/),n=new e.options.MathItem(t.textContent,e.inputJax[0],a),d=document.createTextNode("");t.parentNode.replaceChild(d,t),n.start={node:d,delim:"",n:0},n.end={node:d,delim:"",n:0},e.math.push(n)})},"",!1],insertedScript:[200,()=>{document.querySelectorAll("mjx-container").forEach(e=>{let t=e.parentNode;"li"===t.nodeName.toLowerCase()&&t.parentNode.classList.add("has-jax")})},"",!1]}}},function(){var e=document.createElement("script");e.src="/lib/mathjax/tex-mml-chtml.js",e.defer=!0,document.head.appendChild(e)}()):(MathJax.startup.document.state(0),MathJax.texReset(),MathJax.typeset())</script><script>NexT.utils.loadComments(document.querySelector("#valine-comments"),()=>{NexT.utils.getScript("//unpkg.com/valine/dist/Valine.min.js",()=>{var e=["nick","mail","link"],a="nick,mail";a=a.split(",").filter(a=>e.includes(a)),new Valine({el:"#valine-comments",verify:!1,notify:!1,appId:"qmLbUHV1HOr841BOYkl84riu-gzGzoHsz",appKey:"j4fgTcf1yHRDD5X3HUH5EH95",placeholder:"^_^ happy everyday!",avatar:"wavatar",meta:a,pageSize:"10",visitor:!1,lang:"zh-cn",path:location.pathname,recordIP:!1,serverURLs:""})},window.Valine)})</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":true,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"bottom":-30,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body><script type="text/javascript" src="/lib/jquery-3.4.1.min.js"></script><script type="text/javascript" src="/js/src/love.js"></script></html>