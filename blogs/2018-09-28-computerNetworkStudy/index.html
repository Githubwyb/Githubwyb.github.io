<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-diy.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-diy.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-diy.png"><link rel="mask-icon" href="/images/logo-diy.svg" color="#222"><meta name="baidu-site-verification" content="y1cfESbTt9nd3LsA"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="/lib/pace/pace-theme-flash.min.css"><script src="/lib/pace/pace.min.js"></script><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"githubwyb.github.io",root:"/",scheme:"Pisces",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:null},back2top:{enable:!0,sidebar:!1,scrollpercent:!0},bookmark:{enable:!0,color:"#ff0000",save:"auto"},fancybox:!1,mediumzoom:!0,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="一、网络OSI七层模型  分层介绍应用层 网络服务与最终用户的一个接口。 协议有: HTTP FTP TFTP SMTP SNMP DNS TELNET HTTPS POP3 DHCP  表示层 数据的表示、安全、压缩。（在五层模型里面已经合并到了应用层） 格式有，JPEG、ASCll、DECOIC、加密格式等  会话层 建立、管理、终止会话。（在五层模型里面已经合并到了应用层） 对应主机进程，指"><meta property="og:type" content="article"><meta property="og:title" content="计算机网络学习"><meta property="og:url" content="https://githubwyb.github.io/blogs/2018-09-28-computerNetworkStudy/index.html"><meta property="og:site_name" content="技术的路上奔跑"><meta property="og:description" content="一、网络OSI七层模型  分层介绍应用层 网络服务与最终用户的一个接口。 协议有: HTTP FTP TFTP SMTP SNMP DNS TELNET HTTPS POP3 DHCP  表示层 数据的表示、安全、压缩。（在五层模型里面已经合并到了应用层） 格式有，JPEG、ASCll、DECOIC、加密格式等  会话层 建立、管理、终止会话。（在五层模型里面已经合并到了应用层） 对应主机进程，指"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://githubwyb.github.io/blogs/2018-09-28-computerNetworkStudy/2019_10_14_02.png"><meta property="og:image" content="https://githubwyb.github.io/blogs/2018-09-28-computerNetworkStudy/2022-03-15-03.png"><meta property="og:image" content="https://githubwyb.github.io/blogs/2018-09-28-computerNetworkStudy/2022-03-29-04.png"><meta property="og:image" content="https://githubwyb.github.io/blogs/2018-09-28-computerNetworkStudy/2022-03-29-05.png"><meta property="og:image" content="https://githubwyb.github.io/blogs/2018-09-28-computerNetworkStudy/2022-04-19-06.png"><meta property="og:image" content="https://githubwyb.github.io/blogs/2018-09-28-computerNetworkStudy/2022-04-19-07.png"><meta property="og:image" content="https://githubwyb.github.io/blogs/2018-09-28-computerNetworkStudy/2022-04-20-08.png"><meta property="og:image" content="https://githubwyb.github.io/blogs/2018-09-28-computerNetworkStudy/2022-04-20-09.png"><meta property="article:published_time" content="2018-09-28T03:30:07.000Z"><meta property="article:modified_time" content="2024-01-01T14:47:00.000Z"><meta property="article:author" content="王钰博"><meta property="article:tag" content="网络"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://githubwyb.github.io/blogs/2018-09-28-computerNetworkStudy/2019_10_14_02.png"><link rel="canonical" href="https://githubwyb.github.io/blogs/2018-09-28-computerNetworkStudy/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>计算机网络学习 | 技术的路上奔跑</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">技术的路上奔跑</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">入门</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-fw fa-sitemap"></i>站点地图</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><div class="reading-progress-bar"></div><a role="button" class="book-mark-link book-mark-link-fixed"></a> <a href="https://github.com/Githubwyb" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://githubwyb.github.io/blogs/2018-09-28-computerNetworkStudy/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/12.jpg"><meta itemprop="name" content="王钰博"><meta itemprop="description" content="个人博客"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="技术的路上奔跑"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">计算机网络学习</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2018-09-28 11:30:07" itemprop="dateCreated datePublished" datetime="2018-09-28T11:30:07+08:00">2018-09-28</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2024-01-01 22:47:00" itemprop="dateModified" datetime="2024-01-01T22:47:00+08:00">2024-01-01</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Knowledge/" itemprop="url" rel="index"><span itemprop="name">Knowledge</span></a> </span>， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Knowledge/Study/" itemprop="url" rel="index"><span itemprop="name">Study</span></a> </span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span id="busuanzi_value_page_pv"></span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><span class="post-meta-item-text">Valine：</span> <a title="valine" href="/blogs/2018-09-28-computerNetworkStudy/#valine-comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/blogs/2018-09-28-computerNetworkStudy/" itemprop="commentCount"></span></a></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>24k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>21 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="一、网络OSI七层模型"><a href="#一、网络OSI七层模型" class="headerlink" title="一、网络OSI七层模型"></a>一、网络OSI七层模型</h1><img src="2018_09_28_01.jpg" width="80%"><h2 id="分层介绍"><a href="#分层介绍" class="headerlink" title="分层介绍"></a>分层介绍</h2><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><ul><li>网络服务与最终用户的一个接口。</li><li>协议有: HTTP FTP TFTP SMTP SNMP DNS TELNET HTTPS POP3 DHCP</li></ul><h3 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h3><ul><li>数据的表示、安全、压缩。（在五层模型里面已经合并到了应用层）</li><li>格式有，JPEG、ASCll、DECOIC、加密格式等</li></ul><h3 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h3><ul><li>建立、管理、终止会话。（在五层模型里面已经合并到了应用层）</li><li>对应主机进程，指本地主机与远程主机正在进行的会话</li></ul><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><ul><li>定义传输数据的协议端口号，以及流控和差错校验。</li><li>协议有: TCP UDP，数据包一旦离开网卡即进入网络传输层</li></ul><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><ul><li>进行逻辑地址寻址，实现不同网络之间的路径选择。ip包传输，不带端口。</li><li>协议有: ICMP IGMP IP（IPV4 IPV6） ARP RARP</li></ul><h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><ul><li>建立逻辑连接、进行硬件地址寻址、差错校验 [2] 等功能。（由底层网络定义协议）</li><li>将比特组合成字节进而组合成帧，用MAC地址访问介质，错误发现但不能纠正。</li></ul><h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><ul><li>建立、维护、断开物理连接。（由底层网络定义协议）</li></ul><h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><ul><li>TCP&#x2F;IP 层级模型结构，应用层之间的协议通过逐级调用传输层（Transport layer）、网络层（Network Layer）和物理数据链路层（Physical Data Link）而可以实现应用层的应用程序通信互联。</li><li>应用层需要关心应用程序的逻辑细节，而不是数据在网络中的传输活动。应用层其下三层则处理真正的通信细节。在 Internet 整个发展过程中的所有思想和着重点都以一种称为 RFC（Request For Comments）的文档格式存在。针对每一种特定的 TCP&#x2F;IP 应用，有相应的 RFC [3] 文档。</li><li>一些典型的 TCP&#x2F;IP 应用有 FTP、Telnet、SMTP、SNTP、REXEC、TFTP、LPD、SNMP、NFS、INETD 等。RFC 使一些基本相同的 TCP&#x2F;IP 应用程序实现了标准化，从而使得不同厂家开发的应用程序可以互相通信</li></ul><h1 id="二、物理层"><a href="#二、物理层" class="headerlink" title="二、物理层"></a>二、物理层</h1><h1 id="三、数据链路层"><a href="#三、数据链路层" class="headerlink" title="三、数据链路层"></a>三、数据链路层</h1><h1 id="四、网络层"><a href="#四、网络层" class="headerlink" title="四、网络层"></a>四、网络层</h1><h2 id="1-ip地址分类"><a href="#1-ip地址分类" class="headerlink" title="1. ip地址分类"></a>1. ip地址分类</h2><img src="2019_10_14_02.png" width="80%"><p>IP地址根据网络号和主机号来分，分为A、B、C三类及特殊地址D、E。全0和全1的都保留不用。</p><ul><li>A类: (1.0.0.0-126.0.0.0)（默认子网掩码: 255.0.0.0或 0xFF000000）第一个字节为网络号，后三个字节为主机号。该类IP地址的最前面为“0”，所以地址的网络号取值于1~126之间。一般用于大型网络。</li><li>B类: (128.0.0.0-191.255.0.0)（默认子网掩码: 255.255.0.0或0xFFFF0000）前两个字节为网络号，后两个字节为主机号。该类IP地址的最前面为“10”，所以地址的网络号取值于128~191之间。一般用于中等规模网络。</li><li>C类: (192.0.0.0-223.255.255.0)（子网掩码: 255.255.255.0或 0xFFFFFF00）前三个字节为网络号，最后一个字节为主机号。该类IP地址的最前面为“110”，所以地址的网络号取值于192~223之间。一般用于小型网络。</li><li>D类: 是多播地址。该类IP地址的最前面为“1110”，所以地址的网络号取值于224~239之间。一般用于多路广播用户[1] 。</li><li>E类: 是保留地址。该类IP地址的最前面为“1111”，所以地址的网络号取值于240~255之间。</li></ul><h2 id="2-ip包分析"><a href="#2-ip包分析" class="headerlink" title="2. ip包分析"></a>2. ip包分析</h2><h3 id="2-1-ipv4包"><a href="#2-1-ipv4包" class="headerlink" title="2.1. ipv4包"></a>2.1. ipv4包</h3><p><strong>结构图</strong></p><img src="2022-03-15-03.png"><p><strong>协议头文件定义</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// netinet/ip.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iphdr</span></span><br><span class="line">  &#123;</span><br><span class="line"><span class="comment">// 主机字节序是小端，就在第一个字节后4位</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __BYTE_ORDER == __LITTLE_ENDIAN</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> ihl:<span class="number">4</span>;         <span class="comment">// 0:0-3</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> version:<span class="number">4</span>;     <span class="comment">// 0:4-7</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> __BYTE_ORDER == __BIG_ENDIAN</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> version:<span class="number">4</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> ihl:<span class="number">4</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">error</span>	<span class="string">&quot;Please fix &lt;bits/endian.h&gt;&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">uint8_t</span> tos;        <span class="comment">// 1</span></span><br><span class="line">    <span class="type">uint16_t</span> tot_len;   <span class="comment">// 2-3</span></span><br><span class="line">    <span class="type">uint16_t</span> id;        <span class="comment">// 4-5</span></span><br><span class="line">    <span class="type">uint16_t</span> frag_off;  <span class="comment">// 6-7</span></span><br><span class="line">    <span class="type">uint8_t</span> ttl;        <span class="comment">// 8</span></span><br><span class="line">    <span class="type">uint8_t</span> protocol;   <span class="comment">// 9</span></span><br><span class="line">    <span class="type">uint16_t</span> check;     <span class="comment">// 10-11</span></span><br><span class="line">    <span class="type">uint32_t</span> saddr;     <span class="comment">// 12-15</span></span><br><span class="line">    <span class="type">uint32_t</span> daddr;     <span class="comment">// 16-19</span></span><br><span class="line">    <span class="comment">/*The options start here. */</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面是__USE_MISC定义的</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ip</span></span><br><span class="line">  &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __BYTE_ORDER == __LITTLE_ENDIAN</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> ip_hl:<span class="number">4</span>;		<span class="comment">/* header length */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> ip_v:<span class="number">4</span>;		<span class="comment">/* version */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __BYTE_ORDER == __BIG_ENDIAN</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> ip_v:<span class="number">4</span>;		<span class="comment">/* version */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> ip_hl:<span class="number">4</span>;		<span class="comment">/* header length */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">uint8_t</span> ip_tos;			<span class="comment">/* type of service */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> ip_len;		<span class="comment">/* total length */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> ip_id;		<span class="comment">/* identification */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> ip_off;		<span class="comment">/* fragment offset field */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	IP_RF 0x8000			<span class="comment">/* reserved fragment flag */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	IP_DF 0x4000			<span class="comment">/* dont fragment flag */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	IP_MF 0x2000			<span class="comment">/* more fragments flag */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	IP_OFFMASK 0x1fff		<span class="comment">/* mask for fragmenting bits */</span></span></span><br><span class="line">    <span class="type">uint8_t</span> ip_ttl;			<span class="comment">/* time to live */</span></span><br><span class="line">    <span class="type">uint8_t</span> ip_p;			<span class="comment">/* protocol */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> ip_sum;		<span class="comment">/* checksum */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in_addr</span> ip_src, ip_dst;	<span class="comment">/* source and dest address */</span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><ul><li>正好20个字节</li></ul><p><strong>详细介绍</strong></p><ul><li>ihl: ip包头部长度，包括拓展字段长度</li><li>version: 标识ipv4还是ipv6</li><li>tos: 服务类型，只有在区分服务的时候才会用</li><li>tot_len: ip包总长度</li><li>id: 标识数据包的计数，每一个包，计数加一；分片包此数字一样</li><li>frag_off: 分片包相关标记<ul><li><code>0x8000</code>: 保留未使用</li><li><code>0x4000</code>: 不分片的flag，分片就是0，不分片为1</li><li><code>0x2000</code>: 是否后面还有分片包的标志位</li><li><code>0x1fff</code>: 标识分片包顺序的标志位</li></ul></li><li>ttl: 生存时间，经过每个路由器，TTL减去消耗的时间，当TTL为0，丢掉此数据包</li><li>protocol: 标识协议类型，TCP、UDP、ICMP等，具体定义在<code>netinet/in.h</code>里面</li><li>check: ip头校验和</li><li>saddr: 源地址</li><li>daddr: 目标地址</li></ul><h3 id="2-2-ipv6包"><a href="#2-2-ipv6包" class="headerlink" title="2.2. ipv6包"></a>2.2. ipv6包</h3><p><strong>结构图</strong></p><img src="2022-03-29-04.png"><p><strong>wireshark抓包</strong></p><img src="2022-03-29-05.png"><p><strong>协议头文件定义</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// netinet/ip6.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ip6_hdr</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">union</span></span><br><span class="line">      &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ip6_hdrctl</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="type">uint32_t</span> ip6_un1_flow;   <span class="comment">/* 4 bits version, 8 bits TC,</span></span><br><span class="line"><span class="comment">                    20 bits flow-ID */</span></span><br><span class="line">        <span class="type">uint16_t</span> ip6_un1_plen;   <span class="comment">/* payload length */</span></span><br><span class="line">        <span class="type">uint8_t</span>  ip6_un1_nxt;    <span class="comment">/* next header */</span></span><br><span class="line">        <span class="type">uint8_t</span>  ip6_un1_hlim;   <span class="comment">/* hop limit */</span></span><br><span class="line">      &#125; ip6_un1;</span><br><span class="line">    <span class="type">uint8_t</span> ip6_un2_vfc;       <span class="comment">/* 4 bits version, top 4 bits tclass */</span></span><br><span class="line">      &#125; ip6_ctlun;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in6_addr</span> ip6_src;      <span class="comment">/* source address */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in6_addr</span> ip6_dst;      <span class="comment">/* destination address */</span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p><strong>详细介绍</strong></p><ul><li><code>version</code>: 前4bit，ipv6就只有6</li><li><code>Traffic Class</code>: 紧跟的8bit</li><li><code>ip6_un1_plen</code>: 应用数据包大小（不算ip头）</li><li><code>ip6_un1_nxt</code>: 协议（UDP、TCP等）</li><li><code>ip6_src</code>: 64bit源地址</li><li><code>ip6_dst</code>: 64bit目的地址</li></ul><h1 id="五、传输层"><a href="#五、传输层" class="headerlink" title="五、传输层"></a>五、传输层</h1><ul><li>tcp和udp都是ip包的数据段，分片包协议属于ip网络层协议，非传输层</li></ul><h2 id="1-TCP"><a href="#1-TCP" class="headerlink" title="1. TCP"></a>1. TCP</h2><h3 id="1-1-建立TCP连接-三次握手协议"><a href="#1-1-建立TCP连接-三次握手协议" class="headerlink" title="1.1. 建立TCP连接: 三次握手协议"></a>1.1. 建立TCP连接: 三次握手协议</h3><ul><li>客户端: 我要对你讲话，你能听到吗；</li><li>服务端: 我能听到；而且我也要对你讲话，你能听到吗；</li><li>客户端: 我也能听到。<br>…<br>互相开始通话<br>…</li></ul><h3 id="1-2-关闭TCP连接-四次握手协议"><a href="#1-2-关闭TCP连接-四次握手协议" class="headerlink" title="1.2. 关闭TCP连接: 四次握手协议"></a>1.2. 关闭TCP连接: 四次握手协议</h3><ul><li>客户端: 我说完了，我要闭嘴了；</li><li>服务端: 我收到请求，我要闭耳朵了；<br>（客户端收到这个确认，于是安心地闭嘴了。）<br>…<br>服务端还没倾诉完自己的故事，于是继续唠唠叨叨向客户端说了半天，直到说完为止<br>…</li><li>服务端: 我说完了，我也要闭嘴了；</li><li>客户端: 我收到请求，我要闭耳朵了；（事实上，客户端为了保证这个确认包成功送达，等待了两个最大报文生命周期后，才闭上耳朵。）<br>（服务端收到这个确认，于是安心地闭嘴了。）</li></ul><h4 id="1-问题"><a href="#1-问题" class="headerlink" title="1) 问题"></a>1) 问题</h4><ol><li>客户端收到请求包后，为什么要等待两个最大报文生命周期后，才闭上耳朵呢？<ul><li>为了以防万一，因为最后一个发往服务端B的确认包有可能丢失。若丢失，服务端这里过了响应超时时间timeOut，会再次往客户端A发送关闭连接请求，这时候客户端得保证自己还没闭上耳朵，还能接收请求才行。</li><li>服务端B再次发送的请求包到达客户端A时间，绝不会超过最大报文生命周期。</li><li>这里的问题是，到底上面服务端的是如何判断超时的（我不是很清楚），假如是以自己发送请求时刻开始计时，半天未应答，为超时，那么：</li><li>从服务端B发送请求包的时刻开始算，经过( TimeOut + 最大报文生命周期 )后，A必须还能接收数据包。</li><li>那么A需要等待的时间是: ( TimeOut + 最大报文生命周期 ) - （上一个关闭l请求包从B发送到A的时长）。</li><li>网上这块儿都讲得很模糊，一般就是说到A需要等待( TimeOut + 最大报文生命周期 ) &lt; 2 * 最大报文生命周期，所以等待2 * 最大报文生命周期可以确保万无一失。</li><li>事实上，这里关键需要搞清楚服务端的是如何判断超时的，我不是很清楚。但是假如是以自己发送请求的时刻开始计时，那么TimeOut应该是一个往返的最大时间吧，你们确定一个“请求-应答”往返的最大时间小于最大报文生命周期。</li><li>当然，所有地方都是说要等待 2 * 最大生命周期，虽然没具体搞明白，但是我也同样相信。只是，网上的各种解释，都解析的模模糊糊，而且好多地方从逻辑上都不能完全说通诶，对那些解释，我没法完全相信。</li></ul></li></ol><h3 id="1-3-tcp头部分析"><a href="#1-3-tcp头部分析" class="headerlink" title="1.3. tcp头部分析"></a>1.3. tcp头部分析</h3><p><strong>结构图</strong></p><img src="2022-04-19-06.png"><p><strong>wireshark抓包</strong></p><img src="2022-04-19-07.png"><p><strong>协议头文件定义</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;netinet/tcp.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * TCP header.</span></span><br><span class="line"><span class="comment"> * Per RFC 793, September, 1981.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tcphdr</span></span><br><span class="line">  &#123;</span><br><span class="line">    __extension__ <span class="keyword">union</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">struct</span></span><br><span class="line">      &#123;</span><br><span class="line">	<span class="type">uint16_t</span> th_sport;	<span class="comment">/* source port */</span></span><br><span class="line">	<span class="type">uint16_t</span> th_dport;	<span class="comment">/* destination port */</span></span><br><span class="line">	tcp_seq th_seq;		<span class="comment">/* sequence number */</span></span><br><span class="line">	tcp_seq th_ack;		<span class="comment">/* acknowledgement number */</span></span><br><span class="line"><span class="meta"># <span class="keyword">if</span> __BYTE_ORDER == __LITTLE_ENDIAN</span></span><br><span class="line">	<span class="type">uint8_t</span> th_x2:<span class="number">4</span>;	<span class="comment">/* (unused) */</span></span><br><span class="line">	<span class="type">uint8_t</span> th_off:<span class="number">4</span>;	<span class="comment">/* data offset */</span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">if</span> __BYTE_ORDER == __BIG_ENDIAN</span></span><br><span class="line">	<span class="type">uint8_t</span> th_off:<span class="number">4</span>;	<span class="comment">/* data offset */</span></span><br><span class="line">	<span class="type">uint8_t</span> th_x2:<span class="number">4</span>;	<span class="comment">/* (unused) */</span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">uint8_t</span> th_flags;</span><br><span class="line"><span class="meta"># <span class="keyword">define</span> TH_FIN	0x01</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> TH_SYN	0x02</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> TH_RST	0x04</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> TH_PUSH	0x08</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> TH_ACK	0x10</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> TH_URG	0x20</span></span><br><span class="line">	<span class="type">uint16_t</span> th_win;	<span class="comment">/* window */</span></span><br><span class="line">	<span class="type">uint16_t</span> th_sum;	<span class="comment">/* checksum */</span></span><br><span class="line">	<span class="type">uint16_t</span> th_urp;	<span class="comment">/* urgent pointer */</span></span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="keyword">struct</span></span><br><span class="line">      &#123;</span><br><span class="line">	<span class="type">uint16_t</span> source;</span><br><span class="line">	<span class="type">uint16_t</span> dest;</span><br><span class="line">	<span class="type">uint32_t</span> seq;</span><br><span class="line">	<span class="type">uint32_t</span> ack_seq;</span><br><span class="line"><span class="meta"># <span class="keyword">if</span> __BYTE_ORDER == __LITTLE_ENDIAN</span></span><br><span class="line">	<span class="type">uint16_t</span> res1:<span class="number">4</span>;    <span class="comment">// uint16低8bit在前（0x50），对应低8bit的低4bit（0000）</span></span><br><span class="line">	<span class="type">uint16_t</span> doff:<span class="number">4</span>;    <span class="comment">// uint16低8bit在前（0x50），对应低8bit的高4bit（0101）</span></span><br><span class="line">	<span class="type">uint16_t</span> fin:<span class="number">1</span>;     <span class="comment">// uint16高8bit在后（0x10），对应高8bit的倒数第1位（0）</span></span><br><span class="line">	<span class="type">uint16_t</span> syn:<span class="number">1</span>;     <span class="comment">// uint16高8bit在后（0x10），对应高8bit的倒数第2位（0）</span></span><br><span class="line">	<span class="type">uint16_t</span> rst:<span class="number">1</span>;     <span class="comment">// uint16高8bit在后（0x10），对应高8bit的倒数第3位（0）</span></span><br><span class="line">	<span class="type">uint16_t</span> psh:<span class="number">1</span>;     <span class="comment">// uint16高8bit在后（0x10），对应高8bit的倒数第4位（0）</span></span><br><span class="line">	<span class="type">uint16_t</span> ack:<span class="number">1</span>;     <span class="comment">// uint16高8bit在后（0x10），对应高8bit的倒数第5位（1）</span></span><br><span class="line">	<span class="type">uint16_t</span> urg:<span class="number">1</span>;     <span class="comment">// uint16高8bit在后（0x10），对应高8bit的倒数第6位（0）</span></span><br><span class="line">	<span class="type">uint16_t</span> res2:<span class="number">2</span>;    <span class="comment">// uint16高8bit在后（0x10），对应高8bit的倒数第7,8位（0）</span></span><br><span class="line"><span class="meta"># <span class="keyword">elif</span> __BYTE_ORDER == __BIG_ENDIAN</span></span><br><span class="line">	<span class="type">uint16_t</span> doff:<span class="number">4</span>;</span><br><span class="line">	<span class="type">uint16_t</span> res1:<span class="number">4</span>;</span><br><span class="line">	<span class="type">uint16_t</span> res2:<span class="number">2</span>;</span><br><span class="line">	<span class="type">uint16_t</span> urg:<span class="number">1</span>;</span><br><span class="line">	<span class="type">uint16_t</span> ack:<span class="number">1</span>;</span><br><span class="line">	<span class="type">uint16_t</span> psh:<span class="number">1</span>;</span><br><span class="line">	<span class="type">uint16_t</span> rst:<span class="number">1</span>;</span><br><span class="line">	<span class="type">uint16_t</span> syn:<span class="number">1</span>;</span><br><span class="line">	<span class="type">uint16_t</span> fin:<span class="number">1</span>;</span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#  <span class="keyword">error</span> <span class="string">&quot;Adjust your &lt;bits/endian.h&gt; defines&quot;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">uint16_t</span> window;</span><br><span class="line">	<span class="type">uint16_t</span> check;</span><br><span class="line">	<span class="type">uint16_t</span> urg_ptr;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="1-4-tcp校验和的计算"><a href="#1-4-tcp校验和的计算" class="headerlink" title="1.4. tcp校验和的计算"></a>1.4. tcp校验和的计算</h3><ul><li>硬件有checksum offload能力时，协议栈只需要计算一个伪头部校验和，放到tcp-&gt;check中，然后设置好csum_start（硬件需要计算checksum的起始位置即tcp头部起始位置），csum_offset（计算完成后存放的位置），硬件就会自动计算</li><li>协议栈里面处理tcp校验和的代码</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// net/ipv4/tcp_ipv4.c</span></span><br><span class="line"><span class="type">void</span> __tcp_v4_send_check(<span class="keyword">struct</span> sk_buff *skb, __be32 saddr, __be32 daddr)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">tcphdr</span> *th = <span class="built_in">tcp_hdr</span>(skb);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 伪头部校验和包括tcp包整个长度，源ip和目的ip</span></span><br><span class="line">	th-&gt;check = ~<span class="built_in">tcp_v4_check</span>(skb-&gt;len, saddr, daddr, <span class="number">0</span>);</span><br><span class="line">	skb-&gt;csum_start = <span class="built_in">skb_transport_header</span>(skb) - skb-&gt;head;  <span class="comment">// tcp头部起始位置，基于head的偏移</span></span><br><span class="line">	skb-&gt;csum_offset = <span class="built_in">offsetof</span>(<span class="keyword">struct</span> tcphdr, check);  <span class="comment">// check基于tcp头部起始位置的偏移</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This routine computes an IPv4 TCP checksum. */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tcp_v4_send_check</span><span class="params">(<span class="keyword">struct</span> sock *sk, <span class="keyword">struct</span> sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">inet_sock</span> *inet = <span class="built_in">inet_sk</span>(sk);</span><br><span class="line"></span><br><span class="line">	__tcp_v4_send_check(skb, inet-&gt;inet_saddr, inet-&gt;inet_daddr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">EXPORT_SYMBOL</span>(tcp_v4_send_check);</span><br></pre></td></tr></table></figure><ul><li>伪头部包含源ip和目的ip以及tcp整个包长度，目的是让接收端进行校验，确定tcp构造头部时的源地址和目的地址和数据包是一致的</li></ul><h2 id="2-UDP"><a href="#2-UDP" class="headerlink" title="2. UDP"></a>2. UDP</h2><h3 id="2-1-UDP头部分析"><a href="#2-1-UDP头部分析" class="headerlink" title="2.1. UDP头部分析"></a>2.1. UDP头部分析</h3><p><strong>结构图</strong></p><img src="2022-04-20-08.png"><p><strong>wireshark抓包</strong></p><img src="2022-04-20-09.png"><p><strong>协议头文件定义</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// netinet/udp.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* UDP header as specified by RFC 768, August 1980. */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">udphdr</span></span><br><span class="line">&#123;</span><br><span class="line">  __extension__ <span class="keyword">union</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">struct</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">uint16_t</span> uh_sport;	<span class="comment">/* source port */</span></span><br><span class="line">      <span class="type">uint16_t</span> uh_dport;	<span class="comment">/* destination port */</span></span><br><span class="line">      <span class="type">uint16_t</span> uh_ulen;		<span class="comment">/* udp length */</span></span><br><span class="line">      <span class="type">uint16_t</span> uh_sum;		<span class="comment">/* udp checksum */</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">struct</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">uint16_t</span> source;</span><br><span class="line">      <span class="type">uint16_t</span> dest;</span><br><span class="line">      <span class="type">uint16_t</span> len;</span><br><span class="line">      <span class="type">uint16_t</span> check;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="六、应用层"><a href="#六、应用层" class="headerlink" title="六、应用层"></a>六、应用层</h1><h2 id="1-tls握手流程"><a href="#1-tls握手流程" class="headerlink" title="1. tls握手流程"></a>1. tls握手流程</h2><p>参考自 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/344086342">图解 HTTPS：RSA 握手过程</a></p><h2 id="2-http"><a href="#2-http" class="headerlink" title="2. http"></a>2. http</h2><h3 id="2-1-http-header"><a href="#2-1-http-header" class="headerlink" title="2.1. http header"></a>2.1. http header</h3><h4 id="1-General部分"><a href="#1-General部分" class="headerlink" title="1) General部分"></a>1) General部分</h4><table><thead><tr><th>Header</th><th>解释</th><th>示例</th></tr></thead><tbody><tr><td>Request URL</td><td>请求的url</td><td><a target="_blank" rel="noopener" href="https://www.baidu.com/home/msg/data/personalcontent?callback=jQuery1">https://www.baidu.com/home/msg/data/personalcontent?callback=jQuery1</a></td></tr><tr><td>Request Method</td><td>请求的方法，可以是GET、POST</td><td>GET</td></tr><tr><td>Status Code</td><td><a href="#statusCode">HTTP 状态码</a>，表示请求成功</td><td>200 OK</td></tr><tr><td>Remote Address</td><td>远程IP地址</td><td>119.75.213.61:443</td></tr><tr><td>Referrer Policy</td><td>见下文</td><td>unsafe-url</td></tr></tbody></table><h5 id="Referrer-Policy-States"><a href="#Referrer-Policy-States" class="headerlink" title="Referrer Policy States"></a>Referrer Policy States</h5><p>新的Referrer规定了五种策略：</p><ul><li>No Referrer：任何情况下都不发送Referrer信息</li><li>No Referrer When Downgrade：仅当协议降级（如HTTPS页面引入HTTP资源）时不发送Referrer信息。是大部分浏览器默认策略。</li><li>Origin Only：发送只包含host部分的referrer.</li><li>Origin When Cross-origin：仅在发生跨域访问时发送只包含host的Referer，同域下还是完整的。与Origin Only的区别是多判断了是否Cross-origin。协议、域名和端口都一致，浏览器才认为是同域。</li><li>Unsafe URL：全部都发送Referrer信息。最宽松最不安全的策略。</li></ul><h4 id="2-Requests部分"><a href="#2-Requests部分" class="headerlink" title="2) Requests部分"></a>2) Requests部分</h4><table><thead><tr><th>Header</th><th>解释</th><th>示例</th></tr></thead><tbody><tr><td>Accept</td><td>指定客户端能够接收的内容类型</td><td>Accept: text&#x2F;plain, text&#x2F;html</td></tr><tr><td>Accept-Charset</td><td>浏览器可以接受的字符编码集。</td><td>Accept-Charset: iso-8859-5</td></tr><tr><td>Accept-Encoding</td><td>指定浏览器可以支持的web服务器返回内容压缩编码类型。</td><td>Accept-Encoding: compress, gzip</td></tr><tr><td>Accept-Language</td><td>浏览器可接受的语言</td><td>Accept-Language: en,zh</td></tr><tr><td>Accept-Ranges</td><td>可以请求网页实体的一个或者多个子范围字段</td><td>Accept-Ranges: bytes</td></tr><tr><td>Authorization</td><td>HTTP授权的授权证书</td><td>Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ&#x3D;&#x3D;</td></tr><tr><td>Cache-Control</td><td>指定请求和响应遵循的缓存机制</td><td>Cache-Control: no-cache</td></tr><tr><td>Connection</td><td>表示是否需要持久连接。（HTTP 1.1默认进行持久连接）</td><td>Connection: close</td></tr><tr><td>Cookie</td><td>HTTP请求发送时，会把保存在该请求域名下的所有cookie值一起发送给web服务器。</td><td>Cookie: $Version&#x3D;1; Skin&#x3D;new;</td></tr><tr><td>Content-Length</td><td>请求的内容长度</td><td>Content-Length: 348</td></tr><tr><td>Content-Type</td><td>请求的与实体对应的MIME信息</td><td>Content-Type: application&#x2F;x-www-form-urlencoded</td></tr><tr><td>Date</td><td>请求发送的日期和时间</td><td>Date: Tue, 15 Nov 2010 08:12:31 GMT</td></tr><tr><td>Expect</td><td>请求的特定的服务器行为</td><td>Expect: 100-continue</td></tr><tr><td>From</td><td>发出请求的用户的Email</td><td>From: <a href="mailto:&#117;&#x73;&#x65;&#114;&#64;&#101;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#109;">&#117;&#x73;&#x65;&#114;&#64;&#101;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#109;</a></td></tr><tr><td>Host</td><td>指定请求的服务器的域名和端口号</td><td>Host: <a target="_blank" rel="noopener" href="http://www.zcmhi.com/">www.zcmhi.com</a></td></tr><tr><td>If-Match</td><td>只有请求内容与实体相匹配才有效</td><td>If-Match: “737060cd8c284d8af7ad3082f209582d”</td></tr><tr><td>If-Modified-Since</td><td>如果请求的部分在指定时间之后被修改则请求成功，未被修改则返回304代码</td><td>If-Modified-Since: Sat, 29 Oct 2010 19:43:31 GMT</td></tr><tr><td>If-None-Match</td><td>如果内容未改变返回304代码，参数为服务器先前发送的Etag，与服务器回应的Etag比较判断是否改变</td><td>If-None-Match: “737060cd8c284d8af7ad3082f209582d”</td></tr><tr><td>If-Range</td><td>如果实体未改变，服务器发送客户端丢失的部分，否则发送整个实体。参数也为Etag</td><td>If-Range: “737060cd8c284d8af7ad3082f209582d”</td></tr><tr><td>If-Unmodified-Since</td><td>只在实体在指定时间之后未被修改才请求成功</td><td>If-Unmodified-Since: Sat, 29 Oct 2010 19:43:31 GMT</td></tr><tr><td>Max-Forwards</td><td>限制信息通过代理和网关传送的时间</td><td>Max-Forwards: 10</td></tr><tr><td>Pragma</td><td>用来包含实现特定的指令</td><td>Pragma: no-cache</td></tr><tr><td>Proxy-Authorization</td><td>连接到代理的授权证书</td><td>Proxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ&#x3D;&#x3D;</td></tr><tr><td>Range</td><td>只请求实体的一部分，指定范围</td><td>Range: bytes&#x3D;500-999</td></tr><tr><td>Referer</td><td>先前网页的地址，当前请求网页紧随其后,即来路</td><td>Referer: <a target="_blank" rel="noopener" href="http://www.zcmhi.com/archives/71.html">http://www.zcmhi.com/archives/71.html</a></td></tr><tr><td>TE</td><td>客户端愿意接受的传输编码，并通知服务器接受接受尾加头信息</td><td>TE: trailers,deflate;q&#x3D;0.5</td></tr><tr><td>Upgrade</td><td>向服务器指定某种传输协议以便服务器进行转换（如果支持）</td><td>Upgrade: HTTP&#x2F;2.0, SHTTP&#x2F;1.3, IRC&#x2F;6.9, RTA&#x2F;x11</td></tr><tr><td>User-Agent</td><td>User-Agent的内容包含发出请求的用户信息</td><td>User-Agent: Mozilla&#x2F;5.0 (Linux; X11)</td></tr><tr><td>Via</td><td>通知中间网关或代理服务器地址，通信协议</td><td>Via: 1.0 fred, 1.1 nowhere.com (Apache&#x2F;1.1)</td></tr><tr><td>Warning</td><td>关于消息实体的警告信息</td><td>Warn: 199 Miscellaneous warning</td></tr></tbody></table><h4 id="3-Responses-部分"><a href="#3-Responses-部分" class="headerlink" title="3) Responses 部分"></a>3) Responses 部分</h4><table><thead><tr><th>Header</th><th>解释</th><th>示例</th></tr></thead><tbody><tr><td>Accept-Ranges</td><td>表明服务器是否支持指定范围请求及哪种类型的分段请求</td><td>Accept-Ranges: bytes</td></tr><tr><td>Age</td><td>从原始服务器到代理缓存形成的估算时间（以秒计，非负）</td><td>Age: 12</td></tr><tr><td>Allow</td><td>对某网络资源的有效的请求行为，不允许则返回405</td><td>Allow: GET, HEAD</td></tr><tr><td>Cache-Control</td><td>告诉所有的缓存机制是否可以缓存及哪种类型</td><td>Cache-Control: no-cache</td></tr><tr><td>Content-Encoding</td><td>web服务器支持的返回内容压缩编码类型。</td><td>Content-Encoding: gzip</td></tr><tr><td>Content-Language</td><td>响应体的语言</td><td>Content-Language: en,zh</td></tr><tr><td>Content-Length</td><td>响应体的长度</td><td>Content-Length: 348</td></tr><tr><td>Content-Location</td><td>请求资源可替代的备用的另一地址</td><td>Content-Location: &#x2F;index.htm</td></tr><tr><td>Content-MD5</td><td>返回资源的MD5校验值</td><td>Content-MD5: Q2hlY2sgSW50ZWdyaXR5IQ&#x3D;&#x3D;</td></tr><tr><td>Content-Range</td><td>在整个返回体中本部分的字节位置</td><td>Content-Range: bytes 21010-47021&#x2F;47022</td></tr><tr><td>Content-Type</td><td>返回内容的MIME类型</td><td>Content-Type: text&#x2F;html; charset&#x3D;utf-8</td></tr><tr><td>Date</td><td>原始服务器消息发出的时间</td><td>Date: Tue, 15 Nov 2010 08:12:31 GMT</td></tr><tr><td>ETag</td><td>请求变量的实体标签的当前值</td><td>ETag: “737060cd8c284d8af7ad3082f209582d”</td></tr><tr><td>Expires</td><td>响应过期的日期和时间</td><td>Expires: Thu, 01 Dec 2010 16:00:00 GMT</td></tr><tr><td>Last-Modified</td><td>请求资源的最后修改时间</td><td>Last-Modified: Tue, 15 Nov 2010 12:45:26 GMT</td></tr><tr><td>Location</td><td>用来重定向接收方到非请求URL的位置来完成请求或标识新的资源</td><td>Location: <a target="_blank" rel="noopener" href="http://www.zcmhi.com/archives/94.html">http://www.zcmhi.com/archives/94.html</a></td></tr><tr><td>Pragma</td><td>包括实现特定的指令，它可应用到响应链上的任何接收方</td><td>Pragma: no-cache</td></tr><tr><td>Proxy-Authenticate</td><td>它指出认证方案和可应用到代理的该URL上的参数</td><td>Proxy-Authenticate: Basic</td></tr><tr><td>refresh</td><td>应用于重定向或一个新的资源被创造，在5秒之后重定向（由网景提出，被大部分浏览器支持）</td><td>Refresh: 5; url&#x3D;<a target="_blank" rel="noopener" href="http://www.zcmhi.com/archives/94.html">http://www.zcmhi.com/archives/94.html</a></td></tr><tr><td>Retry-After</td><td>如果实体暂时不可取，通知客户端在指定时间之后再次尝试</td><td>Retry-After: 120</td></tr><tr><td>Server</td><td>web服务器软件名称</td><td>Server: Apache&#x2F;1.3.27 (Unix) (Red-Hat&#x2F;Linux)</td></tr><tr><td>Set-Cookie</td><td>设置Http Cookie</td><td>Set-Cookie: UserID&#x3D;JohnDoe; Max-Age&#x3D;3600; Version&#x3D;1</td></tr><tr><td>Trailer</td><td>指出头域在分块传输编码的尾部存在</td><td>Trailer: Max-Forwards</td></tr><tr><td>Transfer-Encoding</td><td>文件传输编码</td><td>Transfer-Encoding:chunked</td></tr><tr><td>Vary</td><td>告诉下游代理是使用缓存响应还是从原始服务器请求</td><td>Vary: *</td></tr><tr><td>Via</td><td>告知代理客户端响应是通过哪里发送的</td><td>Via: 1.0 fred, 1.1 nowhere.com (Apache&#x2F;1.1)</td></tr><tr><td>Warning</td><td>警告实体可能存在的问题</td><td>Warning: 199 Miscellaneous warning</td></tr><tr><td>WWW-Authenticate</td><td>表明客户端请求实体应该使用的授权方案</td><td>WWW-Authenticate: Basic</td></tr></tbody></table><h3 id="2-2-http状态码记录"><a href="#2-2-http状态码记录" class="headerlink" title="2.2. http状态码记录"></a>2.2. <span id="statusCode">http状态码记录</span></h3><h4 id="1xx-消息"><a href="#1xx-消息" class="headerlink" title="1xx 消息"></a>1xx 消息</h4><p>这一类型的状态码，代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束。由于 HTTP&#x2F;1.0 协议中没有定义任何 1xx 状态码，所以除非在某些试验条件下，服务器禁止向此类客户端发送 1xx 响应。</p><h5 id="100-Continue"><a href="#100-Continue" class="headerlink" title="100 Continue"></a>100 Continue</h5><p>客户端应当继续发送请求。这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应。</p><h5 id="101-Switching-Protocols"><a href="#101-Switching-Protocols" class="headerlink" title="101 Switching Protocols"></a>101 Switching Protocols</h5><p>服务器已经理解了客户端的请求，并将通过Upgrade 消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到在Upgrade 消息头中定义的那些协议。</p><p>只有在切换新的协议更有好处的时候才应该采取类似措施。例如，切换到新的HTTP 版本比旧版本更有优势，或者切换到一个实时且同步的协议以传送利用此类特性的资源。</p><h5 id="102-Processing"><a href="#102-Processing" class="headerlink" title="102 Processing"></a>102 Processing</h5><p>由WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行。</p><h4 id="2xx-成功"><a href="#2xx-成功" class="headerlink" title="2xx 成功"></a>2xx 成功</h4><p>这一类型的状态码，代表请求已成功被服务器接收、理解、并接受。</p><h5 id="200-OK"><a href="#200-OK" class="headerlink" title="200 OK"></a>200 OK</h5><p>请求已成功，请求所希望的响应头或数据体将随此响应返回。出现此状态码是表示正常状态。</p><h5 id="201-Created"><a href="#201-Created" class="headerlink" title="201 Created"></a>201 Created</h5><p>请求已经被实现，而且有一个新的资源已经依据请求的需要而建立，且其 URI 已经随Location 头信息返回。假如需要的资源无法及时建立的话，应当返回 ‘202 Accepted’。</p><h5 id="202-Accepted"><a href="#202-Accepted" class="headerlink" title="202 Accepted"></a>202 Accepted</h5><p>服务器已接受请求，但尚未处理。正如它可能被拒绝一样，最终该请求可能会也可能不会被执行。在异步操作的场合下，没有比发送这个状态码更方便的做法了。</p><p>返回202状态码的响应的目的是允许服务器接受其他过程的请求（例如某个每天只执行一次的基于批处理的操作），而不必让客户端一直保持与服务器的连接直到批处理操作全部完成。在接受请求处理并返回202状态码的响应应当在返回的实体中包含一些指示处理当前状态的信息，以及指向处理状态监视器或状态预测的指针，以便用户能够估计操作是否已经完成。</p><h5 id="203-Non-Authoritative-Information"><a href="#203-Non-Authoritative-Information" class="headerlink" title="203 Non-Authoritative Information"></a>203 Non-Authoritative Information</h5><p>服务器已成功处理了请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝。当前的信息可能是原始版本的子集或者超集。例如，包含资源的元数据可能导致原始服务器知道元信息的超集。使用此状态码不是必须的，而且只有在响应不使用此状态码便会返回200 OK的情况下才是合适的。</p><h5 id="204-No-Content"><a href="#204-No-Content" class="headerlink" title="204 No Content"></a>204 No Content</h5><p>服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。响应可能通过实体头部的形式，返回新的或更新后的元信息。如果存在这些头部信息，则应当与所请求的变量相呼应。</p><p>如果客户端是浏览器的话，那么用户浏览器应保留发送了该请求的页面，而不产生任何文档视图上的变化，即使按照规范新的或更新后的元信息应当被应用到用户浏览器活动视图中的文档。</p><p>由于204响应被禁止包含任何消息体，因此它始终以消息头后的第一个空行结尾。</p><h5 id="205-Reset-Content"><a href="#205-Reset-Content" class="headerlink" title="205 Reset Content"></a>205 Reset Content</h5><p>服务器成功处理了请求，且没有返回任何内容。但是与204响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松地开始另一次输入。</p><p>与204响应一样，该响应也被禁止包含任何消息体，且以消息头后的第一个空行结束。</p><h5 id="206-Partial-Content"><a href="#206-Partial-Content" class="headerlink" title="206 Partial Content"></a>206 Partial Content</h5><p>服务器已经成功处理了部分 GET 请求。类似于 FlashGet 或者迅雷这类的 HTTP下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。</p><p>该请求必须包含 Range 头信息来指示客户端希望得到的内容范围，并且可能包含 If-Range 来作为请求条件。</p><p>响应必须包含如下的头部域：</p><ul><li>Content-Range 用以指示本次响应中返回的内容的范围；如果是 Content-Type 为 multipart&#x2F;byteranges 的多段下载，则每一 multipart 段中都应包含 Content-Range 域用以指示本段的内容范围。假如响应中包含 Content-Length，那么它的数值必须匹配它返回的内容范围的真实字节数。</li><li>Date</li><li>ETag 和&#x2F;或 Content-Location，假如同样的请求本应该返回200响应。</li><li>Expires, Cache-Control，和&#x2F;或 Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。<br>假如本响应请求使用了 If-Range 强缓存验证，那么本次响应不应该包含其他实体头；假如本响应的请求使用了 If-Range 弱缓存验证，那么本次响应禁止包含其他实体头；这避免了缓存的实体内容和更新了的实体头信息之间的不一致。否则，本响应就应当包含所有本应该返回200响应中应当返回的所有实体头部域。</li></ul><p>假如 ETag 或 Last-Modified 头部不能精确匹配的话，则客户端缓存应禁止将206响应返回的内容与之前任何缓存过的内容组合在一起。</p><h5 id="207-Multi-Status"><a href="#207-Multi-Status" class="headerlink" title="207 Multi-Status"></a>207 Multi-Status</h5><p>由WebDAV(RFC 2518)扩展的状态码，代表之后的消息体将是一个XML消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。</p><h4 id="3xx-重定向"><a href="#3xx-重定向" class="headerlink" title="3xx 重定向"></a>3xx 重定向</h4><p>这类状态码代表需要客户端采取进一步的操作才能完成请求。通常，这些状态码用来重定向，后续的请求地址（重定向目标）在本次响应的 Location 域中指明。</p><p>当且仅当后续的请求所使用的方法是 GET 或者 HEAD 时，用户浏览器才可以在没有用户介入的情况下自动提交所需要的后续请求。客户端应当自动监测无限循环重定向（例如：A-&gt;A，或者A-&gt;B-&gt;C-&gt;A），因为这会导致服务器和客户端大量不必要的资源消耗。按照 HTTP&#x2F;1.0 版规范的建议，浏览器不应自动访问超过5次的重定向。</p><h5 id="300-Multiple-Choices"><a href="#300-Multiple-Choices" class="headerlink" title="300 Multiple Choices"></a>300 Multiple Choices</h5><p>被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。</p><p>除非这是一个 HEAD 请求，否则该响应应当包括一个资源特性及地址的列表的实体，以便用户或浏览器从中选择最合适的重定向地址。这个实体的格式由 Content-Type 定义的格式所决定。浏览器可能根据响应的格式以及浏览器自身能力，自动作出最合适的选择。当然，RFC 2616规范并没有规定这样的自动选择该如何进行。</p><p>如果服务器本身已经有了首选的回馈选择，那么在 Location 中应当指明这个回馈的 URI；浏览器可能会将这个 Location 值作为自动重定向的地址。此外，除非额外指定，否则这个响应也是可缓存的。</p><h5 id="301-Moved-Permanently"><a href="#301-Moved-Permanently" class="headerlink" title="301 Moved Permanently"></a>301 Moved Permanently</h5><p>被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。</p><p>新的永久性的URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。</p><p>如果这不是一个 GET 或者 HEAD 请求，因此浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。</p><p>注意：对于某些使用 HTTP&#x2F;1.0 协议的浏览器，当它们发送的 POST 请求得到了一个301响应的话，接下来的重定向请求将会变成 GET 方式。</p><h5 id="302-Move-temporarily"><a href="#302-Move-temporarily" class="headerlink" title="302 Move temporarily"></a>302 Move temporarily</h5><p>请求的资源临时从不同的 URI响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。<br>上文有提及。</p><p>如果这不是一个 GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。</p><p>注意：虽然RFC 1945和RFC 2068规范不允许客户端在重定向时改变请求的方法，但是很多现存的浏览器将302响应视作为303响应，并且使用 GET 方式访问在 Location 中规定的 URI，而无视原先请求的方法。状态码303和307被添加了进来，用以明确服务器期待客户端进行何种反应。</p><h5 id="303-See-Other"><a href="#303-See-Other" class="headerlink" title="303 See Other"></a>303 See Other</h5><p>对应当前请求的响应可以在另一个 URL 上被找到，而且客户端应当采用 GET 的方式访问那个资源。这个方法的存在主要是为了允许由脚本激活的POST请求输出重定向到一个新的资源。这个新的 URI 不是原始资源的替代引用。同时，303响应禁止被缓存。当然，第二个请求（重定向）可能被缓存。</p><p>注意：许多 HTTP&#x2F;1.1 版以前的浏览器不能正确理解303状态。如果需要考虑与这些浏览器之间的互动，302状态码应该可以胜任，因为大多数的浏览器处理302响应时的方式恰恰就是上述规范要求客户端处理303响应时应当做的。</p><h5 id="304-Not-Modified"><a href="#304-Not-Modified" class="headerlink" title="304 Not Modified"></a>304 Not Modified</h5><p>如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。</p><p>该响应必须包含以下的头信息：</p><ul><li>Date，除非这个服务器没有时钟。假如没有时钟的服务器也遵守这些规则，那么代理服务器以及客户端可以自行将 Date 字段添加到接收到的响应头中去（正如RFC 2068中规定的一样），缓存机制将会正常工作。</li><li>ETag 和&#x2F;或 Content-Location，假如同样的请求本应返回200响应。</li><li>Expires, Cache-Control，和&#x2F;或Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。<br>假如本响应请求使用了强缓存验证，那么本次响应不应该包含其他实体头；否则（例如，某个带条件的 GET 请求使用了弱缓存验证），本次响应禁止包含其他实体头；这避免了缓存了的实体内容和更新了的实体头信息之间的不一致。</li></ul><p>假如某个304响应指明了当前某个实体没有缓存，那么缓存系统必须忽视这个响应，并且重复发送不包含限制条件的请求。</p><p>假如接收到一个要求更新某个缓存条目的304响应，那么缓存系统必须更新整个条目以反映所有在响应中被更新的字段的值。</p><h5 id="305-Use-Proxy"><a href="#305-Use-Proxy" class="headerlink" title="305 Use Proxy"></a>305 Use Proxy</h5><p>被请求的资源必须通过指定的代理才能被访问。Location 域中将给出指定的代理所在的 URI 信息，接收者需要重复发送一个单独的请求，通过这个代理才能访问相应资源。只有原始服务器才能建立305响应。</p><p>注意：RFC 2068中没有明确305响应是为了重定向一个单独的请求，而且只能被原始服务器建立。忽视这些限制可能导致严重的安全后果。</p><h5 id="306-Switch-Proxy"><a href="#306-Switch-Proxy" class="headerlink" title="306 Switch Proxy"></a>306 Switch Proxy</h5><p>在最新版的规范中，306状态码已经不再被使用。</p><h5 id="307-Temporary-Redirect"><a href="#307-Temporary-Redirect" class="headerlink" title="307 Temporary Redirect"></a>307 Temporary Redirect</h5><p>请求的资源临时从不同的URI 响应请求。</p><p>新的临时性的URI 应当在响应的 Location 域中返回。除非这是一个HEAD 请求，否则响应的实体中应当包含指向新的URI 的超链接及简短说明。因为部分浏览器不能识别307响应，因此需要添加上述必要信息以便用户能够理解并向新的 URI 发出访问请求。</p><p>如果这不是一个GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。</p><h4 id="4xx-请求错误"><a href="#4xx-请求错误" class="headerlink" title="4xx 请求错误"></a>4xx 请求错误</h4><p>这类的状态码代表了客户端看起来可能发生了错误，妨碍了服务器的处理。除非响应的是一个 HEAD 请求，否则服务器就应该返回一个解释当前错误状况的实体，以及这是临时的还是永久性的状况。这些状态码适用于任何请求方法。浏览器应当向用户显示任何包含在此类错误响应中的实体内容。</p><p>如果错误发生时客户端正在传送数据，那么使用TCP的服务器实现应当仔细确保在关闭客户端与服务器之间的连接之前，客户端已经收到了包含错误信息的数据包。如果客户端在收到错误信息后继续向服务器发送数据，服务器的TCP栈将向客户端发送一个重置数据包，以清除该客户端所有还未识别的输入缓冲，以免这些数据被服务器上的应用程序读取并干扰后者。</p><h5 id="400-Bad-Request"><a href="#400-Bad-Request" class="headerlink" title="400 Bad Request"></a>400 Bad Request</h5><ol><li>语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。</li><li>请求参数有误。</li></ol><h5 id="401-Unauthorized"><a href="#401-Unauthorized" class="headerlink" title="401 Unauthorized"></a>401 Unauthorized</h5><p>当前请求需要用户验证。该响应必须包含一个适用于被请求资源的 WWW-Authenticate 信息头用以询问用户信息。客户端可以重复提交一个包含恰当的 Authorization 头信息的请求。如果当前请求已经包含了 Authorization 证书，那么401响应代表着服务器验证已经拒绝了那些证书。如果401响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。参见RFC 2617。</p><h5 id="402-Payment-Required"><a href="#402-Payment-Required" class="headerlink" title="402 Payment Required"></a>402 Payment Required</h5><p>该状态码是为了将来可能的需求而预留的。</p><h5 id="403-Forbidden"><a href="#403-Forbidden" class="headerlink" title="403 Forbidden"></a>403 Forbidden</h5><p>服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个 HEAD 请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个404响应，假如它不希望让客户端获得任何信息。</p><h5 id="404-Not-Found"><a href="#404-Not-Found" class="headerlink" title="404 Not Found"></a>404 Not Found</h5><p>请求失败，请求所希望得到的资源未被在服务器上发现。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。出现这个错误的最有可能的原因是服务器端没有这个页面。</p><h5 id="405-Method-Not-Allowed"><a href="#405-Method-Not-Allowed" class="headerlink" title="405 Method Not Allowed"></a>405 Method Not Allowed</h5><p>请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个Allow 头信息用以表示出当前资源能够接受的请求方法的列表。</p><p>鉴于 PUT，DELETE 方法会对服务器上的资源进行写操作，因而绝大部分的网页服务器都不支持或者在默认配置下不允许上述请求方法，对于此类请求均会返回405错误。</p><h5 id="406-Not-Acceptable"><a href="#406-Not-Acceptable" class="headerlink" title="406 Not Acceptable"></a>406 Not Acceptable</h5><p>请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体。</p><p>除非这是一个 HEAD 请求，否则该响应就应当返回一个包含可以让用户或者浏览器从中选择最合适的实体特性以及地址列表的实体。实体的格式由 Content-Type 头中定义的媒体类型决定。浏览器可以根据格式及自身能力自行作出最佳选择。但是，规范中并没有定义任何作出此类自动选择的标准。</p><h5 id="407-Proxy-Authentication-Required"><a href="#407-Proxy-Authentication-Required" class="headerlink" title="407 Proxy Authentication Required"></a>407 Proxy Authentication Required</h5><p>与401响应类似，只不过客户端必须在代理服务器上进行身份验证。代理服务器必须返回一个 Proxy-Authenticate 用以进行身份询问。客户端可以返回一个 Proxy-Authorization 信息头用以验证。参见RFC 2617。</p><h5 id="408-Request-Timeout"><a href="#408-Request-Timeout" class="headerlink" title="408 Request Timeout"></a>408 Request Timeout</h5><p>请求超时。客户端没有在服务器预备等待的时间内完成一个请求的发送。客户端可以随时再次提交这一请求而无需进行任何更改。</p><h5 id="409-Conflict"><a href="#409-Conflict" class="headerlink" title="409 Conflict"></a>409 Conflict</h5><p>由于和被请求的资源的当前状态之间存在冲突，请求无法完成。这个代码只允许用在这样的情况下才能被使用：用户被认为能够解决冲突，并且会重新提交新的请求。该响应应当包含足够的信息以便用户发现冲突的源头。</p><p>冲突通常发生于对 PUT 请求的处理中。例如，在采用版本检查的环境下，某次 PUT 提交的对特定资源的修改请求所附带的版本信息与之前的某个（第三方）请求向冲突，那么此时服务器就应该返回一个409错误，告知用户请求无法完成。此时，响应实体中很可能会包含两个冲突版本之间的差异比较，以便用户重新提交归并以后的新版本。</p><h5 id="410-Gone"><a href="#410-Gone" class="headerlink" title="410 Gone"></a>410 Gone</h5><p>被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址。这样的状况应当被认为是永久性的。如果可能，拥有链接编辑功能的客户端应当在获得用户许可后删除所有指向这个地址的引用。如果服务器不知道或者无法确定这个状况是否是永久的，那么就应该使用404状态码。除非额外说明，否则这个响应是可缓存的。</p><p>410响应的目的主要是帮助网站管理员维护网站，通知用户该资源已经不再可用，并且服务器拥有者希望所有指向这个资源的远端连接也被删除。这类事件在限时、增值服务中很普遍。同样，410响应也被用于通知客户端在当前服务器站点上，原本属于某个个人的资源已经不再可用。当然，是否需要把所有永久不可用的资源标记为’410 Gone’，以及是否需要保持此标记多长时间，完全取决于服务器拥有者。</p><h5 id="411-Length-Required"><a href="#411-Length-Required" class="headerlink" title="411 Length Required"></a>411 Length Required</h5><p>服务器拒绝在没有定义 Content-Length 头的情况下接受请求。在添加了表明请求消息体长度的有效 Content-Length 头之后，客户端可以再次提交该请求。</p><h5 id="412-Precondition-Failed"><a href="#412-Precondition-Failed" class="headerlink" title="412 Precondition Failed"></a>412 Precondition Failed</h5><p>服务器在验证在请求的头字段中给出先决条件时，没能满足其中的一个或多个。这个状态码允许客户端在获取资源时在请求的元信息（请求头字段数据）中设置先决条件，以此避免该请求方法被应用到其希望的内容以外的资源上。</p><h5 id="413-Request-Entity-Too-Large"><a href="#413-Request-Entity-Too-Large" class="headerlink" title="413 Request Entity Too Large"></a>413 Request Entity Too Large</h5><p>服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。此种情况下，服务器可以关闭连接以免客户端继续发送此请求。</p><p>如果这个状况是临时的，服务器应当返回一个 Retry-After 的响应头，以告知客户端可以在多少时间以后重新尝试。</p><h5 id="414-Request-URI-Too-Long"><a href="#414-Request-URI-Too-Long" class="headerlink" title="414 Request-URI Too Long"></a>414 Request-URI Too Long</h5><p>请求的URI 长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。这比较少见，通常的情况包括：</p><p>本应使用POST方法的表单提交变成了GET方法，导致查询字符串（Query String）过长。</p><p>重定向URI “黑洞”，例如每次重定向把旧的 URI 作为新的 URI 的一部分，导致在若干次重定向后 URI 超长。</p><p>客户端正在尝试利用某些服务器中存在的安全漏洞攻击服务器。这类服务器使用固定长度的缓冲读取或操作请求的 URI，当 GET 后的参数超过某个数值后，可能会产生缓冲区溢出，导致任意代码被执行[1]。没有此类漏洞的服务器，应当返回414状态码。</p><h5 id="415-Unsupported-Media-Type"><a href="#415-Unsupported-Media-Type" class="headerlink" title="415 Unsupported Media Type"></a>415 Unsupported Media Type</h5><p>对于当前请求的方法和所请求的资源，请求中提交的实体并不是服务器中所支持的格式，因此请求被拒绝。</p><h5 id="416-Requested-Range-Not-Satisfiable"><a href="#416-Requested-Range-Not-Satisfiable" class="headerlink" title="416 Requested Range Not Satisfiable"></a>416 Requested Range Not Satisfiable</h5><p>如果请求中包含了 Range 请求头，并且 Range 中指定的任何数据范围都与当前资源的可用范围不重合，同时请求中又没有定义 If-Range 请求头，那么服务器就应当返回416状态码。</p><p>假如 Range 使用的是字节范围，那么这种情况就是指请求指定的所有数据范围的首字节位置都超过了当前资源的长度。服务器也应当在返回416状态码的同时，包含一个 Content-Range 实体头，用以指明当前资源的长度。这个响应也被禁止使用 multipart&#x2F;byteranges 作为其 Content-Type。</p><h5 id="417-Expectation-Failed"><a href="#417-Expectation-Failed" class="headerlink" title="417 Expectation Failed"></a>417 Expectation Failed</h5><p>在请求头 Expect 中指定的预期内容无法被服务器满足，或者这个服务器是一个代理服务器，它有明显的证据证明在当前路由的下一个节点上，Expect 的内容无法被满足。</p><h5 id="418-I’m-a-teapot"><a href="#418-I’m-a-teapot" class="headerlink" title="418 I’m a teapot"></a>418 I’m a teapot</h5><h5 id="421-too-many-connections"><a href="#421-too-many-connections" class="headerlink" title="421 too many connections"></a>421 too many connections</h5><p>There are too many connections from your internet address</p><p>从当前客户端所在的IP地址到服务器的连接数超过了服务器许可的最大范围。通常，这里的IP地址指的是从服务器上看到的客户端地址（比如用户的网关或者代理服务器地址）。在这种情况下，连接数的计算可能涉及到不止一个终端用户。</p><h5 id="422-Unprocessable-Entity"><a href="#422-Unprocessable-Entity" class="headerlink" title="422 Unprocessable Entity"></a>422 Unprocessable Entity</h5><p>请求格式正确，但是由于含有语义错误，无法响应。（RFC 4918 WebDAV）</p><h5 id="423-Locked"><a href="#423-Locked" class="headerlink" title="423 Locked"></a>423 Locked</h5><p>当前资源被锁定。（RFC 4918 WebDAV）</p><h5 id="424-Failed-Dependency"><a href="#424-Failed-Dependency" class="headerlink" title="424 Failed Dependency"></a>424 Failed Dependency</h5><p>由于之前的某个请求发生的错误，导致当前请求失败，例如 PROPPATCH。（RFC 4918 WebDAV）</p><h5 id="425-Unordered-Collection"><a href="#425-Unordered-Collection" class="headerlink" title="425 Unordered Collection"></a>425 Unordered Collection</h5><p>在WebDav Advanced Collections 草案中定义，但是未出现在《WebDAV 顺序集协议》（RFC 3658）中。</p><h5 id="426-Upgrade-Required"><a href="#426-Upgrade-Required" class="headerlink" title="426 Upgrade Required"></a>426 Upgrade Required</h5><p>客户端应当切换到TLS&#x2F;1.0。（RFC 2817）</p><h5 id="449-Retry-With"><a href="#449-Retry-With" class="headerlink" title="449 Retry With"></a>449 Retry With</h5><p>由微软扩展，代表请求应当在执行完适当的操作后进行重试。</p><h5 id="451-Unavailable-For-Legal-Reasons"><a href="#451-Unavailable-For-Legal-Reasons" class="headerlink" title="451 Unavailable For Legal Reasons"></a>451 Unavailable For Legal Reasons</h5><p>该请求因法律原因不可用。（RFC 7725）</p><h4 id="5xx、6xx-服务器错误"><a href="#5xx、6xx-服务器错误" class="headerlink" title="5xx、6xx 服务器错误"></a>5xx、6xx 服务器错误</h4><p>这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。除非这是一个HEAD 请求，否则服务器应当包含一个解释当前错误状态以及这个状况是临时的还是永久的解释信息实体。浏览器应当向用户展示任何在当前响应中被包含的实体。</p><p>这些状态码适用于任何响应方法。</p><h5 id="500-Internal-Server-Error"><a href="#500-Internal-Server-Error" class="headerlink" title="500 Internal Server Error"></a>500 Internal Server Error</h5><p>服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器端的源代码出现错误时出现。</p><h5 id="501-Not-Implemented"><a href="#501-Not-Implemented" class="headerlink" title="501 Not Implemented"></a>501 Not Implemented</h5><p>服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。</p><h5 id="502-Bad-Gateway"><a href="#502-Bad-Gateway" class="headerlink" title="502 Bad Gateway"></a>502 Bad Gateway</h5><p>作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。</p><h5 id="503-Service-Unavailable"><a href="#503-Service-Unavailable" class="headerlink" title="503 Service Unavailable"></a>503 Service Unavailable</h5><p>由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复。如果能够预计延迟时间，那么响应中可以包含一个 Retry-After 头用以标明这个延迟时间。如果没有给出这个 Retry-After 信息，那么客户端应当以处理500响应的方式处理它。</p><p>注意：503状态码的存在并不意味着服务器在过载的时候必须使用它。某些服务器只不过是希望拒绝客户端的连接。</p><h5 id="504-Gateway-Timeout"><a href="#504-Gateway-Timeout" class="headerlink" title="504 Gateway Timeout"></a>504 Gateway Timeout</h5><p>作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。<br>注意：某些代理服务器在DNS查询超时时会返回400或者500错误</p><h5 id="505-HTTP-Version-Not-Supported"><a href="#505-HTTP-Version-Not-Supported" class="headerlink" title="505 HTTP Version Not Supported"></a>505 HTTP Version Not Supported</h5><p>服务器不支持，或者拒绝支持在请求中使用的 HTTP 版本。这暗示着服务器不能或不愿使用与客户端相同的版本。响应中应当包含一个描述了为何版本不被支持以及服务器支持哪些协议的实体。</p><h5 id="506-Variant-Also-Negotiates"><a href="#506-Variant-Also-Negotiates" class="headerlink" title="506 Variant Also Negotiates"></a>506 Variant Also Negotiates</h5><p>由《透明内容协商协议》（RFC 2295）扩展，代表服务器存在内部配置错误：被请求的协商变元资源被配置为在透明内容协商中使用自己，因此在一个协商处理中不是一个合适的重点。</p><h5 id="507-Insufficient-Storage"><a href="#507-Insufficient-Storage" class="headerlink" title="507 Insufficient Storage"></a>507 Insufficient Storage</h5><p>服务器无法存储完成请求所必须的内容。这个状况被认为是临时的。WebDAV (RFC 4918)</p><h5 id="509-Bandwidth-Limit-Exceeded"><a href="#509-Bandwidth-Limit-Exceeded" class="headerlink" title="509 Bandwidth Limit Exceeded"></a>509 Bandwidth Limit Exceeded</h5><p>服务器达到带宽限制。这不是一个官方的状态码，但是仍被广泛使用。</p><h5 id="510-Not-Extended"><a href="#510-Not-Extended" class="headerlink" title="510 Not Extended"></a>510 Not Extended</h5><p>获取资源所需要的策略并没有被满足。（RFC 2774）</p><h5 id="600-Unparseable-Response-Headers"><a href="#600-Unparseable-Response-Headers" class="headerlink" title="600 Unparseable Response Headers"></a>600 Unparseable Response Headers</h5><p>源站没有返回响应头部，只返回实体内容。</p><h2 id="3-DNS"><a href="#3-DNS" class="headerlink" title="3. DNS"></a>3. DNS</h2><h3 id="3-1-不同系统处理dns响应和首选备选的区别"><a href="#3-1-不同系统处理dns响应和首选备选的区别" class="headerlink" title="3.1. 不同系统处理dns响应和首选备选的区别"></a>3.1. 不同系统处理dns响应和首选备选的区别</h3><h4 id="dns响应的理解"><a href="#dns响应的理解" class="headerlink" title="dns响应的理解"></a>dns响应的理解</h4><ul><li>空结果代表存在此dns的SOA记录，但是此域名没有请求的类型，系统会认为此域名没有这个类型，不会使用备选dns</li><li>no such name代表dns上不存在此域名的记录，系统会认为此域名没有配置，不会使用备选dns</li><li>server failure代表dns服务器出错，会立即使用备选dns</li></ul><h4 id="1-linux"><a href="#1-linux" class="headerlink" title="1) linux"></a>1) linux</h4><ul><li>ping会同时请求A记录和AAAA记录</li><li>nslookup会先A记录再AAAA记录，如果A不通不会请求AAAA</li><li>浏览器请求了A记录，根据当前网卡来</li><li>本地没有dns时，请求127地址</li><li>首选不通，超时5s请求备选</li></ul><h4 id="2-windows"><a href="#2-windows" class="headerlink" title="2) windows"></a>2) windows</h4><ul><li>基本同上，但是超时时间为1s</li></ul><h3 id="3-2-tcp和udp"><a href="#3-2-tcp和udp" class="headerlink" title="3.2. tcp和udp"></a>3.2. tcp和udp</h3><ul><li>tcpdns和udpdns相比在前两个字节多了一个长度（单位字节，不带长度所占的两个字节的大小），也就是dns请求和响应包最大不超过65535</li><li>udp的dns如果超过512字节，就会使用tcp传输</li></ul><h3 id="3-3-SOA和NS"><a href="#3-3-SOA和NS" class="headerlink" title="3.3. SOA和NS"></a>3.3. SOA和NS</h3><p>参考 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/bighammerdata/p/12776830.html">SOA记录和NS记录的通俗解释</a></p><p>DNS服务器里有两个比较重要的记录。一个叫SOA记录（起始授权机构） 一个叫NS（Name Server）记录（域名服务器）关于这两个记录，很多文章都有解释，但是很多人还是很糊涂。我现在通俗的解释一下这两个记录是干什么的。如果理解有错误，欢迎高手来指正。<br>SOA记录表明了DNS服务器之间的关系。SOA记录表明了谁是这个区域的所有者。比如51CTO.COM这个区域。一个DNS服务器安装后，需要创建一个区域，以后这个区域的查询解析，都是通过DNS服务器来完成的。现在来说一下所有者，我这里所说的所有者，就是谁对这个区域有修改权利。常见的DNS服务器只能创建一个标准区域，然后可以创建很多个辅助区域。标准区域是可以读写修改的。而辅助区域只能通过标准区域复制来完成，不能在辅助区域中进行修改。而创建标准区域的DNS就会有SOA记录，或者准确说SOA记录中的主机地址一定是这个标准区域的服务器IP地址。</p><p>如果是两台集成了DNS的DC，实际上由于要求DNS区域可写，所以打破了单纯DNS服务器只能有一个标准区域的限制。所以两台DC都有SOA记录指向自己。</p><p>NS记录实际上也是在DNS服务器之间，表明谁对某个区域有解释权，即权威DNS。大家都知道电信和网通都有很多的DNS服务器。这些服务器为我们上公网做域名解析提供了很多方便。但是这些DNS服务器有一个有意思的地方是这些DNS不存放任何区域，看上去更像是一个DNS CLIENT，它们被称为唯缓存DNS服务器。它们会缓存大量的解析地址，这样就会让你解析的时候选择它们会觉得很快。它们在查询的时候就会查询NS记录，通过这个记录就知道谁在负责比如51CTO.COM这个地域的管理工作。还有一种情况来说明NS记录的作用。比如你先在万网申请了一个域名ABC.COM。一般情况是万网的域名服务器替你来解析如WWW.ABC.COM这样的主机记录。如果你想自己架设一个DNS服务器，让这台服务器从今往后替代万网的DNS服务器解析，那么你就需要在你的DNS上设置NS记录，然后将万网域名管理系统中的NS记录改成你的DNSIP。这样以后就是你自己的DNS服务器负责提供解析了。即使万网的DNS服务器出现故障，别人仍然可以找到你。</p><p>另外值得一说的是，相对你DNS的CLIENT，你设置的DNS服务器地址就是你的权威DNS。通过NSLOOKUP工具可以看到。而那个非权威应答，恰恰是那个区域真正的NS。</p><h1 id="七、网络设备"><a href="#七、网络设备" class="headerlink" title="七、网络设备"></a>七、网络设备</h1><table><thead><tr><th>名称</th><th>工作层</th><th>作用</th><th>备注</th></tr></thead><tbody><tr><td>中继器</td><td>物理层</td><td>将一个网络信号放大发送</td><td></td></tr><tr><td>集线器</td><td>物理层</td><td>将一个端口的网络信号放大发送到其他端口</td><td>多端口中继器</td></tr><tr><td>网桥</td><td>数据链路层</td><td>将一个端口的数据发送给另一个端口，需要mac地址对应</td><td></td></tr><tr><td>交换机</td><td>数据链路层</td><td>学习端口mac地址，将一个端口的数据查询mac地址发送给对应端口</td><td>相当于多个网桥</td></tr><tr><td>路由器</td><td>网络层</td><td>根据目的ip和路由规则决定转发到哪个端口</td><td></td></tr><tr><td>网关</td><td>网络层&#x2F;应用层</td><td>连接两个不同的网络区域</td><td>网关只是概念<br>路由器和三层交换机都可以算作网关</td></tr></tbody></table><ul><li>工作在网络层及以上的设备有自己的mac地址，所以目的mac地址是此设备才能到，设备发出去的包源mac一般为自己</li></ul><h2 id="1-家用路由器和计算机网络中的路由器的区分"><a href="#1-家用路由器和计算机网络中的路由器的区分" class="headerlink" title="1. 家用路由器和计算机网络中的路由器的区分"></a>1. 家用路由器和计算机网络中的路由器的区分</h2><ul><li>家用路由器可以算作pppoe拨号客户端 + DHCP服务器 + NAT转换 + DNS代理，有路由的功能</li><li>计算机网络中的路由器仅是路由这个功能，主要是根据路由表进行ip数据包转发</li></ul><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="1-局域网和外网？"><a href="#1-局域网和外网？" class="headerlink" title="1. 局域网和外网？"></a>1. 局域网和外网？</h2><h3 id="一个局域网内共用一个外网ip，数据如何定位到自己的电脑上的？"><a href="#一个局域网内共用一个外网ip，数据如何定位到自己的电脑上的？" class="headerlink" title="一个局域网内共用一个外网ip，数据如何定位到自己的电脑上的？"></a>一个局域网内共用一个外网ip，数据如何定位到自己的电脑上的？</h3><ul><li>通过端口定位</li><li>电脑通过路由器连接到外网时，会在路由器上映射一个nat表，nat运行在传输层，因为要解析端口</li><li>表中映射为<code>ip:port</code>，会将路由器上随机生成一个端口，并且将局域网ip加端口和外网ip加端口相互映射。</li><li>本地电脑通过这个映射表连上外网</li></ul><p>如:</p><ul><li>路由器外网ip: 115.156.207.252</li><li>电脑的局域网ip: 192.168.11.109</li></ul><p>电脑连外网时，通过本机的<code>80</code>端口访问网页。路由器会随机生成一个端口号，比如<code>1234</code>。路由器的nat映射表就会有一条记录：<code>115.156.207.252:1234 &lt;-&gt; 192.168.11.109:80</code>，外网的数据就通过返回到<code>115.156.207.252:1234</code>这个地址来给到电脑的<code>80</code>端口上。</p><h2 id="1-tun网卡和tap网卡区别"><a href="#1-tun网卡和tap网卡区别" class="headerlink" title="1. tun网卡和tap网卡区别"></a>1. tun网卡和tap网卡区别</h2><ul><li>tun网卡工作在第三层网络层，没有mac地址，不能跟物理网卡做桥转发</li><li>tap网卡工作在第二层数据链路层，有mac地址，可以跟物理网卡做桥转发</li></ul></div><div class="reward-container"><div></div><button onclick='var qr=document.getElementById("qr");qr.style.display="none"===qr.style.display?"block":"none"'>打赏</button><div id="qr" style="display:none"><div style="display:inline-block"><img src="/images/wechatpay.png" alt="王钰博 微信支付"><p>微信支付</p></div><div style="display:inline-block"><img src="/images/alipay.jpg" alt="王钰博 支付宝"><p>支付宝</p></div></div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/%E7%BD%91%E7%BB%9C/" rel="tag"># 网络</a></div><div class="post-nav"><div class="post-nav-item"><a href="/blogs/2018-09-19-DakaQukuailian/" rel="prev" title="区块链-达闼科技师兄分享"><i class="fa fa-chevron-left"></i> 区块链-达闼科技师兄分享</a></div><div class="post-nav-item"><a href="/blogs/2018-09-28-hexoStudy/" rel="next" title="hexo搭建中的学习笔记">hexo搭建中的学习笔记 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="valine-comments"></div><script>window.addEventListener("tabs:register",()=>{let{activeClass:t}=CONFIG.comments;if(CONFIG.comments.storage&&(t=localStorage.getItem("comments_active")||t),t){let e=document.querySelector(`a[href="#comment-${t}"]`);e&&e.click()}}),CONFIG.comments.storage&&window.addEventListener("tabs:click",t=>{if(!t.target.matches(".tabs-comment .tab-content .tab-pane"))return;let e=t.target.classList[1];localStorage.setItem("comments_active",e)})</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E7%BD%91%E7%BB%9COSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B"><span class="nav-text">一、网络OSI七层模型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E5%B1%82%E4%BB%8B%E7%BB%8D"><span class="nav-text">分层介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82"><span class="nav-text">应用层</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%A8%E7%A4%BA%E5%B1%82"><span class="nav-text">表示层</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%9A%E8%AF%9D%E5%B1%82"><span class="nav-text">会话层</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%A0%E8%BE%93%E5%B1%82"><span class="nav-text">传输层</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82"><span class="nav-text">网络层</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82"><span class="nav-text">数据链路层</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%A9%E7%90%86%E5%B1%82"><span class="nav-text">物理层</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%87%E6%B3%A8"><span class="nav-text">备注</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E7%89%A9%E7%90%86%E5%B1%82"><span class="nav-text">二、物理层</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82"><span class="nav-text">三、数据链路层</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E7%BD%91%E7%BB%9C%E5%B1%82"><span class="nav-text">四、网络层</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-ip%E5%9C%B0%E5%9D%80%E5%88%86%E7%B1%BB"><span class="nav-text">1. ip地址分类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-ip%E5%8C%85%E5%88%86%E6%9E%90"><span class="nav-text">2. ip包分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-ipv4%E5%8C%85"><span class="nav-text">2.1. ipv4包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-ipv6%E5%8C%85"><span class="nav-text">2.2. ipv6包</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E4%BC%A0%E8%BE%93%E5%B1%82"><span class="nav-text">五、传输层</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-TCP"><span class="nav-text">1. TCP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E5%BB%BA%E7%AB%8BTCP%E8%BF%9E%E6%8E%A5-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%8D%8F%E8%AE%AE"><span class="nav-text">1.1. 建立TCP连接: 三次握手协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E5%85%B3%E9%97%ADTCP%E8%BF%9E%E6%8E%A5-%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%8D%8F%E8%AE%AE"><span class="nav-text">1.2. 关闭TCP连接: 四次握手协议</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E9%97%AE%E9%A2%98"><span class="nav-text">1) 问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-tcp%E5%A4%B4%E9%83%A8%E5%88%86%E6%9E%90"><span class="nav-text">1.3. tcp头部分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-tcp%E6%A0%A1%E9%AA%8C%E5%92%8C%E7%9A%84%E8%AE%A1%E7%AE%97"><span class="nav-text">1.4. tcp校验和的计算</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-UDP"><span class="nav-text">2. UDP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-UDP%E5%A4%B4%E9%83%A8%E5%88%86%E6%9E%90"><span class="nav-text">2.1. UDP头部分析</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%AD%E3%80%81%E5%BA%94%E7%94%A8%E5%B1%82"><span class="nav-text">六、应用层</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-tls%E6%8F%A1%E6%89%8B%E6%B5%81%E7%A8%8B"><span class="nav-text">1. tls握手流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-http"><span class="nav-text">2. http</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-http-header"><span class="nav-text">2.1. http header</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-General%E9%83%A8%E5%88%86"><span class="nav-text">1) General部分</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Referrer-Policy-States"><span class="nav-text">Referrer Policy States</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-Requests%E9%83%A8%E5%88%86"><span class="nav-text">2) Requests部分</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-Responses-%E9%83%A8%E5%88%86"><span class="nav-text">3) Responses 部分</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-http%E7%8A%B6%E6%80%81%E7%A0%81%E8%AE%B0%E5%BD%95"><span class="nav-text">2.2. http状态码记录</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1xx-%E6%B6%88%E6%81%AF"><span class="nav-text">1xx 消息</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#100-Continue"><span class="nav-text">100 Continue</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#101-Switching-Protocols"><span class="nav-text">101 Switching Protocols</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#102-Processing"><span class="nav-text">102 Processing</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2xx-%E6%88%90%E5%8A%9F"><span class="nav-text">2xx 成功</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#200-OK"><span class="nav-text">200 OK</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#201-Created"><span class="nav-text">201 Created</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#202-Accepted"><span class="nav-text">202 Accepted</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#203-Non-Authoritative-Information"><span class="nav-text">203 Non-Authoritative Information</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#204-No-Content"><span class="nav-text">204 No Content</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#205-Reset-Content"><span class="nav-text">205 Reset Content</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#206-Partial-Content"><span class="nav-text">206 Partial Content</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#207-Multi-Status"><span class="nav-text">207 Multi-Status</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3xx-%E9%87%8D%E5%AE%9A%E5%90%91"><span class="nav-text">3xx 重定向</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#300-Multiple-Choices"><span class="nav-text">300 Multiple Choices</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#301-Moved-Permanently"><span class="nav-text">301 Moved Permanently</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#302-Move-temporarily"><span class="nav-text">302 Move temporarily</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#303-See-Other"><span class="nav-text">303 See Other</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#304-Not-Modified"><span class="nav-text">304 Not Modified</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#305-Use-Proxy"><span class="nav-text">305 Use Proxy</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#306-Switch-Proxy"><span class="nav-text">306 Switch Proxy</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#307-Temporary-Redirect"><span class="nav-text">307 Temporary Redirect</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4xx-%E8%AF%B7%E6%B1%82%E9%94%99%E8%AF%AF"><span class="nav-text">4xx 请求错误</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#400-Bad-Request"><span class="nav-text">400 Bad Request</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#401-Unauthorized"><span class="nav-text">401 Unauthorized</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#402-Payment-Required"><span class="nav-text">402 Payment Required</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#403-Forbidden"><span class="nav-text">403 Forbidden</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#404-Not-Found"><span class="nav-text">404 Not Found</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#405-Method-Not-Allowed"><span class="nav-text">405 Method Not Allowed</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#406-Not-Acceptable"><span class="nav-text">406 Not Acceptable</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#407-Proxy-Authentication-Required"><span class="nav-text">407 Proxy Authentication Required</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#408-Request-Timeout"><span class="nav-text">408 Request Timeout</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#409-Conflict"><span class="nav-text">409 Conflict</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#410-Gone"><span class="nav-text">410 Gone</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#411-Length-Required"><span class="nav-text">411 Length Required</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#412-Precondition-Failed"><span class="nav-text">412 Precondition Failed</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#413-Request-Entity-Too-Large"><span class="nav-text">413 Request Entity Too Large</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#414-Request-URI-Too-Long"><span class="nav-text">414 Request-URI Too Long</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#415-Unsupported-Media-Type"><span class="nav-text">415 Unsupported Media Type</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#416-Requested-Range-Not-Satisfiable"><span class="nav-text">416 Requested Range Not Satisfiable</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#417-Expectation-Failed"><span class="nav-text">417 Expectation Failed</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#418-I%E2%80%99m-a-teapot"><span class="nav-text">418 I’m a teapot</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#421-too-many-connections"><span class="nav-text">421 too many connections</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#422-Unprocessable-Entity"><span class="nav-text">422 Unprocessable Entity</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#423-Locked"><span class="nav-text">423 Locked</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#424-Failed-Dependency"><span class="nav-text">424 Failed Dependency</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#425-Unordered-Collection"><span class="nav-text">425 Unordered Collection</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#426-Upgrade-Required"><span class="nav-text">426 Upgrade Required</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#449-Retry-With"><span class="nav-text">449 Retry With</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#451-Unavailable-For-Legal-Reasons"><span class="nav-text">451 Unavailable For Legal Reasons</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5xx%E3%80%816xx-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%94%99%E8%AF%AF"><span class="nav-text">5xx、6xx 服务器错误</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#500-Internal-Server-Error"><span class="nav-text">500 Internal Server Error</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#501-Not-Implemented"><span class="nav-text">501 Not Implemented</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#502-Bad-Gateway"><span class="nav-text">502 Bad Gateway</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#503-Service-Unavailable"><span class="nav-text">503 Service Unavailable</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#504-Gateway-Timeout"><span class="nav-text">504 Gateway Timeout</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#505-HTTP-Version-Not-Supported"><span class="nav-text">505 HTTP Version Not Supported</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#506-Variant-Also-Negotiates"><span class="nav-text">506 Variant Also Negotiates</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#507-Insufficient-Storage"><span class="nav-text">507 Insufficient Storage</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#509-Bandwidth-Limit-Exceeded"><span class="nav-text">509 Bandwidth Limit Exceeded</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#510-Not-Extended"><span class="nav-text">510 Not Extended</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#600-Unparseable-Response-Headers"><span class="nav-text">600 Unparseable Response Headers</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-DNS"><span class="nav-text">3. DNS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E4%B8%8D%E5%90%8C%E7%B3%BB%E7%BB%9F%E5%A4%84%E7%90%86dns%E5%93%8D%E5%BA%94%E5%92%8C%E9%A6%96%E9%80%89%E5%A4%87%E9%80%89%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">3.1. 不同系统处理dns响应和首选备选的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#dns%E5%93%8D%E5%BA%94%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-text">dns响应的理解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-linux"><span class="nav-text">1) linux</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-windows"><span class="nav-text">2) windows</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-tcp%E5%92%8Cudp"><span class="nav-text">3.2. tcp和udp</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-SOA%E5%92%8CNS"><span class="nav-text">3.3. SOA和NS</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%83%E3%80%81%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87"><span class="nav-text">七、网络设备</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%AE%B6%E7%94%A8%E8%B7%AF%E7%94%B1%E5%99%A8%E5%92%8C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E8%B7%AF%E7%94%B1%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%86"><span class="nav-text">1. 家用路由器和计算机网络中的路由器的区分</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%97%AE%E9%A2%98"><span class="nav-text">问题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%B1%80%E5%9F%9F%E7%BD%91%E5%92%8C%E5%A4%96%E7%BD%91%EF%BC%9F"><span class="nav-text">1. 局域网和外网？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E5%B1%80%E5%9F%9F%E7%BD%91%E5%86%85%E5%85%B1%E7%94%A8%E4%B8%80%E4%B8%AA%E5%A4%96%E7%BD%91ip%EF%BC%8C%E6%95%B0%E6%8D%AE%E5%A6%82%E4%BD%95%E5%AE%9A%E4%BD%8D%E5%88%B0%E8%87%AA%E5%B7%B1%E7%9A%84%E7%94%B5%E8%84%91%E4%B8%8A%E7%9A%84%EF%BC%9F"><span class="nav-text">一个局域网内共用一个外网ip，数据如何定位到自己的电脑上的？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-tun%E7%BD%91%E5%8D%A1%E5%92%8Ctap%E7%BD%91%E5%8D%A1%E5%8C%BA%E5%88%AB"><span class="nav-text">1. tun网卡和tap网卡区别</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="王钰博" src="/images/12.jpg"><p class="site-author-name" itemprop="name">王钰博</p><div class="site-description" itemprop="description">个人博客</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">122</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">22</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">14</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/Githubwyb" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Githubwyb" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:1061322005@qq.com" title="E-Mail → mailto:1061322005@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a></span></div><div class="links-of-blogroll motion-element"><div class="links-of-blogroll-title"><i class="fa fa-fw fa-link"></i> 友情链接</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="https://githubwyb.github.io/bookPages/" title="https:&#x2F;&#x2F;githubwyb.github.io&#x2F;bookPages&#x2F;">markdown books</a></li></ul></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="beian"><a href="http://www.beian.miit.gov.cn/" rel="noopener" target="_blank">豫ICP备16023189号 </a><img src="/images/beian.png" style="display:inline-block"></div><div class="copyright">&copy; <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">王钰博</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-area-chart"></i> </span><span title="站点总字数">919k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span title="站点阅读时长">13:56</span></div><div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动</div><div class="addthis_inline_share_toolbox"><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e1986d4e4e2d132" async></script></div><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-divider">|</span> <span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer></div><script src="/lib/anime.min.js"></script><script src="/lib/medium-zoom.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><script src="/js/local-search.js"></script><script>document.querySelectorAll(".pdfobject-container").forEach(e=>{let t=e.dataset.target,a="#"+Object.entries({navpanes:0,toolbar:0,statusbar:0,pagemode:"thumbs",view:"FitH"}).map(([e,t])=>`${e}=${encodeURIComponent(t)}`).join("&"),i=`/lib/pdf/web/viewer.html?file=${encodeURIComponent(t)}${a}`;NexT.utils.supportsPDFs()?e.innerHTML=`<embed class="pdfobject" src="${t+a}" type="application/pdf" style="height: ${e.dataset.height};">`:e.innerHTML=`<iframe src="${i}" style="height: ${e.dataset.height};" frameborder="0"></iframe>`})</script><script>"undefined"==typeof MathJax?(window.MathJax={loader:{source:{"[tex]/amsCd":"[tex]/amscd","[tex]/AMScd":"[tex]/amscd"}},tex:{inlineMath:{"[+]":[["$","$"]]},tags:"ams"},options:{renderActions:{findScript:[10,e=>{document.querySelectorAll('script[type^="math/tex"]').forEach(t=>{const a=!!t.type.match(/; *mode=display/),n=new e.options.MathItem(t.textContent,e.inputJax[0],a),d=document.createTextNode("");t.parentNode.replaceChild(d,t),n.start={node:d,delim:"",n:0},n.end={node:d,delim:"",n:0},e.math.push(n)})},"",!1],insertedScript:[200,()=>{document.querySelectorAll("mjx-container").forEach(e=>{let t=e.parentNode;"li"===t.nodeName.toLowerCase()&&t.parentNode.classList.add("has-jax")})},"",!1]}}},function(){var e=document.createElement("script");e.src="/lib/mathjax/tex-mml-chtml.js",e.defer=!0,document.head.appendChild(e)}()):(MathJax.startup.document.state(0),MathJax.texReset(),MathJax.typeset())</script><script>NexT.utils.loadComments(document.querySelector("#valine-comments"),()=>{NexT.utils.getScript("//unpkg.com/valine/dist/Valine.min.js",()=>{var e=["nick","mail","link"],a="nick,mail";a=a.split(",").filter(a=>e.includes(a)),new Valine({el:"#valine-comments",verify:!1,notify:!1,appId:"qmLbUHV1HOr841BOYkl84riu-gzGzoHsz",appKey:"j4fgTcf1yHRDD5X3HUH5EH95",placeholder:"^_^ happy everyday!",avatar:"wavatar",meta:a,pageSize:"10",visitor:!1,lang:"zh-cn",path:location.pathname,recordIP:!1,serverURLs:""})},window.Valine)})</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":true,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"bottom":-30,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body><script type="text/javascript" src="/lib/jquery-3.4.1.min.js"></script><script type="text/javascript" src="/js/src/love.js"></script></html>