<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.0.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-diy.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-diy.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-diy.png"><link rel="mask-icon" href="/images/logo-diy.svg" color="#222"><meta name="baidu-site-verification" content="y1cfESbTt9nd3LsA"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="/lib/pace/pace-theme-flash.min.css"><script src="/lib/pace/pace.min.js"></script><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"githubwyb.github.io",root:"/",scheme:"Pisces",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:null},back2top:{enable:!0,sidebar:!1,scrollpercent:!0},bookmark:{enable:!0,color:"#ff0000",save:"auto"},fancybox:!1,mediumzoom:!0,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="前言 算法讲解汇总的网站 OI wiki  一、数学知识复习对数定理 1.1$$ log_A{B} &#x3D; \frac{log_C{B}}{log_C{A}} ; C &gt; 0 $$ 级数几何级数公式$$ \sum_{i &#x3D; 0}^{N}2^i &#x3D; 2^{N+1} - 1 $$ $$ \sum_{i &#x3D; 0}^{N}A^i &#x3D; \frac{A^{N"><meta property="og:type" content="article"><meta property="og:title" content="算法与数据结构学习"><meta property="og:url" content="https://githubwyb.github.io/blogs/2018-09-18-algorithmStudy/index.html"><meta property="og:site_name" content="技术的路上奔跑"><meta property="og:description" content="前言 算法讲解汇总的网站 OI wiki  一、数学知识复习对数定理 1.1$$ log_A{B} &#x3D; \frac{log_C{B}}{log_C{A}} ; C &gt; 0 $$ 级数几何级数公式$$ \sum_{i &#x3D; 0}^{N}2^i &#x3D; 2^{N+1} - 1 $$ $$ \sum_{i &#x3D; 0}^{N}A^i &#x3D; \frac{A^{N"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://githubwyb.github.io/2024-03-14-01.png"><meta property="og:image" content="https://githubwyb.github.io/blogs/2018-09-18-algorithmStudy/2023-04-19-01.png"><meta property="og:image" content="https://githubwyb.github.io/blogs/2018-09-18-algorithmStudy/2023-04-19-02.png"><meta property="og:image" content="https://githubwyb.github.io/blogs/2018-09-18-algorithmStudy/2023-04-19-03.png"><meta property="og:image" content="https://githubwyb.github.io/blogs/2018-09-18-algorithmStudy/2023-04-19-04.png"><meta property="article:published_time" content="2018-09-18T07:07:21.000Z"><meta property="article:modified_time" content="2024-03-14T12:39:27.000Z"><meta property="article:author" content="王钰博"><meta property="article:tag" content="算法"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://githubwyb.github.io/2024-03-14-01.png"><link rel="canonical" href="https://githubwyb.github.io/blogs/2018-09-18-algorithmStudy/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>算法与数据结构学习 | 技术的路上奔跑</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">技术的路上奔跑</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">入门</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-fw fa-sitemap"></i>站点地图</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><div class="reading-progress-bar"></div><a role="button" class="book-mark-link book-mark-link-fixed"></a> <a href="https://github.com/Githubwyb" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://githubwyb.github.io/blogs/2018-09-18-algorithmStudy/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/12.jpg"><meta itemprop="name" content="王钰博"><meta itemprop="description" content="个人博客"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="技术的路上奔跑"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">算法与数据结构学习</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2018-09-18 15:07:21" itemprop="dateCreated datePublished" datetime="2018-09-18T15:07:21+08:00">2018-09-18</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2024-03-14 20:39:27" itemprop="dateModified" datetime="2024-03-14T20:39:27+08:00">2024-03-14</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Knowledge/" itemprop="url" rel="index"><span itemprop="name">Knowledge</span></a> </span>， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Knowledge/Study/" itemprop="url" rel="index"><span itemprop="name">Study</span></a> </span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span id="busuanzi_value_page_pv"></span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><span class="post-meta-item-text">Valine：</span> <a title="valine" href="/blogs/2018-09-18-algorithmStudy/#valine-comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/blogs/2018-09-18-algorithmStudy/" itemprop="commentCount"></span></a></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>26k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>24 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li>算法讲解汇总的网站 <a target="_blank" rel="noopener" href="https://oi-wiki.org/">OI wiki</a></li></ul><h1 id="一、数学知识复习"><a href="#一、数学知识复习" class="headerlink" title="一、数学知识复习"></a>一、数学知识复习</h1><h2 id="对数"><a href="#对数" class="headerlink" title="对数"></a>对数</h2><h3 id="定理-1-1"><a href="#定理-1-1" class="headerlink" title="定理 1.1"></a>定理 1.1</h3><p>$$ log_A{B} &#x3D; \frac{log_C{B}}{log_C{A}} ; C &gt; 0 $$</p><h2 id="级数"><a href="#级数" class="headerlink" title="级数"></a>级数</h2><h3 id="几何级数公式"><a href="#几何级数公式" class="headerlink" title="几何级数公式"></a>几何级数公式</h3><p>$$ \sum_{i &#x3D; 0}^{N}2^i &#x3D; 2^{N+1} - 1 $$</p><p>$$ \sum_{i &#x3D; 0}^{N}A^i &#x3D; \frac{A^{N+1} - 1}{A - 1} $$</p><p>当N趋于$\infty$时，该和趋于$\frac{1}{1-A}$。</p><h1 id="二、算法分析"><a href="#二、算法分析" class="headerlink" title="二、算法分析"></a>二、算法分析</h1><h2 id="1-数学基础"><a href="#1-数学基础" class="headerlink" title="1. 数学基础"></a>1. 数学基础</h2><h3 id="1-1-四个定义"><a href="#1-1-四个定义" class="headerlink" title="1.1. 四个定义"></a>1.1. 四个定义</h3><ul><li>如果存在正常数 $c$ 和 $n_0$ 使得当 $N \geq n_0$ 时 $T(N) \leq cf(N)$ ，则即为 $T(N) &#x3D; O(f(N))$ 。</li><li>如果存在正常数 $c$ 和 $n_0$ 使得当 $N \geq n_0$ 时 $T(N) \geq cg(N)$ ，则即为 $T(N) &#x3D; \Omega(f(N))$ 。</li><li>$T(N) &#x3D; \Theta (h(N))$ 当且仅当 $T(N) &#x3D; O(h(N))$ 且 $T(N) &#x3D; \Omega(h(N))$ 。</li><li>如果 $T(N) &#x3D; O(p(N))$ 且 $T(N) \neq \Theta(p(N))$ ，则 $T(N) &#x3D; o(p(N))$</li></ul><h2 id="2-排列组合"><a href="#2-排列组合" class="headerlink" title="2. 排列组合"></a>2. 排列组合</h2><h3 id="2-1-公式记录"><a href="#2-1-公式记录" class="headerlink" title="2.1. 公式记录"></a>2.1. 公式记录</h3><ul><li>n个不同元素取m个，关心顺序。为排列，使用A表示</li></ul><p>$$ A_n^m &#x3D; \frac{n!}{(n-m)!} $$</p><ul><li>n个不同元素取m个，不关心顺序。为组合，使用C表示<ul><li>排列的方式除以顺序造成的多余方案数</li></ul></li></ul><p>$$ C_n^m &#x3D; \frac{A_n^m}{m!} &#x3D; \frac{n!}{m!(n-m)!} $$<br>$$ C_n^m &#x3D; C_n^{n-m} $$</p><h2 id="3-质数"><a href="#3-质数" class="headerlink" title="3. 质数"></a>3. 质数</h2><p>使用欧拉线性筛计算出来的 $10^n$ 以内的质数的数量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">10 4</span><br><span class="line">100 25</span><br><span class="line">1000 168</span><br><span class="line">10000 1229</span><br><span class="line">100000 9592</span><br><span class="line">1000000 78498</span><br><span class="line">10000000 664579</span><br><span class="line">100000000 5761455</span><br></pre></td></tr></table></figure><h3 id="3-1-埃氏筛"><a href="#3-1-埃氏筛" class="headerlink" title="3.1. 埃氏筛"></a>3.1. 埃氏筛</h3><ul><li>埃氏筛是将一个合数分成一个质数乘以一个整数，那么循环所有的数，将他们乘以小于自己的质数，得到的结果一定不是质数</li><li>那么循环到某个数时，如果其没有被小于自己的数排掉，那么一定是质数</li></ul><h4 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h4><ul><li>反证法，如果有一个合数x没有被排掉，可以分为 $x &#x3D; a \times b，a为因数中最小的质数$</li><li>b为合数一定大于a，因为b也可以分为质因数相乘，a为其中最小的；b为质数同样大于a</li><li>在循环到b时，乘以小于自己的所有质数，到a时一定会把x排除掉，假设不成立，证明是可行的</li></ul><h3 id="3-2-欧拉线性筛：使用O-n-的时间复杂度找出n以内的所有质数"><a href="#3-2-欧拉线性筛：使用O-n-的时间复杂度找出n以内的所有质数" class="headerlink" title="3.2. 欧拉线性筛：使用O(n)的时间复杂度找出n以内的所有质数"></a>3.2. 欧拉线性筛：使用O(n)的时间复杂度找出n以内的所有质数</h3><ul><li>核心思想是埃氏筛，但是使用一个提前退出将时间复杂度降到O(n)</li><li>当一个合数 $x &#x3D; a \times b$，其中b为a的倍数，a为质数，遍历到x时提前退出的唯一顾虑是 $n &#x3D; x \times c &#x3D; a \times b \times c，c为质数$ 没有做排除</li><li>当遍历到 $b \times c$ 时，会将n进行排除，所以此顾虑消失，提前退出减少循环计算次数</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mx <span class="type">int</span> = <span class="number">1e8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> primes []<span class="type">int</span> = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">5</span>*<span class="number">1e7</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	flag := <span class="built_in">make</span>([]<span class="type">bool</span>, mx+<span class="number">1</span>) <span class="comment">// 标记数有没有被筛掉，false就是没有</span></span><br><span class="line">	check := <span class="number">10</span>                <span class="comment">// 打印使用</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">2</span>; i &lt; mx+<span class="number">1</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> !flag[i] &#123;</span><br><span class="line">			<span class="comment">// 数没有被比自己小的数筛掉，就代表是质数</span></span><br><span class="line">			primes = <span class="built_in">append</span>(primes, i)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> _, v := <span class="keyword">range</span> primes &#123;</span><br><span class="line">			<span class="keyword">if</span> i*v &gt; mx &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 每一个数都作为因子乘以比自己小的素数筛掉后面的数</span></span><br><span class="line">			flag[i*v] = <span class="literal">true</span></span><br><span class="line">			<span class="keyword">if</span> i%v == <span class="number">0</span> &#123;</span><br><span class="line">				<span class="comment">// 减少时间复杂度的关键算法</span></span><br><span class="line">				<span class="comment">// 12 = 2 * 3 * 2，i = 4时，只排了8就退出了，因为6会将12排除</span></span><br><span class="line">				<span class="comment">// 也就是，假设v可以整除i即i = kv，有某个数为x = mi = kmv</span></span><br><span class="line">				<span class="comment">//        那么存在一个数 i &lt; km &lt; x可以把x排掉，用i乘以所有的质数去排除就没什么意义了，提前退出减少时间复杂度</span></span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 仅打印使用</span></span><br><span class="line">		<span class="keyword">if</span> i == check &#123;</span><br><span class="line">			fmt.Println(i, <span class="built_in">len</span>(primes))</span><br><span class="line">			check *= <span class="number">10</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三、数据结构"><a href="#三、数据结构" class="headerlink" title="三、数据结构"></a>三、数据结构</h1><h2 id="1-树"><a href="#1-树" class="headerlink" title="1. 树"></a>1. 树</h2><h3 id="1-1-公共部分"><a href="#1-1-公共部分" class="headerlink" title="1.1. 公共部分"></a>1.1. 公共部分</h3><h4 id="1-遍历"><a href="#1-遍历" class="headerlink" title="1) 遍历"></a>1) 遍历</h4><h5 id="1-树的深度优先和广度优先遍历"><a href="#1-树的深度优先和广度优先遍历" class="headerlink" title="(1) 树的深度优先和广度优先遍历"></a>(1) <span id="treeSpan">树的深度优先和广度优先遍历</span></h5><p>定义树结构</p><img src="2019_02_27_10.png" width="40%"><h6 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h6><p>深度优先遍历（Depth First Search），简称DFS，其原则是，沿着一条路径一直找到最深的那个节点，当没有子节点的时候，返回上一级节点，寻找其另外的子节点，继续向下遍历，没有就向上返回一级，直到所有的节点都被遍历到，每个节点只能访问一次。</p><p><strong>算法步骤：</strong></p><p>使用栈的数据结构实现</p><ol><li>首先将根节点1压入栈中【1】</li><li>将1节点弹出，找到1的两个子节点3，2，首先压入3节点，再压入2节点（后压入左节点的话，会先取出左节点，这样就保证了先遍历左节点），2节点再栈的顶部，最先出来【2，3】</li><li>弹出2节点，将2节点的两个子节点5，4压入【4，5，3】</li><li>弹出4节点，将4的子节点9，8压入【8，9，5，3】</li><li>弹出8，8没有子节点，不压入【9，5，3】</li><li>弹出9，9没有子节点，不压入【5，3】</li><li>弹出5，5有一个节点，压入10，【10，3】</li><li>弹出10，10没有节点，不压入【3】</li><li>弹出3，压入3的子节点7，6【6，7】</li><li>弹出6，没有子节点【7】</li><li>弹出7，没有子节点，栈为空【】，算法结束</li></ol><p>出栈顺序【1，2，4，8，9，5，10，3，6，7】</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//树结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    vector&lt;shared_ptr&lt;Node&gt;&gt; pChild;</span><br><span class="line">    weak_ptr&lt;Node&gt; pParent;</span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="comment">//深度优先打印节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printNodesDeepFirst</span><span class="params">(<span class="type">const</span> shared_ptr&lt;Node&gt; &amp;node)</span> </span>&#123;</span><br><span class="line">    stack&lt;shared_ptr&lt;Node&gt;&gt; myStack;</span><br><span class="line">    myStack.<span class="built_in">push</span>(node);</span><br><span class="line">    <span class="keyword">while</span> (myStack.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        shared_ptr&lt;Node&gt; pTmp = myStack.<span class="built_in">top</span>();</span><br><span class="line">        myStack.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="built_in">PRINT</span>(<span class="string">&quot;%d &quot;</span>, pTmp-&gt;value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//由于栈的后进先出特性，需要倒序使左节点先出</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = pTmp-&gt;pChild.<span class="built_in">size</span>(); i != <span class="number">0</span>; --i) &#123;</span><br><span class="line">            myStack.<span class="built_in">push</span>(pTmp-&gt;pChild[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">PRINT</span>(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h6><p>广度优先遍历（Breadth First Search），简称BFS；广度优先遍历的原则就是对每一层的节点依次访问，一层访问结束后，进入下一层，直到最后一个节点，同样的，每个节点都只访问一次。</p><p><strong>算法步骤：</strong></p><p>使用队列的数据结构实现</p><ol><li>节点1，插入队列【1】</li><li>取出节点1，插入1的子节点2，3 ，节点2在队列的前端【2，3】</li><li>取出节点2，插入2的子节点4，5，节点3在队列的最前端【3，4，5】</li><li>取出节点3，插入3的子节点6，7，节点4在队列的最前端【4，5，6，7】</li><li>取出节点4，插入3的子节点8，9，节点5在队列的最前端【5，6，7，8，9】</li><li>取出节点5，插入5的子节点10，节点6在队列的最前端【6，7，8，9，10】</li><li>取出节点6，没有子节点，不插入，节点7在队列的最前端【7，8，9，10】</li><li>取出节点7，没有子节点，不插入，节点8在队列的最前端【8，9，10】</li><li>取出节点8，没有子节点，不插入，节点9在队列的最前端【9，10】</li><li>取出节点9，没有子节点，不插入，节点10在队列的最前端【10】</li><li>取出节点10，队列为空，算法结束</li></ol><p>我们看一下节点出队的顺序【1，2，3，4，5，6，7，8，9，10】</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//树结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    vector&lt;shared_ptr&lt;Node&gt;&gt; pChild;</span><br><span class="line">    weak_ptr&lt;Node&gt; pParent;</span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="comment">//广度优先打印节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printNodesWidthFirst</span><span class="params">(<span class="type">const</span> shared_ptr&lt;Node&gt; &amp;node)</span> </span>&#123;</span><br><span class="line">    queue&lt;shared_ptr&lt;Node&gt;&gt; myQueue;</span><br><span class="line">    myQueue.<span class="built_in">push</span>(node);</span><br><span class="line">    <span class="keyword">while</span> (myQueue.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        shared_ptr&lt;Node&gt; pTmp = myQueue.<span class="built_in">front</span>();</span><br><span class="line">        myQueue.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="built_in">PRINT</span>(<span class="string">&quot;%d &quot;</span>, pTmp-&gt;value);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> tmp : pTmp-&gt;pChild) &#123;</span><br><span class="line">            myQueue.<span class="built_in">push</span>(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">PRINT</span>(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-度"><a href="#2-度" class="headerlink" title="2) 度"></a>2) 度</h4><ul><li>孩子结点个数就是结点的度，0度就是没有孩子结点</li><li>树的度就是结点中最大的度</li></ul><h3 id="1-2-二叉树"><a href="#1-2-二叉树" class="headerlink" title="1.2. 二叉树"></a>1.2. 二叉树</h3><h4 id="1-性质和算法"><a href="#1-性质和算法" class="headerlink" title="1) 性质和算法"></a>1) 性质和算法</h4><h5 id="1-二叉树前中后序遍历"><a href="#1-二叉树前中后序遍历" class="headerlink" title="(1) 二叉树前中后序遍历"></a>(1) <span id="towTree">二叉树前中后序遍历</span></h5><ul><li>前序遍历指先访问根，然后访问子树的遍历方式</li></ul><img src="2019_02_22_05.png" width="40%"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">in_order_traversal</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Do Something with root</span></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;lchild != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">in_order_traversal</span>(root-&gt;lchild);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;rchild != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">in_order_traversal</span>(root-&gt;rchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>中序遍历指先访问左（右）子树，然后访问根，最后访问右（左）子树的遍历方式</li></ul><img src="2019_02_22_06.png" width="40%"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">in_order_traversal</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;lchild != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">in_order_traversal</span>(root-&gt;lchild);</span><br><span class="line">    <span class="comment">// Do Something with root</span></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;rchild != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">in_order_traversal</span>(root-&gt;rchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>后序遍历指先访问子树，然后访问根的遍历方式</li></ul><img src="2019_02_22_07.png" width="40%"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">in_order_traversal</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;lchild != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">in_order_traversal</span>(root-&gt;lchild);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;rchild != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">in_order_traversal</span>(root-&gt;rchild);</span><br><span class="line">    <span class="comment">// Do Something with root</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-完全二叉树和满二叉树"><a href="#2-完全二叉树和满二叉树" class="headerlink" title="(2) 完全二叉树和满二叉树"></a>(2) 完全二叉树和满二叉树</h5><ul><li>满二叉树，只有最后一行是叶子节点，其他的节点都是度为2的节点</li><li>完全二叉树指的是除了最后一行，整体是满二叉树，最后一行叶子节点从左到右依次排列</li></ul><h4 id="2-二叉搜索树"><a href="#2-二叉搜索树" class="headerlink" title="2) 二叉搜索树"></a>2) 二叉搜索树</h4><p>二叉查找树（Binary Search Tree），（又：二叉搜索树，二叉排序树）它或者是一棵空树，或者是具有下列性质的二叉树：<br><strong>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</strong><br>它的左、右子树也分别为二叉排序树。</p><h5 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h5><p>二叉排序树的查找过程和次优二叉树类似，通常采取二叉链表作为二叉排序树的存储结构。<strong>中序遍历</strong>二叉排序树可得到一个关键字的有序序列，一个无序序列可以通过构造一棵二叉排序树变成一个有序序列，构造树的过程即为对无序序列进行排序的过程。每次插入的新的结点都是二叉排序树上新的叶子结点，在进行插入操作时，不必移动其它结点，只需改动某个结点的指针，由空变为非空即可。搜索,插入,删除的复杂度等于树高，O(log(n)).</p><h4 id="3-大（小）根堆（优先队列）"><a href="#3-大（小）根堆（优先队列）" class="headerlink" title="3) 大（小）根堆（优先队列）"></a>3) 大（小）根堆（优先队列）</h4><p>大（小）根堆是堆的两种形式之一。根结点（亦称为堆顶）的关键字是堆里所有结点关键字中最大（小）者，称为大（小）根堆，又称最大（小）堆、大（小）顶堆。大（小）根堆要求根节点的关键字既大（小）于或等于左子树的关键字值，又大（小）于或等于右子树的关键字值。<br>普通的队列是一种先进先出的数据结构，元素在队列尾追加，而从队列头删除。在优先队列中，元素被赋予优先级。当访问元素时，具有最高优先级的元素最先删除。优先队列具有最高级先出 （first in, largest out）的行为特征。通常采用堆数据结构来实现。</p><h5 id="性质和应用"><a href="#性质和应用" class="headerlink" title="性质和应用"></a>性质和应用</h5><ul><li>最大或最小值在堆顶，可以用于排序数组</li><li>可以用队列表示，第$i$个元素大于或者小于第$i * 2$和第$i * 2 + 1$个元素</li><li>最基本的应用，查找<a href="/blogs/2019-10-21-programQuestion/#minKNumber">数组最小（大）k个值</a></li><li><a href="/blogs/2018-07-06-CppStudy/#bigHeap">C++标准库有接口可以直接应用</a></li></ul><h4 id="4-红黑树"><a href="#4-红黑树" class="headerlink" title="4) 红黑树"></a>4) 红黑树</h4><p>参考 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/78152265">红黑树(R-B tree)原理图文详解</a></p><h5 id="1-红黑树的特性和应用"><a href="#1-红黑树的特性和应用" class="headerlink" title="(1) 红黑树的特性和应用"></a>(1) 红黑树的特性和应用</h5><ul><li>红黑树的查找和插入时间复杂度都是 $O(\log n)$，相比hash表更加稳定</li></ul><p><strong>应用</strong></p><ul><li>std::map和std::set使用的是红黑树</li><li>epoll的底层实现是用红黑树组织fd</li></ul><h3 id="1-3-线段树"><a href="#1-3-线段树" class="headerlink" title="1.3. 线段树"></a>1.3. 线段树</h3><p>用于求区间值的一种数据结构</p><h4 id="1-原理"><a href="#1-原理" class="headerlink" title="1) 原理"></a>1) 原理</h4><p>线段树是一个平衡二叉树，母节点代表整个区间的和，越向下区间越小。对于一个数组<code>[1, 2, 3, 4, 5]</code>，构建线段树如下</p><p><img src="/2024-03-14-01.png"></p><p>某个节点对应线段为<code>[a, b]</code>，设 $mid &#x3D; \frac{l+r}{2}$ 向下取整，两个子节点对应线段是<code>[a, mid]</code>和<code>[mid+1, b]</code>，左区间数量比右区间数量相等或多一个</p><h4 id="2-示例1-区间和的个数"><a href="#2-示例1-区间和的个数" class="headerlink" title="2) 示例1 区间和的个数"></a>2) 示例1 区间和的个数</h4><p><strong>题目</strong></p><p>给你一个整数数组 nums 以及两个整数 lower 和 upper 。求数组中，值位于范围 [lower, upper] （包含 lower 和 upper）之内的 区间和的个数 。</p><p>区间和 S(i, j) 表示在 nums 中，位置从 i 到 j 的元素之和，包含 i 和 j (i ≤ j)。</p><h2 id="2-hashTable-哈希表"><a href="#2-hashTable-哈希表" class="headerlink" title="2. hashTable 哈希表"></a>2. hashTable 哈希表</h2><h3 id="2-1-为什么哈希表的除数要用素数"><a href="#2-1-为什么哈希表的除数要用素数" class="headerlink" title="2.1. 为什么哈希表的除数要用素数"></a>2.1. 为什么哈希表的除数要用素数</h3><p>参考自 <a target="_blank" rel="noopener" href="https://blog.csdn.net/w_y_x_y/article/details/82288178">腾讯面试真题：证明为什么哈希表除m取余法的被除数为什么用素数比较好</a></p><ul><li>使用合数可能和等差数列的差值含有公因数，导致碰撞概率增大</li></ul><h4 id="1-假设"><a href="#1-假设" class="headerlink" title="1) 假设"></a>1) 假设</h4><ul><li>传入的key是等差数列: 首项1，差值从2到5，长度10</li><li>两个hash表，一个使用6取模，一个使用7取模</li></ul><h4 id="2-效果"><a href="#2-效果" class="headerlink" title="2) 效果"></a>2) 效果</h4><p><strong>差值2</strong></p><table><thead><tr><th>余数</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th></tr></thead><tbody><tr><td>首次</td><td></td><td>1</td><td></td><td>3</td><td></td><td>5</td></tr><tr><td>碰撞</td><td></td><td>7</td><td></td><td>9</td><td></td><td>11</td></tr><tr><td>碰撞</td><td></td><td>13</td><td></td><td>15</td><td></td><td>17</td></tr><tr><td>碰撞</td><td></td><td>19</td><td></td><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th>余数</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th></tr></thead><tbody><tr><td>首次</td><td>7</td><td>1</td><td>9</td><td>3</td><td>11</td><td>5</td><td>13</td></tr><tr><td>碰撞</td><td></td><td>15</td><td></td><td>17</td><td></td><td>19</td><td></td></tr></tbody></table><p><strong>差值3</strong></p><table><thead><tr><th>余数</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th></tr></thead><tbody><tr><td>首次</td><td></td><td>1</td><td></td><td></td><td>4</td><td></td></tr><tr><td>碰撞</td><td></td><td>7</td><td></td><td></td><td>10</td><td></td></tr><tr><td>碰撞</td><td></td><td>13</td><td></td><td></td><td>16</td><td></td></tr><tr><td>碰撞</td><td></td><td>19</td><td></td><td></td><td>22</td><td></td></tr><tr><td>碰撞</td><td></td><td>25</td><td></td><td></td><td>28</td><td></td></tr></tbody></table><table><thead><tr><th>余数</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th></tr></thead><tbody><tr><td>首次</td><td>7</td><td>1</td><td>16</td><td>10</td><td>4</td><td>19</td><td>13</td></tr><tr><td>碰撞</td><td>28</td><td>22</td><td></td><td></td><td>25</td><td></td><td></td></tr></tbody></table><p><strong>差值4</strong></p><table><thead><tr><th>余数</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th></tr></thead><tbody><tr><td>首次</td><td></td><td>1</td><td></td><td>9</td><td></td><td>5</td></tr><tr><td>碰撞</td><td></td><td>13</td><td></td><td>21</td><td></td><td>17</td></tr><tr><td>碰撞</td><td></td><td>25</td><td></td><td>33</td><td></td><td>29</td></tr><tr><td>碰撞</td><td></td><td>37</td><td></td><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th>余数</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th></tr></thead><tbody><tr><td>首次</td><td>21</td><td>1</td><td>9</td><td>17</td><td>25</td><td>5</td><td>13</td></tr><tr><td>碰撞</td><td></td><td>29</td><td>37</td><td></td><td></td><td>33</td><td></td></tr></tbody></table><p><strong>差值5</strong></p><table><thead><tr><th>余数</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th></tr></thead><tbody><tr><td>首次</td><td>6</td><td>1</td><td>26</td><td>21</td><td>16</td><td>11</td></tr><tr><td>碰撞</td><td>36</td><td>31</td><td></td><td></td><td>46</td><td>41</td></tr></tbody></table><table><thead><tr><th>余数</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th></tr></thead><tbody><tr><td>首次</td><td>21</td><td>1</td><td>16</td><td>31</td><td>11</td><td>26</td><td>6</td></tr><tr><td>碰撞</td><td></td><td>36</td><td></td><td></td><td>46</td><td></td><td>41</td></tr></tbody></table><h4 id="3-结论"><a href="#3-结论" class="headerlink" title="3) 结论"></a>3) 结论</h4><ul><li>如果差值和被除数之间不含有公因数，效果一样</li><li>如果含有公因数，碰撞概率会变高</li></ul><h2 id="3-bitmap-位图"><a href="#3-bitmap-位图" class="headerlink" title="3. bitmap 位图"></a>3. bitmap 位图</h2><h3 id="3-1-原理"><a href="#3-1-原理" class="headerlink" title="3.1. 原理"></a>3.1. 原理</h3><ul><li>一个int表示32位，可以表示32个数字，即</li></ul><table><thead><tr><th>0</th><th>1</th><th>2</th><th>3</th><th>…</th><th>31</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>1</td><td>0</td><td>…</td><td>1</td></tr></tbody></table><ul><li>代表2和31都在集合中</li><li>按照在二进制中的位置表示对应的数字</li><li>使用数组可以将一个很大的内存区域集合在一起，根据对应的位置说明对应的数字</li></ul><h3 id="3-2-举例"><a href="#3-2-举例" class="headerlink" title="3.2. 举例"></a>3.2. 举例</h3><ul><li>对一大批不同的11位qq号进行排序</li></ul><h4 id="1-实现"><a href="#1-实现" class="headerlink" title="1) 实现"></a>1) 实现</h4><ul><li>11位qq号最大99999999999，也就是需要 $1 \times 10^{12}$ 个bit保存</li><li>计算成int数组 $1 \times 10^{12} &#x2F; 32 &#x3D; 31250000000$</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_QQ_NUMBER 99999999ll</span></span><br><span class="line"><span class="type">const</span> <span class="type">long</span> BITS_PER_LONG = <span class="number">8</span> * <span class="built_in">sizeof</span>(<span class="type">long</span>);</span><br><span class="line"><span class="type">long</span> qq_bitmap[MAX_QQ_NUMBER / BITS_PER_LONG + <span class="number">1</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_qq_bitmap</span><span class="params">(<span class="type">long</span> <span class="type">long</span> qq)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (qq &gt; MAX_QQ_NUMBER) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 假设32位，long为32位</span></span><br><span class="line">    <span class="comment">// 先将输入的qq按照32一组找到对应的位置，然后将在其在32个一组中的位置置1</span></span><br><span class="line">    <span class="comment">// 61 =&gt; qq_bitmap[1] |= (1 &lt;&lt; 29)</span></span><br><span class="line">    qq_bitmap[qq / BITS_PER_LONG] |= (<span class="number">1</span> &lt;&lt; (qq % BITS_PER_LONG));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">check_qq_bitmap</span><span class="params">(<span class="type">long</span> <span class="type">long</span> qq)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (qq &gt; MAX_QQ_NUMBER) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 同理，找到qq按照32个一组的位置，检查对应的32个数字中的位置是否为1</span></span><br><span class="line">    <span class="keyword">return</span> qq_bitmap[qq / BITS_PER_LONG] &amp; (<span class="number">1</span> &lt;&lt; (qq % BITS_PER_LONG));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-ST-稀疏表"><a href="#4-ST-稀疏表" class="headerlink" title="4. ST 稀疏表"></a>4. ST 稀疏表</h2><h3 id="4-1-原理"><a href="#4-1-原理" class="headerlink" title="4.1. 原理"></a>4.1. 原理</h3><ul><li>本身是解决区间问题，也就是给一个序列，找到<code>a-b</code>之间的最大值（或者其他值）为x的有几组</li><li>这种题目暴力解决，需要先计算所有两个点之间的最大值存到一个 $n \times n$ 的表里面，然后遍历表进行统计，空间复杂度和时间复杂度太高</li><li>使用稀疏表可以使用比较少的空间并节省大量的计算，用到的矩阵大小是 $n \times log_2 n$</li><li>首次对数据进行预处理形成一个稀疏表后，可以直接进行 $O(1)$ 的查询</li><li>整理成的矩阵的每个元素代表（拿取最大值表示）</li></ul><p>$$<br>st[j][i] &#x3D; \max \limits_{j \le x \le j + 2^{i}-1} arr[x]<br>$$</p><ul><li>想要取a到b之间的结果，那么取 $s &#x3D; log_2(b-a+1)$</li></ul><p>$$<br>f(a, b) &#x3D; \max(st[a][s], st[b-2^{s}+1][s])<br>$$</p><ul><li>其中 $a + 2^{s}-1 &#x3D; a + (b - a + 1) - 1 &#x3D; b \ge a &#x3D; b - (b - a + 1) + 1 &#x3D; b - 2^{s} + 1$</li></ul><h2 id="5-并查集"><a href="#5-并查集" class="headerlink" title="5. 并查集"></a>5. 并查集</h2><h3 id="5-1-原理"><a href="#5-1-原理" class="headerlink" title="5.1. 原理"></a>5.1. 原理</h3><ul><li>找关系，给一系列点，给出一些点和点的关系。然后找出某两个点是否有关系</li><li>单一一个可以直接使用bfs解就好了，如果空间不足，使用并查集可以做到 $O(n)$ 的空间复杂度</li><li>首先将所有点初始化关系只有自己和自己</li><li>然后遍历一边关系列表，将点和点连接起来，找到公共的父级</li><li>查找时就是看是否两个点存在公共父级</li></ul><h3 id="5-2-实现"><a href="#5-2-实现" class="headerlink" title="5.2. 实现"></a>5.2. 实现</h3><ul><li>主要实现两个方法，查找和插入</li><li>由于查找要用递归，想要减少递归深度，每次查找，整条链上的所有节点的父级都要指向最终点，这样下次只有一级查找</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数外模板</span></span><br><span class="line"><span class="keyword">type</span> unionFind []<span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initUnionFind</span><span class="params">(n <span class="type">int</span>)</span></span> unionFind &#123;</span><br><span class="line">	u := <span class="built_in">make</span>(unionFind, n)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> u &#123;</span><br><span class="line">		u[i] = i</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> u</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u unionFind)</span></span> find(a <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">	ap := u[a]</span><br><span class="line">	<span class="comment">// 找到最终节点</span></span><br><span class="line">	<span class="keyword">for</span> ap != u[ap] &#123;</span><br><span class="line">		ap = u[ap]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 沿途都赋值最终节点</span></span><br><span class="line">	<span class="keyword">for</span> a != ap &#123;</span><br><span class="line">		u[a], a = ap, u[a]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ap</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把a的子集合并到b上，如果b是树根节点，a的所有子节点查找都会查找到b</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u unionFind)</span></span> merge(a, b <span class="type">int</span>) &#123;</span><br><span class="line">	u[u.find(b)] = u.find(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>函数内并查集模板</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 并查集模板</span></span><br><span class="line">	uf := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> uf &#123;</span><br><span class="line">		uf[i] = i</span><br><span class="line">	&#125;</span><br><span class="line">	find := <span class="function"><span class="keyword">func</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">		ap := uf[x]</span><br><span class="line">		<span class="comment">// 找到最终节点</span></span><br><span class="line">		<span class="keyword">for</span> ap != uf[ap] &#123;</span><br><span class="line">			ap = uf[ap]</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 沿途都赋值最终节点</span></span><br><span class="line">		<span class="keyword">for</span> x != ap &#123;</span><br><span class="line">			uf[x], x = ap, uf[x]</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ap</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 把a的子集合并到b上，如果b是树根节点，a的所有子节点查找都会查找到b</span></span><br><span class="line">	merge := <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">		uf[find(a)] = find(b)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四、算法"><a href="#四、算法" class="headerlink" title="四、算法"></a>四、算法</h1><h2 id="1-排序算法"><a href="#1-排序算法" class="headerlink" title="1. 排序算法"></a>1. 排序算法</h2><h3 id="时间复杂度总结"><a href="#时间复杂度总结" class="headerlink" title="时间复杂度总结"></a>时间复杂度总结</h3><img src="2018_09_26_01.jpg" width="80%"><h4 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h4><ul><li>$N$个互异数的数组的平均逆序数是 $N(N-1)&#x2F;4$ 。</li><li>通过交换相邻元素进行排序的任何算法平均需要 $\Omega(N^2)$ 时间。</li></ul><h3 id="1-1-插入排序"><a href="#1-1-插入排序" class="headerlink" title="1.1. 插入排序"></a>1.1. 插入排序</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><ul><li>自我理解像扑克牌起牌一样，一张一张插入到已有的序列中</li></ul><img src="2018_09_26_02.gif" width="80%"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @function 用插入排序数组</span></span><br><span class="line"><span class="comment"> * @param data 数组首地址</span></span><br><span class="line"><span class="comment"> * @param length 数组长度</span></span><br><span class="line"><span class="comment"> * @param order 排列顺序：顺序，true；倒序，false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertionSort</span><span class="params">(T *data, <span class="type">int</span> length, <span class="type">bool</span> order = <span class="literal">true</span>)</span> </span>&#123;</span><br><span class="line">    T tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; length; ++i) &#123;</span><br><span class="line">        tmp = data[i];</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = i; j &gt; <span class="number">0</span> &amp;&amp; ((data[j - <span class="number">1</span>] &gt; tmp) ^ !order); --j) &#123;</span><br><span class="line">            data[j] = data[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        data[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-希尔排序"><a href="#1-2-希尔排序" class="headerlink" title="1.2. 希尔排序"></a>1.2. 希尔排序</h3><ul><li>带间隔的插入排序</li></ul><img src="2018_09_26_03.gif" width="80%"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @function 用希尔增量的希尔排序数组</span></span><br><span class="line"><span class="comment"> * @param data 数组首地址</span></span><br><span class="line"><span class="comment"> * @param length 数组长度</span></span><br><span class="line"><span class="comment"> * @param order 排列顺序：顺序，true；倒序，false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shellSort</span><span class="params">(T *data, <span class="type">int</span> length, <span class="type">bool</span> order = <span class="literal">true</span>)</span> </span>&#123;</span><br><span class="line">    T tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> increment = length / <span class="number">2</span>; increment &gt; <span class="number">0</span>; increment /= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = increment; i &lt; length; ++i) &#123;</span><br><span class="line">            tmp = data[i];</span><br><span class="line">            <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (j = i; j &gt;= increment &amp;&amp; ((data[j - increment] &gt; tmp) ^ !order); j -= increment) &#123;</span><br><span class="line">                data[j] = data[j - increment];</span><br><span class="line">            &#125;</span><br><span class="line">            data[j] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="定理-1"><a href="#定理-1" class="headerlink" title="定理"></a>定理</h4><ul><li>使用希尔增量时希尔排序的最坏情形的运行时间为 $\Theta(N^2)$ 。</li><li>使用Hibbard增量的希尔排序的最坏情形运行时间为 $\Theta(N^{\frac{3}{2}})$</li></ul><h3 id="1-3-堆排序"><a href="#1-3-堆排序" class="headerlink" title="1.3. 堆排序"></a>1.3. 堆排序</h3><img src="2018_09_26_04.gif" width="80%"><ul><li>大根堆或小根堆，保证父节点一定大于（小于）子节点，头节点为最大（最小）的</li></ul><h3 id="1-4-快速排序（分治思想）"><a href="#1-4-快速排序（分治思想）" class="headerlink" title="1.4. 快速排序（分治思想）"></a>1.4. 快速排序（分治思想）</h3><img src="2021_03_26_01.gif" width="80%"><ul><li>选定一个中轴数，将数组分为大于和小于的部分，中轴放中间</li><li>对大于部分和小于部分分别做同样的事</li></ul><h2 id="2-最短路径算法"><a href="#2-最短路径算法" class="headerlink" title="2. 最短路径算法"></a>2. 最短路径算法</h2><h3 id="Dijkstra-迪杰斯特拉-算法"><a href="#Dijkstra-迪杰斯特拉-算法" class="headerlink" title="Dijkstra(迪杰斯特拉)算法"></a>Dijkstra(迪杰斯特拉)算法</h3><p>Dijkstra(迪杰斯特拉)算法是典型的单源最短路径算法，用于计算一个节点到某个节点的最短路径。主要特点是以起始点为中心向外层层扩展，直到扩展到终点为止。</p><h4 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h4><img src="2019_02_23_08.png" width="40%"> <img src="2019_02_23_09.png" width="80%"><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> pointS <span class="keyword">struct</span> &#123;</span><br><span class="line">	ch   <span class="type">byte</span></span><br><span class="line">	step <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> littleQueue []pointS</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *littleQueue)</span></span> Push(v <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">	*q = <span class="built_in">append</span>(*q, v.(pointS))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *littleQueue)</span></span> Pop() <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">	x := (*q)[<span class="built_in">len</span>(*q)<span class="number">-1</span>]</span><br><span class="line">	*q = (*q)[:<span class="built_in">len</span>(*q)<span class="number">-1</span>]</span><br><span class="line">	<span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *littleQueue)</span></span> Len() <span class="type">int</span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(*q) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *littleQueue)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123; <span class="keyword">return</span> (*q)[i].step &lt; (*q)[j].step &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *littleQueue)</span></span> Swap(i, j <span class="type">int</span>)      &#123; (*q)[i], (*q)[j] = (*q)[j], (*q)[i] &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dijkstra</span><span class="params">(src <span class="type">byte</span>, dst <span class="type">byte</span>, distMaps <span class="keyword">map</span>[<span class="type">byte</span>]<span class="keyword">map</span>[<span class="type">byte</span>]<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="comment">// 定义小根堆，主要为了每次取最小的一个距离进行扩展</span></span><br><span class="line">	pq := <span class="built_in">make</span>(littleQueue, <span class="number">1</span>)</span><br><span class="line">	<span class="comment">// 把起点插入</span></span><br><span class="line">	pq[<span class="number">0</span>] = pointS&#123;src, <span class="number">0</span>&#125;</span><br><span class="line">	heap.Init(&amp;pq)</span><br><span class="line">	<span class="comment">// 记录一下从起点到某一个点的最小距离</span></span><br><span class="line">	finalDistMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">byte</span>]<span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> pq.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// 取头部当前已走的最小距离的点进行拓展</span></span><br><span class="line">		t := heap.Pop(&amp;pq).(pointS)</span><br><span class="line">		<span class="comment">// 如果当前是目的地址，那么步数就是最小的</span></span><br><span class="line">		<span class="comment">// 反证一下，假设存在一个更小的，那么肯定还没到目的点，如果到了，前面会插入到小根堆中，这次就不会取到大的</span></span><br><span class="line">		<span class="comment">//          如果没到，还得再走，距离会是那个点继续加，那么就不可能比当前更小</span></span><br><span class="line">		<span class="keyword">if</span> t.ch == dst &#123;</span><br><span class="line">			<span class="keyword">return</span> t.step</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 从此点向外走，获取此点能到的最近的点的距离</span></span><br><span class="line">		distMap := distMaps[t.ch]</span><br><span class="line">		<span class="keyword">for</span> i, v := <span class="keyword">range</span> distMap &#123;</span><br><span class="line">			<span class="comment">// 从起点到t再走到i的距离</span></span><br><span class="line">			step := t.step + v</span><br><span class="line">			<span class="comment">// 如果记录的到i点距离更小，这个点就不走了，因为之前记录那一次走过了</span></span><br><span class="line">			<span class="keyword">if</span> d, ok := finalDistMap[i]; ok &amp;&amp; d &lt;= step &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			finalDistMap[i] = step</span><br><span class="line">			heap.Push(&amp;pq, pointS&#123;i, step&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 定义好距离矩阵</span></span><br><span class="line">	distMaps := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">byte</span>]<span class="keyword">map</span>[<span class="type">byte</span>]<span class="type">int</span>)</span><br><span class="line">	distMaps[<span class="string">&#x27;A&#x27;</span>] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">byte</span>]<span class="type">int</span>)</span><br><span class="line">	distMaps[<span class="string">&#x27;A&#x27;</span>][<span class="string">&#x27;B&#x27;</span>] = <span class="number">6</span></span><br><span class="line">	distMaps[<span class="string">&#x27;A&#x27;</span>][<span class="string">&#x27;C&#x27;</span>] = <span class="number">3</span></span><br><span class="line">	distMaps[<span class="string">&#x27;B&#x27;</span>] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">byte</span>]<span class="type">int</span>)</span><br><span class="line">	distMaps[<span class="string">&#x27;B&#x27;</span>][<span class="string">&#x27;A&#x27;</span>] = <span class="number">6</span></span><br><span class="line">	distMaps[<span class="string">&#x27;B&#x27;</span>][<span class="string">&#x27;C&#x27;</span>] = <span class="number">2</span></span><br><span class="line">	distMaps[<span class="string">&#x27;B&#x27;</span>][<span class="string">&#x27;D&#x27;</span>] = <span class="number">5</span></span><br><span class="line">	distMaps[<span class="string">&#x27;C&#x27;</span>] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">byte</span>]<span class="type">int</span>)</span><br><span class="line">	distMaps[<span class="string">&#x27;C&#x27;</span>][<span class="string">&#x27;A&#x27;</span>] = <span class="number">3</span></span><br><span class="line">	distMaps[<span class="string">&#x27;C&#x27;</span>][<span class="string">&#x27;B&#x27;</span>] = <span class="number">2</span></span><br><span class="line">	distMaps[<span class="string">&#x27;C&#x27;</span>][<span class="string">&#x27;D&#x27;</span>] = <span class="number">3</span></span><br><span class="line">	distMaps[<span class="string">&#x27;C&#x27;</span>][<span class="string">&#x27;E&#x27;</span>] = <span class="number">4</span></span><br><span class="line">	distMaps[<span class="string">&#x27;D&#x27;</span>] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">byte</span>]<span class="type">int</span>)</span><br><span class="line">	distMaps[<span class="string">&#x27;D&#x27;</span>][<span class="string">&#x27;B&#x27;</span>] = <span class="number">5</span></span><br><span class="line">	distMaps[<span class="string">&#x27;D&#x27;</span>][<span class="string">&#x27;C&#x27;</span>] = <span class="number">3</span></span><br><span class="line">	distMaps[<span class="string">&#x27;D&#x27;</span>][<span class="string">&#x27;E&#x27;</span>] = <span class="number">2</span></span><br><span class="line">	distMaps[<span class="string">&#x27;D&#x27;</span>][<span class="string">&#x27;F&#x27;</span>] = <span class="number">3</span></span><br><span class="line">	distMaps[<span class="string">&#x27;E&#x27;</span>] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">byte</span>]<span class="type">int</span>)</span><br><span class="line">	distMaps[<span class="string">&#x27;E&#x27;</span>][<span class="string">&#x27;C&#x27;</span>] = <span class="number">4</span></span><br><span class="line">	distMaps[<span class="string">&#x27;E&#x27;</span>][<span class="string">&#x27;D&#x27;</span>] = <span class="number">2</span></span><br><span class="line">	distMaps[<span class="string">&#x27;E&#x27;</span>][<span class="string">&#x27;F&#x27;</span>] = <span class="number">5</span></span><br><span class="line">	distMaps[<span class="string">&#x27;F&#x27;</span>] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">byte</span>]<span class="type">int</span>)</span><br><span class="line">	distMaps[<span class="string">&#x27;F&#x27;</span>][<span class="string">&#x27;D&#x27;</span>] = <span class="number">3</span></span><br><span class="line">	distMaps[<span class="string">&#x27;F&#x27;</span>][<span class="string">&#x27;E&#x27;</span>] = <span class="number">5</span></span><br><span class="line">	<span class="comment">// A =&gt; F 最短路径为 A =&gt; C =&gt; D =&gt; F = 9</span></span><br><span class="line">	fmt.Println(dijkstra(<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, distMaps))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a>Floyd算法</h3><p>Floyd-Warshall算法（Floyd-Warshall algorithm）是解决任意两点间的最短路径的一种算法，可以正确处理有向图或负权的最短路径问题，同时也被用于计算有向图的传递闭包。Floyd-Warshall算法的时间复杂度为O(N3)，空间复杂度为O(N2)。</p><h4 id="算法描述-1"><a href="#算法描述-1" class="headerlink" title="算法描述"></a>算法描述</h4><p>使用距离矩阵，从第一个顶点开始，计算所有两个点通过1点的路径是否是最短。然后再从第二个顶点开始，同样计算所有两个点的路径是否是最短，直到所有点计算完毕，得到的距离矩阵即为最短路径。</p><p>示例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;log.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> InputFileName <span class="string">&quot;../input.txt&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按行返回数据</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">readFile</span><span class="params">(string &amp;input)</span> </span>&#123;</span><br><span class="line">    input = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> ifstream <span class="title">inFile</span><span class="params">(InputFileName)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!inFile) &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;Failed to open file %s&quot;</span>, InputFileName);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!inFile.<span class="built_in">eof</span>()) &#123;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">128</span>];</span><br><span class="line">        inFile.<span class="built_in">getline</span>(buf, <span class="number">128</span>);</span><br><span class="line">        input = <span class="built_in">string</span>(buf);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将字母转成数字</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getIndex</span><span class="params">(<span class="type">char</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (a) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;E&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;F&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将数字转成字母</span></span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">getChar</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (a) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;C&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;D&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;E&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;F&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//由于已知点数量，第一行废掉</span></span><br><span class="line">    string inputStr = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">readFile</span>(inputStr) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;Read file error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义距离矩阵</span></span><br><span class="line">    <span class="type">int</span> distance[<span class="number">6</span>][<span class="number">6</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">6</span>; ++j) &#123;</span><br><span class="line">            <span class="comment">//初始化所有距离为-1</span></span><br><span class="line">            distance[i][j] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//自己到自己为0</span></span><br><span class="line">        distance[i][i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    map&lt;string, string&gt; road;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">readFile</span>(inputStr) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> a = <span class="built_in">getIndex</span>(inputStr[<span class="number">0</span>]);      <span class="comment">//第一个点</span></span><br><span class="line">        <span class="type">int</span> b = <span class="built_in">getIndex</span>(inputStr[<span class="number">2</span>]);      <span class="comment">//第二个点</span></span><br><span class="line">        <span class="type">int</span> c = <span class="built_in">stoi</span>(inputStr.<span class="built_in">substr</span>(<span class="number">3</span>));   <span class="comment">//距离</span></span><br><span class="line">        <span class="comment">//赋值给距离矩阵</span></span><br><span class="line">        <span class="built_in">LOG_INFO</span>(<span class="string">&quot;%c--%c: %d&quot;</span>, <span class="built_in">getChar</span>(a), <span class="built_in">getChar</span>(b), c);</span><br><span class="line">        distance[a][b] = c;</span><br><span class="line">        <span class="comment">//添加到路由表</span></span><br><span class="line">        <span class="type">char</span> tmp[<span class="number">2</span>] = &#123;<span class="built_in">getChar</span>(a), <span class="built_in">getChar</span>(b)&#125;;</span><br><span class="line">        road[tmp] = <span class="built_in">string</span>(tmp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">6</span>; ++k) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">6</span>; ++j) &#123;</span><br><span class="line">                <span class="comment">//添加key</span></span><br><span class="line">                <span class="type">char</span> tmp[<span class="number">3</span>] = &#123;<span class="built_in">getChar</span>(i), <span class="built_in">getChar</span>(j), <span class="number">0x00</span>&#125;;</span><br><span class="line">                <span class="comment">//防止路径遗漏，补充路由表</span></span><br><span class="line">                <span class="keyword">if</span> (distance[i][j] != <span class="number">-1</span> &amp;&amp; road.<span class="built_in">count</span>(tmp) == <span class="number">0</span>) &#123;</span><br><span class="line">                    road[tmp] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//可通过k到达i且可通过k到达j</span></span><br><span class="line">                <span class="keyword">if</span> (distance[i][k] != <span class="number">-1</span> &amp;&amp; distance[k][j] != <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="comment">//ij之间没有通路或者当前计算的最短路径大于通过k到达的距离</span></span><br><span class="line">                    <span class="keyword">if</span> (distance[i][j] == <span class="number">-1</span> ||</span><br><span class="line">                        distance[i][j] &gt; distance[i][k] + distance[k][j]) &#123;</span><br><span class="line">                        distance[i][j] = distance[i][k] + distance[k][j];</span><br><span class="line">                        <span class="comment">//更新路由表</span></span><br><span class="line">                        <span class="type">char</span> tmp1[<span class="number">3</span>] = &#123;<span class="built_in">getChar</span>(i), <span class="built_in">getChar</span>(k), <span class="number">0x00</span>&#125;;</span><br><span class="line">                        <span class="type">char</span> tmp2[<span class="number">3</span>] = &#123;<span class="built_in">getChar</span>(k), <span class="built_in">getChar</span>(j), <span class="number">0x00</span>&#125;;</span><br><span class="line">                        string tmpRoad = road[tmp1];</span><br><span class="line">                        tmpRoad.<span class="built_in">pop_back</span>();     <span class="comment">//防止重复字母</span></span><br><span class="line">                        road[tmp] = tmpRoad + road[tmp2];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">6</span>; ++j) &#123;</span><br><span class="line">            <span class="built_in">PRINT</span>(<span class="string">&quot;%d\t&quot;</span>, distance[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">PRINT</span>(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印结果</span></span><br><span class="line">    <span class="built_in">PRINT</span>(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">    <span class="built_in">LOG_INFO</span>(<span class="string">&quot;Result:&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> m = <span class="number">0</span>; m &lt; <span class="number">6</span>; ++m) &#123;</span><br><span class="line">        <span class="type">char</span> tmp[<span class="number">3</span>] = &#123;<span class="built_in">getChar</span>(m), <span class="number">0x00</span>, <span class="number">0x00</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i) &#123;</span><br><span class="line">            tmp[<span class="number">1</span>] = <span class="built_in">getChar</span>(i);</span><br><span class="line">            <span class="built_in">LOG_INFO</span>(<span class="string">&quot;%c-&gt;%c %s: %d&quot;</span>, tmp[<span class="number">0</span>], tmp[<span class="number">1</span>], road[tmp].<span class="built_in">c_str</span>(), distance[m][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-bfs-（Breadth-First-Search）广度优先遍历"><a href="#3-bfs-（Breadth-First-Search）广度优先遍历" class="headerlink" title="3. bfs （Breadth-First Search）广度优先遍历"></a>3. bfs （Breadth-First Search）广度优先遍历</h2><ul><li>广度优先算法比较适合带环的图的最短路径，需要使用seen标记某个点是否被访问过</li></ul><h3 id="3-1-二叉树的广度优先遍历"><a href="#3-1-二叉树的广度优先遍历" class="headerlink" title="3.1. 二叉树的广度优先遍历"></a>3.1. 二叉树的广度优先遍历</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">	value <span class="type">int</span></span><br><span class="line">	left  *TreeNode</span><br><span class="line">	right *TreeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bfs</span><span class="params">(root *TreeNode)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> queue list.List</span><br><span class="line">	queue.PushBack(&amp;root)</span><br><span class="line">	<span class="keyword">for</span> queue.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">		node := queue.Front().Value.(*TreeNode)</span><br><span class="line">		queue.Remove(queue.Front())</span><br><span class="line">		<span class="keyword">if</span> node.left != <span class="literal">nil</span> &#123;</span><br><span class="line">			queue.PushBack(node.left)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> node.right != <span class="literal">nil</span> &#123;</span><br><span class="line">			queue.PushBack(node.right)</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println(node.value)	<span class="comment">// 这里取值</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-方格中找两点最短路径"><a href="#3-2-方格中找两点最短路径" class="headerlink" title="3.2. 方格中找两点最短路径"></a>3.2. 方格中找两点最短路径</h3><ul><li>两格之间步数为1，<code>#</code>作为墙不可走</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> pointT <span class="keyword">struct</span> &#123;</span><br><span class="line">	x <span class="type">int</span></span><br><span class="line">	y <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	<span class="comment">// 按照上下左右的相对位置设定，用于后面方便找四周的点</span></span><br><span class="line">	kRoundPoints = [][]<span class="type">int</span>&#123;</span><br><span class="line">		&#123;<span class="number">0</span>, <span class="number">-1</span>&#125;,</span><br><span class="line">		&#123;<span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">		&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">		&#123;<span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回从src到dst的最短路径长度，带层间隔版本</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bfsFloor</span><span class="params">(src pointT, dst pointT, grid []<span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="comment">// 减小计算量，走过的路不再走，记录一下哪里走过了</span></span><br><span class="line">	seen := <span class="built_in">make</span>([][]<span class="type">bool</span>, <span class="built_in">len</span>(grid))</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> seen &#123;</span><br><span class="line">		seen[i] = <span class="built_in">make</span>([]<span class="type">bool</span>, <span class="built_in">len</span>(grid[<span class="number">0</span>]))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 源地址记录走过了，注意x是第二维的坐标</span></span><br><span class="line">	seen[src.y][src.x] = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用层数作为步数</span></span><br><span class="line">	curDepth := <span class="number">0</span></span><br><span class="line">	<span class="keyword">var</span> queue list.List</span><br><span class="line">	<span class="comment">// 插入源地址，作为第一层，使用nil作为层间隔</span></span><br><span class="line">	queue.PushBack(src)</span><br><span class="line">	queue.PushBack(<span class="literal">nil</span>)</span><br><span class="line">	<span class="comment">// 队列一定含有一个层间隔，不在头就在尾，如果只剩一个层间隔，说明没路可走</span></span><br><span class="line">	<span class="keyword">for</span> queue.Len() &gt; <span class="number">1</span> &#123;</span><br><span class="line">		tmp := queue.Front().Value</span><br><span class="line">		queue.Remove(queue.Front())</span><br><span class="line">		<span class="keyword">if</span> tmp == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// 找到层间隔，说明当前层遍历完了，步数加一准备下一层</span></span><br><span class="line">			curDepth++</span><br><span class="line">			<span class="comment">// 当前层遍历完，队列剩余的都是下一层，加入一个层间隔</span></span><br><span class="line">			queue.PushBack(<span class="literal">nil</span>)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 判断当前点是不是目标点，如果是，说明走到了，返回步数</span></span><br><span class="line">		tx, ty := tmp.(pointT).x, tmp.(pointT).y</span><br><span class="line">		<span class="keyword">if</span> tx == dst.x &amp;&amp; ty == dst.y &#123;</span><br><span class="line">			<span class="keyword">return</span> curDepth</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 不是目标点，从此点出发，向四周走一下</span></span><br><span class="line">		<span class="keyword">for</span> i := <span class="keyword">range</span> kRoundPoints &#123;</span><br><span class="line">			px, py := tx+kRoundPoints[i][<span class="number">0</span>], ty+kRoundPoints[i][<span class="number">1</span>]</span><br><span class="line">			<span class="comment">// 如果超出边界或者已经走过了或者碰到墙，就继续</span></span><br><span class="line">			<span class="keyword">if</span> py &lt; <span class="number">0</span> || py &gt;= <span class="built_in">len</span>(grid) || px &lt; <span class="number">0</span> || px &gt;= <span class="built_in">len</span>(grid[<span class="number">0</span>]) || seen[py][px] || grid[py][px] == <span class="string">&#x27;#&#x27;</span> &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 这个点可以走，走上去，记录到队列中，作为下一层的起点</span></span><br><span class="line">			seen[py][px] = <span class="literal">true</span></span><br><span class="line">			queue.PushBack(pointT&#123;px, py&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> pointST <span class="keyword">struct</span> &#123;</span><br><span class="line">	x    <span class="type">int</span></span><br><span class="line">	y    <span class="type">int</span></span><br><span class="line">	step <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回从src到dst的最短路径长度</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bfs</span><span class="params">(src pointST, dst pointST, grid []<span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="comment">// 减小计算量，走过的路不再走，记录一下哪里走过了</span></span><br><span class="line">	seen := <span class="built_in">make</span>([][]<span class="type">bool</span>, <span class="built_in">len</span>(grid))</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> seen &#123;</span><br><span class="line">		seen[i] = <span class="built_in">make</span>([]<span class="type">bool</span>, <span class="built_in">len</span>(grid[<span class="number">0</span>]))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 源地址记录走过了，注意x是第二维的坐标</span></span><br><span class="line">	seen[src.y][src.x] = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> queue list.List</span><br><span class="line">	<span class="comment">// 插入源地址</span></span><br><span class="line">	queue.PushBack(src)</span><br><span class="line">	<span class="keyword">for</span> queue.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">		tmp := queue.Front().Value.(pointST)</span><br><span class="line">		queue.Remove(queue.Front())</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 判断当前点是不是目标点，如果是，说明走到了，返回步数</span></span><br><span class="line">		<span class="keyword">if</span> tmp.x == dst.x &amp;&amp; tmp.y == dst.y &#123;</span><br><span class="line">			<span class="keyword">return</span> tmp.step</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 不是目标点，从此点出发，向四周走一下</span></span><br><span class="line">		<span class="keyword">for</span> i := <span class="keyword">range</span> kRoundPoints &#123;</span><br><span class="line">			px, py := tmp.x+kRoundPoints[i][<span class="number">0</span>], tmp.y+kRoundPoints[i][<span class="number">1</span>]</span><br><span class="line">			<span class="comment">// 如果超出边界或者已经走过了或者碰到墙，就继续</span></span><br><span class="line">			<span class="keyword">if</span> py &lt; <span class="number">0</span> || py &gt;= <span class="built_in">len</span>(grid) || px &lt; <span class="number">0</span> || px &gt;= <span class="built_in">len</span>(grid[<span class="number">0</span>]) || seen[py][px] || grid[py][px] == <span class="string">&#x27;#&#x27;</span> &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 这个点可以走，走上去，记录到队列中，作为下一层的起点</span></span><br><span class="line">			seen[py][px] = <span class="literal">true</span></span><br><span class="line">			queue.PushBack(pointST&#123;px, py, tmp.step+<span class="number">1</span>&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		@ # . . *</span></span><br><span class="line"><span class="comment">		. . . # .</span></span><br><span class="line"><span class="comment">		# . . . .</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	grid := []<span class="type">string</span>&#123;<span class="string">&quot;@#..*&quot;</span>, <span class="string">&quot;...#.&quot;</span>, <span class="string">&quot;#....&quot;</span>&#125;</span><br><span class="line">	<span class="comment">// @ 到 * 的最短距离为6</span></span><br><span class="line">	fmt.Println(bfs(pointST&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, pointST&#123;<span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, grid))</span><br><span class="line">	fmt.Println(bfsFloor(pointT&#123;<span class="number">0</span>, <span class="number">0</span>&#125;, pointT&#123;<span class="number">4</span>, <span class="number">0</span>&#125;, grid))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-dfs-（Depth-First-Search）深度优先遍历"><a href="#4-dfs-（Depth-First-Search）深度优先遍历" class="headerlink" title="4. dfs （Depth-First Search）深度优先遍历"></a>4. dfs （Depth-First Search）深度优先遍历</h2><ul><li>dfs一般需要使用递归，可以用于无环图的最短路径查找，可以使用上一步走过的节点来防止重入</li></ul><h3 id="4-1-获取无环图的两个节点之间的路径"><a href="#4-1-获取无环图的两个节点之间的路径" class="headerlink" title="4.1. 获取无环图的两个节点之间的路径"></a>4.1. 获取无环图的两个节点之间的路径</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 起点、终点、上一个点，关系</span></span><br><span class="line"><span class="comment">// cb调用的是所有路上的节点，调用顺序是从e到s，因为dfs从最深处返回</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dfs</span><span class="params">(s, e, last <span class="type">int</span>, rel [][]<span class="type">int</span>, cb <span class="keyword">func</span>(n <span class="type">int</span>)</span></span>) <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> s == e &#123;</span><br><span class="line">		cb(e)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 从起点出发，所有能走的点走一遍</span></span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> rel[s] &#123;</span><br><span class="line">		<span class="comment">// 上一次就是这个点，不能回去</span></span><br><span class="line">		<span class="comment">// 或此路不通，继续</span></span><br><span class="line">		<span class="keyword">if</span> v == last || !dfs(v, e, s, rel, cb) &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 此路可以到达，将当前点输出出去</span></span><br><span class="line">		cb(s)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 都到不了</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">				 1</span></span><br><span class="line"><span class="comment">			   /   \</span></span><br><span class="line"><span class="comment">			  2     3</span></span><br><span class="line"><span class="comment">			 /\    / \</span></span><br><span class="line"><span class="comment">			4  5  0   6</span></span><br><span class="line"><span class="comment">			  / \</span></span><br><span class="line"><span class="comment">			 7   8</span></span><br><span class="line"><span class="comment">			/</span></span><br><span class="line"><span class="comment">		   9</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="comment">// 关系图，代表某个点和哪个点连接</span></span><br><span class="line">	rel := [][]<span class="type">int</span>&#123;</span><br><span class="line">		&#123;<span class="number">3</span>&#125;,       <span class="comment">// 0</span></span><br><span class="line">		&#123;<span class="number">2</span>, <span class="number">3</span>&#125;,    <span class="comment">// 1</span></span><br><span class="line">		&#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>&#125;, <span class="comment">// 2</span></span><br><span class="line">		&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">6</span>&#125;, <span class="comment">// 3</span></span><br><span class="line">		&#123;<span class="number">2</span>&#125;,       <span class="comment">// 4</span></span><br><span class="line">		&#123;<span class="number">2</span>, <span class="number">7</span>, <span class="number">8</span>&#125;, <span class="comment">// 5</span></span><br><span class="line">		&#123;<span class="number">3</span>&#125;,       <span class="comment">// 6</span></span><br><span class="line">		&#123;<span class="number">5</span>, <span class="number">9</span>&#125;,    <span class="comment">// 7</span></span><br><span class="line">		&#123;<span class="number">5</span>&#125;,       <span class="comment">// 8</span></span><br><span class="line">		&#123;<span class="number">7</span>&#125;,       <span class="comment">// 9</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	road := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">	dfs(<span class="number">4</span>, <span class="number">6</span>, <span class="number">-1</span>, rel, <span class="function"><span class="keyword">func</span><span class="params">(n <span class="type">int</span>)</span></span> &#123; road = <span class="built_in">append</span>(road, n) &#125;)</span><br><span class="line">	fmt.Println(road) <span class="comment">// 6 3 1 2 4</span></span><br><span class="line"></span><br><span class="line">	road = road[:<span class="number">0</span>]</span><br><span class="line">	dfs(<span class="number">4</span>, <span class="number">4</span>, <span class="number">-1</span>, rel, <span class="function"><span class="keyword">func</span><span class="params">(n <span class="type">int</span>)</span></span> &#123; road = <span class="built_in">append</span>(road, n) &#125;)</span><br><span class="line">	fmt.Println(road) <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">	road = road[:<span class="number">0</span>]</span><br><span class="line">	dfs(<span class="number">9</span>, <span class="number">8</span>, <span class="number">-1</span>, rel, <span class="function"><span class="keyword">func</span><span class="params">(n <span class="type">int</span>)</span></span> &#123; road = <span class="built_in">append</span>(road, n) &#125;)</span><br><span class="line">	fmt.Println(road) <span class="comment">// 8 5 7 9</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-全排列算法（回溯法）"><a href="#5-全排列算法（回溯法）" class="headerlink" title="5. 全排列算法（回溯法）"></a>5. 全排列算法（回溯法）</h2><img src="2020_04_29_01.png"><ul><li>原理是遍历替换首字母和后面的字符，替换到最后输出</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全排列</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">permutation</span><span class="params">(str []<span class="type">byte</span>, index <span class="type">int</span>, f <span class="keyword">func</span>(str []<span class="type">byte</span>)</span></span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(str) == index &#123;</span><br><span class="line">        <span class="comment">// 这里输出结果</span></span><br><span class="line">		f(str)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 不交换的场景</span></span><br><span class="line">	permutation(str, index+<span class="number">1</span>, f)</span><br><span class="line">	<span class="comment">// index对应位置向后交换</span></span><br><span class="line">	<span class="keyword">for</span> i := index + <span class="number">1</span>; i &lt; <span class="built_in">len</span>(str); i++ &#123;</span><br><span class="line">		str[i], str[index] = str[index], str[i]</span><br><span class="line">		permutation(str, index+<span class="number">1</span>, f)</span><br><span class="line">		str[i], str[index] = str[index], str[i]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-动态规划"><a href="#6-动态规划" class="headerlink" title="6. 动态规划"></a>6. 动态规划</h2><ul><li>动态规划一般是推导真实场景的某一状态和下一状态之间的关系</li><li>根据两个状态的关系列出方程，然后从第一个状态不断向状态n靠近</li></ul><h3 id="6-1-背包算法"><a href="#6-1-背包算法" class="headerlink" title="6.1. 背包算法"></a>6.1. 背包算法</h3><h4 id="1-01背包"><a href="#1-01背包" class="headerlink" title="1) 01背包"></a>1) 01背包</h4><ul><li>主要解决选元素的方案数的问题</li><li>思想是考虑选择出来的元素要装到背包中，每个元素都有装或者不装两个选择</li><li>背包本身的价值可以使用map进行枚举，每个元素选择是否装入背包，装入则背包价值增加</li><li>每个价值的方案数因为一个元素的加入可以列出状态转移方程</li></ul><p>$$<br>count(价值) &#x3D; count(不包含这个元素时已有的方案数) + f(加上这个元素可以达到价值对应的方案数)<br>$$</p><ul><li>典型题目: <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-the-number-of-square-free-subsets/">无平方子集</a>，对应<a href="/bookPages/docs/leetcode/medium/leetcode2572/">讲解</a></li></ul><h3 id="6-2-数位dp"><a href="#6-2-数位dp" class="headerlink" title="6.2. 数位dp"></a>6.2. 数位dp</h3><ul><li>主要求某个上线以下满足某个条件的数的数量</li><li>一般上界很大，暴力会超时</li><li>主要思想是记忆化搜索，从最高位开始，向低位遍历每一位能取到的值，记忆一个状态下去</li></ul><h4 id="1-记忆化搜索模板"><a href="#1-记忆化搜索模板" class="headerlink" title="1) 记忆化搜索模板"></a>1) 记忆化搜索模板</h4><ul><li>在小于上界范围内，如果数可以从0到最大的n个9，同一个状态下，数量是一样的，记录下来不用重复统计</li><li>不可以取到最大n个9的单独计算</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数位dp模板</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NumDP</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> mod <span class="type">int</span> = <span class="number">1e9</span> + <span class="number">7</span></span><br><span class="line">	max_sum := <span class="number">10</span></span><br><span class="line"></span><br><span class="line">	stateNum := max_sum</span><br><span class="line">	<span class="comment">// 返回小于s的满足条件的数量</span></span><br><span class="line">	getCount := <span class="function"><span class="keyword">func</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">		<span class="comment">// 状态记忆数组，第一维是位数，第二维是状态（状态根据具体情况来），value是从这一位向后满足状态的数量</span></span><br><span class="line">		memo := <span class="built_in">make</span>([][]<span class="type">int</span>, <span class="built_in">len</span>(s))</span><br><span class="line">		<span class="keyword">for</span> i := <span class="keyword">range</span> memo &#123;</span><br><span class="line">			memo[i] = <span class="built_in">make</span>([]<span class="type">int</span>, stateNum+<span class="number">1</span>)</span><br><span class="line">			<span class="keyword">for</span> j := <span class="keyword">range</span> memo[i] &#123;</span><br><span class="line">				memo[i][j] = <span class="number">-1</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// p为当前要枚举的位，0是最高位，len(s)-1是最低位</span></span><br><span class="line">		<span class="comment">// sum是前面位数的和</span></span><br><span class="line">		<span class="comment">// limitUp代表前面的数位是否都到达上界</span></span><br><span class="line">		<span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(p, sum <span class="type">int</span>, limitUp <span class="type">bool</span>)</span></span> (res <span class="type">int</span>)</span><br><span class="line">		dfs = <span class="function"><span class="keyword">func</span><span class="params">(p, sum <span class="type">int</span>, limitUp <span class="type">bool</span>)</span></span> (res <span class="type">int</span>) &#123;</span><br><span class="line">			<span class="comment">// 处理一些限制条件</span></span><br><span class="line">			<span class="comment">// TODO</span></span><br><span class="line">			<span class="keyword">if</span> p == <span class="built_in">len</span>(s) &#123;</span><br><span class="line">				<span class="comment">// 到最后一位了，满足条件返回1，不满足返回0</span></span><br><span class="line">				<span class="comment">// TODO</span></span><br><span class="line">				<span class="keyword">if</span> <span class="literal">true</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> !limitUp &#123;</span><br><span class="line">				<span class="comment">// 没到上界才能取状态下的值，否则状态是假的</span></span><br><span class="line">				tmp := memo[p][sum]</span><br><span class="line">				<span class="keyword">if</span> tmp &gt;= <span class="number">0</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> tmp</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; memo[p][sum] = res &#125;()</span><br><span class="line">			&#125;</span><br><span class="line">			up := <span class="number">9</span></span><br><span class="line">			<span class="keyword">if</span> limitUp &#123;</span><br><span class="line">				up = <span class="type">int</span>(s[p] - <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> d := <span class="number">0</span>; d &lt;= up; d++ &#123;</span><br><span class="line">				res = (res + dfs(p+<span class="number">1</span>, sum+d, limitUp &amp;&amp; d == <span class="type">int</span>(s[p]-<span class="string">&#x27;0&#x27;</span>))) % mod</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> dfs(<span class="number">0</span>, <span class="number">0</span>, <span class="literal">true</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	getCount(<span class="string">&quot;1234&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-示例"><a href="#2-示例" class="headerlink" title="2) 示例"></a>2) 示例</h4><h5 id="1-求不大于给定数字s，所有位数相加小于n的数量，答案对1000000007取模"><a href="#1-求不大于给定数字s，所有位数相加小于n的数量，答案对1000000007取模" class="headerlink" title="(1) 求不大于给定数字s，所有位数相加小于n的数量，答案对1000000007取模"></a>(1) 求不大于给定数字s，所有位数相加小于n的数量，答案对1000000007取模</h5><ul><li>直接套用模板，限定条件带入，状态定义好</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数位dp模板</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">count</span><span class="params">(s <span class="type">string</span>, n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> mod <span class="type">int</span> = <span class="number">1e9</span> + <span class="number">7</span></span><br><span class="line"></span><br><span class="line">	stateNum := n</span><br><span class="line">	<span class="comment">// 状态记忆数组，第一维是位数，第二维是状态（状态为前面位加在一起的和），value是从这一位向后满足状态的数量</span></span><br><span class="line">	memo := <span class="built_in">make</span>([][]<span class="type">int</span>, <span class="built_in">len</span>(s))</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> memo &#123;</span><br><span class="line">		memo[i] = <span class="built_in">make</span>([]<span class="type">int</span>, stateNum+<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">for</span> j := <span class="keyword">range</span> memo[i] &#123;</span><br><span class="line">			memo[i][j] = <span class="number">-1</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// p为当前要枚举的位，0是最高位，len(s)-1是最低位</span></span><br><span class="line">	<span class="comment">// sum是前面位数的和</span></span><br><span class="line">	<span class="comment">// limitUp代表前面的数位是否都到达上界</span></span><br><span class="line">	<span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(p, sum <span class="type">int</span>, limitUp <span class="type">bool</span>)</span></span> (res <span class="type">int</span>)</span><br><span class="line">	dfs = <span class="function"><span class="keyword">func</span><span class="params">(p, sum <span class="type">int</span>, limitUp <span class="type">bool</span>)</span></span> (res <span class="type">int</span>) &#123;</span><br><span class="line">		<span class="comment">// 处理一些限制条件</span></span><br><span class="line">		<span class="comment">// 和不能大于n</span></span><br><span class="line">		<span class="keyword">if</span> sum &gt; n &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> p == <span class="built_in">len</span>(s) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> !limitUp &#123;</span><br><span class="line">			<span class="comment">// 没到上界才能取状态下的值，否则状态是假的</span></span><br><span class="line">			tmp := memo[p][sum]</span><br><span class="line">			<span class="keyword">if</span> tmp &gt;= <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> tmp</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; memo[p][sum] = res &#125;()</span><br><span class="line">		&#125;</span><br><span class="line">		up := <span class="number">9</span></span><br><span class="line">		<span class="keyword">if</span> limitUp &#123;</span><br><span class="line">			up = <span class="type">int</span>(s[p] - <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> d := <span class="number">0</span>; d &lt;= up; d++ &#123;</span><br><span class="line">			res = (res + dfs(p+<span class="number">1</span>, sum+d, limitUp &amp;&amp; d == <span class="type">int</span>(s[p]-<span class="string">&#x27;0&#x27;</span>))) % mod</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dfs(<span class="number">0</span>, <span class="number">0</span>, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(count(<span class="string">&quot;12&quot;</span>, <span class="number">8</span>))	<span class="comment">// 12</span></span><br><span class="line">	fmt.Println(count(<span class="string">&quot;13&quot;</span>, <span class="number">8</span>))	<span class="comment">// 13</span></span><br><span class="line">	fmt.Println(count(<span class="string">&quot;19&quot;</span>, <span class="number">8</span>))	<span class="comment">// 17</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-gcd-最大公约数算法"><a href="#7-gcd-最大公约数算法" class="headerlink" title="7. gcd 最大公约数算法"></a>7. gcd 最大公约数算法</h2><ul><li>利用欧几里得算法，即辗转相除法</li></ul><h3 id="证明-1"><a href="#证明-1" class="headerlink" title="证明"></a>证明</h3><ul><li>a可以表示成 $a &#x3D; kb + r$（a，b，k，r皆为正整数，且 $r&lt;b$ ），则 $r &#x3D; a\ mod\ b$</li><li>假设d是a,b的一个公约数，记作 $d|a, d|b$，即a和b都可以被d整除。</li><li>而 $r &#x3D; a - kb$，两边同时除以d， $r&#x2F;d &#x3D; a&#x2F;d - kb&#x2F;d &#x3D; m$，由等式右边可知m为整数，因此 $d|r$</li><li>因此d也是 $b, a\ mod\ b$ 的公约数</li><li>假设d是 $b, a\ mod\ b$ 的公约数, 则 $d|b,d|(a - k \times b)$，k是一个整数</li><li>因此 $(a, b)$ 和 $(b,a\ mod\ b)$ 的公约数是一样的，其最大公约数也必然相等，得证</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcd</span><span class="params">(a <span class="type">int</span>, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="comment">// 当a为最大公约数时，计算后a = 0，b = a</span></span><br><span class="line">	<span class="keyword">for</span> a != <span class="number">0</span> &#123;</span><br><span class="line">		a, b = b%a, a</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-选取中位数"><a href="#8-选取中位数" class="headerlink" title="8. 选取中位数"></a>8. 选取中位数</h2><ul><li>可以使用两个堆，一个大根堆一个小根堆，中间的就是中位数</li></ul><h2 id="9-位运算的骚操作"><a href="#9-位运算的骚操作" class="headerlink" title="9. 位运算的骚操作"></a>9. 位运算的骚操作</h2><h3 id="9-1-取反"><a href="#9-1-取反" class="headerlink" title="9.1. 取反"></a>9.1. 取反</h3><h4 id="1-从低到高找第一个1"><a href="#1-从低到高找第一个1" class="headerlink" title="1) 从低到高找第一个1"></a>1) 从低到高找第一个1</h4><ul><li>取反加1，再和原来数字与一下</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getFirst</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	v := (^i) + <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> i &amp; v</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>举个例子，<code>0b00110010</code>，取反<code>0b11001101</code>，加一<code>0b11001110</code>，与一下原来的数<code>0b00000010</code></li></ul><h3 id="9-2-异或"><a href="#9-2-异或" class="headerlink" title="9.2. 异或"></a>9.2. 异或</h3><h4 id="1-0和1的互转"><a href="#1-0和1的互转" class="headerlink" title="1) 0和1的互转"></a>1) 0和1的互转</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := <span class="number">1</span></span><br><span class="line">	fmt.Println(a) <span class="comment">// 1</span></span><br><span class="line">	a ^= <span class="number">1</span></span><br><span class="line">	fmt.Println(a) <span class="comment">// 0</span></span><br><span class="line">	a ^= <span class="number">1</span></span><br><span class="line">	fmt.Println(a) <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-3-与运算"><a href="#9-3-与运算" class="headerlink" title="9.3. 与运算"></a>9.3. 与运算</h3><h4 id="1-2的幂次取整"><a href="#1-2的幂次取整" class="headerlink" title="1) 2的幂次取整"></a>1) 2的幂次取整</h4><h5 id="向下取整"><a href="#向下取整" class="headerlink" title="向下取整"></a>向下取整</h5><ul><li>直接二进制上与要取整的数减一取反就好了，如要对8也就是<code>0b1000</code>取整，就是与上<code>0b11111000</code></li></ul><h5 id="向上取整"><a href="#向上取整" class="headerlink" title="向上取整"></a>向上取整</h5><ul><li>由于需要有多余位就加一个，防止判断可以使用加上取整的数减一然后再对其取反相与</li><li>如要对8向上取整就是<code>(i + 0b00000111) &amp; 0b11111000</code></li></ul><h2 id="10-LCA-（Lowest-Common-Ancestor）最近公共祖先算法"><a href="#10-LCA-（Lowest-Common-Ancestor）最近公共祖先算法" class="headerlink" title="10. LCA （Lowest Common Ancestor）最近公共祖先算法"></a>10. LCA （Lowest Common Ancestor）最近公共祖先算法</h2><ul><li>主要处理无环图的两个点的公共祖先，一般用于求两个点之间的路径</li></ul><h3 id="10-1-Tarjan算法处理LCA"><a href="#10-1-Tarjan算法处理LCA" class="headerlink" title="10.1. Tarjan算法处理LCA"></a>10.1. Tarjan算法处理LCA</h3><ul><li>一次遍历把所有询问解决完</li><li>有个通俗的解释，十分清晰说明这个算法，参考 <a target="_blank" rel="noopener" href="https://www.zhihu.com/question/68753603/answer/267513879">如何理解 Tarjan 的 LCA 算法？</a></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个熊孩子Link从一棵有根树的最左边最底下的结点灌岩浆，Link表示很讨厌这种倒着长的树。岩浆会不断的注入，直到注满整个树…如果岩浆灌满了一棵子树，Link发现树的另一边有一棵更深的子树，Link会先去将那棵子树灌满。岩浆只有在迫不得已的情况下才会向上升高，找到一个新的子树继续注入。机(yu)智(chun)的Link发现了找LCA的好方法，即如果两个结点都被岩浆烧掉时，他们的LCA即为那棵子树上岩浆最高的位置。</span><br></pre></td></tr></table></figure><ul><li>所以我们可以从根节点开始，向下走，当两个点都走到了，当前子树的根节点就是最近公共祖先，用并查集处理当前子树的根节点</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">				 0</span></span><br><span class="line"><span class="comment">			   /   \</span></span><br><span class="line"><span class="comment">			  2     3</span></span><br><span class="line"><span class="comment">			 /\    / \</span></span><br><span class="line"><span class="comment">			4  5  1   6</span></span><br><span class="line"><span class="comment">			  / \</span></span><br><span class="line"><span class="comment">			 7   8</span></span><br><span class="line"><span class="comment">			/</span></span><br><span class="line"><span class="comment">		   9</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="comment">// 关系图，代表某个点和哪个点连接</span></span><br><span class="line">	rel := [][]<span class="type">int</span>&#123;</span><br><span class="line">		&#123;<span class="number">2</span>, <span class="number">3</span>&#125;,    <span class="comment">// 0</span></span><br><span class="line">		&#123;<span class="number">3</span>&#125;,       <span class="comment">// 1</span></span><br><span class="line">		&#123;<span class="number">0</span>, <span class="number">4</span>, <span class="number">5</span>&#125;, <span class="comment">// 2</span></span><br><span class="line">		&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">6</span>&#125;, <span class="comment">// 3</span></span><br><span class="line">		&#123;<span class="number">2</span>&#125;,       <span class="comment">// 4</span></span><br><span class="line">		&#123;<span class="number">2</span>, <span class="number">7</span>, <span class="number">8</span>&#125;, <span class="comment">// 5</span></span><br><span class="line">		&#123;<span class="number">3</span>&#125;,       <span class="comment">// 6</span></span><br><span class="line">		&#123;<span class="number">5</span>, <span class="number">9</span>&#125;,    <span class="comment">// 7</span></span><br><span class="line">		&#123;<span class="number">5</span>&#125;,       <span class="comment">// 8</span></span><br><span class="line">		&#123;<span class="number">7</span>&#125;,       <span class="comment">// 9</span></span><br><span class="line">	&#125;</span><br><span class="line">	n := <span class="number">10</span></span><br><span class="line"></span><br><span class="line">	trips := [][]<span class="type">int</span>&#123;</span><br><span class="line">		&#123;<span class="number">4</span>, <span class="number">9</span>&#125;, <span class="comment">// 2</span></span><br><span class="line">		&#123;<span class="number">5</span>, <span class="number">6</span>&#125;, <span class="comment">// 0</span></span><br><span class="line">		&#123;<span class="number">1</span>, <span class="number">6</span>&#125;, <span class="comment">// 3</span></span><br><span class="line">		&#123;<span class="number">9</span>, <span class="number">0</span>&#125;, <span class="comment">// 0</span></span><br><span class="line">		&#123;<span class="number">7</span>, <span class="number">8</span>&#125;, <span class="comment">// 5</span></span><br><span class="line">	&#125;</span><br><span class="line">	qs := <span class="keyword">map</span>[<span class="type">int</span>][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> trips &#123;</span><br><span class="line">		x, y := v[<span class="number">0</span>], v[<span class="number">1</span>]</span><br><span class="line">		qs[x] = <span class="built_in">append</span>(qs[x], y)</span><br><span class="line">		<span class="keyword">if</span> x != y &#123;</span><br><span class="line">			<span class="comment">// 这里防止自己走到自己多算一遍</span></span><br><span class="line">			qs[y] = <span class="built_in">append</span>(qs[y], x)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 并查集模板</span></span><br><span class="line">	uf := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> uf &#123;</span><br><span class="line">		uf[i] = i</span><br><span class="line">	&#125;</span><br><span class="line">	find := <span class="function"><span class="keyword">func</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">		ap := uf[x]</span><br><span class="line">		<span class="comment">// 找到最终节点</span></span><br><span class="line">		<span class="keyword">for</span> ap != uf[ap] &#123;</span><br><span class="line">			ap = uf[ap]</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 沿途都赋值最终节点</span></span><br><span class="line">		<span class="keyword">for</span> x != ap &#123;</span><br><span class="line">			uf[x], x = ap, uf[x]</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ap</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 把a的子集合并到b上，如果b是树根节点，a的所有子节点查找都会查找到b</span></span><br><span class="line">	merge := <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">		uf[find(a)] = find(b)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	color := <span class="built_in">make</span>([]<span class="type">bool</span>, n)</span><br><span class="line">	<span class="keyword">var</span> tarjan <span class="function"><span class="keyword">func</span><span class="params">(a, fa <span class="type">int</span>, cb <span class="keyword">func</span>(a, b, lca <span class="type">int</span>)</span></span>)</span><br><span class="line">	tarjan = <span class="function"><span class="keyword">func</span><span class="params">(a, fa <span class="type">int</span>, cb <span class="keyword">func</span>(a, b, lca <span class="type">int</span>)</span></span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> _, v := <span class="keyword">range</span> rel[a] &#123;</span><br><span class="line">			<span class="keyword">if</span> v == fa &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			tarjan(v, a, cb)</span><br><span class="line">			<span class="comment">// 进去出来后，将v为根节点的子树设置公共祖先为a</span></span><br><span class="line">			merge(v, a)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 查一下有没有要求的LCA</span></span><br><span class="line">		<span class="keyword">for</span> _, v := <span class="keyword">range</span> qs[a] &#123;</span><br><span class="line">			<span class="keyword">if</span> v != a &amp;&amp; !color[v] &#123;</span><br><span class="line">				<span class="comment">// 自己走到自己是可以计算的，要判断</span></span><br><span class="line">				<span class="comment">// v还没走到，继续</span></span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			cb(a, v, find(v))</span><br><span class="line">		&#125;</span><br><span class="line">		color[a] = <span class="literal">true</span> <span class="comment">// a被灌了岩浆，也就是a的子树走完了，要向上走了</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 从0向下走</span></span><br><span class="line">	tarjan(<span class="number">0</span>, <span class="number">-1</span>, <span class="function"><span class="keyword">func</span><span class="params">(a, b, lca <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">		fmt.Println(a, b, lca)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11-差分"><a href="#11-差分" class="headerlink" title="11. 差分"></a>11. 差分</h2><h3 id="11-1-数组差分"><a href="#11-1-数组差分" class="headerlink" title="11.1. 数组差分"></a>11.1. 数组差分</h3><table><thead><tr><th>原数组</th><th>9</th><th>4</th><th>7</th><th>5</th><th>9</th></tr></thead><tbody><tr><td>前缀和</td><td>9</td><td>13</td><td>20</td><td>25</td><td>34</td></tr><tr><td>差分</td><td>9</td><td>-5</td><td>3</td><td>-2</td><td>4</td></tr><tr><td>前缀和的差分</td><td>9</td><td>4</td><td>7</td><td>5</td><td>9</td></tr><tr><td>差分的前缀和</td><td>9</td><td>4</td><td>7</td><td>5</td><td>9</td></tr></tbody></table><h3 id="11-2-树上差分"><a href="#11-2-树上差分" class="headerlink" title="11.2. 树上差分"></a>11.2. 树上差分</h3><ul><li>对下面的一棵树</li></ul><img src="2023-04-19-01.png"><ul><li>如果想要从一个点到另一个点中间经过的所有点都加一，通常做法是dfs遍历，经过的点都加一</li><li>单独一次请求时间复杂度为 $O(n)$ ，如果q次请求，时间复杂度就是 $O(nq)$</li><li>使用差分只需要设置两个点和他们的公共祖先和祖先的父级就可以标记，标记的时间复杂度为 $O(n + q)$ ，因为LCA使用Tarjan算法就可以实现一次遍历全部查询出来</li><li>LCA和Tarjan就不多叙述，见上文，这里说明一下差分如何推出原始数组</li><li>上图的树，假设从节点8到节点6，差分标记8和6都为1，节点3为拐点或称公共祖先，标记-1，3的父节点0标记-1</li></ul><img src="2023-04-19-02.png"><ul><li>那么一次dfs的处理就是，到根节点，将cnt加上当前值，返回给上一个节点，那么8和6到达3之前的都会设置为1，其他非路径的子树设置为0</li></ul><img src="2023-04-19-03.png"><ul><li>父节点的树等于两个子节点的和加上当前的差分，节点3就是<code>1 + 1 - 1 = 1</code>，节点0就是<code>1 + 0 - 1 = 0</code></li></ul><img src="2023-04-19-04.png"><ul><li>可以发现一次dfs处理后，所有节点都设置完了，而对应走过的路都被标记了1，很完美</li></ul></div><div class="reward-container"><div></div><button onclick='var qr=document.getElementById("qr");qr.style.display="none"===qr.style.display?"block":"none"'>打赏</button><div id="qr" style="display:none"><div style="display:inline-block"><img src="/images/wechatpay.png" alt="王钰博 微信支付"><p>微信支付</p></div><div style="display:inline-block"><img src="/images/alipay.jpg" alt="王钰博 支付宝"><p>支付宝</p></div></div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/%E7%AE%97%E6%B3%95/" rel="tag"># 算法</a></div><div class="post-nav"><div class="post-nav-item"><a href="/blogs/2018-09-16-shellStudy/" rel="prev" title="shell学习笔记"><i class="fa fa-chevron-left"></i> shell学习笔记</a></div><div class="post-nav-item"><a href="/blogs/2018-09-18-latexStudy/" rel="next" title="latex笔记">latex笔记 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="valine-comments"></div><script>window.addEventListener("tabs:register",()=>{let{activeClass:t}=CONFIG.comments;if(CONFIG.comments.storage&&(t=localStorage.getItem("comments_active")||t),t){let e=document.querySelector(`a[href="#comment-${t}"]`);e&&e.click()}}),CONFIG.comments.storage&&window.addEventListener("tabs:click",t=>{if(!t.target.matches(".tabs-comment .tab-content .tab-pane"))return;let e=t.target.classList[1];localStorage.setItem("comments_active",e)})</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-text">前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0"><span class="nav-text">一、数学知识复习</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E6%95%B0"><span class="nav-text">对数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E7%90%86-1-1"><span class="nav-text">定理 1.1</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%A7%E6%95%B0"><span class="nav-text">级数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%A0%E4%BD%95%E7%BA%A7%E6%95%B0%E5%85%AC%E5%BC%8F"><span class="nav-text">几何级数公式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90"><span class="nav-text">二、算法分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80"><span class="nav-text">1. 数学基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E5%9B%9B%E4%B8%AA%E5%AE%9A%E4%B9%89"><span class="nav-text">1.1. 四个定义</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88"><span class="nav-text">2. 排列组合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E5%85%AC%E5%BC%8F%E8%AE%B0%E5%BD%95"><span class="nav-text">2.1. 公式记录</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E8%B4%A8%E6%95%B0"><span class="nav-text">3. 质数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E5%9F%83%E6%B0%8F%E7%AD%9B"><span class="nav-text">3.1. 埃氏筛</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%81%E6%98%8E"><span class="nav-text">证明</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E6%AC%A7%E6%8B%89%E7%BA%BF%E6%80%A7%E7%AD%9B%EF%BC%9A%E4%BD%BF%E7%94%A8O-n-%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%89%BE%E5%87%BAn%E4%BB%A5%E5%86%85%E7%9A%84%E6%89%80%E6%9C%89%E8%B4%A8%E6%95%B0"><span class="nav-text">3.2. 欧拉线性筛：使用O(n)的时间复杂度找出n以内的所有质数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-text">三、数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E6%A0%91"><span class="nav-text">1. 树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E5%85%AC%E5%85%B1%E9%83%A8%E5%88%86"><span class="nav-text">1.1. 公共部分</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E9%81%8D%E5%8E%86"><span class="nav-text">1) 遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E5%92%8C%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86"><span class="nav-text">(1) 树的深度优先和广度优先遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86"><span class="nav-text">深度优先遍历</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86"><span class="nav-text">广度优先遍历</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%BA%A6"><span class="nav-text">2) 度</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">1.2. 二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E6%80%A7%E8%B4%A8%E5%92%8C%E7%AE%97%E6%B3%95"><span class="nav-text">1) 性质和算法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-text">(1) 二叉树前中后序遍历</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">(2) 完全二叉树和满二叉树</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-text">2) 二叉搜索树</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%A7%E8%B4%A8"><span class="nav-text">性质</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%A4%A7%EF%BC%88%E5%B0%8F%EF%BC%89%E6%A0%B9%E5%A0%86%EF%BC%88%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%EF%BC%89"><span class="nav-text">3) 大（小）根堆（优先队列）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%A7%E8%B4%A8%E5%92%8C%E5%BA%94%E7%94%A8"><span class="nav-text">性质和应用</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="nav-text">4) 红黑树</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E7%89%B9%E6%80%A7%E5%92%8C%E5%BA%94%E7%94%A8"><span class="nav-text">(1) 红黑树的特性和应用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="nav-text">1.3. 线段树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%8E%9F%E7%90%86"><span class="nav-text">1) 原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E7%A4%BA%E4%BE%8B1-%E5%8C%BA%E9%97%B4%E5%92%8C%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="nav-text">2) 示例1 区间和的个数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-hashTable-%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="nav-text">2. hashTable 哈希表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E9%99%A4%E6%95%B0%E8%A6%81%E7%94%A8%E7%B4%A0%E6%95%B0"><span class="nav-text">2.1. 为什么哈希表的除数要用素数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%81%87%E8%AE%BE"><span class="nav-text">1) 假设</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E6%95%88%E6%9E%9C"><span class="nav-text">2) 效果</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E7%BB%93%E8%AE%BA"><span class="nav-text">3) 结论</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-bitmap-%E4%BD%8D%E5%9B%BE"><span class="nav-text">3. bitmap 位图</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E5%8E%9F%E7%90%86"><span class="nav-text">3.1. 原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E4%B8%BE%E4%BE%8B"><span class="nav-text">3.2. 举例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%AE%9E%E7%8E%B0"><span class="nav-text">1) 实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-ST-%E7%A8%80%E7%96%8F%E8%A1%A8"><span class="nav-text">4. ST 稀疏表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-%E5%8E%9F%E7%90%86"><span class="nav-text">4.1. 原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="nav-text">5. 并查集</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-%E5%8E%9F%E7%90%86"><span class="nav-text">5.1. 原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-%E5%AE%9E%E7%8E%B0"><span class="nav-text">5.2. 实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E7%AE%97%E6%B3%95"><span class="nav-text">四、算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="nav-text">1. 排序算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%80%BB%E7%BB%93"><span class="nav-text">时间复杂度总结</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E7%90%86"><span class="nav-text">定理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="nav-text">1.1. 插入排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E7%90%86"><span class="nav-text">原理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="nav-text">1.2. 希尔排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E7%90%86-1"><span class="nav-text">定理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="nav-text">1.3. 堆排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%EF%BC%88%E5%88%86%E6%B2%BB%E6%80%9D%E6%83%B3%EF%BC%89"><span class="nav-text">1.4. 快速排序（分治思想）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95"><span class="nav-text">2. 最短路径算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Dijkstra-%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89-%E7%AE%97%E6%B3%95"><span class="nav-text">Dijkstra(迪杰斯特拉)算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E6%8F%8F%E8%BF%B0"><span class="nav-text">算法描述</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Floyd%E7%AE%97%E6%B3%95"><span class="nav-text">Floyd算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E6%8F%8F%E8%BF%B0-1"><span class="nav-text">算法描述</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-bfs-%EF%BC%88Breadth-First-Search%EF%BC%89%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86"><span class="nav-text">3. bfs （Breadth-First Search）广度优先遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86"><span class="nav-text">3.1. 二叉树的广度优先遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E6%96%B9%E6%A0%BC%E4%B8%AD%E6%89%BE%E4%B8%A4%E7%82%B9%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="nav-text">3.2. 方格中找两点最短路径</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-dfs-%EF%BC%88Depth-First-Search%EF%BC%89%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86"><span class="nav-text">4. dfs （Depth-First Search）深度优先遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-%E8%8E%B7%E5%8F%96%E6%97%A0%E7%8E%AF%E5%9B%BE%E7%9A%84%E4%B8%A4%E4%B8%AA%E8%8A%82%E7%82%B9%E4%B9%8B%E9%97%B4%E7%9A%84%E8%B7%AF%E5%BE%84"><span class="nav-text">4.1. 获取无环图的两个节点之间的路径</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E5%85%A8%E6%8E%92%E5%88%97%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9E%E6%BA%AF%E6%B3%95%EF%BC%89"><span class="nav-text">5. 全排列算法（回溯法）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="nav-text">6. 动态规划</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-%E8%83%8C%E5%8C%85%E7%AE%97%E6%B3%95"><span class="nav-text">6.1. 背包算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-01%E8%83%8C%E5%8C%85"><span class="nav-text">1) 01背包</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-%E6%95%B0%E4%BD%8Ddp"><span class="nav-text">6.2. 数位dp</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2%E6%A8%A1%E6%9D%BF"><span class="nav-text">1) 记忆化搜索模板</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E7%A4%BA%E4%BE%8B"><span class="nav-text">2) 示例</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%B1%82%E4%B8%8D%E5%A4%A7%E4%BA%8E%E7%BB%99%E5%AE%9A%E6%95%B0%E5%AD%97s%EF%BC%8C%E6%89%80%E6%9C%89%E4%BD%8D%E6%95%B0%E7%9B%B8%E5%8A%A0%E5%B0%8F%E4%BA%8En%E7%9A%84%E6%95%B0%E9%87%8F%EF%BC%8C%E7%AD%94%E6%A1%88%E5%AF%B91000000007%E5%8F%96%E6%A8%A1"><span class="nav-text">(1) 求不大于给定数字s，所有位数相加小于n的数量，答案对1000000007取模</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-gcd-%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E7%AE%97%E6%B3%95"><span class="nav-text">7. gcd 最大公约数算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%81%E6%98%8E-1"><span class="nav-text">证明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81"><span class="nav-text">代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-%E9%80%89%E5%8F%96%E4%B8%AD%E4%BD%8D%E6%95%B0"><span class="nav-text">8. 选取中位数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E9%AA%9A%E6%93%8D%E4%BD%9C"><span class="nav-text">9. 位运算的骚操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#9-1-%E5%8F%96%E5%8F%8D"><span class="nav-text">9.1. 取反</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E4%BB%8E%E4%BD%8E%E5%88%B0%E9%AB%98%E6%89%BE%E7%AC%AC%E4%B8%80%E4%B8%AA1"><span class="nav-text">1) 从低到高找第一个1</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-2-%E5%BC%82%E6%88%96"><span class="nav-text">9.2. 异或</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-0%E5%92%8C1%E7%9A%84%E4%BA%92%E8%BD%AC"><span class="nav-text">1) 0和1的互转</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-3-%E4%B8%8E%E8%BF%90%E7%AE%97"><span class="nav-text">9.3. 与运算</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2%E7%9A%84%E5%B9%82%E6%AC%A1%E5%8F%96%E6%95%B4"><span class="nav-text">1) 2的幂次取整</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%90%91%E4%B8%8B%E5%8F%96%E6%95%B4"><span class="nav-text">向下取整</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%90%91%E4%B8%8A%E5%8F%96%E6%95%B4"><span class="nav-text">向上取整</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-LCA-%EF%BC%88Lowest-Common-Ancestor%EF%BC%89%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%E7%AE%97%E6%B3%95"><span class="nav-text">10. LCA （Lowest Common Ancestor）最近公共祖先算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#10-1-Tarjan%E7%AE%97%E6%B3%95%E5%A4%84%E7%90%86LCA"><span class="nav-text">10.1. Tarjan算法处理LCA</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-%E5%B7%AE%E5%88%86"><span class="nav-text">11. 差分</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#11-1-%E6%95%B0%E7%BB%84%E5%B7%AE%E5%88%86"><span class="nav-text">11.1. 数组差分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-2-%E6%A0%91%E4%B8%8A%E5%B7%AE%E5%88%86"><span class="nav-text">11.2. 树上差分</span></a></li></ol></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="王钰博" src="/images/12.jpg"><p class="site-author-name" itemprop="name">王钰博</p><div class="site-description" itemprop="description">个人博客</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">122</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">22</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">14</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/Githubwyb" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Githubwyb" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:1061322005@qq.com" title="E-Mail → mailto:1061322005@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a></span></div><div class="links-of-blogroll motion-element"><div class="links-of-blogroll-title"><i class="fa fa-fw fa-link"></i> 友情链接</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="https://githubwyb.github.io/bookPages/" title="https:&#x2F;&#x2F;githubwyb.github.io&#x2F;bookPages&#x2F;">markdown books</a></li></ul></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="beian"><a href="http://www.beian.miit.gov.cn/" rel="noopener" target="_blank">豫ICP备16023189号 </a><img src="/images/beian.png" style="display:inline-block"></div><div class="copyright">&copy; <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">王钰博</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-area-chart"></i> </span><span title="站点总字数">941k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span title="站点阅读时长">14:16</span></div><div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动</div><div class="addthis_inline_share_toolbox"><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e1986d4e4e2d132" async></script></div><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-divider">|</span> <span class="post-meta-item" id="busuanzi_container_site_pv"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer></div><script src="/lib/anime.min.js"></script><script src="/lib/medium-zoom.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><script src="/js/local-search.js"></script><script>document.querySelectorAll(".pdfobject-container").forEach(e=>{let t=e.dataset.target,a="#"+Object.entries({navpanes:0,toolbar:0,statusbar:0,pagemode:"thumbs",view:"FitH"}).map(([e,t])=>`${e}=${encodeURIComponent(t)}`).join("&"),i=`/lib/pdf/web/viewer.html?file=${encodeURIComponent(t)}${a}`;NexT.utils.supportsPDFs()?e.innerHTML=`<embed class="pdfobject" src="${t+a}" type="application/pdf" style="height: ${e.dataset.height};">`:e.innerHTML=`<iframe src="${i}" style="height: ${e.dataset.height};" frameborder="0"></iframe>`})</script><script>"undefined"==typeof MathJax?(window.MathJax={loader:{source:{"[tex]/amsCd":"[tex]/amscd","[tex]/AMScd":"[tex]/amscd"}},tex:{inlineMath:{"[+]":[["$","$"]]},tags:"ams"},options:{renderActions:{findScript:[10,e=>{document.querySelectorAll('script[type^="math/tex"]').forEach(t=>{const a=!!t.type.match(/; *mode=display/),n=new e.options.MathItem(t.textContent,e.inputJax[0],a),d=document.createTextNode("");t.parentNode.replaceChild(d,t),n.start={node:d,delim:"",n:0},n.end={node:d,delim:"",n:0},e.math.push(n)})},"",!1],insertedScript:[200,()=>{document.querySelectorAll("mjx-container").forEach(e=>{let t=e.parentNode;"li"===t.nodeName.toLowerCase()&&t.parentNode.classList.add("has-jax")})},"",!1]}}},function(){var e=document.createElement("script");e.src="/lib/mathjax/tex-mml-chtml.js",e.defer=!0,document.head.appendChild(e)}()):(MathJax.startup.document.state(0),MathJax.texReset(),MathJax.typeset())</script><script>NexT.utils.loadComments(document.querySelector("#valine-comments"),()=>{NexT.utils.getScript("//unpkg.com/valine/dist/Valine.min.js",()=>{var e=["nick","mail","link"],a="nick,mail";a=a.split(",").filter(a=>e.includes(a)),new Valine({el:"#valine-comments",verify:!1,notify:!1,appId:"qmLbUHV1HOr841BOYkl84riu-gzGzoHsz",appKey:"j4fgTcf1yHRDD5X3HUH5EH95",placeholder:"^_^ happy everyday!",avatar:"wavatar",meta:a,pageSize:"10",visitor:!1,lang:"zh-cn",path:location.pathname,recordIP:!1,serverURLs:""})},window.Valine)})</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":true,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"bottom":-30,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body><script type="text/javascript" src="/lib/jquery-3.4.1.min.js"></script><script type="text/javascript" src="/js/src/love.js"></script></html>